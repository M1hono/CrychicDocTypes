declare module "packages/info/journeymap/shaded/kotlin/spark/$Routable" {
import {$ResponseTransformer, $ResponseTransformer$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer"
import {$TemplateEngine, $TemplateEngine$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Filter"
import {$TemplateViewRoute, $TemplateViewRoute$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateViewRoute"
import {$Route, $Route$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Route"

export class $Routable {


public "get"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "get"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "get"(arg0: string, arg1: string, arg2: $Route$Type): void
public "get"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "get"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "get"(arg0: string, arg1: $Route$Type): void
public "put"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "put"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "put"(arg0: string, arg1: string, arg2: $Route$Type): void
public "put"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "put"(arg0: string, arg1: $Route$Type): void
public "put"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "trace"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "trace"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "trace"(arg0: string, arg1: string, arg2: $Route$Type): void
public "trace"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "trace"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "trace"(arg0: string, arg1: $Route$Type): void
public "delete"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "delete"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "delete"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "delete"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "delete"(arg0: string, arg1: $Route$Type): void
public "delete"(arg0: string, arg1: string, arg2: $Route$Type): void
public "connect"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "connect"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "connect"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "connect"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "connect"(arg0: string, arg1: string, arg2: $Route$Type): void
public "connect"(arg0: string, arg1: $Route$Type): void
public "options"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "options"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "options"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "options"(arg0: string, arg1: $Route$Type): void
public "options"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "options"(arg0: string, arg1: string, arg2: $Route$Type): void
public "before"(arg0: string, arg1: string, arg2: $Filter$Type): void
public "before"(arg0: $Filter$Type): void
public "before"(arg0: string, arg1: $Filter$Type): void
public "after"(arg0: string, arg1: $Filter$Type): void
public "after"(arg0: string, arg1: string, arg2: $Filter$Type): void
public "after"(arg0: $Filter$Type): void
public "head"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "head"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "head"(arg0: string, arg1: $Route$Type): void
public "head"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "head"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "head"(arg0: string, arg1: string, arg2: $Route$Type): void
public "patch"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "patch"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "patch"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "patch"(arg0: string, arg1: string, arg2: $Route$Type): void
public "patch"(arg0: string, arg1: $Route$Type): void
public "patch"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "post"(arg0: string, arg1: string, arg2: $Route$Type): void
public "post"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public "post"(arg0: string, arg1: $Route$Type): void
public "post"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public "post"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public "post"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public "afterAfter"(arg0: $Filter$Type): void
public "afterAfter"(arg0: string, arg1: $Filter$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Routable$Type = ($Routable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Routable_ = $Routable$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt___MapsKt" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MapsKt__MapsKt, $MapsKt__MapsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapsKt"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapsKt___MapsKt extends $MapsKt__MapsKt {

constructor()

public static "mapTo"<K, V, R, C extends $Collection<(any)>>(arg0: $Map$Type<(any), (any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "map"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "toList"<K, V>(arg0: $Map$Type<(any), (any)>): $List<($Pair<(K), (V)>)>
public static "count"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "flatMap"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "forEach"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "all"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"<K, V>(arg0: $Map$Type<(any), (any)>): boolean
public static "none"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"<K, V>(arg0: $Map$Type<(any), (any)>): boolean
public static "asSequence"<K, V>(arg0: $Map$Type<(any), (any)>): $Sequence<($Map$Entry<(K), (V)>)>
public static "flatMapTo"<K, V, R, C extends $Collection<(any)>>(arg0: $Map$Type<(any), (any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapNotNull"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "onEach"<K, V, M extends $Map<(any), (any)>>(arg0: M, arg1: $Function1$Type<(any), ($Unit$Type)>): M
public static "onEachIndexed"<K, V, M extends $Map<(any), (any)>>(arg0: M, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): M
public static "mapNotNullTo"<K, V, R, C extends $Collection<(any)>>(arg0: $Map$Type<(any), (any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapSequenceTo"<K, V, R, C extends $Collection<(any)>>(arg0: $Map$Type<(any), (any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapSequence"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapsKt___MapsKt$Type = ($MapsKt___MapsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapsKt___MapsKt_ = $MapsKt___MapsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketUpgradeFilter" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"
import {$MappedWebSocketCreator, $MappedWebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$MappedWebSocketCreator"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$WebSocketServerFactory, $WebSocketServerFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketServerFactory"
import {$FilterConfig, $FilterConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterConfig"
import {$WebSocketServletFactory, $WebSocketServletFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketServletFactory"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"
import {$FilterChain, $FilterChain$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterChain"
import {$ServletContextHandler, $ServletContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletContextHandler"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$NativeWebSocketConfiguration, $NativeWebSocketConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$NativeWebSocketConfiguration"
import {$PathSpec as $PathSpec$0, $PathSpec$Type as $PathSpec$0$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec"

export class $WebSocketUpgradeFilter implements $Filter, $MappedWebSocketCreator, $Dumpable {
static readonly "CONTEXT_ATTRIBUTE_KEY": string
static readonly "CONFIG_ATTRIBUTE_KEY": string

constructor(arg0: $NativeWebSocketConfiguration$Type)
constructor(arg0: $WebSocketServerFactory$Type)
constructor()

public "doFilter"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: $FilterChain$Type): void
public "toString"(): string
public "getFactory"(): $WebSocketServletFactory
public "init"(arg0: $FilterConfig$Type): void
public "destroy"(): void
public "removeMapping"(arg0: string): boolean
public "addMapping"(arg0: $PathSpec$Type, arg1: $WebSocketCreator$Type): void
public "addMapping"(arg0: string, arg1: $WebSocketCreator$Type): void
/**
 * 
 * @deprecated
 */
public "addMapping"(arg0: $PathSpec$0$Type, arg1: $WebSocketCreator$Type): void
public "getMapping"(arg0: string): $WebSocketCreator
public "setToAttribute"(arg0: $ServletContext$Type, arg1: string): void
public static "configureContext"(arg0: $ServletContextHandler$Type): $WebSocketUpgradeFilter
/**
 * 
 * @deprecated
 */
public static "configureContext"(arg0: $ServletContext$Type): $WebSocketUpgradeFilter
public "getConfiguration"(): $NativeWebSocketConfiguration
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
get "factory"(): $WebSocketServletFactory
get "configuration"(): $NativeWebSocketConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketUpgradeFilter$Type = ($WebSocketUpgradeFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketUpgradeFilter_ = $WebSocketUpgradeFilter$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$IndexingSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"

export class $IndexingSequence<T> implements $Sequence<($IndexedValue<(any)>)> {

constructor(arg0: $Sequence$Type<(any)>)

public "iterator"(): $Iterator<($IndexedValue<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexingSequence$Type<T> = ($IndexingSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexingSequence_<T> = $IndexingSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator$State" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpGenerator$State extends $Enum<($HttpGenerator$State)> {
static readonly "START": $HttpGenerator$State
static readonly "COMMITTED": $HttpGenerator$State
static readonly "COMPLETING": $HttpGenerator$State
static readonly "COMPLETING_1XX": $HttpGenerator$State
static readonly "END": $HttpGenerator$State


public static "values"(): ($HttpGenerator$State)[]
public static "valueOf"(arg0: string): $HttpGenerator$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpGenerator$State$Type = (("committed") | ("start") | ("end") | ("completing") | ("completing_1xx")) | ($HttpGenerator$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpGenerator$State_ = $HttpGenerator$State$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/statistic/$CounterStatistic" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CounterStatistic {

constructor()

public "add"(arg0: long): long
public "toString"(): string
public "increment"(): long
public "reset"(): void
public "reset"(arg0: long): void
public "decrement"(): long
public "getMax"(): long
public "getCurrent"(): long
public "getTotal"(): long
get "max"(): long
get "current"(): long
get "total"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CounterStatistic$Type = ($CounterStatistic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CounterStatistic_ = $CounterStatistic$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ConcurrentHashSet" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractSet, $AbstractSet$Type} from "packages/java/util/$AbstractSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ConcurrentHashSet<E> extends $AbstractSet<(E)> implements $Set<(E)> {

constructor()

public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(E)>
public "contains"(arg0: any): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConcurrentHashSet$Type<E> = ($ConcurrentHashSet<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConcurrentHashSet_<E> = $ConcurrentHashSet$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgressionIterator" {
import {$CharIterator, $CharIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator"

export class $CharProgressionIterator extends $CharIterator {

constructor(arg0: character, arg1: character, arg2: integer)

public "hasNext"(): boolean
public "nextChar"(): character
public "getStep"(): integer
get "step"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharProgressionIterator$Type = ($CharProgressionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharProgressionIterator_ = $CharProgressionIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileTreeWalk" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$File, $File$Type} from "packages/java/io/$File"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$FileWalkDirection, $FileWalkDirection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileWalkDirection"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $FileTreeWalk implements $Sequence<($File)> {

constructor(arg0: $File$Type, arg1: $FileWalkDirection$Type, arg2: integer, arg3: $DefaultConstructorMarker$Type)
constructor(arg0: $File$Type, arg1: $FileWalkDirection$Type)

public "iterator"(): $Iterator<($File)>
public "maxDepth"(arg0: integer): $FileTreeWalk
public "onFail"(arg0: $Function2$Type<(any), (any), ($Unit$Type)>): $FileTreeWalk
public "onLeave"(arg0: $Function1$Type<(any), ($Unit$Type)>): $FileTreeWalk
public "onEnter"(arg0: $Function1$Type<(any), (boolean)>): $FileTreeWalk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FileTreeWalk$Type = ($FileTreeWalk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FileTreeWalk_ = $FileTreeWalk$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextEvent" {
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$EventObject, $EventObject$Type} from "packages/java/util/$EventObject"

export class $ServletContextEvent extends $EventObject {

constructor(arg0: $ServletContext$Type)

public "getServletContext"(): $ServletContext
get "servletContext"(): $ServletContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextEvent$Type = ($ServletContextEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextEvent_ = $ServletContextEvent$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session" {
import {$Locker$Lock, $Locker$Lock$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Locker$Lock"
import {$HttpSessionContext, $HttpSessionContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionContext"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$SessionHandler$SessionIf, $SessionHandler$SessionIf$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler$SessionIf"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $Session implements $SessionHandler$SessionIf {
static readonly "SESSION_CREATED_SECURE": string

constructor(arg0: $SessionHandler$Type, arg1: $HttpServletRequest$Type, arg2: $SessionData$Type)
constructor(arg0: $SessionHandler$Type, arg1: $SessionData$Type)

public "lock"(): $Locker$Lock
/**
 * 
 * @deprecated
 */
public "getValue"(arg0: string): any
public "getId"(): string
public "getAttributes"(): integer
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "isValid"(): boolean
/**
 * 
 * @deprecated
 */
public "putValue"(arg0: string, arg1: any): void
public "getCreationTime"(): long
public "invalidate"(): void
public "renewId"(arg0: $HttpServletRequest$Type): void
public "isIdChanged"(): boolean
public "getSessionHandler"(): $SessionHandler
public "lockIfNotHeld"(): $Locker$Lock
public "isNew"(): boolean
public "removeAttribute"(arg0: string): void
public "getContextPath"(): string
public "getSession"(): $Session
public "getNames"(): $Set<(string)>
public "getServletContext"(): $ServletContext
public "getRequests"(): long
public "getExtendedId"(): string
public "getAttributeNames"(): $Enumeration<(string)>
/**
 * 
 * @deprecated
 */
public "getSessionContext"(): $HttpSessionContext
public "getLastAccessedTime"(): long
/**
 * 
 * @deprecated
 */
public "removeValue"(arg0: string): void
/**
 * 
 * @deprecated
 */
public "getValueNames"(): (string)[]
public "willPassivate"(): void
public "isResident"(): boolean
public "setResident"(arg0: boolean): void
public "didActivate"(): void
public "setExtendedId"(arg0: string): void
public "unbindValue"(arg0: string, arg1: any): void
public "bindValue"(arg0: string, arg1: any): void
public "getCookieSetTime"(): long
public "setIdChanged"(arg0: boolean): void
public "getVHost"(): string
public "stopInactivityTimer"(): void
public "updateInactivityTimer"(): void
public "getMaxInactiveInterval"(): integer
public "setMaxInactiveInterval"(arg0: integer): void
get "id"(): string
get "attributes"(): integer
get "valid"(): boolean
get "creationTime"(): long
get "idChanged"(): boolean
get "sessionHandler"(): $SessionHandler
get "new"(): boolean
get "contextPath"(): string
get "session"(): $Session
get "names"(): $Set<(string)>
get "servletContext"(): $ServletContext
get "requests"(): long
get "extendedId"(): string
get "attributeNames"(): $Enumeration<(string)>
get "sessionContext"(): $HttpSessionContext
get "lastAccessedTime"(): long
get "valueNames"(): (string)[]
get "resident"(): boolean
set "resident"(value: boolean)
set "extendedId"(value: string)
get "cookieSetTime"(): long
set "idChanged"(value: boolean)
get "vHost"(): string
get "maxInactiveInterval"(): integer
set "maxInactiveInterval"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Session$Type = ($Session);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Session_ = $Session$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerList" {
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HandlerCollection, $HandlerCollection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerCollection"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $HandlerList extends $HandlerCollection {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(...arg0: ($Handler$Type)[])

public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandlerList$Type = ($HandlerList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandlerList_ = $HandlerList$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$NotSupportedException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $NotSupportedException extends $RuntimeException {


public static "raise"(arg0: string, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotSupportedException$Type = ($NotSupportedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotSupportedException_ = $NotSupportedException$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$NoBodyOutputStream" {
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$WriteListener, $WriteListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$WriteListener"

export class $NoBodyOutputStream extends $ServletOutputStream {


public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "write"(arg0: integer): void
public "isReady"(): boolean
public "setWriteListener"(arg0: $WriteListener$Type): void
get "ready"(): boolean
set "writeListener"(value: $WriteListener$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoBodyOutputStream$Type = ($NoBodyOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoBodyOutputStream_ = $NoBodyOutputStream$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$RestrictedSuspendLambda" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$SuspendFunction, $SuspendFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$SuspendFunction"
import {$RestrictedContinuationImpl, $RestrictedContinuationImpl$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$RestrictedContinuationImpl"
import {$FunctionBase, $FunctionBase$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase"

export class $RestrictedSuspendLambda extends $RestrictedContinuationImpl implements $FunctionBase<(any)>, $SuspendFunction {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $Continuation$Type<(any)>)

public "toString"(): string
public "getArity"(): integer
get "arity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RestrictedSuspendLambda$Type = ($RestrictedSuspendLambda);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RestrictedSuspendLambda_ = $RestrictedSuspendLambda$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngHelperInternal" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$File, $File$Type} from "packages/java/io/$File"
import {$PngReader, $PngReader$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngReader"
import {$Logger, $Logger$Type} from "packages/java/util/logging/$Logger"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $PngHelperInternal {
static readonly "KEY_LOGGER": string
static readonly "LOGGER": $Logger
static "charsetLatin1name": string
static "charsetLatin1": $Charset
static "charsetUTF8name": string
static "charsetUTF8": $Charset

constructor()

public static "writeInt2tobytes"(arg0: integer, arg1: (byte)[], arg2: integer): void
public static "readInt2fromBytes"(arg0: (byte)[], arg1: integer): integer
public static "readInt1fromByte"(arg0: (byte)[], arg1: integer): integer
public static "debug"(arg0: any): void
public static "isDebug"(): boolean
public static "readBytes"(arg0: $InputStream$Type, arg1: (byte)[], arg2: integer, arg3: integer): void
public static "writeBytes"(arg0: $OutputStream$Type, arg1: (byte)[]): void
public static "writeBytes"(arg0: $OutputStream$Type, arg1: (byte)[], arg2: integer, arg3: integer): void
public static "skipBytes"(arg0: $InputStream$Type, arg1: long): void
public static "readByte"(arg0: $InputStream$Type): integer
public static "writeByte"(arg0: $OutputStream$Type, arg1: (byte)[]): void
public static "writeByte"(arg0: $OutputStream$Type, arg1: byte): void
public static "getDigest"(arg0: $PngReader$Type): long
public static "writeInt4tobytes"(arg0: integer, arg1: (byte)[], arg2: integer): void
public static "readInt4fromBytes"(arg0: (byte)[], arg1: integer): integer
public static "setDebug"(arg0: boolean): void
public static "writeInt2"(arg0: $OutputStream$Type, arg1: integer): void
public static "getPngIdSignature"(): (byte)[]
public static "istreamFromFile"(arg0: $File$Type): $InputStream
public static "filterRowPaeth"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): integer
public static "filterRowSub"(arg0: integer, arg1: integer): integer
public static "initCrcForTests"(arg0: $PngReader$Type): void
public static "filterRowUp"(arg0: integer, arg1: integer): integer
public static "logdebug"(arg0: string): void
public static "getRawIdatBytes"(arg0: $PngReader$Type): long
public static "doubleToInt100000"(arg0: double): integer
public static "readInt4"(arg0: $InputStream$Type): integer
public static "writeInt4"(arg0: $OutputStream$Type, arg1: integer): void
public static "filterRowNone"(arg0: integer): integer
public static "filterRowAverage"(arg0: integer, arg1: integer, arg2: integer): integer
public static "intToDouble100000"(arg0: integer): double
public static "readInt2"(arg0: $InputStream$Type): integer
get "pngIdSignature"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngHelperInternal$Type = ($PngHelperInternal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngHelperInternal_ = $PngHelperInternal$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$LinesSequence" {
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $LinesSequence implements $Sequence<(string)> {

constructor(arg0: $BufferedReader$Type)

public "iterator"(): $Iterator<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinesSequence$Type = ($LinesSequence);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LinesSequence_ = $LinesSequence$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnector" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $AbstractConnector extends $ContainerLifeCycle implements $Connector, $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Server$Type, arg1: $Executor$Type, arg2: $Scheduler$Type, arg3: $ByteBufferPool$Type, arg4: integer, ...arg5: ($ConnectionFactory$Type)[])

public "addFirstConnectionFactory"(arg0: $ConnectionFactory$Type): void
public "setAcceptorPriorityDelta"(arg0: integer): void
public "clearConnectionFactories"(): void
public "setConnectionFactories"(arg0: $Collection$Type<($ConnectionFactory$Type)>): void
public "removeConnectionFactory"(arg0: string): $ConnectionFactory
public "addIfAbsentConnectionFactory"(arg0: $ConnectionFactory$Type): void
public "addConnectionFactory"(arg0: $ConnectionFactory$Type): void
public "getAcceptorPriorityDelta"(): integer
public "getName"(): string
public "shutdown"(): $Future<(void)>
public "toString"(): string
public "join"(): void
public "join"(arg0: long): void
public "setName"(arg0: string): void
public "getExecutor"(): $Executor
public "getDefaultProtocol"(): string
public "setDefaultProtocol"(arg0: string): void
public "getProtocols"(): $List<(string)>
public "getServer"(): $Server
public "getDefaultConnectionFactory"(): $ConnectionFactory
public "getConnectedEndPoints"(): $Collection<($EndPoint)>
public "getConnectionFactories"(): $Collection<($ConnectionFactory)>
public "getConnectionFactory"<T>(arg0: $Class$Type<(T)>): T
public "getConnectionFactory"(arg0: string): $ConnectionFactory
public "getScheduler"(): $Scheduler
public "getAcceptors"(): integer
public "getByteBufferPool"(): $ByteBufferPool
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "getTransport"(): any
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "acceptorPriorityDelta"(value: integer)
set "connectionFactories"(value: $Collection$Type<($ConnectionFactory$Type)>)
get "acceptorPriorityDelta"(): integer
get "name"(): string
set "name"(value: string)
get "executor"(): $Executor
get "defaultProtocol"(): string
set "defaultProtocol"(value: string)
get "protocols"(): $List<(string)>
get "server"(): $Server
get "defaultConnectionFactory"(): $ConnectionFactory
get "connectedEndPoints"(): $Collection<($EndPoint)>
get "connectionFactories"(): $Collection<($ConnectionFactory)>
get "scheduler"(): $Scheduler
get "acceptors"(): integer
get "byteBufferPool"(): $ByteBufferPool
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "transport"(): any
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractConnector$Type = ($AbstractConnector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractConnector_ = $AbstractConnector$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketRemoteEndpoint" {
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$WebSocketFrame, $WebSocketFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketFrame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"
import {$RemoteEndpoint, $RemoteEndpoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$RemoteEndpoint"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketRemoteEndpoint implements $RemoteEndpoint {

constructor(arg0: $LogicalConnection$Type, arg1: $OutgoingFrames$Type)
constructor(arg0: $LogicalConnection$Type, arg1: $OutgoingFrames$Type, arg2: $BatchMode$Type)

public "toString"(): string
public "flush"(): void
public "sendPong"(arg0: $ByteBuffer$Type): void
public "getBatchMode"(): $BatchMode
public "getInetSocketAddress"(): $InetSocketAddress
public "sendPing"(arg0: $ByteBuffer$Type): void
public "uncheckedSendFrame"(arg0: $WebSocketFrame$Type, arg1: $WriteCallback$Type): void
public "sendBytes"(arg0: $ByteBuffer$Type): void
public "sendBytes"(arg0: $ByteBuffer$Type, arg1: $WriteCallback$Type): void
public "sendBytesByFuture"(arg0: $ByteBuffer$Type): $Future<(void)>
public "sendString"(arg0: string): void
public "sendString"(arg0: string, arg1: $WriteCallback$Type): void
public "sendPartialString"(arg0: string, arg1: boolean): void
public "sendPartialBytes"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "sendStringByFuture"(arg0: string): $Future<(void)>
public "setBatchMode"(arg0: $BatchMode$Type): void
get "batchMode"(): $BatchMode
get "inetSocketAddress"(): $InetSocketAddress
set "batchMode"(value: $BatchMode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketRemoteEndpoint$Type = ($WebSocketRemoteEndpoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketRemoteEndpoint_ = $WebSocketRemoteEndpoint$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ReadListener" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"

export interface $ReadListener extends $EventListener {

 "onAllDataRead"(): void
 "onDataAvailable"(): void
 "onError"(arg0: $Throwable$Type): void
}

export namespace $ReadListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReadListener$Type = ($ReadListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReadListener_ = $ReadListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ExperimentalStdlibApi" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ExperimentalStdlibApi extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ExperimentalStdlibApi {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperimentalStdlibApi$Type = ($ExperimentalStdlibApi);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperimentalStdlibApi_ = $ExperimentalStdlibApi$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$PlatformRandom" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Random$Default, $Random$Default$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$AbstractPlatformRandom, $AbstractPlatformRandom$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$AbstractPlatformRandom"

export class $PlatformRandom extends $AbstractPlatformRandom implements $Serializable {
static readonly "Default": $Random$Default

constructor(arg0: $Random$Type)

public "getImpl"(): $Random
get "impl"(): $Random
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformRandom$Type = ($PlatformRandom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformRandom_ = $PlatformRandom$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathMappings" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MappedResource, $MappedResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$MappedResource"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $PathMappings<E> implements $Iterable<($MappedResource<(E)>)>, $Dumpable {

constructor()

public "remove"(arg0: $PathSpec$Type): boolean
public "put"(arg0: $PathSpec$Type, arg1: E): boolean
public "put"(arg0: string, arg1: E): boolean
public "toString"(): string
public "size"(): integer
public "iterator"(): $Iterator<($MappedResource<(E)>)>
public "reset"(): void
public "removeIf"(arg0: $Predicate$Type<($MappedResource$Type<(E)>)>): void
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "getMatches"(arg0: string): $List<($MappedResource<(E)>)>
public static "asPathSpec"(arg0: string): $PathSpec
public "getMatch"(arg0: string): $MappedResource<(E)>
public "getMappings"(): $List<($MappedResource<(E)>)>
public "spliterator"(): $Spliterator<($MappedResource<(E)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$MappedResource<(E)>>;
get "mappings"(): $List<($MappedResource<(E)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathMappings$Type<E> = ($PathMappings<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathMappings_<E> = $PathMappings$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$Grouping" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Grouping<T, K> {

 "keyOf"(arg0: T): K
 "sourceIterator"(): $Iterator<(T)>
}

export namespace $Grouping {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Grouping$Type<T, K> = ($Grouping<(T), (K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Grouping_<T, K> = $Grouping$Type<(T), (K)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableCollection" {
import {$KMutableCollection, $KMutableCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $AbstractMutableCollection<E> extends $AbstractCollection<(E)> implements $Collection<(E)>, $KMutableCollection {


public "add"(arg0: E): boolean
public "size"(): integer
public "getSize"(): integer
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMutableCollection$Type<E> = ($AbstractMutableCollection<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMutableCollection_<E> = $AbstractMutableCollection$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketBehavior" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $WebSocketBehavior extends $Enum<($WebSocketBehavior)> {
static readonly "CLIENT": $WebSocketBehavior
static readonly "SERVER": $WebSocketBehavior


public static "values"(): ($WebSocketBehavior)[]
public static "valueOf"(arg0: string): $WebSocketBehavior
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketBehavior$Type = (("server") | ("client")) | ($WebSocketBehavior);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketBehavior_ = $WebSocketBehavior$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$UserDataConstraint" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $UserDataConstraint extends $Enum<($UserDataConstraint)> {
static readonly "None": $UserDataConstraint
static readonly "Integral": $UserDataConstraint
static readonly "Confidential": $UserDataConstraint


public static "get"(arg0: integer): $UserDataConstraint
public static "values"(): ($UserDataConstraint)[]
public static "valueOf"(arg0: string): $UserDataConstraint
public "combine"(arg0: $UserDataConstraint$Type): $UserDataConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UserDataConstraint$Type = (("integral") | ("none") | ("confidential")) | ($UserDataConstraint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UserDataConstraint_ = $UserDataConstraint$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$SuspendToken" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SuspendToken {

 "resume"(): void

(): void
}

export namespace $SuspendToken {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuspendToken$Type = ($SuspendToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuspendToken_ = $SuspendToken$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$Regex$Companion" {
import {$Regex, $Regex$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$Regex"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $Regex$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "escape"(arg0: string): string
public "escapeReplacement"(arg0: string): string
public "fromLiteral"(arg0: string): $Regex
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Regex$Companion$Type = ($Regex$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Regex$Companion_ = $Regex$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput$Interceptor" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"

export interface $HttpOutput$Interceptor {

 "write"(arg0: $ByteBuffer$Type, arg1: boolean, arg2: $Callback$Type): void
 "isOptimizedForDirectBuffers"(): boolean
 "resetBuffer"(): void
 "getNextInterceptor"(): $HttpOutput$Interceptor
}

export namespace $HttpOutput$Interceptor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpOutput$Interceptor$Type = ($HttpOutput$Interceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpOutput$Interceptor_ = $HttpOutput$Interceptor$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$BasicAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"

export class $BasicAuthenticator extends $LoginAuthenticator {

constructor()

public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "getAuthMethod"(): string
get "authMethod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicAuthenticator$Type = ($BasicAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicAuthenticator_ = $BasicAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkMultiple" {
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export class $PngChunkMultiple extends $PngChunk {
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean


public "allowsMultiple"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkMultiple$Type = ($PngChunkMultiple);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkMultiple_ = $PngChunkMultiple$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Loader" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$ResourceBundle, $ResourceBundle$Type} from "packages/java/util/$ResourceBundle"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $Loader {

constructor()

public static "loadClass"(arg0: $Class$Type<(any)>, arg1: string): $Class<(any)>
public static "loadClass"(arg0: string): $Class<(any)>
public static "getResource"(arg0: string): $URL
public static "getResourceBundle"(arg0: string, arg1: boolean, arg2: $Locale$Type): $ResourceBundle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Loader$Type = ($Loader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Loader_ = $Loader$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletConfig" {
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export interface $ServletConfig {

 "getInitParameter"(arg0: string): string
 "getServletName"(): string
 "getServletContext"(): $ServletContext
 "getInitParameterNames"(): $Enumeration<(string)>
}

export namespace $ServletConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletConfig$Type = ($ServletConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletConfig_ = $ServletConfig$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$AcceptHash" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AcceptHash {

constructor()

public static "hashKey"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptHash$Type = ($AcceptHash);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptHash_ = $AcceptHash$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$RegexPathSpec" {
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec"

/**
 * 
 * @deprecated
 */
export class $RegexPathSpec extends $PathSpec {

constructor(arg0: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexPathSpec$Type = ($RegexPathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexPathSpec_ = $RegexPathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketCreatorFactory" {
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"

export class $WebSocketCreatorFactory {

constructor()

public static "create"(arg0: $WebSocketHandlerWrapper$Type): $WebSocketCreator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketCreatorFactory$Type = ($WebSocketCreatorFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketCreatorFactory_ = $WebSocketCreatorFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$UArraySortingKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UArraySortingKt {


public static "sortArray-Aa5vz7o"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "sortArray-oBK06Vg"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "sortArray--nroSd4"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "sortArray-4UcCI2c"(arg0: (byte)[], arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UArraySortingKt$Type = ($UArraySortingKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UArraySortingKt_ = $UArraySortingKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropTakeSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export interface $DropTakeSequence<T> extends $Sequence<(T)> {

 "drop"(arg0: integer): $Sequence<(T)>
 "take"(arg0: integer): $Sequence<(T)>
 "iterator"(): $Iterator<(T)>
}

export namespace $DropTakeSequence {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropTakeSequence$Type<T> = ($DropTakeSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropTakeSequence_<T> = $DropTakeSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UShortArray" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UShort, $UShort$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UShort"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $UShortArray implements $Collection<($UShort)>, $KMappedMarker {


public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<($UShort)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "set-01HTLdE"(arg0: (short)[], arg1: integer, arg2: short): void
public "contains-xj2QHRw"(arg0: short): boolean
public static "contains-xj2QHRw"(arg0: (short)[], arg1: short): boolean
public "add-xj2QHRw"(arg0: short): boolean
public static "constructor-impl"(arg0: integer): (short)[]
public static "constructor-impl"(arg0: (short)[]): (short)[]
public static "getSize-impl"(arg0: (short)[]): integer
public static "equals-impl"(arg0: (short)[], arg1: any): boolean
public static "containsAll-impl"(arg0: (short)[], arg1: $Collection$Type<($UShort$Type)>): boolean
public static "hashCode-impl"(arg0: (short)[]): integer
public static "iterator-impl"(arg0: (short)[]): $Iterator<($UShort)>
public static "toString-impl"(arg0: (short)[]): string
public static "isEmpty-impl"(arg0: (short)[]): boolean
public static "equals-impl0"(arg0: (short)[], arg1: (short)[]): boolean
public static "get-Mh2AYeg"(arg0: (short)[], arg1: integer): short
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<($UShort)>
public "spliterator"(): $Spliterator<($UShort)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<($UShort)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$UShort>;
get "empty"(): boolean
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UShortArray$Type = ($UShortArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UShortArray_ = $UShortArray$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/routematch/$RouteMatch" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RouteMatch {

constructor(arg0: any, arg1: string, arg2: string, arg3: string)

public "getTarget"(): any
public "getMatchUri"(): string
public "getRequestURI"(): string
public "getAcceptType"(): string
get "target"(): any
get "matchUri"(): string
get "requestURI"(): string
get "acceptType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteMatch$Type = ($RouteMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteMatch_ = $RouteMatch$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__RegexExtensionsKt" {
import {$StringsKt__RegexExtensionsJVMKt, $StringsKt__RegexExtensionsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__RegexExtensionsJVMKt"

export class $StringsKt__RegexExtensionsKt extends $StringsKt__RegexExtensionsJVMKt {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__RegexExtensionsKt$Type = ($StringsKt__RegexExtensionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__RegexExtensionsKt_ = $StringsKt__RegexExtensionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$BadMessageException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $BadMessageException extends $RuntimeException {

constructor(arg0: integer, arg1: string, arg2: $Throwable$Type)
constructor(arg0: integer, arg1: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor()
constructor(arg0: integer)
constructor(arg0: string)

public "getReason"(): string
public "getCode"(): integer
get "reason"(): string
get "code"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BadMessageException$Type = ($BadMessageException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BadMessageException_ = $BadMessageException$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Registration, $Registration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Registration"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ServletRegistration extends $Registration {

 "getRunAsRole"(): string
 "addMapping"(...arg0: (string)[]): $Set<(string)>
 "getMappings"(): $Collection<(string)>
 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $ServletRegistration {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRegistration$Type = ($ServletRegistration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRegistration_ = $ServletRegistration$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult" {
import {$MatchResult$Destructured, $MatchResult$Destructured$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult$Destructured"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MatchGroupCollection, $MatchGroupCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroupCollection"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export interface $MatchResult {

 "getValue"(): string
 "next"(): $MatchResult
 "getRange"(): $IntRange
 "getGroups"(): $MatchGroupCollection
 "getGroupValues"(): $List<(string)>
 "getDestructured"(): $MatchResult$Destructured
}

export namespace $MatchResult {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchResult$Type = ($MatchResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchResult_ = $MatchResult$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$TextStreamsKt" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$List, $List$Type} from "packages/java/util/$List"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$Writer, $Writer$Type} from "packages/java/io/$Writer"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $TextStreamsKt {


public static "readBytes"(arg0: $URL$Type): (byte)[]
public static "lineSequence"(arg0: $BufferedReader$Type): $Sequence<(string)>
public static "forEachLine"(arg0: $Reader$Type, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "copyTo"(arg0: $Reader$Type, arg1: $Writer$Type, arg2: integer): long
public static "readLines"(arg0: $Reader$Type): $List<(string)>
public static "useLines"<T>(arg0: $Reader$Type, arg1: $Function1$Type<(any), (any)>): T
public static "readText"(arg0: $Reader$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextStreamsKt$Type = ($TextStreamsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextStreamsKt_ = $TextStreamsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedMap$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $SerializedMap$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializedMap$Companion$Type = ($SerializedMap$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializedMap$Companion_ = $SerializedMap$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$URLResource" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$ReadableByteChannel, $ReadableByteChannel$Type} from "packages/java/nio/channels/$ReadableByteChannel"
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $URLResource extends $Resource {
static "__defaultUseCaches": boolean


public "getReadableByteChannel"(): $ReadableByteChannel
public "getName"(): string
public "equals"(arg0: any): boolean
public "length"(): long
public "toString"(): string
public "hashCode"(): integer
public "list"(): (string)[]
public "delete"(): boolean
public "close"(): void
public "getInputStream"(): $InputStream
public "getFile"(): $File
public "exists"(): boolean
public "renameTo"(arg0: $Resource$Type): boolean
public "isDirectory"(): boolean
public "lastModified"(): long
public "getURL"(): $URL
public "getUseCaches"(): boolean
public "addPath"(arg0: string): $Resource
public "isContainedIn"(arg0: $Resource$Type): boolean
get "readableByteChannel"(): $ReadableByteChannel
get "name"(): string
get "inputStream"(): $InputStream
get "file"(): $File
get "directory"(): boolean
get "uRL"(): $URL
get "useCaches"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $URLResource$Type = ($URLResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $URLResource_ = $URLResource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$JvmField" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JvmField extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JvmField {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JvmField$Type = ($JvmField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JvmField_ = $JvmField$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileWalkDirection" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FileWalkDirection extends $Enum<($FileWalkDirection)> {
static readonly "TOP_DOWN": $FileWalkDirection
static readonly "BOTTOM_UP": $FileWalkDirection


public static "values"(): ($FileWalkDirection)[]
public static "valueOf"(arg0: string): $FileWalkDirection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FileWalkDirection$Type = (("bottom_up") | ("top_down")) | ($FileWalkDirection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FileWalkDirection_ = $FileWalkDirection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SubSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$DropTakeSequence, $DropTakeSequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropTakeSequence"

export class $SubSequence<T> implements $Sequence<(T)>, $DropTakeSequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: integer)

public "iterator"(): $Iterator<(T)>
public "drop"(arg0: integer): $Sequence<(T)>
public "take"(arg0: integer): $Sequence<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubSequence$Type<T> = ($SubSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubSequence_<T> = $SubSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__RegexExtensionsJVMKt" {
import {$StringsKt__IndentKt, $StringsKt__IndentKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__IndentKt"

export class $StringsKt__RegexExtensionsJVMKt extends $StringsKt__IndentKt {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__RegexExtensionsJVMKt$Type = ($StringsKt__RegexExtensionsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__RegexExtensionsJVMKt_ = $StringsKt__RegexExtensionsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$PlatformImplementationsKt" {
import {$PlatformImplementations, $PlatformImplementations$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/internal/$PlatformImplementations"

export class $PlatformImplementationsKt {
static readonly "IMPLEMENTATIONS": $PlatformImplementations


public static "apiVersionIsAtLeast"(arg0: integer, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformImplementationsKt$Type = ($PlatformImplementationsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformImplementationsKt_ = $PlatformImplementationsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream" {
import {$ReadListener, $ReadListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ReadListener"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $ServletInputStream extends $InputStream {


public "readLine"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "isReady"(): boolean
public "setReadListener"(arg0: $ReadListener$Type): void
public "isFinished"(): boolean
get "ready"(): boolean
set "readListener"(value: $ReadListener$Type)
get "finished"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletInputStream$Type = ($ServletInputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletInputStream_ = $ServletInputStream$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IntIterator"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$IntProgression$Companion, $IntProgression$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression$Companion"

export class $IntProgression implements $Iterable<(integer)>, $KMappedMarker {
static readonly "Companion": $IntProgression$Companion

constructor(arg0: integer, arg1: integer, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $IntIterator
public "getFirst"(): integer
public "getLast"(): integer
public "getStep"(): integer
public "spliterator"(): $Spliterator<(integer)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
get "empty"(): boolean
get "first"(): integer
get "last"(): integer
get "step"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntProgression$Type = ($IntProgression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntProgression_ = $IntProgression$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$MultiPartCleanerListener" {
import {$ServletRequestEvent, $ServletRequestEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestEvent"
import {$ServletRequestListener, $ServletRequestListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestListener"

export class $MultiPartCleanerListener implements $ServletRequestListener {
static readonly "INSTANCE": $MultiPartCleanerListener


public "requestInitialized"(arg0: $ServletRequestEvent$Type): void
public "requestDestroyed"(arg0: $ServletRequestEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiPartCleanerListener$Type = ($MultiPartCleanerListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiPartCleanerListener_ = $MultiPartCleanerListener$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineArray" {
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export interface $IImageLineArray {

 "getSize"(): integer
 "getElem"(arg0: integer): integer
 "getImageInfo"(): $ImageInfo
 "getFilterType"(): $FilterType
}

export namespace $IImageLineArray {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IImageLineArray$Type = ($IImageLineArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IImageLineArray_ = $IImageLineArray$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ExceptionsKt" {
import {$ExceptionsKt__ExceptionsKt, $ExceptionsKt__ExceptionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ExceptionsKt__ExceptionsKt"

export class $ExceptionsKt extends $ExceptionsKt__ExceptionsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionsKt$Type = ($ExceptionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionsKt_ = $ExceptionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeResponse" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $UpgradeResponse {

 "setAcceptedSubProtocol"(arg0: string): void
 "getAcceptedSubProtocol"(): string
 "setExtensions"(arg0: $List$Type<($ExtensionConfig$Type)>): void
 "getExtensions"(): $List<($ExtensionConfig)>
 "getHeader"(arg0: string): string
 "getHeaders"(arg0: string): $List<(string)>
 "getHeaders"(): $Map<(string), ($List<(string)>)>
 "getStatusCode"(): integer
 "isSuccess"(): boolean
 "addHeader"(arg0: string, arg1: string): void
 "setHeader"(arg0: string, arg1: string): void
 "getHeaderNames"(): $Set<(string)>
 "setSuccess"(arg0: boolean): void
 "setStatusCode"(arg0: integer): void
 "getStatusReason"(): string
 "sendForbidden"(arg0: string): void
 "setStatusReason"(arg0: string): void
}

export namespace $UpgradeResponse {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeResponse$Type = ($UpgradeResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeResponse_ = $UpgradeResponse$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Intrinsics" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Intrinsics {


public static "needClassReification"(arg0: string): void
public static "needClassReification"(): void
public static "reifiedOperationMarker"(arg0: integer, arg1: string): void
public static "reifiedOperationMarker"(arg0: integer, arg1: string, arg2: string): void
public static "checkParameterIsNotNull"(arg0: any, arg1: string): void
public static "checkReturnedValueIsNotNull"(arg0: any, arg1: string): void
public static "checkReturnedValueIsNotNull"(arg0: any, arg1: string, arg2: string): void
public static "checkFieldIsNotNull"(arg0: any, arg1: string): void
public static "checkFieldIsNotNull"(arg0: any, arg1: string, arg2: string): void
public static "checkExpressionValueIsNotNull"(arg0: any, arg1: string): void
public static "throwIllegalArgument"(): void
public static "throwIllegalArgument"(arg0: string): void
public static "throwUndefinedForReified"(): void
public static "throwUndefinedForReified"(arg0: string): void
public static "throwUninitializedProperty"(arg0: string): void
public static "compare"(arg0: integer, arg1: integer): integer
public static "compare"(arg0: long, arg1: long): integer
public static "checkNotNull"(arg0: any): void
public static "checkNotNull"(arg0: any, arg1: string): void
public static "areEqual"(arg0: float, arg1: float): boolean
public static "areEqual"(arg0: double, arg1: double): boolean
public static "areEqual"(arg0: any, arg1: any): boolean
public static "areEqual"(arg0: double, arg1: double): boolean
public static "areEqual"(arg0: float, arg1: float): boolean
public static "areEqual"(arg0: double, arg1: double): boolean
public static "areEqual"(arg0: float, arg1: float): boolean
public static "throwIllegalState"(): void
public static "throwIllegalState"(arg0: string): void
public static "throwNpe"(arg0: string): void
public static "throwNpe"(): void
public static "throwAssert"(): void
public static "throwAssert"(arg0: string): void
public static "throwJavaNpe"(arg0: string): void
public static "throwJavaNpe"(): void
public static "checkHasClass"(arg0: string, arg1: string): void
public static "checkHasClass"(arg0: string): void
public static "checkNotNullParameter"(arg0: any, arg1: string): void
public static "checkNotNullExpressionValue"(arg0: any, arg1: string): void
public static "stringPlus"(arg0: string, arg1: any): string
public static "throwUninitializedPropertyAccessException"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Intrinsics$Type = ($Intrinsics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Intrinsics_ = $Intrinsics$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$Graceful, $Graceful$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Graceful"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export interface $Connector extends $LifeCycle, $Graceful {

 "getName"(): string
 "getExecutor"(): $Executor
 "getProtocols"(): $List<(string)>
 "getServer"(): $Server
 "getDefaultConnectionFactory"(): $ConnectionFactory
 "getConnectedEndPoints"(): $Collection<($EndPoint)>
 "getConnectionFactories"(): $Collection<($ConnectionFactory)>
 "getConnectionFactory"(arg0: string): $ConnectionFactory
 "getConnectionFactory"<T>(arg0: $Class$Type<(T)>): T
 "getScheduler"(): $Scheduler
 "getByteBufferPool"(): $ByteBufferPool
 "getIdleTimeout"(): long
 "getTransport"(): any
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
 "shutdown"(): $Future<(void)>
}

export namespace $Connector {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Connector$Type = ($Connector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Connector_ = $Connector$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $FunctionBase<R> extends $Function<(R)> {

 "getArity"(): integer

(): integer
}

export namespace $FunctionBase {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionBase$Type<R> = ($FunctionBase<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionBase_<R> = $FunctionBase$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$EmbeddedJettyServer" {
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$EmbeddedServer, $EmbeddedServer$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServer"
import {$SslStores, $SslStores$Type} from "packages/info/journeymap/shaded/kotlin/spark/ssl/$SslStores"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$JettyServerFactory, $JettyServerFactory$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$JettyServerFactory"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmbeddedJettyServer implements $EmbeddedServer {

constructor(arg0: $JettyServerFactory$Type, arg1: $Handler$Type)

public "ignite"(arg0: string, arg1: integer, arg2: $SslStores$Type, arg3: integer, arg4: integer, arg5: integer): integer
public "join"(): void
public "extinguish"(): void
public "configureWebSockets"(arg0: $Map$Type<(string), ($WebSocketHandlerWrapper$Type)>, arg1: $Optional$Type<(integer)>): void
public "activeThreadCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedJettyServer$Type = ($EmbeddedJettyServer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedJettyServer_ = $EmbeddedJettyServer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator" {
import {$ServletUpgradeResponse, $ServletUpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeResponse"
import {$ServletUpgradeRequest, $ServletUpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeRequest"

export interface $WebSocketCreator {

 "createWebSocket"(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): any

(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): any
}

export namespace $WebSocketCreator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketCreator$Type = ($WebSocketCreator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketCreator_ = $WebSocketCreator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$LoginService, $LoginService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService"

export interface $Authenticator$AuthConfiguration {

 "getIdentityService"(): $IdentityService
 "getLoginService"(): $LoginService
 "getRealmName"(): string
 "getInitParameter"(arg0: string): string
 "getAuthMethod"(): string
 "isSessionRenewedOnAuthentication"(): boolean
 "getInitParameterNames"(): $Set<(string)>
}

export namespace $Authenticator$AuthConfiguration {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authenticator$AuthConfiguration$Type = ($Authenticator$AuthConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authenticator$AuthConfiguration_ = $Authenticator$AuthConfiguration$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$Registration$Dynamic" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Registration, $Registration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Registration"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Registration$Dynamic extends $Registration {

 "setAsyncSupported"(arg0: boolean): void
 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $Registration$Dynamic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Registration$Dynamic$Type = ($Registration$Dynamic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Registration$Dynamic_ = $Registration$Dynamic$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KMappedMarker {

}

export namespace $KMappedMarker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMappedMarker$Type = ($KMappedMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMappedMarker_ = $KMappedMarker$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkSeqReaderPng" {
import {$IChunkFactory, $IChunkFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IChunkFactory"
import {$Deinterlacer, $Deinterlacer$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$Deinterlacer"
import {$ChunkLoadBehaviour, $ChunkLoadBehaviour$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkLoadBehaviour"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"
import {$IdatSet, $IdatSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IdatSet"
import {$ChunkSeqReader, $ChunkSeqReader$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkSeqReader"

export class $ChunkSeqReaderPng extends $ChunkSeqReader {

constructor(arg0: boolean)

public "close"(): void
public "consume"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "shouldSkipContent"(arg0: integer, arg1: string): boolean
public "getChunksToSkip"(): $Set<(string)>
public "isCheckCrc"(): boolean
public "isCallbackMode"(): boolean
public "setChunkFactory"(arg0: $IChunkFactory$Type): void
public "getChunks"(): $List<($PngChunk)>
public "getDeinterlacer"(): $Deinterlacer
public "getImageInfo"(): $ImageInfo
public "getIdatSet"(): $IdatSet
public "setCheckCrc"(arg0: boolean): void
public "setChunksToSkip"(...arg0: (string)[]): void
public "isInterlaced"(): boolean
public "addChunkToSkip"(arg0: string): void
public "getBytesChunksLoaded"(): long
public "getSkipChunkMaxSize"(): long
public "setIncludeNonBufferedChunks"(arg0: boolean): void
public "getMaxTotalBytesRead"(): long
public "getMaxBytesMetadata"(): long
public "setMaxTotalBytesRead"(arg0: long): void
public "setMaxBytesMetadata"(arg0: long): void
public "firstChunksNotYetRead"(): boolean
public "setSkipChunkMaxSize"(arg0: long): void
public "setChunkLoadBehaviour"(arg0: $ChunkLoadBehaviour$Type): void
public "getCurrentChunkGroup"(): integer
get "chunksToSkip"(): $Set<(string)>
get "checkCrc"(): boolean
get "callbackMode"(): boolean
set "chunkFactory"(value: $IChunkFactory$Type)
get "chunks"(): $List<($PngChunk)>
get "deinterlacer"(): $Deinterlacer
get "imageInfo"(): $ImageInfo
get "idatSet"(): $IdatSet
set "checkCrc"(value: boolean)
set "chunksToSkip"(value: (string)[])
get "interlaced"(): boolean
get "bytesChunksLoaded"(): long
get "skipChunkMaxSize"(): long
set "includeNonBufferedChunks"(value: boolean)
get "maxTotalBytesRead"(): long
get "maxBytesMetadata"(): long
set "maxTotalBytesRead"(value: long)
set "maxBytesMetadata"(value: long)
set "skipChunkMaxSize"(value: long)
set "chunkLoadBehaviour"(value: $ChunkLoadBehaviour$Type)
get "currentChunkGroup"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSeqReaderPng$Type = ($ChunkSeqReaderPng);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkSeqReaderPng_ = $ChunkSeqReaderPng$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$Body" {
import {$SerializerChain, $SerializerChain$Type} from "packages/info/journeymap/shaded/kotlin/spark/serialization/$SerializerChain"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $Body {


public "get"(): any
public "set"(arg0: any): void
public "isSet"(): boolean
public static "create"(): $Body
public "serializeTo"(arg0: $HttpServletResponse$Type, arg1: $SerializerChain$Type, arg2: $HttpServletRequest$Type): void
public "notSet"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Body$Type = ($Body);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Body_ = $Body$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__UtilsKt" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$FilesKt__FileTreeWalkKt, $FilesKt__FileTreeWalkKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FileTreeWalkKt"
import {$File, $File$Type} from "packages/java/io/$File"

export class $FilesKt__UtilsKt extends $FilesKt__FileTreeWalkKt {

constructor()

public static "startsWith"(arg0: $File$Type, arg1: string): boolean
public static "startsWith"(arg0: $File$Type, arg1: $File$Type): boolean
public static "endsWith"(arg0: $File$Type, arg1: string): boolean
public static "endsWith"(arg0: $File$Type, arg1: $File$Type): boolean
public static "resolve"(arg0: $File$Type, arg1: $File$Type): $File
public static "resolve"(arg0: $File$Type, arg1: string): $File
public static "normalize"(arg0: $File$Type): $File
public static "createTempFile"(arg0: string, arg1: string, arg2: $File$Type): $File
public static "resolveSibling"(arg0: $File$Type, arg1: string): $File
public static "resolveSibling"(arg0: $File$Type, arg1: $File$Type): $File
public static "getExtension"(arg0: $File$Type): string
public static "createTempDir"(arg0: string, arg1: string, arg2: $File$Type): $File
public static "deleteRecursively"(arg0: $File$Type): boolean
public static "getNameWithoutExtension"(arg0: $File$Type): string
public static "copyTo"(arg0: $File$Type, arg1: $File$Type, arg2: boolean, arg3: integer): $File
public static "relativeToOrNull"(arg0: $File$Type, arg1: $File$Type): $File
public static "toRelativeString"(arg0: $File$Type, arg1: $File$Type): string
public static "copyRecursively"(arg0: $File$Type, arg1: $File$Type, arg2: boolean, arg3: $Function2$Type<(any), (any), (any)>): boolean
public static "relativeToOrSelf"(arg0: $File$Type, arg1: $File$Type): $File
public static "relativeTo"(arg0: $File$Type, arg1: $File$Type): $File
public static "getInvariantSeparatorsPath"(arg0: $File$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilesKt__UtilsKt$Type = ($FilesKt__UtilsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilesKt__UtilsKt_ = $FilesKt__UtilsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$FilterImpl" {
import {$Wrapper, $Wrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/utils/$Wrapper"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Filter"

export class $FilterImpl implements $Filter, $Wrapper {


public "handle"(arg0: $Request$Type, arg1: $Response$Type): void
public "getPath"(): string
public "delegate"(): any
public "withPrefix"(arg0: string): $FilterImpl
public "getAcceptType"(): string
get "path"(): string
get "acceptType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterImpl$Type = ($FilterImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterImpl_ = $FilterImpl$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IteratingCallback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $IteratingCallback implements $Callback {


public "toString"(): string
public "close"(): void
public "reset"(): boolean
public "iterate"(): void
public "isClosed"(): boolean
public "succeeded"(): void
public "isFailed"(): boolean
public "failed"(arg0: $Throwable$Type): void
public "isSucceeded"(): boolean
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public "getInvocationType"(): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "closed"(): boolean
get "invocationType"(): $Invocable$InvocationType
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IteratingCallback$Type = ($IteratingCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IteratingCallback_ = $IteratingCallback$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharRange" {
import {$CharRange$Companion, $CharRange$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharRange$Companion"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"
import {$CharProgression, $CharProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression"

export class $CharRange extends $CharProgression implements $ClosedRange<(character)> {
static readonly "Companion": $CharRange$Companion

constructor(arg0: character, arg1: character)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: character): boolean
public "getEndInclusive"(): character
get "empty"(): boolean
get "endInclusive"(): character
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharRange$Type = ($CharRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharRange_ = $CharRange$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$Deinterlacer" {
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $Deinterlacer {

constructor(arg0: $ImageInfo$Type)

public "getBytesToRead"(): integer
public "getoX"(): integer
public "getTotalRows"(): integer
public "getdY"(): integer
public "getoY"(): integer
public "getPixelsToRead"(): integer
public "getdX"(): integer
public "getCurrRowSeq"(): integer
public "getTotalRawBytes"(): long
get "bytesToRead"(): integer
get "oX"(): integer
get "totalRows"(): integer
get "dY"(): integer
get "oY"(): integer
get "pixelsToRead"(): integer
get "dX"(): integer
get "currRowSeq"(): integer
get "totalRawBytes"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Deinterlacer$Type = ($Deinterlacer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Deinterlacer_ = $Deinterlacer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/payload/$PayloadProcessor" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $PayloadProcessor {

 "reset"(arg0: $Frame$Type): void
 "process"(arg0: $ByteBuffer$Type): void
}

export namespace $PayloadProcessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PayloadProcessor$Type = ($PayloadProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PayloadProcessor_ = $PayloadProcessor$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharDirectionality$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$CharDirectionality, $CharDirectionality$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharDirectionality"

export class $CharDirectionality$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "valueOf"(arg0: integer): $CharDirectionality
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharDirectionality$Companion$Type = ($CharDirectionality$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharDirectionality$Companion_ = $CharDirectionality$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ListenerHolder" {
import {$BaseHolder, $BaseHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$BaseHolder"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"

export class $ListenerHolder extends $BaseHolder<($EventListener)> {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Source$Type)

public "getListener"(): $EventListener
public "doStart"(): void
public "setListener"(arg0: $EventListener$Type): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "listener"(): $EventListener
set "listener"(value: $EventListener$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListenerHolder$Type = ($ListenerHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListenerHolder_ = $ListenerHolder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Constraint" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"

export class $Constraint implements $Cloneable, $Serializable {
static readonly "__BASIC_AUTH": string
static readonly "__FORM_AUTH": string
static readonly "__DIGEST_AUTH": string
static readonly "__CERT_AUTH": string
static readonly "__CERT_AUTH2": string
static readonly "__SPNEGO_AUTH": string
static readonly "__NEGOTIATE_AUTH": string
static readonly "DC_UNSET": integer
static readonly "DC_NONE": integer
static readonly "DC_INTEGRAL": integer
static readonly "DC_CONFIDENTIAL": integer
static readonly "DC_FORBIDDEN": integer
static readonly "NONE": string
static readonly "ANY_ROLE": string
static readonly "ANY_AUTH": string

constructor()
constructor(arg0: string, arg1: string)

public "setAuthenticate"(arg0: boolean): void
public "setRoles"(arg0: (string)[]): void
public "setDataConstraint"(arg0: integer): void
public "getRoles"(): (string)[]
public "isForbidden"(): boolean
public "getDataConstraint"(): integer
public "isAnyRole"(): boolean
public "getAuthenticate"(): boolean
public "isAnyAuth"(): boolean
public "hasRole"(arg0: string): boolean
public "hasDataConstraint"(): boolean
public "getName"(): string
public "toString"(): string
public "clone"(): any
public "setName"(arg0: string): void
public static "validateMethod"(arg0: string): boolean
set "authenticate"(value: boolean)
set "roles"(value: (string)[])
set "dataConstraint"(value: integer)
get "roles"(): (string)[]
get "forbidden"(): boolean
get "dataConstraint"(): integer
get "anyRole"(): boolean
get "authenticate"(): boolean
get "anyAuth"(): boolean
get "name"(): string
set "name"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Constraint$Type = ($Constraint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Constraint_ = $Constraint$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$RequestLogCollection" {
import {$RequestLog, $RequestLog$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$RequestLog"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Response"

export class $RequestLogCollection implements $RequestLog {

constructor(...arg0: ($RequestLog$Type)[])

public "add"(arg0: $RequestLog$Type): void
public "log"(arg0: $Request$Type, arg1: $Response$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestLogCollection$Type = ($RequestLogCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequestLogCollection_ = $RequestLogCollection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$RemoteEndpointFactory" {
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"
import {$RemoteEndpoint, $RemoteEndpoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$RemoteEndpoint"

export interface $RemoteEndpointFactory {

 "newRemoteEndpoint"(arg0: $LogicalConnection$Type, arg1: $OutgoingFrames$Type, arg2: $BatchMode$Type): $RemoteEndpoint

(arg0: $LogicalConnection$Type, arg1: $OutgoingFrames$Type, arg2: $BatchMode$Type): $RemoteEndpoint
}

export namespace $RemoteEndpointFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoteEndpointFactory$Type = ($RemoteEndpointFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoteEndpointFactory_ = $RemoteEndpointFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpURI, $HttpURI$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpURI"
import {$HttpScheme, $HttpScheme$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpScheme"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$HostPortHttpField, $HostPortHttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HostPortHttpField"
import {$MetaData, $MetaData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData"

export class $MetaData$Request extends $MetaData {

constructor(arg0: string, arg1: $HttpScheme$Type, arg2: $HostPortHttpField$Type, arg3: string, arg4: $HttpVersion$Type, arg5: $HttpFields$Type, arg6: long)
constructor(arg0: string, arg1: string, arg2: $HostPortHttpField$Type, arg3: string, arg4: $HttpVersion$Type, arg5: $HttpFields$Type, arg6: long)
constructor(arg0: $MetaData$Request$Type)
constructor(arg0: $HttpFields$Type)
constructor(arg0: string, arg1: $HttpScheme$Type, arg2: $HostPortHttpField$Type, arg3: string, arg4: $HttpVersion$Type, arg5: $HttpFields$Type)
constructor(arg0: string, arg1: $HttpURI$Type, arg2: $HttpVersion$Type, arg3: $HttpFields$Type, arg4: long)
constructor(arg0: string, arg1: $HttpURI$Type, arg2: $HttpVersion$Type, arg3: $HttpFields$Type)

public "isRequest"(): boolean
public "toString"(): string
public "getMethod"(): string
public "setMethod"(arg0: string): void
public "getURI"(): $HttpURI
public "setURI"(arg0: $HttpURI$Type): void
public "recycle"(): void
public "getURIString"(): string
get "request"(): boolean
get "method"(): string
set "method"(value: string)
get "uRI"(): $HttpURI
set "uRI"(value: $HttpURI$Type)
get "uRIString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaData$Request$Type = ($MetaData$Request);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaData$Request_ = $MetaData$Request$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DeprecationWarning" {
import {$Decorator, $Decorator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Decorator"

export class $DeprecationWarning implements $Decorator {

constructor()

public "destroy"(arg0: any): void
public "decorate"<T>(arg0: T): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeprecationWarning$Type = ($DeprecationWarning);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeprecationWarning_ = $DeprecationWarning$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference0" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KMutableProperty0, $KMutableProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0"
import {$MutablePropertyReference, $MutablePropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference"

export class $MutablePropertyReference0 extends $MutablePropertyReference implements $KMutableProperty0<(any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: any)

public "invoke"(): any
public "getDelegate"(): any
public "set"(arg0: any): void
public "get"(): any
get "delegate"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutablePropertyReference0$Type = ($MutablePropertyReference0);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutablePropertyReference0_ = $MutablePropertyReference0$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference1" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KMutableProperty1, $KMutableProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1"
import {$MutablePropertyReference, $MutablePropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference"

export class $MutablePropertyReference1 extends $MutablePropertyReference implements $KMutableProperty1<(any), (any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: any)

public "invoke"(arg0: any): any
public "getDelegate"(arg0: any): any
public "set"(arg0: any, arg1: any): void
public "get"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutablePropertyReference1$Type = ($MutablePropertyReference1);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutablePropertyReference1_ = $MutablePropertyReference1$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference2" {
import {$KMutableProperty2, $KMutableProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MutablePropertyReference, $MutablePropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference"

export class $MutablePropertyReference2 extends $MutablePropertyReference implements $KMutableProperty2<(any), (any), (any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: $Class$Type<(any)>, arg1: string, arg2: string, arg3: integer)

public "invoke"(arg0: any, arg1: any): any
public "getDelegate"(arg0: any, arg1: any): any
public "set"(arg0: any, arg1: any, arg2: any): void
public "get"(arg0: any, arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutablePropertyReference2$Type = ($MutablePropertyReference2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutablePropertyReference2_ = $MutablePropertyReference2$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksListForWrite" {
import {$ChunksList, $ChunksList$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksList"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export class $ChunksListForWrite extends $ChunksList {
static readonly "CHUNK_GROUP_0_IDHR": integer
static readonly "CHUNK_GROUP_1_AFTERIDHR": integer
static readonly "CHUNK_GROUP_2_PLTE": integer
static readonly "CHUNK_GROUP_3_AFTERPLTE": integer
static readonly "CHUNK_GROUP_4_IDAT": integer
static readonly "CHUNK_GROUP_5_AFTERIDAT": integer
static readonly "CHUNK_GROUP_6_END": integer

constructor(arg0: $ImageInfo$Type)

public "getQueuedChunks"(): $List<($PngChunk)>
public "toString"(): string
public "queue"(arg0: $PngChunk$Type): boolean
public "writeChunks"(arg0: $OutputStream$Type, arg1: integer): integer
public "getQueuedById1"(arg0: string): $PngChunk
public "getQueuedById1"(arg0: string, arg1: string, arg2: boolean): $PngChunk
public "getQueuedById1"(arg0: string, arg1: boolean): $PngChunk
public "getQueuedById"(arg0: string): $List<(any)>
public "getQueuedById"(arg0: string, arg1: string): $List<(any)>
public "removeChunk"(arg0: $PngChunk$Type): boolean
public "toStringFull"(): string
public "getQueuedEquivalent"(arg0: $PngChunk$Type): $List<($PngChunk)>
get "queuedChunks"(): $List<($PngChunk)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunksListForWrite$Type = ($ChunksListForWrite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunksListForWrite_ = $ChunksListForWrite$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableList" {
import {$KMutableCollection, $KMutableCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableCollection"

export interface $KMutableList extends $KMutableCollection {

}

export namespace $KMutableList {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableList$Type = ($KMutableList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableList_ = $KMutableList$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSPLT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$PngChunkMultiple, $PngChunkMultiple$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkMultiple"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PngChunkSPLT extends $PngChunkMultiple {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getPalette"(): (integer)[]
public "getNentries"(): integer
public "setSampledepth"(arg0: integer): void
public "setPalette"(arg0: (integer)[]): void
public "getPalName"(): string
public "setPalName"(arg0: string): void
public "getSampledepth"(): integer
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "palette"(): (integer)[]
get "nentries"(): integer
set "sampledepth"(value: integer)
set "palette"(value: (integer)[])
get "palName"(): string
set "palName"(value: string)
get "sampledepth"(): integer
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkSPLT$Type = ($PngChunkSPLT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkSPLT_ = $PngChunkSPLT$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authenticator, $Authenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$LoginService, $LoginService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export class $LoginAuthenticator implements $Authenticator {


public "getLoginService"(): $LoginService
public "prepareRequest"(arg0: $ServletRequest$Type): void
public "setConfiguration"(arg0: $Authenticator$AuthConfiguration$Type): void
public "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $UserIdentity
public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "getAuthMethod"(): string
get "loginService"(): $LoginService
set "configuration"(value: $Authenticator$AuthConfiguration$Type)
get "authMethod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoginAuthenticator$Type = ($LoginAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoginAuthenticator_ = $LoginAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ReversedListReadOnly" {
import {$AbstractList$Companion, $AbstractList$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList$Companion"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList"

export class $ReversedListReadOnly<T> extends $AbstractList<(T)> {
static readonly "Companion": $AbstractList$Companion

constructor(arg0: $List$Type<(any)>)

public "get"(arg0: integer): T
public "getSize"(): integer
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReversedListReadOnly$Type<T> = ($ReversedListReadOnly<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReversedListReadOnly_<T> = $ReversedListReadOnly$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$DirectoryTraversal" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DirectoryTraversal {

constructor()

public static "protectAgainstForExternal"(arg0: string): void
public static "protectAgainstInClassPath"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectoryTraversal$Type = ($DirectoryTraversal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DirectoryTraversal_ = $DirectoryTraversal$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$MatcherFilter" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$FilterConfig, $FilterConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterConfig"
import {$StaticFilesConfiguration, $StaticFilesConfiguration$Type} from "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesConfiguration"
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"
import {$FilterChain, $FilterChain$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterChain"

export class $MatcherFilter implements $Filter {

constructor(arg0: $Routes$Type, arg1: $StaticFilesConfiguration$Type, arg2: boolean, arg3: boolean)

public "doFilter"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: $FilterChain$Type): void
public "init"(arg0: $FilterConfig$Type): void
public "destroy"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatcherFilter$Type = ($MatcherFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatcherFilter_ = $MatcherFilter$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$TransportGuarantee" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ServletSecurity$TransportGuarantee extends $Enum<($ServletSecurity$TransportGuarantee)> {
static readonly "NONE": $ServletSecurity$TransportGuarantee
static readonly "CONFIDENTIAL": $ServletSecurity$TransportGuarantee


public static "values"(): ($ServletSecurity$TransportGuarantee)[]
public static "valueOf"(arg0: string): $ServletSecurity$TransportGuarantee
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletSecurity$TransportGuarantee$Type = (("none") | ("confidential")) | ($ServletSecurity$TransportGuarantee);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletSecurity$TransportGuarantee_ = $ServletSecurity$TransportGuarantee$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayShortIterator" {
import {$ShortIterator, $ShortIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ShortIterator"

export class $ArrayShortIterator extends $ShortIterator {

constructor(arg0: (short)[])

public "hasNext"(): boolean
public "nextShort"(): short
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayShortIterator$Type = ($ArrayShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayShortIterator_ = $ArrayShortIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$AsyncListener, $AsyncListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncListener"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $AsyncContext {

 "getTimeout"(): long
 "dispatch"(): void
 "dispatch"(arg0: string): void
 "dispatch"(arg0: $ServletContext$Type, arg1: string): void
 "start"(arg0: $Runnable$Type): void
 "complete"(): void
 "setTimeout"(arg0: long): void
 "getResponse"(): $ServletResponse
 "createListener"<T extends $AsyncListener>(arg0: $Class$Type<(T)>): T
 "addListener"(arg0: $AsyncListener$Type, arg1: $ServletRequest$Type, arg2: $ServletResponse$Type): void
 "addListener"(arg0: $AsyncListener$Type): void
 "getRequest"(): $ServletRequest
 "hasOriginalRequestAndResponse"(): boolean
}

export namespace $AsyncContext {
const ASYNC_REQUEST_URI: string
const ASYNC_CONTEXT_PATH: string
const ASYNC_MAPPING: string
const ASYNC_PATH_INFO: string
const ASYNC_SERVLET_PATH: string
const ASYNC_QUERY_STRING: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncContext$Type = ($AsyncContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncContext_ = $AsyncContext$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequencesKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SequencesKt__SequencesJVMKt, $SequencesKt__SequencesJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequencesJVMKt"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"

export class $SequencesKt__SequencesKt extends $SequencesKt__SequencesJVMKt {

constructor()

public static "flattenSequenceOfIterable"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "flatten"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "generateSequence"<T>(arg0: $Function0$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(T)>
public static "generateSequence"<T>(arg0: T, arg1: $Function1$Type<(any), (any)>): $Sequence<(T)>
public static "generateSequence"<T>(arg0: $Function0$Type<(any)>): $Sequence<(T)>
public static "asSequence"<T>(arg0: $Iterator$Type<(any)>): $Sequence<(T)>
public static "flatMapIndexed"<T, C, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>, arg2: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "constrainOnce"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "emptySequence"<T>(): $Sequence<(T)>
public static "sequenceOf"<T>(...arg0: (T)[]): $Sequence<(T)>
public static "shuffled"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "shuffled"<T>(arg0: $Sequence$Type<(any)>, arg1: $Random$Type): $Sequence<(T)>
public static "ifEmpty"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function0$Type<(any)>): $Sequence<(T)>
public static "unzip"<T, R>(arg0: $Sequence$Type<(any)>): $Pair<($List<(T)>), ($List<(R)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt__SequencesKt$Type = ($SequencesKt__SequencesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt__SequencesKt_ = $SequencesKt__SequencesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$AbstractLogger" {
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Properties, $Properties$Type} from "packages/java/util/$Properties"

export class $AbstractLogger implements $Logger {
static readonly "LEVEL_DEFAULT": integer
static readonly "LEVEL_ALL": integer
static readonly "LEVEL_DEBUG": integer
static readonly "LEVEL_INFO": integer
static readonly "LEVEL_WARN": integer
static readonly "LEVEL_OFF": integer

constructor()

public "getLogger"(arg0: string): $Logger
public "debug"(arg0: string, arg1: long): void
public static "getLoggingProperty"(arg0: $Properties$Type, arg1: string, arg2: string): string
public static "lookupLoggingLevel"(arg0: $Properties$Type, arg1: string): integer
public "getName"(): string
public "info"(arg0: string, ...arg1: (any)[]): void
public "info"(arg0: $Throwable$Type): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "debug"(arg0: $Throwable$Type): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "ignore"(arg0: $Throwable$Type): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: $Throwable$Type): void
public "isDebugEnabled"(): boolean
public "setDebugEnabled"(arg0: boolean): void
get "name"(): string
get "debugEnabled"(): boolean
set "debugEnabled"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLogger$Type = ($AbstractLogger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLogger_ = $AbstractLogger$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$BaseContinuationImpl" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$CoroutineStackFrame, $CoroutineStackFrame$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$CoroutineStackFrame"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"

export class $BaseContinuationImpl implements $Continuation<(any)>, $CoroutineStackFrame, $Serializable {

constructor(arg0: $Continuation$Type<(any)>)

public "toString"(): string
public "create"(arg0: $Continuation$Type<(any)>): $Continuation<($Unit)>
public "create"(arg0: any, arg1: $Continuation$Type<(any)>): $Continuation<($Unit)>
public "resumeWith"(arg0: any): void
public "getCallerFrame"(): $CoroutineStackFrame
public "getStackTraceElement"(): $StackTraceElement
public "getCompletion"(): $Continuation<(any)>
public "getContext"(): $CoroutineContext
get "callerFrame"(): $CoroutineStackFrame
get "stackTraceElement"(): $StackTraceElement
get "completion"(): $Continuation<(any)>
get "context"(): $CoroutineContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseContinuationImpl$Type = ($BaseContinuationImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseContinuationImpl_ = $BaseContinuationImpl$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextAttributeListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$ServletContextAttributeEvent, $ServletContextAttributeEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextAttributeEvent"

export interface $ServletContextAttributeListener extends $EventListener {

 "attributeAdded"(arg0: $ServletContextAttributeEvent$Type): void
 "attributeReplaced"(arg0: $ServletContextAttributeEvent$Type): void
 "attributeRemoved"(arg0: $ServletContextAttributeEvent$Type): void
}

export namespace $ServletContextAttributeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextAttributeListener$Type = ($ServletContextAttributeListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextAttributeListener_ = $ServletContextAttributeListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpTransport" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$MetaData$Response, $MetaData$Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response"
import {$MetaData$Request, $MetaData$Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"

export interface $HttpTransport {

 "push"(arg0: $MetaData$Request$Type): void
 "abort"(arg0: $Throwable$Type): void
 "isOptimizedForDirectBuffers"(): boolean
 "send"(arg0: $MetaData$Response$Type, arg1: boolean, arg2: $ByteBuffer$Type, arg3: boolean, arg4: $Callback$Type): void
 "onCompleted"(): void
 "isPushSupported"(): boolean
}

export namespace $HttpTransport {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpTransport$Type = ($HttpTransport);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpTransport_ = $HttpTransport$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/math/$MathKt__MathHKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MathKt__MathHKt {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MathKt__MathHKt$Type = ($MathKt__MathHKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MathKt__MathHKt_ = $MathKt__MathHKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable" {
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ThreadLocal, $ThreadLocal$Type} from "packages/java/lang/$ThreadLocal"

export interface $Invocable {

 "getInvocationType"(): $Invocable$InvocationType
}

export namespace $Invocable {
const __nonBlocking: $ThreadLocal<(boolean)>
function getInvocationType(arg0: any): $Invocable$InvocationType
function asPreferred(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
function invokePreferred(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
function invokeNonBlocking(arg0: $Runnable$Type): void
function isNonBlockingInvocation(): boolean
function invokePreferNonBlocking(arg0: $Runnable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Invocable$Type = ($Invocable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Invocable_ = $Invocable$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$MimeType" {
import {$AbstractFileResolvingResource, $AbstractFileResolvingResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractFileResolvingResource"

export class $MimeType {

constructor()

public static "disableGuessing"(): void
public static "register"(arg0: string, arg1: string): void
public static "fromResource"(arg0: $AbstractFileResolvingResource$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MimeType$Type = ($MimeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MimeType_ = $MimeType$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$OnWebSocketMessage" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OnWebSocketMessage extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OnWebSocketMessage {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnWebSocketMessage$Type = ($OnWebSocketMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnWebSocketMessage_ = $OnWebSocketMessage$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/annotation/$ManagedOperation" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ManagedOperation extends $Annotation {

 "value"(): string
 "proxied"(): boolean
 "impact"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ManagedOperation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedOperation$Type = ($ManagedOperation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedOperation_ = $ManagedOperation$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Log" {
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Properties, $Properties$Type} from "packages/java/util/$Properties"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Log {
static readonly "EXCEPTION": string
static readonly "IGNORED": string
static "__logClass": string
static "__ignored": boolean

constructor()

public static "getLogger"(arg0: string): $Logger
public static "getLogger"(arg0: $Class$Type<(any)>): $Logger
public static "getProperties"(): $Properties
public static "initialized"(): void
public static "getRootLogger"(): $Logger
public static "getLoggers"(): $Map<(string), ($Logger)>
public static "setLog"(arg0: $Logger$Type): void
public static "setLogToParent"(arg0: string): void
public static "getLog"(): $Logger
get "properties"(): $Properties
get "rootLogger"(): $Logger
get "loggers"(): $Map<(string), ($Logger)>
set "log"(value: $Logger$Type)
set "logToParent"(value: string)
get "log"(): $Logger
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Log$Type = ($Log);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Log_ = $Log$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestWrapper" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServletRequestWrapper implements $ServletRequest {

constructor(arg0: $ServletRequest$Type)

public "getScheme"(): string
public "getInputStream"(): $ServletInputStream
public "getProtocol"(): string
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "getLocale"(): $Locale
public "getContentLength"(): integer
/**
 * 
 * @deprecated
 */
public "getRealPath"(arg0: string): string
public "getContentLengthLong"(): long
public "getContentType"(): string
public "isSecure"(): boolean
public "getParameter"(arg0: string): string
public "getLocalName"(): string
public "getLocalPort"(): integer
public "removeAttribute"(arg0: string): void
public "getCharacterEncoding"(): string
public "setCharacterEncoding"(arg0: string): void
public "getRequestDispatcher"(arg0: string): $RequestDispatcher
public "getServerName"(): string
public "getReader"(): $BufferedReader
public "getDispatcherType"(): $DispatcherType
public "getServletContext"(): $ServletContext
public "isAsyncStarted"(): boolean
public "getRemotePort"(): integer
public "getParameterNames"(): $Enumeration<(string)>
public "getParameterValues"(arg0: string): (string)[]
public "getLocalAddr"(): string
public "startAsync"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $AsyncContext
public "startAsync"(): $AsyncContext
public "getRemoteAddr"(): string
public "getParameterMap"(): $Map<(string), ((string)[])>
public "getLocales"(): $Enumeration<($Locale)>
public "getRemoteHost"(): string
public "getServerPort"(): integer
public "isAsyncSupported"(): boolean
public "getAsyncContext"(): $AsyncContext
public "getRequest"(): $ServletRequest
public "setRequest"(arg0: $ServletRequest$Type): void
public "getAttributeNames"(): $Enumeration<(string)>
public "isWrapperFor"(arg0: $Class$Type<(any)>): boolean
public "isWrapperFor"(arg0: $ServletRequest$Type): boolean
get "scheme"(): string
get "inputStream"(): $ServletInputStream
get "protocol"(): string
get "locale"(): $Locale
get "contentLength"(): integer
get "contentLengthLong"(): long
get "contentType"(): string
get "secure"(): boolean
get "localName"(): string
get "localPort"(): integer
get "characterEncoding"(): string
set "characterEncoding"(value: string)
get "serverName"(): string
get "reader"(): $BufferedReader
get "dispatcherType"(): $DispatcherType
get "servletContext"(): $ServletContext
get "asyncStarted"(): boolean
get "remotePort"(): integer
get "parameterNames"(): $Enumeration<(string)>
get "localAddr"(): string
get "remoteAddr"(): string
get "parameterMap"(): $Map<(string), ((string)[])>
get "locales"(): $Enumeration<($Locale)>
get "remoteHost"(): string
get "serverPort"(): integer
get "asyncSupported"(): boolean
get "asyncContext"(): $AsyncContext
get "request"(): $ServletRequest
set "request"(value: $ServletRequest$Type)
get "attributeNames"(): $Enumeration<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestWrapper$Type = ($ServletRequestWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestWrapper_ = $ServletRequestWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt___ComparisonsJvmKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ComparisonsKt__ComparisonsKt, $ComparisonsKt__ComparisonsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt__ComparisonsKt"

export class $ComparisonsKt___ComparisonsJvmKt extends $ComparisonsKt__ComparisonsKt {

constructor()

public static "minOf"<T extends $Comparable<(any)>>(arg0: T, arg1: T, arg2: T): T
public static "minOf"<T extends $Comparable<(any)>>(arg0: T, arg1: T): T
public static "minOf"(arg0: short, ...arg1: (short)[]): short
public static "minOf"(arg0: integer, ...arg1: (integer)[]): integer
public static "minOf"(arg0: long, ...arg1: (long)[]): long
public static "minOf"(arg0: float, ...arg1: (float)[]): float
public static "minOf"(arg0: double, ...arg1: (double)[]): double
public static "minOf"<T extends $Comparable<(any)>>(arg0: T, ...arg1: (T)[]): T
public static "minOf"(arg0: byte, ...arg1: (byte)[]): byte
public static "maxOf"<T extends $Comparable<(any)>>(arg0: T, arg1: T, arg2: T): T
public static "maxOf"<T extends $Comparable<(any)>>(arg0: T, arg1: T): T
public static "maxOf"(arg0: short, ...arg1: (short)[]): short
public static "maxOf"(arg0: integer, ...arg1: (integer)[]): integer
public static "maxOf"(arg0: long, ...arg1: (long)[]): long
public static "maxOf"(arg0: float, ...arg1: (float)[]): float
public static "maxOf"(arg0: double, ...arg1: (double)[]): double
public static "maxOf"<T extends $Comparable<(any)>>(arg0: T, ...arg1: (T)[]): T
public static "maxOf"(arg0: byte, ...arg1: (byte)[]): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparisonsKt___ComparisonsJvmKt$Type = ($ComparisonsKt___ComparisonsJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparisonsKt___ComparisonsJvmKt_ = $ComparisonsKt___ComparisonsJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Sequence<T> {

 "iterator"(): $Iterator<(T)>

(): $Iterator<(T)>
}

export namespace $Sequence {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sequence$Type<T> = ($Sequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sequence_<T> = $Sequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeRequest" {
import {$X509Certificate, $X509Certificate$Type} from "packages/java/security/cert/$X509Certificate"
import {$HttpCookie, $HttpCookie$Type} from "packages/java/net/$HttpCookie"
import {$UpgradeRequest, $UpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeRequest"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $ServletUpgradeRequest implements $UpgradeRequest {

constructor(arg0: $HttpServletRequest$Type)

public "setServletAttribute"(arg0: string, arg1: any): void
public "getMethod"(): string
public "getCertificates"(): ($X509Certificate)[]
public "getHost"(): string
public "getLocalHostName"(): string
public "getLocale"(): $Locale
public "complete"(): void
public "setExtensions"(arg0: $List$Type<($ExtensionConfig$Type)>): void
public "getExtensions"(): $List<($ExtensionConfig)>
public "setMethod"(arg0: string): void
public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $List<(string)>
public "getHeaders"(): $Map<(string), ($List<(string)>)>
public "isSecure"(): boolean
public "getProtocolVersion"(): string
public "getRequestURI"(): $URI
public "setHeaders"(arg0: $Map$Type<(string), ($List$Type<(string)>)>): void
public "getLocalAddress"(): string
public "getLocalPort"(): integer
public "getRemoteSocketAddress"(): $InetSocketAddress
public "getLocalSocketAddress"(): $InetSocketAddress
public "getQueryString"(): string
public "setCookies"(arg0: $List$Type<($HttpCookie$Type)>): void
public "setSession"(arg0: any): void
public "setHttpVersion"(arg0: string): void
public "getRemoteAddress"(): string
public "getOrigin"(): string
public "setHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: string, arg1: $List$Type<(string)>): void
public "isUserInRole"(arg0: string): boolean
public "getUserPrincipal"(): $Principal
public "getCookies"(): $List<($HttpCookie)>
public "getRemotePort"(): integer
public "getParameterMap"(): $Map<(string), ($List<(string)>)>
public "getLocales"(): $Enumeration<($Locale)>
public "getHttpVersion"(): string
public "getRequestPath"(): string
/**
 * 
 * @deprecated
 */
public "getPrincipal"(): $Principal
public "getRemoteHostName"(): string
public "clearHeaders"(): void
public "getHttpServletRequest"(): $HttpServletRequest
public "getHeaderInt"(arg0: string): integer
public "addExtensions"(...arg0: ($ExtensionConfig$Type)[]): void
public "addExtensions"(...arg0: (string)[]): void
public "setRequestURI"(arg0: $URI$Type): void
public "setSubProtocols"(arg0: $List$Type<(string)>): void
public "setSubProtocols"(...arg0: (string)[]): void
public "isOrigin"(arg0: string): boolean
public "getSubProtocols"(): $List<(string)>
public "hasSubProtocol"(arg0: string): boolean
public "getServletAttribute"(arg0: string): any
public "getServletAttributes"(): $Map<(string), (any)>
public "getServletParameters"(): $Map<(string), ($List<(string)>)>
get "method"(): string
get "certificates"(): ($X509Certificate)[]
get "host"(): string
get "localHostName"(): string
get "locale"(): $Locale
set "extensions"(value: $List$Type<($ExtensionConfig$Type)>)
get "extensions"(): $List<($ExtensionConfig)>
set "method"(value: string)
get "headers"(): $Map<(string), ($List<(string)>)>
get "secure"(): boolean
get "protocolVersion"(): string
get "requestURI"(): $URI
set "headers"(value: $Map$Type<(string), ($List$Type<(string)>)>)
get "localAddress"(): string
get "localPort"(): integer
get "remoteSocketAddress"(): $InetSocketAddress
get "localSocketAddress"(): $InetSocketAddress
get "queryString"(): string
set "cookies"(value: $List$Type<($HttpCookie$Type)>)
set "session"(value: any)
set "httpVersion"(value: string)
get "remoteAddress"(): string
get "origin"(): string
get "userPrincipal"(): $Principal
get "cookies"(): $List<($HttpCookie)>
get "remotePort"(): integer
get "parameterMap"(): $Map<(string), ($List<(string)>)>
get "locales"(): $Enumeration<($Locale)>
get "httpVersion"(): string
get "requestPath"(): string
get "principal"(): $Principal
get "remoteHostName"(): string
get "httpServletRequest"(): $HttpServletRequest
set "requestURI"(value: $URI$Type)
set "subProtocols"(value: $List$Type<(string)>)
set "subProtocols"(value: (string)[])
get "subProtocols"(): $List<(string)>
get "servletAttributes"(): $Map<(string), (any)>
get "servletParameters"(): $Map<(string), ($List<(string)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletUpgradeRequest$Type = ($ServletUpgradeRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletUpgradeRequest_ = $ServletUpgradeRequest$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt__ComparisonsKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"

export class $ComparisonsKt__ComparisonsKt {

constructor()

public static "reverseOrder"<T extends $Comparable<(any)>>(): $Comparator<(T)>
public static "reversed"<T>(arg0: $Comparator$Type<(T)>): $Comparator<(T)>
public static "naturalOrder"<T extends $Comparable<(any)>>(): $Comparator<(T)>
public static "nullsFirst"<T>(arg0: $Comparator$Type<(any)>): $Comparator<(T)>
public static "nullsLast"<T>(arg0: $Comparator$Type<(any)>): $Comparator<(T)>
public static "compareValues"<T extends $Comparable<(any)>>(arg0: T, arg1: T): integer
public static "then"<T>(arg0: $Comparator$Type<(T)>, arg1: $Comparator$Type<(any)>): $Comparator<(T)>
public static "compareBy"<T>(...arg0: ($Function1$Type<(any), (any)>)[]): $Comparator<(T)>
public static "compareValuesBy"<T>(arg0: T, arg1: T, ...arg2: ($Function1$Type<(any), (any)>)[]): integer
public static "thenDescending"<T>(arg0: $Comparator$Type<(T)>, arg1: $Comparator$Type<(any)>): $Comparator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparisonsKt__ComparisonsKt$Type = ($ComparisonsKt__ComparisonsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparisonsKt__ComparisonsKt_ = $ComparisonsKt__ComparisonsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export interface $EndPoint extends $Closeable {

 "getCreatedTimeStamp"(): long
 "flush"(...arg0: ($ByteBuffer$Type)[]): boolean
 "fill"(arg0: $ByteBuffer$Type): integer
 "isOpen"(): boolean
 "write"(arg0: $Callback$Type, ...arg1: ($ByteBuffer$Type)[]): void
 "close"(): void
 "onClose"(): void
 "getConnection"(): $Connection
 "getLocalAddress"(): $InetSocketAddress
 "tryFillInterested"(arg0: $Callback$Type): boolean
 "fillInterested"(arg0: $Callback$Type): void
 "isFillInterested"(): boolean
 "setConnection"(arg0: $Connection$Type): void
 "isInputShutdown"(): boolean
 "isOutputShutdown"(): boolean
 "shutdownOutput"(): void
 "onOpen"(): void
 "isOptimizedForDirectBuffers"(): boolean
 "getRemoteAddress"(): $InetSocketAddress
 "upgrade"(arg0: $Connection$Type): void
 "setIdleTimeout"(arg0: long): void
 "getIdleTimeout"(): long
 "getTransport"(): any
}

export namespace $EndPoint {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndPoint$Type = ($EndPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EndPoint_ = $EndPoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IntIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $IntIterator implements $Iterator<(integer)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextInt"(): integer
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterator$Type = ($IntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterator_ = $IntIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayFloatIterator" {
import {$FloatIterator, $FloatIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$FloatIterator"

export class $ArrayFloatIterator extends $FloatIterator {

constructor(arg0: (float)[])

public "hasNext"(): boolean
public "nextFloat"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayFloatIterator$Type = ($ArrayFloatIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayFloatIterator_ = $ArrayFloatIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$IntrinsicsKt__IntrinsicsKt" {
import {$IntrinsicsKt__IntrinsicsJvmKt, $IntrinsicsKt__IntrinsicsJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$IntrinsicsKt__IntrinsicsJvmKt"

export class $IntrinsicsKt__IntrinsicsKt extends $IntrinsicsKt__IntrinsicsJvmKt {

constructor()

public static "getCOROUTINE_SUSPENDED"(): any
get "cOROUTINE_SUSPENDED"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntrinsicsKt__IntrinsicsKt$Type = ($IntrinsicsKt__IntrinsicsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntrinsicsKt__IntrinsicsKt_ = $IntrinsicsKt__IntrinsicsKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FilterType extends $Enum<($FilterType)> {
static readonly "FILTER_NONE": $FilterType
static readonly "FILTER_SUB": $FilterType
static readonly "FILTER_UP": $FilterType
static readonly "FILTER_AVERAGE": $FilterType
static readonly "FILTER_PAETH": $FilterType
static readonly "FILTER_DEFAULT": $FilterType
static readonly "FILTER_AGGRESSIVE": $FilterType
static readonly "FILTER_VERYAGGRESSIVE": $FilterType
static readonly "FILTER_ADAPTIVE_FULL": $FilterType
static readonly "FILTER_ADAPTIVE_MEDIUM": $FilterType
static readonly "FILTER_ADAPTIVE_FAST": $FilterType
static readonly "FILTER_SUPER_ADAPTIVE": $FilterType
static readonly "FILTER_PRESERVE": $FilterType
static readonly "FILTER_CYCLIC": $FilterType
static readonly "FILTER_UNKNOWN": $FilterType
readonly "val": integer


public static "values"(): ($FilterType)[]
public static "valueOf"(arg0: string): $FilterType
public static "getByVal"(arg0: integer): $FilterType
public static "isValidStandard"(arg0: $FilterType$Type): boolean
public static "isValidStandard"(arg0: integer): boolean
public static "isAdaptive"(arg0: $FilterType$Type): boolean
public static "getAllStandard"(): ($FilterType)[]
public static "getAllStandardNoneLast"(): ($FilterType)[]
public static "getAllStandardExceptNone"(): ($FilterType)[]
get "allStandard"(): ($FilterType)[]
get "allStandardNoneLast"(): ($FilterType)[]
get "allStandardExceptNone"(): ($FilterType)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterType$Type = (("filter_paeth") | ("filter_sub") | ("filter_none") | ("filter_super_adaptive") | ("filter_cyclic") | ("filter_adaptive_full") | ("filter_unknown") | ("filter_up") | ("filter_aggressive") | ("filter_veryaggressive") | ("filter_preserve") | ("filter_average") | ("filter_adaptive_fast") | ("filter_default") | ("filter_adaptive_medium")) | ($FilterType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterType_ = $FilterType$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IdatSet" {
import {$Deinterlacer, $Deinterlacer$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$Deinterlacer"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$Inflater, $Inflater$Type} from "packages/java/util/zip/$Inflater"
import {$DeflatedChunksSet, $DeflatedChunksSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$DeflatedChunksSet"

export class $IdatSet extends $DeflatedChunksSet {
readonly "chunkid": string

constructor(arg0: string, arg1: $ImageInfo$Type, arg2: $Deinterlacer$Type)
constructor(arg0: string, arg1: $ImageInfo$Type, arg2: $Deinterlacer$Type, arg3: $Inflater$Type, arg4: (byte)[])

public "close"(): void
public "unfilterRow"(): void
public "getFilterUseStat"(): (integer)[]
public "getDeinterlacer"(): $Deinterlacer
public "isRowReady"(): boolean
public "advanceToNextRow"(): integer
public "getUnfilteredRow"(): (byte)[]
get "filterUseStat"(): (integer)[]
get "deinterlacer"(): $Deinterlacer
get "rowReady"(): boolean
get "unfilteredRow"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdatSet$Type = ($IdatSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdatSet_ = $IdatSet$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConnectionFactory" {
import {$HttpCompliance, $HttpCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance"
import {$AbstractConnectionFactory, $AbstractConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnectionFactory"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpConfiguration$ConnectionFactory, $HttpConfiguration$ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$ConnectionFactory"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $HttpConnectionFactory extends $AbstractConnectionFactory implements $HttpConfiguration$ConnectionFactory {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $HttpConfiguration$Type, arg1: $HttpCompliance$Type)
constructor(arg0: $HttpConfiguration$Type)
constructor()

public "getHttpConfiguration"(): $HttpConfiguration
public "newConnection"(arg0: $Connector$Type, arg1: $EndPoint$Type): $Connection
public "isRecordHttpComplianceViolations"(): boolean
public "setRecordHttpComplianceViolations"(arg0: boolean): void
public "getHttpCompliance"(): $HttpCompliance
public "setHttpCompliance"(arg0: $HttpCompliance$Type): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "httpConfiguration"(): $HttpConfiguration
get "recordHttpComplianceViolations"(): boolean
set "recordHttpComplianceViolations"(value: boolean)
get "httpCompliance"(): $HttpCompliance
set "httpCompliance"(value: $HttpCompliance$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConnectionFactory$Type = ($HttpConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConnectionFactory_ = $HttpConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/$Logger" {
import {$Marker, $Marker$Type} from "packages/info/journeymap/shaded/org/slf4j/$Marker"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $Logger {

 "getName"(): string
 "info"(arg0: string, arg1: any, arg2: any): void
 "info"(arg0: string, ...arg1: (any)[]): void
 "info"(arg0: string, arg1: $Throwable$Type): void
 "info"(arg0: string, arg1: any): void
 "info"(arg0: string): void
 "info"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
 "info"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
 "info"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
 "info"(arg0: $Marker$Type, arg1: string, arg2: any): void
 "info"(arg0: $Marker$Type, arg1: string): void
 "trace"(arg0: $Marker$Type, arg1: string): void
 "trace"(arg0: $Marker$Type, arg1: string, arg2: any): void
 "trace"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
 "trace"(arg0: string, arg1: any): void
 "trace"(arg0: string, arg1: any, arg2: any): void
 "trace"(arg0: string, ...arg1: (any)[]): void
 "trace"(arg0: string): void
 "trace"(arg0: string, arg1: $Throwable$Type): void
 "trace"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
 "trace"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
 "debug"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
 "debug"(arg0: string, ...arg1: (any)[]): void
 "debug"(arg0: string, arg1: any): void
 "debug"(arg0: string): void
 "debug"(arg0: $Marker$Type, arg1: string): void
 "debug"(arg0: string, arg1: any, arg2: any): void
 "debug"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
 "debug"(arg0: $Marker$Type, arg1: string, arg2: any): void
 "debug"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
 "debug"(arg0: string, arg1: $Throwable$Type): void
 "error"(arg0: string, arg1: any): void
 "error"(arg0: string): void
 "error"(arg0: string, arg1: any, arg2: any): void
 "error"(arg0: string, ...arg1: (any)[]): void
 "error"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
 "error"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
 "error"(arg0: $Marker$Type, arg1: string, arg2: any): void
 "error"(arg0: $Marker$Type, arg1: string): void
 "error"(arg0: string, arg1: $Throwable$Type): void
 "error"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
 "warn"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
 "warn"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
 "warn"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
 "warn"(arg0: string, arg1: any): void
 "warn"(arg0: string): void
 "warn"(arg0: string, ...arg1: (any)[]): void
 "warn"(arg0: string, arg1: any, arg2: any): void
 "warn"(arg0: string, arg1: $Throwable$Type): void
 "warn"(arg0: $Marker$Type, arg1: string): void
 "warn"(arg0: $Marker$Type, arg1: string, arg2: any): void
 "isTraceEnabled"(arg0: $Marker$Type): boolean
 "isTraceEnabled"(): boolean
 "isDebugEnabled"(arg0: $Marker$Type): boolean
 "isDebugEnabled"(): boolean
 "isInfoEnabled"(): boolean
 "isInfoEnabled"(arg0: $Marker$Type): boolean
 "isErrorEnabled"(): boolean
 "isErrorEnabled"(arg0: $Marker$Type): boolean
 "isWarnEnabled"(): boolean
 "isWarnEnabled"(arg0: $Marker$Type): boolean
}

export namespace $Logger {
const ROOT_LOGGER_NAME: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Logger$Type = ($Logger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Logger_ = $Logger$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketServletFactory" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$ExtensionFactory, $ExtensionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"

export interface $WebSocketServletFactory {

 "getExtensionFactory"(): $ExtensionFactory
 "start"(): void
 "register"(arg0: $Class$Type<(any)>): void
 "stop"(): void
 "getPolicy"(): $WebSocketPolicy
 "setCreator"(arg0: $WebSocketCreator$Type): void
 "isUpgradeRequest"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type): boolean
 "acceptWebSocket"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type): boolean
 "acceptWebSocket"(arg0: $WebSocketCreator$Type, arg1: $HttpServletRequest$Type, arg2: $HttpServletResponse$Type): boolean
 "getCreator"(): $WebSocketCreator
}

export namespace $WebSocketServletFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServletFactory$Type = ($WebSocketServletFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServletFactory_ = $WebSocketServletFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$TransformingIndexedSequence" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $TransformingIndexedSequence<T, R> implements $Sequence<(R)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>)

public "iterator"(): $Iterator<(R)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformingIndexedSequence$Type<T, R> = ($TransformingIndexedSequence<(T), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformingIndexedSequence_<T, R> = $TransformingIndexedSequence$Type<(T), (R)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataMap" {
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"

export interface $SessionDataMap extends $LifeCycle {

 "load"(arg0: string): $SessionData
 "store"(arg0: string, arg1: $SessionData$Type): void
 "initialize"(arg0: $SessionContext$Type): void
 "delete"(arg0: string): boolean
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $SessionDataMap {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionDataMap$Type = ($SessionDataMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionDataMap_ = $SessionDataMap$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSRGB" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkSRGB extends $PngChunkSingle {
static readonly "ID": string
static readonly "RENDER_INTENT_Perceptual": integer
static readonly "RENDER_INTENT_Relative_colorimetric": integer
static readonly "RENDER_INTENT_Saturation": integer
static readonly "RENDER_INTENT_Absolute_colorimetric": integer
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getIntent"(): integer
public "setIntent"(arg0: integer): void
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "intent"(): integer
set "intent"(value: integer)
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkSRGB$Type = ($PngChunkSRGB);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkSRGB_ = $PngChunkSRGB$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext" {
import {$SessionTrackingMode, $SessionTrackingMode$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionTrackingMode"
import {$Servlet, $Servlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Servlet"
import {$FilterRegistration, $FilterRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletRegistration$Dynamic, $ServletRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$FilterRegistration$Dynamic, $FilterRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration$Dynamic"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ServletRegistration, $ServletRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration"
import {$JspConfigDescriptor, $JspConfigDescriptor$Type} from "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspConfigDescriptor"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SessionCookieConfig, $SessionCookieConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionCookieConfig"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ServletContext {

 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "createServlet"<T extends $Servlet>(arg0: $Class$Type<(T)>): T
 "addServlet"(arg0: string, arg1: $Class$Type<(any)>): $ServletRegistration$Dynamic
 "addServlet"(arg0: string, arg1: string): $ServletRegistration$Dynamic
 "addServlet"(arg0: string, arg1: $Servlet$Type): $ServletRegistration$Dynamic
 "getNamedDispatcher"(arg0: string): $RequestDispatcher
/**
 * 
 * @deprecated
 */
 "getServlet"(arg0: string): $Servlet
/**
 * 
 * @deprecated
 */
 "getServletNames"(): $Enumeration<(string)>
/**
 * 
 * @deprecated
 */
 "getServlets"(): $Enumeration<($Servlet)>
 "getResourcePaths"(arg0: string): $Set<(string)>
 "addJspFile"(arg0: string, arg1: string): $ServletRegistration$Dynamic
 "declareRoles"(...arg0: (string)[]): void
 "log"(arg0: string): void
/**
 * 
 * @deprecated
 */
 "log"(arg0: $Exception$Type, arg1: string): void
 "log"(arg0: string, arg1: $Throwable$Type): void
 "getClassLoader"(): $ClassLoader
 "getResourceAsStream"(arg0: string): $InputStream
 "getResource"(arg0: string): $URL
 "getContext"(arg0: string): $ServletContext
 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
 "getMajorVersion"(): integer
 "getMinorVersion"(): integer
 "getRealPath"(arg0: string): string
 "getMimeType"(arg0: string): string
 "createFilter"<T extends $Filter>(arg0: $Class$Type<(T)>): T
 "removeAttribute"(arg0: string): void
 "getRequestDispatcher"(arg0: string): $RequestDispatcher
 "createListener"<T extends $EventListener>(arg0: $Class$Type<(T)>): T
 "getContextPath"(): string
 "getServerInfo"(): string
 "addListener"(arg0: $Class$Type<(any)>): void
 "addListener"<T extends $EventListener>(arg0: T): void
 "addListener"(arg0: string): void
 "setSessionTimeout"(arg0: integer): void
 "getSessionTimeout"(): integer
 "addFilter"(arg0: string, arg1: $Filter$Type): $FilterRegistration$Dynamic
 "addFilter"(arg0: string, arg1: string): $FilterRegistration$Dynamic
 "addFilter"(arg0: string, arg1: $Class$Type<(any)>): $FilterRegistration$Dynamic
 "getAttributeNames"(): $Enumeration<(string)>
 "getInitParameterNames"(): $Enumeration<(string)>
 "getEffectiveMinorVersion"(): integer
 "setSessionTrackingModes"(arg0: $Set$Type<($SessionTrackingMode$Type)>): void
 "getFilterRegistration"(arg0: string): $FilterRegistration
 "getServletRegistration"(arg0: string): $ServletRegistration
 "getVirtualServerName"(): string
 "getResponseCharacterEncoding"(): string
 "getFilterRegistrations"(): $Map<(string), (any)>
 "getSessionCookieConfig"(): $SessionCookieConfig
 "getEffectiveSessionTrackingModes"(): $Set<($SessionTrackingMode)>
 "getJspConfigDescriptor"(): $JspConfigDescriptor
 "getServletContextName"(): string
 "getServletRegistrations"(): $Map<(string), (any)>
 "getDefaultSessionTrackingModes"(): $Set<($SessionTrackingMode)>
 "setResponseCharacterEncoding"(arg0: string): void
 "setRequestCharacterEncoding"(arg0: string): void
 "getEffectiveMajorVersion"(): integer
 "getRequestCharacterEncoding"(): string
}

export namespace $ServletContext {
const TEMPDIR: string
const ORDERED_LIBS: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContext$Type = ($ServletContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContext_ = $ServletContext$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgression$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$UIntProgression, $UIntProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgression"

export class $UIntProgression$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "fromClosedRange-Nkh28Cs"(arg0: integer, arg1: integer, arg2: integer): $UIntProgression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntProgression$Companion$Type = ($UIntProgression$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntProgression$Companion_ = $UIntProgression$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ResultKt" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export class $ResultKt {


public static "throwOnFailure"(arg0: any): void
public static "createFailure"(arg0: $Throwable$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResultKt$Type = ($ResultKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResultKt_ = $ResultKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Response" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpContent, $HttpContent$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpContent"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$MetaData$Response, $MetaData$Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response"
import {$HttpOutput, $HttpOutput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput"
import {$HttpCookie, $HttpCookie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCookie"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Response implements $HttpServletResponse {
static readonly "SET_INCLUDE_HEADER_PREFIX": string
static readonly "HTTP_ONLY_COMMENT": string

constructor(arg0: $HttpChannel$Type, arg1: $HttpOutput$Type)

public "toString"(): string
public "reset"(arg0: boolean): void
public "reset"(): void
public "flushBuffer"(): void
public "getLocale"(): $Locale
public "setLocale"(arg0: $Locale$Type): void
public "getHeader"(arg0: string): string
public "getContentLength"(): long
public "getContentType"(): string
public "getHeaders"(arg0: string): $Collection<(string)>
public "getOutputStream"(): $ServletOutputStream
public "setContentType"(arg0: string): void
public "setContentLength"(arg0: integer): void
public "include"(): void
public "getReason"(): string
public "sendError"(arg0: integer, arg1: string): void
public "sendError"(arg0: integer): void
public "included"(): void
public "isIncluding"(): boolean
public "isWriting"(): boolean
public "sendProcessing"(): void
public "resetForForward"(): void
public "getContentCount"(): long
public static "putHeaders"(arg0: $HttpServletResponse$Type, arg1: $HttpContent$Type, arg2: long, arg3: boolean): void
public "putHeaders"(arg0: $HttpContent$Type, arg1: long, arg2: boolean): void
public "setStatus"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "setStatus"(arg0: integer, arg1: string): void
public "getCommittedMetaData"(): $MetaData$Response
public "getCharacterEncoding"(): string
public "setContentLengthLong"(arg0: long): void
public "setCharacterEncoding"(arg0: string): void
public "setBufferSize"(arg0: integer): void
public "getStatus"(): integer
public "getBufferSize"(): integer
public "getWriter"(): $PrintWriter
public "addHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: $HttpHeader$Type, arg1: string): void
public "setHeader"(arg0: string, arg1: string): void
public "isCommitted"(): boolean
public "sendRedirect"(arg0: integer, arg1: string): void
public "sendRedirect"(arg0: string): void
public "setIntHeader"(arg0: string, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "encodeUrl"(arg0: string): string
public "encodeRedirectURL"(arg0: string): string
public "getHeaderNames"(): $Collection<(string)>
/**
 * 
 * @deprecated
 */
public "encodeRedirectUrl"(arg0: string): string
public "addCookie"(arg0: $Cookie$Type): void
public "addCookie"(arg0: $HttpCookie$Type): void
public "containsHeader"(arg0: string): boolean
public "setDateHeader"(arg0: string, arg1: long): void
public "addIntHeader"(arg0: string, arg1: integer): void
public "addDateHeader"(arg0: string, arg1: long): void
public "encodeURL"(arg0: string): string
public "resetBuffer"(): void
public "closeOutput"(): void
public "isContentComplete"(arg0: long): boolean
public "getHttpOutput"(): $HttpOutput
public "getHttpFields"(): $HttpFields
public "setTrailers"(arg0: $Supplier$Type<($HttpFields$Type)>): void
public "getHttpChannel"(): $HttpChannel
public "getTrailers"(): $Supplier<($HttpFields)>
public "addSetRFC2965Cookie"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: long, arg5: string, arg6: boolean, arg7: boolean, arg8: integer): void
public "addSetRFC6265Cookie"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: long, arg5: boolean, arg6: boolean): void
public "isAllContentWritten"(arg0: long): boolean
public "getLongContentLength"(): long
public "setStatusWithReason"(arg0: integer, arg1: string): void
public "setLongContentLength"(arg0: long): void
public "setTrailerFields"(arg0: $Supplier$Type<($Map$Type<(string), (string)>)>): void
public "getTrailerFields"(): $Supplier<($Map<(string), (string)>)>
get "locale"(): $Locale
set "locale"(value: $Locale$Type)
get "contentLength"(): long
get "contentType"(): string
get "outputStream"(): $ServletOutputStream
set "contentType"(value: string)
set "contentLength"(value: integer)
get "reason"(): string
get "including"(): boolean
get "writing"(): boolean
get "contentCount"(): long
set "status"(value: integer)
get "committedMetaData"(): $MetaData$Response
get "characterEncoding"(): string
set "contentLengthLong"(value: long)
set "characterEncoding"(value: string)
set "bufferSize"(value: integer)
get "status"(): integer
get "bufferSize"(): integer
get "writer"(): $PrintWriter
get "committed"(): boolean
get "headerNames"(): $Collection<(string)>
get "httpOutput"(): $HttpOutput
get "httpFields"(): $HttpFields
set "trailers"(value: $Supplier$Type<($HttpFields$Type)>)
get "httpChannel"(): $HttpChannel
get "trailers"(): $Supplier<($HttpFields)>
get "longContentLength"(): long
set "longContentLength"(value: long)
set "trailerFields"(value: $Supplier$Type<($Map$Type<(string), (string)>)>)
get "trailerFields"(): $Supplier<($Map<(string), (string)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Response$Type = ($Response);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Response_ = $Response$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketListener" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WebSocketConnectionListener, $WebSocketConnectionListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener"

export interface $WebSocketListener extends $WebSocketConnectionListener {

 "onWebSocketBinary"(arg0: (byte)[], arg1: integer, arg2: integer): void
 "onWebSocketText"(arg0: string): void
 "onWebSocketConnect"(arg0: $Session$Type): void
 "onWebSocketClose"(arg0: integer, arg1: string): void
 "onWebSocketError"(arg0: $Throwable$Type): void
}

export namespace $WebSocketListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketListener$Type = ($WebSocketListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketListener_ = $WebSocketListener$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ProgressiveOutputStream" {
import {$ByteArrayOutputStream, $ByteArrayOutputStream$Type} from "packages/java/io/$ByteArrayOutputStream"

export class $ProgressiveOutputStream extends $ByteArrayOutputStream {

constructor(arg0: integer)

public "flush"(): void
public "write"(arg0: integer): void
public "write"(arg0: (byte)[]): void
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "close"(): void
public "reset"(): void
public "setSize"(arg0: integer): void
public "getCountFlushed"(): long
set "size"(value: integer)
get "countFlushed"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressiveOutputStream$Type = ($ProgressiveOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressiveOutputStream_ = $ProgressiveOutputStream$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringsJVMKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$StringsKt__StringNumberConversionsKt, $StringsKt__StringNumberConversionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringNumberConversionsKt"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$StringCompanionObject, $StringCompanionObject$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$StringCompanionObject"

export class $StringsKt__StringsJVMKt extends $StringsKt__StringNumberConversionsKt {

constructor()

public static "equals"(arg0: string, arg1: string, arg2: boolean): boolean
public static "compareTo"(arg0: string, arg1: string, arg2: boolean): integer
public static "contentEquals"(arg0: charseq, arg1: charseq, arg2: boolean): boolean
public static "contentEquals"(arg0: charseq, arg1: charseq): boolean
public static "regionMatches"(arg0: string, arg1: integer, arg2: string, arg3: integer, arg4: integer, arg5: boolean): boolean
public static "regionMatches"(arg0: charseq, arg1: integer, arg2: charseq, arg3: integer, arg4: integer, arg5: boolean): boolean
public static "startsWith"(arg0: string, arg1: string, arg2: integer, arg3: boolean): boolean
public static "startsWith"(arg0: string, arg1: string, arg2: boolean): boolean
public static "replace"(arg0: string, arg1: string, arg2: string, arg3: boolean): string
public static "replace"(arg0: string, arg1: character, arg2: character, arg3: boolean): string
public static "replaceFirst"(arg0: string, arg1: string, arg2: string, arg3: boolean): string
public static "replaceFirst"(arg0: string, arg1: character, arg2: character, arg3: boolean): string
public static "split"(arg0: charseq, arg1: $Pattern$Type, arg2: integer): $List<(string)>
public static "repeat"(arg0: charseq, arg1: integer): string
public static "isBlank"(arg0: charseq): boolean
public static "toCharArray"(arg0: string, arg1: integer, arg2: integer): (character)[]
public static "endsWith"(arg0: string, arg1: string, arg2: boolean): boolean
public static "capitalize"(arg0: string): string
public static "capitalize"(arg0: string, arg1: $Locale$Type): string
public static "decapitalize"(arg0: string, arg1: $Locale$Type): string
public static "decapitalize"(arg0: string): string
public static "concatToString"(arg0: (character)[], arg1: integer, arg2: integer): string
public static "concatToString"(arg0: (character)[]): string
public static "encodeToByteArray"(arg0: string, arg1: integer, arg2: integer, arg3: boolean): (byte)[]
public static "encodeToByteArray"(arg0: string): (byte)[]
public static "decodeToString"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: boolean): string
public static "decodeToString"(arg0: (byte)[]): string
public static "getCASE_INSENSITIVE_ORDER"(arg0: $StringCompanionObject$Type): $Comparator<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringsJVMKt$Type = ($StringsKt__StringsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringsJVMKt_ = $StringsKt__StringsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionSystemProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CollectionSystemProperties {
static readonly "INSTANCE": $CollectionSystemProperties
static readonly "brittleContainsOptimizationEnabled": boolean


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionSystemProperties$Type = ($CollectionSystemProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionSystemProperties_ = $CollectionSystemProperties$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$RemoteEndpoint" {
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export interface $RemoteEndpoint {

 "flush"(): void
 "sendPong"(arg0: $ByteBuffer$Type): void
 "getBatchMode"(): $BatchMode
 "getInetSocketAddress"(): $InetSocketAddress
 "sendPing"(arg0: $ByteBuffer$Type): void
 "sendBytes"(arg0: $ByteBuffer$Type): void
 "sendBytes"(arg0: $ByteBuffer$Type, arg1: $WriteCallback$Type): void
 "sendBytesByFuture"(arg0: $ByteBuffer$Type): $Future<(void)>
 "sendString"(arg0: string, arg1: $WriteCallback$Type): void
 "sendString"(arg0: string): void
 "sendPartialString"(arg0: string, arg1: boolean): void
 "sendPartialBytes"(arg0: $ByteBuffer$Type, arg1: boolean): void
 "sendStringByFuture"(arg0: string): $Future<(void)>
 "setBatchMode"(arg0: $BatchMode$Type): void
}

export namespace $RemoteEndpoint {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoteEndpoint$Type = ($RemoteEndpoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoteEndpoint_ = $RemoteEndpoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$ScreenFloatValueRegEx" {
import {$Regex, $Regex$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$Regex"

export class $ScreenFloatValueRegEx {
static readonly "INSTANCE": $ScreenFloatValueRegEx
static readonly "value": $Regex


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenFloatValueRegEx$Type = ($ScreenFloatValueRegEx);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenFloatValueRegEx_ = $ScreenFloatValueRegEx$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/extensions/$AbstractExtension" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$Extension, $Extension$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Extension"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"

export class $AbstractExtension extends $AbstractLifeCycle implements $Dumpable, $Extension {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "getNextOutgoing"(): $OutgoingFrames
public "getNextIncoming"(): $IncomingFrames
public "incomingError"(arg0: $Throwable$Type): void
public "isRsv3User"(): boolean
public "isRsv2User"(): boolean
public "isRsv1User"(): boolean
public "getName"(): string
public "toString"(): string
public "init"(arg0: $WebSocketPolicy$Type, arg1: $ByteBufferPool$Type): void
/**
 * 
 * @deprecated
 */
public "init"(arg0: $WebSocketContainerScope$Type): void
public "getConnection"(): $LogicalConnection
public "getPolicy"(): $WebSocketPolicy
public "setConnection"(arg0: $LogicalConnection$Type): void
public "getBufferPool"(): $ByteBufferPool
public "setBufferPool"(arg0: $ByteBufferPool$Type): void
public "getConfig"(): $ExtensionConfig
public "setPolicy"(arg0: $WebSocketPolicy$Type): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "setConfig"(arg0: $ExtensionConfig$Type): void
public "setNextIncomingFrames"(arg0: $IncomingFrames$Type): void
public "setNextOutgoingFrames"(arg0: $OutgoingFrames$Type): void
public "incomingFrame"(arg0: $Frame$Type): void
public "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "nextOutgoing"(): $OutgoingFrames
get "nextIncoming"(): $IncomingFrames
get "rsv3User"(): boolean
get "rsv2User"(): boolean
get "rsv1User"(): boolean
get "name"(): string
get "connection"(): $LogicalConnection
get "policy"(): $WebSocketPolicy
set "connection"(value: $LogicalConnection$Type)
get "bufferPool"(): $ByteBufferPool
set "bufferPool"(value: $ByteBufferPool$Type)
get "config"(): $ExtensionConfig
set "policy"(value: $WebSocketPolicy$Type)
set "config"(value: $ExtensionConfig$Type)
set "nextIncomingFrames"(value: $IncomingFrames$Type)
set "nextOutgoingFrames"(value: $OutgoingFrames$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractExtension$Type = ($AbstractExtension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractExtension_ = $AbstractExtension$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$SystemProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SystemProperties {
static readonly "INSTANCE": $SystemProperties
static readonly "LINE_SEPARATOR": string


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SystemProperties$Type = ($SystemProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SystemProperties_ = $SystemProperties$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Route" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"

export interface $Route {

 "handle"(arg0: $Request$Type, arg1: $Response$Type): any

(arg0: $Request$Type, arg1: $Response$Type): any
}

export namespace $Route {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Route$Type = ($Route);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Route_ = $Route$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Filter" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"

export interface $Filter {

 "handle"(arg0: $Request$Type, arg1: $Response$Type): void

(arg0: $Request$Type, arg1: $Response$Type): void
}

export namespace $Filter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Filter$Type = ($Filter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Filter_ = $Filter$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$SocketConnectorFactory" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$SslStores, $SslStores$Type} from "packages/info/journeymap/shaded/kotlin/spark/ssl/$SslStores"
import {$ServerConnector, $ServerConnector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ServerConnector"

export class $SocketConnectorFactory {

constructor()

public static "createSocketConnector"(arg0: $Server$Type, arg1: string, arg2: integer): $ServerConnector
public static "createSecureSocketConnector"(arg0: $Server$Type, arg1: string, arg2: integer, arg3: $SslStores$Type): $ServerConnector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SocketConnectorFactory$Type = ($SocketConnectorFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SocketConnectorFactory_ = $SocketConnectorFactory$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkOFFS" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkOFFS extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setUnits"(arg0: integer): void
public "getUnits"(): integer
public "setPosX"(arg0: long): void
public "setPosY"(arg0: long): void
public "getPosY"(): long
public "getPosX"(): long
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "units"(value: integer)
get "units"(): integer
set "posX"(value: long)
set "posY"(value: long)
get "posY"(): long
get "posX"(): long
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkOFFS$Type = ($PngChunkOFFS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkOFFS_ = $PngChunkOFFS$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$BaseHolder" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ServletHandler, $ServletHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHandler"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"

export class $BaseHolder<T> extends $AbstractLifeCycle implements $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener


public "isInstance"(): boolean
public "initialize"(): void
public "getClassName"(): string
public "getSource"(): $Source
public "setClassName"(arg0: string): void
public "getServletHandler"(): $ServletHandler
public "getHeldClass"(): $Class<(any)>
public "setHeldClass"(arg0: $Class$Type<(any)>): void
public "setServletHandler"(arg0: $ServletHandler$Type): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "doStart"(): void
public "doStop"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "instance"(): boolean
get "className"(): string
get "source"(): $Source
set "className"(value: string)
get "servletHandler"(): $ServletHandler
get "heldClass"(): $Class<(any)>
set "heldClass"(value: $Class$Type<(any)>)
set "servletHandler"(value: $ServletHandler$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseHolder$Type<T> = ($BaseHolder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseHolder_<T> = $BaseHolder$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjBadCrcException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$PngjInputException, $PngjInputException$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjInputException"

export class $PngjBadCrcException extends $PngjInputException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngjBadCrcException$Type = ($PngjBadCrcException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngjBadCrcException_ = $PngjBadCrcException$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$PixelsWriter" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$CompressorStream, $CompressorStream$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$CompressorStream"
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PixelsWriter {

constructor(arg0: $ImageInfo$Type)

public "getOs"(): $OutputStream
public "close"(): void
public "setOs"(arg0: $OutputStream$Type): void
public "getFilterType"(): $FilterType
public "setFilterType"(arg0: $FilterType$Type): void
public "setDeflaterStrategy"(arg0: integer): void
public "getDeflaterCompLevel"(): integer
public "setDeflaterCompLevel"(arg0: integer): void
public "setCompressorStream"(arg0: $CompressorStream$Type): void
public "getTotalBytesToWrite"(): long
public "processRow"(arg0: (byte)[]): void
public "getCompression"(): double
public "getFiltersUsed"(): string
public "getRowb"(): (byte)[]
get "os"(): $OutputStream
set "os"(value: $OutputStream$Type)
get "filterType"(): $FilterType
set "filterType"(value: $FilterType$Type)
set "deflaterStrategy"(value: integer)
get "deflaterCompLevel"(): integer
set "deflaterCompLevel"(value: integer)
set "compressorStream"(value: $CompressorStream$Type)
get "totalBytesToWrite"(): long
get "compression"(): double
get "filtersUsed"(): string
get "rowb"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PixelsWriter$Type = ($PixelsWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PixelsWriter_ = $PixelsWriter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeResponse" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$UpgradeResponse, $UpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeResponse"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServletUpgradeResponse implements $UpgradeResponse {

constructor(arg0: $HttpServletResponse$Type)

public "setAcceptedSubProtocol"(arg0: string): void
public "isExtensionsNegotiated"(): boolean
public "getAcceptedSubProtocol"(): string
public "toString"(): string
public "complete"(): void
public "setExtensions"(arg0: $List$Type<($ExtensionConfig$Type)>): void
public "getExtensions"(): $List<($ExtensionConfig)>
public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $List<(string)>
public "getHeaders"(): $Map<(string), ($List<(string)>)>
public "getStatusCode"(): integer
public "isSuccess"(): boolean
public "sendError"(arg0: integer, arg1: string): void
public "addHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: string, arg1: string): void
public "isCommitted"(): boolean
public "getHeaderNames"(): $Set<(string)>
public "setSuccess"(arg0: boolean): void
public "isSubprotocolNegotiated"(): boolean
public "setStatusCode"(arg0: integer): void
public "getStatusReason"(): string
public "sendForbidden"(arg0: string): void
public "setStatusReason"(arg0: string): void
set "acceptedSubProtocol"(value: string)
get "extensionsNegotiated"(): boolean
get "acceptedSubProtocol"(): string
set "extensions"(value: $List$Type<($ExtensionConfig$Type)>)
get "extensions"(): $List<($ExtensionConfig)>
get "headers"(): $Map<(string), ($List<(string)>)>
get "statusCode"(): integer
get "success"(): boolean
get "committed"(): boolean
get "headerNames"(): $Set<(string)>
set "success"(value: boolean)
get "subprotocolNegotiated"(): boolean
set "statusCode"(value: integer)
get "statusReason"(): string
set "statusReason"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletUpgradeResponse$Type = ($ServletUpgradeResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletUpgradeResponse_ = $ServletUpgradeResponse$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ScheduledExecutorScheduler" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"
import {$Scheduler$Task, $Scheduler$Task$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler$Task"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$ThreadGroup, $ThreadGroup$Type} from "packages/java/lang/$ThreadGroup"

export class $ScheduledExecutorScheduler extends $AbstractLifeCycle implements $Scheduler, $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: string, arg1: boolean, arg2: $ClassLoader$Type, arg3: $ThreadGroup$Type)
constructor(arg0: string, arg1: boolean, arg2: $ClassLoader$Type)
constructor(arg0: string, arg1: boolean)
constructor()

public "schedule"(arg0: $Runnable$Type, arg1: long, arg2: $TimeUnit$Type): $Scheduler$Task
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledExecutorScheduler$Type = ($ScheduledExecutorScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledExecutorScheduler_ = $ScheduledExecutorScheduler$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration$Dynamic" {
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$FilterRegistration, $FilterRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Registration$Dynamic, $Registration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Registration$Dynamic"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $FilterRegistration$Dynamic extends $FilterRegistration, $Registration$Dynamic {

 "addMappingForUrlPatterns"(arg0: $EnumSet$Type<($DispatcherType$Type)>, arg1: boolean, ...arg2: (string)[]): void
 "getUrlPatternMappings"(): $Collection<(string)>
 "addMappingForServletNames"(arg0: $EnumSet$Type<($DispatcherType$Type)>, arg1: boolean, ...arg2: (string)[]): void
 "getServletNameMappings"(): $Collection<(string)>
 "setAsyncSupported"(arg0: boolean): void
 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $FilterRegistration$Dynamic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterRegistration$Dynamic$Type = ($FilterRegistration$Dynamic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterRegistration$Dynamic_ = $FilterRegistration$Dynamic$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt__ArraysKt" {
import {$ArraysKt__ArraysJVMKt, $ArraysKt__ArraysJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt__ArraysJVMKt"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"

export class $ArraysKt__ArraysKt extends $ArraysKt__ArraysJVMKt {

constructor()

public static "contentDeepEquals"<T>(arg0: (T)[], arg1: (T)[]): boolean
public static "contentDeepToString"<T>(arg0: (T)[]): string
public static "flatten"<T>(arg0: ((T)[])[]): $List<(T)>
public static "unzip"<T, R>(arg0: ($Pair$Type<(any), (any)>)[]): $Pair<($List<(T)>), ($List<(R)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysKt__ArraysKt$Type = ($ArraysKt__ArraysKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysKt__ArraysKt_ = $ArraysKt__ArraysKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHolder" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Servlet, $Servlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Servlet"
import {$Holder, $Holder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Holder"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletRegistration$Dynamic, $ServletRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$UnavailableException, $UnavailableException$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$UnavailableException"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServletHolder extends $Holder<($Servlet)> implements $UserIdentity$Scope, $Comparable<($ServletHolder)> {
static readonly "APACHE_SENTINEL_CLASS": string
static readonly "JSP_GENERATED_PACKAGE_NAME": string
static readonly "NO_MAPPED_ROLES": $Map<(string), (string)>
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(arg0: $Source$Type)
constructor(arg0: string, arg1: $Class$Type<(any)>)
constructor(arg0: $Class$Type<(any)>)
constructor(arg0: string, arg1: $Servlet$Type)
constructor(arg0: $Servlet$Type)

public "getServlet"(): $Servlet
public "destroyInstance"(arg0: any): void
public "getRunAsRole"(): string
public "getInitOrder"(): integer
public "setServlet"(arg0: $Servlet$Type): void
public "setInitOrder"(arg0: integer): void
public "getClassNameForJsp"(arg0: string): string
public "getServletInstance"(): $Servlet
public "setUserRoleLink"(arg0: string, arg1: string): void
public "getUserRoleLink"(arg0: string): string
public "setRunAsRole"(arg0: string): void
public "setForcedPath"(arg0: string): void
public "getForcedPath"(): string
public "checkServletType"(): void
public "ensureInstance"(): $Servlet
public "getNameOfJspClass"(arg0: string): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $ServletHolder$Type): integer
public "initialize"(): void
public "handle"(arg0: $Request$Type, arg1: $ServletRequest$Type, arg2: $ServletResponse$Type): void
public "isEnabled"(): boolean
public "isAvailable"(): boolean
public "setEnabled"(arg0: boolean): void
public "getJspPackagePrefix"(): string
public "getPackageOfJspClass"(arg0: string): string
public "getUnavailableException"(): $UnavailableException
public "getContextPath"(): string
public "getRegistration"(): $ServletRegistration$Dynamic
public "doStart"(): void
public "doStop"(): void
public "getRoleRefMap"(): $Map<(string), (string)>
public "getName"(): string
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "servlet"(): $Servlet
get "runAsRole"(): string
get "initOrder"(): integer
set "servlet"(value: $Servlet$Type)
set "initOrder"(value: integer)
get "servletInstance"(): $Servlet
set "runAsRole"(value: string)
set "forcedPath"(value: string)
get "forcedPath"(): string
get "enabled"(): boolean
get "available"(): boolean
set "enabled"(value: boolean)
get "jspPackagePrefix"(): string
get "unavailableException"(): $UnavailableException
get "contextPath"(): string
get "registration"(): $ServletRegistration$Dynamic
get "roleRefMap"(): $Map<(string), (string)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletHolder$Type = ($ServletHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletHolder_ = $ServletHolder$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/math/$Constants" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Constants {
static readonly "INSTANCE": $Constants
static readonly "LN2": double
static readonly "epsilon": double
static readonly "taylor_2_bound": double
static readonly "taylor_n_bound": double
static readonly "upper_taylor_2_bound": double
static readonly "upper_taylor_n_bound": double


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Constants$Type = ($Constants);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Constants_ = $Constants$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$ClassUtils" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"

export class $ClassUtils {
static readonly "ARRAY_SUFFIX": string

constructor()

public static "resolvePrimitiveClassName"(arg0: string): $Class<(any)>
public static "forName"(arg0: string, arg1: $ClassLoader$Type): $Class<(any)>
public static "classPackageAsResourcePath"(arg0: $Class$Type<(any)>): string
public static "getDefaultClassLoader"(): $ClassLoader
get "defaultClassLoader"(): $ClassLoader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassUtils$Type = ($ClassUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassUtils_ = $ClassUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$Syntax" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Syntax {

constructor()

public static "requireValidRFC6265CookieValue"(arg0: string): void
public static "requireValidRFC2616Token"(arg0: string, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Syntax$Type = ($Syntax);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Syntax_ = $Syntax$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$RouteContext" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Body, $Body$Type} from "packages/info/journeymap/shaded/kotlin/spark/http/matching/$Body"
import {$RequestWrapper, $RequestWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/http/matching/$RequestWrapper"
import {$ResponseWrapper, $ResponseWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/http/matching/$ResponseWrapper"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"
import {$HttpMethod, $HttpMethod$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$HttpMethod"

export class $RouteContext {


public "httpMethod"(): $HttpMethod
public "httpRequest"(): $HttpServletRequest
public "uri"(): string
public "body"(): $Body
public "response"(): $Response
public "acceptType"(): string
public "requestWrapper"(): $RequestWrapper
public "responseWrapper"(): $ResponseWrapper
public "withResponseWrapper"(arg0: $ResponseWrapper$Type): $RouteContext
public "routeMatcher"(): $Routes
public "withResponse"(arg0: $Response$Type): $RouteContext
public "withHttpRequest"(arg0: $HttpServletRequest$Type): $RouteContext
public "withBody"(arg0: $Body$Type): $RouteContext
public "withMatcher"(arg0: $Routes$Type): $RouteContext
public "withAcceptType"(arg0: string): $RouteContext
public "withRequestWrapper"(arg0: $RequestWrapper$Type): $RouteContext
public "withHttpMethod"(arg0: $HttpMethod$Type): $RouteContext
public "withUri"(arg0: string): $RouteContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteContext$Type = ($RouteContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteContext_ = $RouteContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WebSocketException, $WebSocketException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketException"

export class $CloseException extends $WebSocketException {

constructor(arg0: integer, arg1: $Throwable$Type)
constructor(arg0: integer, arg1: string, arg2: $Throwable$Type)
constructor(arg0: integer, arg1: string)

public "getStatusCode"(): integer
get "statusCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseException$Type = ($CloseException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseException_ = $CloseException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$SessionAuthentication" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractUserAuthentication, $AbstractUserAuthentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$AbstractUserAuthentication"
import {$HttpSessionEvent, $HttpSessionEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$HttpSessionBindingEvent, $HttpSessionBindingEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingEvent"
import {$HttpSessionActivationListener, $HttpSessionActivationListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionActivationListener"
import {$HttpSessionBindingListener, $HttpSessionBindingListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingListener"

export class $SessionAuthentication extends $AbstractUserAuthentication implements $Serializable, $HttpSessionActivationListener, $HttpSessionBindingListener {
static readonly "__J_AUTHENTICATED": string

constructor(arg0: string, arg1: $UserIdentity$Type, arg2: any)

public "toString"(): string
public "logout"(): void
public "valueUnbound"(arg0: $HttpSessionBindingEvent$Type): void
public "valueBound"(arg0: $HttpSessionBindingEvent$Type): void
public "sessionDidActivate"(arg0: $HttpSessionEvent$Type): void
public "sessionWillPassivate"(arg0: $HttpSessionEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionAuthentication$Type = ($SessionAuthentication);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionAuthentication_ = $SessionAuthentication$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$EmptyList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $EmptyList implements $List<(any)>, $Serializable, $RandomAccess, $KMappedMarker {
static readonly "INSTANCE": $EmptyList


public "add"(arg0: integer, arg1: void): void
public "add"(arg0: void): boolean
public "remove"(arg0: integer): void
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "indexOf"(arg0: void): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "lastIndexOf"(arg0: void): integer
public "isEmpty"(): boolean
public "size"(): integer
public "subList"(arg0: integer, arg1: integer): $List<(any)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(any)>
public "contains"(arg0: any): boolean
public "contains"(arg0: void): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: void): void
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "listIterator"(): $ListIterator<(any)>
public "listIterator"(arg0: integer): $ListIterator<(any)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(any)>
public "replaceAll"(arg0: $UnaryOperator$Type<(any)>): void
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any): $List<(any)>
public static "of"<E>(arg0: any): $List<(any)>
public static "of"<E>(): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): $List<(any)>
public static "of"<E>(...arg0: (any)[]): $List<(any)>
public "spliterator"(): $Spliterator<(any)>
public "sort"(arg0: $Comparator$Type<(any)>): void
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(any)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(any)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<any>;
[index: number]: any
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyList$Type = ($EmptyList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyList_ = $EmptyList$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/kotlin/$RouteHandler" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$QueryParamsMap, $QueryParamsMap$Type} from "packages/info/journeymap/shaded/kotlin/spark/$QueryParamsMap"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Session"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RouteHandler {

constructor(arg0: $Request$Type, arg1: $Response$Type)

public "type"(): string
public "type"(arg0: string): void
public "host"(): string
public "status"(): integer
public "status"(arg0: integer): void
public "port"(): integer
public "uri"(): string
public "params"(arg0: string): string
public "params"(): $Map<(string), (string)>
public "protocol"(): string
public "scheme"(): string
public "attributes"(): $Set<(string)>
public "attribute"(arg0: string): string
public "attribute"(arg0: string, arg1: string): void
public "redirect"(arg0: string): void
public "redirect"(arg0: string, arg1: integer): void
public "contentType"(): string
public "getResponse"(): $Response
public "queryMap"(arg0: string): $QueryParamsMap
public "queryMap"(): $QueryParamsMap
public "splat"(): (string)[]
public "requestMethod"(): string
public "queryParams"(arg0: string): string
public "userAgent"(): string
public "contextPath"(): string
public "servletPath"(): string
public "pathInfo"(): string
public "session"(): $Session
public "session"(arg0: boolean): $Session
public "getRequest"(): $Request
get "response"(): $Response
get "request"(): $Request
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteHandler$Type = ($RouteHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteHandler_ = $RouteHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatingPointRange" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export interface $ClosedFloatingPointRange<T extends $Comparable<(any)>> extends $ClosedRange<(T)> {

 "isEmpty"(): boolean
 "contains"(arg0: T): boolean
 "lessThanOrEquals"(arg0: T, arg1: T): boolean
 "getEndInclusive"(): T
 "getStart"(): T
}

export namespace $ClosedFloatingPointRange {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClosedFloatingPointRange$Type<T> = ($ClosedFloatingPointRange<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClosedFloatingPointRange_<T> = $ClosedFloatingPointRange$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$Part" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export interface $Part {

 "getName"(): string
 "write"(arg0: string): void
 "delete"(): void
 "getSize"(): long
 "getInputStream"(): $InputStream
 "getHeader"(arg0: string): string
 "getContentType"(): string
 "getHeaders"(arg0: string): $Collection<(string)>
 "getHeaderNames"(): $Collection<(string)>
 "getSubmittedFileName"(): string
}

export namespace $Part {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Part$Type = ($Part);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Part_ = $Part$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$ListBuilderKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ListBuilderKt {


public static "resetAt"<E>(arg0: (E)[], arg1: integer): void
public static "resetRange"<E>(arg0: (E)[], arg1: integer, arg2: integer): void
public static "arrayOfUninitializedElements"<E>(arg0: integer): (E)[]
public static "copyOfUninitializedElements"<T>(arg0: (T)[], arg1: integer): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListBuilderKt$Type = ($ListBuilderKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListBuilderKt_ = $ListBuilderKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$NamedLoggerBase" {
import {$Marker, $Marker$Type} from "packages/info/journeymap/shaded/org/slf4j/$Marker"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export class $NamedLoggerBase implements $Logger, $Serializable {


public "getName"(): string
public "info"(arg0: string, arg1: any, arg2: any): void
public "info"(arg0: string, ...arg1: (any)[]): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "info"(arg0: string, arg1: any): void
public "info"(arg0: string): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "info"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "info"(arg0: $Marker$Type, arg1: string): void
public "trace"(arg0: $Marker$Type, arg1: string): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "trace"(arg0: string, arg1: any): void
public "trace"(arg0: string, arg1: any, arg2: any): void
public "trace"(arg0: string, ...arg1: (any)[]): void
public "trace"(arg0: string): void
public "trace"(arg0: string, arg1: $Throwable$Type): void
public "trace"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "debug"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "debug"(arg0: string, arg1: any): void
public "debug"(arg0: string): void
public "debug"(arg0: $Marker$Type, arg1: string): void
public "debug"(arg0: string, arg1: any, arg2: any): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "error"(arg0: string, arg1: any): void
public "error"(arg0: string): void
public "error"(arg0: string, arg1: any, arg2: any): void
public "error"(arg0: string, ...arg1: (any)[]): void
public "error"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "error"(arg0: $Marker$Type, arg1: string): void
public "error"(arg0: string, arg1: $Throwable$Type): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "warn"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "warn"(arg0: string, arg1: any): void
public "warn"(arg0: string): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "warn"(arg0: string, arg1: any, arg2: any): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: $Marker$Type, arg1: string): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "isTraceEnabled"(arg0: $Marker$Type): boolean
public "isTraceEnabled"(): boolean
public "isDebugEnabled"(arg0: $Marker$Type): boolean
public "isDebugEnabled"(): boolean
public "isInfoEnabled"(): boolean
public "isInfoEnabled"(arg0: $Marker$Type): boolean
public "isErrorEnabled"(): boolean
public "isErrorEnabled"(arg0: $Marker$Type): boolean
public "isWarnEnabled"(): boolean
public "isWarnEnabled"(arg0: $Marker$Type): boolean
get "name"(): string
get "traceEnabled"(): boolean
get "debugEnabled"(): boolean
get "infoEnabled"(): boolean
get "errorEnabled"(): boolean
get "warnEnabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedLoggerBase$Type = ($NamedLoggerBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedLoggerBase_ = $NamedLoggerBase$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DateCache$Tick" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DateCache$Tick {

constructor(arg0: long, arg1: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DateCache$Tick$Type = ($DateCache$Tick);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DateCache$Tick_ = $DateCache$Tick$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$Filter" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$FilterConfig, $FilterConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterConfig"
import {$FilterChain, $FilterChain$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterChain"

export interface $Filter {

 "doFilter"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: $FilterChain$Type): void
 "init"(arg0: $FilterConfig$Type): void
 "destroy"(): void

(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: $FilterChain$Type): void
}

export namespace $Filter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Filter$Type = ($Filter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Filter_ = $Filter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ReadLineInputStream" {
import {$BufferedInputStream, $BufferedInputStream$Type} from "packages/java/io/$BufferedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $ReadLineInputStream extends $BufferedInputStream {

constructor(arg0: $InputStream$Type)
constructor(arg0: $InputStream$Type, arg1: integer)

public "read"(): integer
public "read"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "readLine"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReadLineInputStream$Type = ($ReadLineInputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReadLineInputStream_ = $ReadLineInputStream$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpMethod" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"

export class $HttpMethod extends $Enum<($HttpMethod)> {
static readonly "GET": $HttpMethod
static readonly "POST": $HttpMethod
static readonly "HEAD": $HttpMethod
static readonly "PUT": $HttpMethod
static readonly "OPTIONS": $HttpMethod
static readonly "DELETE": $HttpMethod
static readonly "TRACE": $HttpMethod
static readonly "CONNECT": $HttpMethod
static readonly "MOVE": $HttpMethod
static readonly "PROXY": $HttpMethod
static readonly "PRI": $HttpMethod
static readonly "CACHE": $Trie<($HttpMethod)>


public static "lookAheadGet"(arg0: (byte)[], arg1: integer, arg2: integer): $HttpMethod
public static "lookAheadGet"(arg0: $ByteBuffer$Type): $HttpMethod
public static "values"(): ($HttpMethod)[]
public static "valueOf"(arg0: string): $HttpMethod
public "getBytes"(): (byte)[]
public "is"(arg0: string): boolean
public static "fromString"(arg0: string): $HttpMethod
public "asBuffer"(): $ByteBuffer
public "asString"(): string
get "bytes"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpMethod$Type = (("head") | ("proxy") | ("trace") | ("move") | ("post") | ("pri") | ("get") | ("options") | ("delete") | ("put") | ("connect")) | ($HttpMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpMethod_ = $HttpMethod$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key" {
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export interface $CoroutineContext$Key<E extends $CoroutineContext$Element> {

}

export namespace $CoroutineContext$Key {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoroutineContext$Key$Type<E> = ($CoroutineContext$Key<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoroutineContext$Key_<E> = $CoroutineContext$Key$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$ServletPathSpec" {
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"

export class $ServletPathSpec extends $PathSpec {

constructor(arg0: string)

public "getRelativePath"(arg0: string, arg1: string): string
public "getPathMatch"(arg0: string): string
public "matches"(arg0: string): boolean
public static "normalize"(arg0: string): string
public "getPathInfo"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletPathSpec$Type = ($ServletPathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletPathSpec_ = $ServletPathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSTER" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkSTER extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setMode"(arg0: byte): void
public "getMode"(): byte
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "mode"(value: byte)
get "mode"(): byte
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkSTER$Type = ($PngChunkSTER);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkSTER_ = $PngChunkSTER$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$LazyThreadSafetyMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $LazyThreadSafetyMode extends $Enum<($LazyThreadSafetyMode)> {
static readonly "SYNCHRONIZED": $LazyThreadSafetyMode
static readonly "PUBLICATION": $LazyThreadSafetyMode
static readonly "NONE": $LazyThreadSafetyMode


public static "values"(): ($LazyThreadSafetyMode)[]
public static "valueOf"(arg0: string): $LazyThreadSafetyMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyThreadSafetyMode$Type = (("synchronized") | ("publication") | ("none")) | ($LazyThreadSafetyMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyThreadSafetyMode_ = $LazyThreadSafetyMode$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterator" {
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"

export interface $KMutableIterator extends $KMappedMarker {

}

export namespace $KMutableIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableIterator$Type = ($KMutableIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableIterator_ = $KMutableIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest" {
import {$HttpUpgradeHandler, $HttpUpgradeHandler$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletMapping, $HttpServletMapping$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $HttpServletRequest extends $ServletRequest {

 "getMethod"(): string
 "getHeader"(arg0: string): string
 "getHeaders"(arg0: string): $Enumeration<(string)>
 "authenticate"(arg0: $HttpServletResponse$Type): boolean
 "getRequestURI"(): string
 "getAuthType"(): string
 "getQueryString"(): string
 "getHttpServletMapping"(): $HttpServletMapping
 "isRequestedSessionIdValid"(): boolean
 "isRequestedSessionIdFromCookie"(): boolean
 "isRequestedSessionIdFromURL"(): boolean
/**
 * 
 * @deprecated
 */
 "isRequestedSessionIdFromUrl"(): boolean
 "isTrailerFieldsReady"(): boolean
 "getRequestedSessionId"(): string
 "getContextPath"(): string
 "getSession"(arg0: boolean): $HttpSession
 "getSession"(): $HttpSession
 "upgrade"<T extends $HttpUpgradeHandler>(arg0: $Class$Type<(T)>): T
 "getPathInfo"(): string
 "getHeaderNames"(): $Enumeration<(string)>
 "getTrailerFields"(): $Map<(string), (string)>
 "getIntHeader"(arg0: string): integer
 "newPushBuilder"(): $PushBuilder
 "getPathTranslated"(): string
 "isUserInRole"(arg0: string): boolean
 "getDateHeader"(arg0: string): long
 "getRemoteUser"(): string
 "getUserPrincipal"(): $Principal
 "getCookies"(): ($Cookie)[]
 "getRequestURL"(): $StringBuffer
 "changeSessionId"(): string
 "getServletPath"(): string
 "login"(arg0: string, arg1: string): void
 "logout"(): void
 "getParts"(): $Collection<($Part)>
 "getPart"(arg0: string): $Part
 "getScheme"(): string
 "getInputStream"(): $ServletInputStream
 "getProtocol"(): string
 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
 "getLocale"(): $Locale
 "getContentLength"(): integer
 "getRealPath"(arg0: string): string
 "getContentLengthLong"(): long
 "getContentType"(): string
 "isSecure"(): boolean
 "getParameter"(arg0: string): string
 "getLocalName"(): string
 "getLocalPort"(): integer
 "removeAttribute"(arg0: string): void
 "getCharacterEncoding"(): string
 "setCharacterEncoding"(arg0: string): void
 "getRequestDispatcher"(arg0: string): $RequestDispatcher
 "getServerName"(): string
 "getReader"(): $BufferedReader
 "getDispatcherType"(): $DispatcherType
 "getServletContext"(): $ServletContext
 "isAsyncStarted"(): boolean
 "getRemotePort"(): integer
 "getParameterNames"(): $Enumeration<(string)>
 "getParameterValues"(arg0: string): (string)[]
 "getLocalAddr"(): string
 "startAsync"(): $AsyncContext
 "startAsync"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $AsyncContext
 "getRemoteAddr"(): string
 "getParameterMap"(): $Map<(string), ((string)[])>
 "getLocales"(): $Enumeration<($Locale)>
 "getRemoteHost"(): string
 "getServerPort"(): integer
 "isAsyncSupported"(): boolean
 "getAsyncContext"(): $AsyncContext
 "getAttributeNames"(): $Enumeration<(string)>
}

export namespace $HttpServletRequest {
const BASIC_AUTH: string
const FORM_AUTH: string
const CLIENT_CERT_AUTH: string
const DIGEST_AUTH: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServletRequest$Type = ($HttpServletRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServletRequest_ = $HttpServletRequest$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapsKt" {
import {$LinkedHashMap, $LinkedHashMap$Type} from "packages/java/util/$LinkedHashMap"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$MapsKt__MapsJVMKt, $MapsKt__MapsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapsJVMKt"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapsKt__MapsKt extends $MapsKt__MapsJVMKt {

constructor()

public static "optimizeReadOnlyMap"<K, V>(arg0: $Map$Type<(K), (any)>): $Map<(K), (V)>
public static "linkedMapOf"<K, V>(...arg0: ($Pair$Type<(any), (any)>)[]): $LinkedHashMap<(K), (V)>
public static "hashMapOf"<K, V>(...arg0: ($Pair$Type<(any), (any)>)[]): $HashMap<(K), (V)>
public static "getOrElseNullable"<K, V>(arg0: $Map$Type<(K), (any)>, arg1: K, arg2: $Function0$Type<(any)>): V
public static "mapKeysTo"<K, V, R, M extends $Map<(any), (any)>>(arg0: $Map$Type<(any), (any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "mapValuesTo"<K, V, R, M extends $Map<(any), (any)>>(arg0: $Map$Type<(any), (any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "mutableMapOf"<K, V>(...arg0: ($Pair$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "toMutableMap"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "getValue"<K, V>(arg0: $Map$Type<(K), (any)>, arg1: K): V
public static "filter"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): $Map<(K), (V)>
public static "putAll"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: ($Pair$Type<(any), (any)>)[]): void
public static "putAll"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Iterable$Type<(any)>): void
public static "putAll"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Sequence$Type<(any)>): void
public static "toMap"<K, V>(arg0: ($Pair$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "toMap"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "toMap"<K, V, M extends $Map<(any), (any)>>(arg0: $Map$Type<(any), (any)>, arg1: M): M
public static "toMap"<K, V, M extends $Map<(any), (any)>>(arg0: ($Pair$Type<(any), (any)>)[], arg1: M): M
public static "toMap"<K, V, M extends $Map<(any), (any)>>(arg0: $Iterable$Type<(any)>, arg1: M): M
public static "toMap"<K, V>(arg0: $Iterable$Type<(any)>): $Map<(K), (V)>
public static "toMap"<K, V>(arg0: $Sequence$Type<(any)>): $Map<(K), (V)>
public static "toMap"<K, V, M extends $Map<(any), (any)>>(arg0: $Sequence$Type<(any)>, arg1: M): M
public static "filterValues"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): $Map<(K), (V)>
public static "emptyMap"<K, V>(): $Map<(K), (V)>
public static "plus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Pair$Type<(any), (any)>): $Map<(K), (V)>
public static "plus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "plus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Sequence$Type<(any)>): $Map<(K), (V)>
public static "plus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Iterable$Type<(any)>): $Map<(K), (V)>
public static "plus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: ($Pair$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "minus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Sequence$Type<(any)>): $Map<(K), (V)>
public static "minus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: (K)[]): $Map<(K), (V)>
public static "minus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: K): $Map<(K), (V)>
public static "minus"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Iterable$Type<(any)>): $Map<(K), (V)>
public static "filterKeys"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): $Map<(K), (V)>
public static "mapValues"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (R)>
public static "mapOf"<K, V>(...arg0: ($Pair$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "filterNot"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (boolean)>): $Map<(K), (V)>
public static "filterTo"<K, V, M extends $Map<(any), (any)>>(arg0: $Map$Type<(any), (any)>, arg1: M, arg2: $Function1$Type<(any), (boolean)>): M
public static "filterNotTo"<K, V, M extends $Map<(any), (any)>>(arg0: $Map$Type<(any), (any)>, arg1: M, arg2: $Function1$Type<(any), (boolean)>): M
public static "getOrPut"<K, V>(arg0: $Map$Type<(K), (V)>, arg1: K, arg2: $Function0$Type<(any)>): V
public static "mapKeys"<K, V, R>(arg0: $Map$Type<(any), (any)>, arg1: $Function1$Type<(any), (any)>): $Map<(R), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapsKt__MapsKt$Type = ($MapsKt__MapsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapsKt__MapsKt_ = $MapsKt__MapsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"

export class $Cookie implements $Cloneable, $Serializable {

constructor(arg0: string, arg1: string)

public "getName"(): string
public "clone"(): any
public "getValue"(): string
public "setValue"(arg0: string): void
public "getPath"(): string
public "setComment"(arg0: string): void
public "getComment"(): string
public "getVersion"(): integer
public "setVersion"(arg0: integer): void
public "getDomain"(): string
public "isHttpOnly"(): boolean
public "setPath"(arg0: string): void
public "setSecure"(arg0: boolean): void
public "getSecure"(): boolean
public "setMaxAge"(arg0: integer): void
public "getMaxAge"(): integer
public "setDomain"(arg0: string): void
public "setHttpOnly"(arg0: boolean): void
get "name"(): string
get "value"(): string
set "value"(value: string)
get "path"(): string
set "comment"(value: string)
get "comment"(): string
get "version"(): integer
set "version"(value: integer)
get "domain"(): string
get "httpOnly"(): boolean
set "path"(value: string)
set "secure"(value: boolean)
get "secure"(): boolean
set "maxAge"(value: integer)
get "maxAge"(): integer
set "domain"(value: string)
set "httpOnly"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Cookie$Type = ($Cookie);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Cookie_ = $Cookie$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields" {
import {$HttpHeaderValue, $HttpHeaderValue$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeaderValue"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HttpFields implements $Iterable<($HttpField)> {
/**
 * 
 * @deprecated
 */
static readonly "__separators": string

constructor()
constructor(arg0: integer)
constructor(arg0: $HttpFields$Type)

public "addCSV"(arg0: $HttpHeader$Type, ...arg1: (string)[]): boolean
public "addCSV"(arg0: string, ...arg1: (string)[]): boolean
/**
 * 
 * @deprecated
 */
public "getStringField"(arg0: $HttpHeader$Type): string
/**
 * 
 * @deprecated
 */
public "getStringField"(arg0: string): string
public "getCSV"(arg0: $HttpHeader$Type, arg1: boolean): $List<(string)>
public "getCSV"(arg0: string, arg1: boolean): $List<(string)>
/**
 * 
 * @deprecated
 */
public static "qualityList"(arg0: $Enumeration$Type<(string)>): $List<(string)>
public "add"(arg0: string, arg1: string): void
public "add"(arg0: $HttpHeader$Type, arg1: $HttpHeaderValue$Type): void
public "add"(arg0: $HttpField$Type): void
public "add"(arg0: $HttpFields$Type): void
public "add"(arg0: $HttpHeader$Type, arg1: string): void
public "remove"(arg0: string): $HttpField
public "remove"(arg0: $HttpHeader$Type): $HttpField
public "get"(arg0: $HttpHeader$Type): string
public "get"(arg0: string): string
public "put"(arg0: $HttpHeader$Type, arg1: $HttpHeaderValue$Type): void
public "put"(arg0: $HttpHeader$Type, arg1: string): void
public "put"(arg0: string, arg1: string): void
public "put"(arg0: string, arg1: $List$Type<(string)>): void
public "put"(arg0: $HttpField$Type): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "size"(): integer
public "iterator"(): $Iterator<($HttpField)>
public "stream"(): $Stream<($HttpField)>
public "contains"(arg0: $HttpField$Type): boolean
public "contains"(arg0: $HttpHeader$Type, arg1: string): boolean
public "contains"(arg0: $HttpHeader$Type): boolean
public "contains"(arg0: string, arg1: string): boolean
public "addAll"(arg0: $HttpFields$Type): void
public "getField"(arg0: $HttpHeader$Type): $HttpField
public "getField"(arg0: integer): $HttpField
public "getField"(arg0: string): $HttpField
public "containsKey"(arg0: string): boolean
public "getFieldNames"(): $Enumeration<(string)>
public "getValuesList"(arg0: string): $List<(string)>
public "getValuesList"(arg0: $HttpHeader$Type): $List<(string)>
/**
 * 
 * @deprecated
 */
public static "getQuality"(arg0: string): float
public "putLongField"(arg0: $HttpHeader$Type, arg1: long): void
public "putLongField"(arg0: string, arg1: long): void
public "addDateField"(arg0: string, arg1: long): void
public "putDateField"(arg0: string, arg1: long): void
public "putDateField"(arg0: $HttpHeader$Type, arg1: long): void
public static "stripParameters"(arg0: string): string
public "getDateField"(arg0: string): long
public "getQualityCSV"(arg0: string): $List<(string)>
public "getQualityCSV"(arg0: $HttpHeader$Type): $List<(string)>
public static "valueParameters"(arg0: string, arg1: $Map$Type<(string), (string)>): string
public "getFieldNamesCollection"(): $Set<(string)>
public "getLongField"(arg0: string): long
/**
 * 
 * @deprecated
 */
public "getValues"(arg0: string, arg1: string): $Enumeration<(string)>
public "getValues"(arg0: string): $Enumeration<(string)>
public "spliterator"(): $Spliterator<($HttpField)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$HttpField>;
get "fieldNames"(): $Enumeration<(string)>
get "fieldNamesCollection"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpFields$Type = ($HttpFields);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpFields_ = $HttpFields$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/serialization/$DefaultSerializer" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Serializer, $Serializer$Type} from "packages/info/journeymap/shaded/kotlin/spark/serialization/$Serializer"

export class $DefaultSerializer extends $Serializer {


public "process"(arg0: $OutputStream$Type, arg1: any): void
public "canProcess"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultSerializer$Type = ($DefaultSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultSerializer_ = $DefaultSerializer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServer" {
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$SslStores, $SslStores$Type} from "packages/info/journeymap/shaded/kotlin/spark/ssl/$SslStores"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $EmbeddedServer {

 "ignite"(arg0: string, arg1: integer, arg2: $SslStores$Type, arg3: integer, arg4: integer, arg5: integer): integer
 "join"(): void
 "extinguish"(): void
 "configureWebSockets"(arg0: $Map$Type<(string), ($WebSocketHandlerWrapper$Type)>, arg1: $Optional$Type<(integer)>): void
 "activeThreadCount"(): integer
}

export namespace $EmbeddedServer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedServer$Type = ($EmbeddedServer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedServer_ = $EmbeddedServer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$CertificateValidator" {
import {$Certificate, $Certificate$Type} from "packages/java/security/cert/$Certificate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$KeyStore, $KeyStore$Type} from "packages/java/security/$KeyStore"

export class $CertificateValidator {

constructor(arg0: $KeyStore$Type, arg1: $Collection$Type<(any)>)

public "validate"(arg0: $KeyStore$Type): void
public "validate"(arg0: ($Certificate$Type)[]): void
public "validate"(arg0: $KeyStore$Type, arg1: $Certificate$Type): void
public "validate"(arg0: $KeyStore$Type, arg1: string): string
public "setOcspResponderURL"(arg0: string): void
public "getMaxCertPathLength"(): integer
public "getOcspResponderURL"(): string
public "setMaxCertPathLength"(arg0: integer): void
public "getCrls"(): $Collection<(any)>
public "isEnableCRLDP"(): boolean
public "setEnableCRLDP"(arg0: boolean): void
public "getTrustStore"(): $KeyStore
public "isEnableOCSP"(): boolean
public "setEnableOCSP"(arg0: boolean): void
set "ocspResponderURL"(value: string)
get "maxCertPathLength"(): integer
get "ocspResponderURL"(): string
set "maxCertPathLength"(value: integer)
get "crls"(): $Collection<(any)>
get "enableCRLDP"(): boolean
set "enableCRLDP"(value: boolean)
get "trustStore"(): $KeyStore
get "enableOCSP"(): boolean
set "enableOCSP"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CertificateValidator$Type = ($CertificateValidator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CertificateValidator_ = $CertificateValidator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$CollectionUtils" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $CollectionUtils {

constructor()

public static "isEmpty"(arg0: $Collection$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionUtils$Type = ($CollectionUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionUtils_ = $CollectionUtils$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassReference$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ClassReference$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getClassSimpleName"(arg0: $Class$Type<(any)>): string
public "isInstance"(arg0: any, arg1: $Class$Type<(any)>): boolean
public "getClassQualifiedName"(arg0: $Class$Type<(any)>): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassReference$Companion$Type = ($ClassReference$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassReference$Companion_ = $ClassReference$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Utf8Appendable" {
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Utf8Appendable {
static readonly "REPLACEMENT": character
static readonly "REPLACEMENT_UTF8": (byte)[]

constructor(arg0: $Appendable$Type)

public "length"(): integer
public "append"(arg0: string, arg1: integer, arg2: integer): void
public "append"(arg0: byte): void
public "append"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): boolean
public "append"(arg0: $ByteBuffer$Type): void
public "append"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "append"(arg0: character): void
public "append"(arg0: string): void
public "isUtf8SequenceComplete"(): boolean
public "toReplacedString"(): string
get "utf8SequenceComplete"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8Appendable$Type = ($Utf8Appendable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8Appendable_ = $Utf8Appendable$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$Factory" {
import {$Authenticator, $Authenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$LoginService, $LoginService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export interface $Authenticator$Factory {

 "getAuthenticator"(arg0: $Server$Type, arg1: $ServletContext$Type, arg2: $Authenticator$AuthConfiguration$Type, arg3: $IdentityService$Type, arg4: $LoginService$Type): $Authenticator

(arg0: $Server$Type, arg1: $ServletContext$Type, arg2: $Authenticator$AuthConfiguration$Type, arg3: $IdentityService$Type, arg4: $LoginService$Type): $Authenticator
}

export namespace $Authenticator$Factory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authenticator$Factory$Type = ($Authenticator$Factory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authenticator$Factory_ = $Authenticator$Factory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpContent" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$ReadableByteChannel, $ReadableByteChannel$Type} from "packages/java/nio/channels/$ReadableByteChannel"
import {$CompressedContentFormat, $CompressedContentFormat$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$CompressedContentFormat"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$MimeTypes$Type, $MimeTypes$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MimeTypes$Type"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $HttpContent {

 "getReadableByteChannel"(): $ReadableByteChannel
 "getResource"(): $Resource
 "getInputStream"(): $InputStream
 "release"(): void
 "getLastModified"(): $HttpField
 "getContentLength"(): $HttpField
 "getContentType"(): $HttpField
 "getContentEncoding"(): $HttpField
 "getETag"(): $HttpField
 "getETagValue"(): string
 "getMimeType"(): $MimeTypes$Type
 "getCharacterEncoding"(): string
 "getIndirectBuffer"(): $ByteBuffer
 "getDirectBuffer"(): $ByteBuffer
 "getContentEncodingValue"(): string
 "getContentLengthValue"(): long
 "getContentTypeValue"(): string
 "getPrecompressedContents"(): $Map<($CompressedContentFormat), (any)>
 "getLastModifiedValue"(): string
}

export namespace $HttpContent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpContent$Type = ($HttpContent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpContent_ = $HttpContent$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSet" {
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"

export interface $IImageLineSet<T extends $IImageLine> {

 "size"(): integer
 "getImageLine"(arg0: integer): T
 "hasImageLine"(arg0: integer): boolean
}

export namespace $IImageLineSet {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IImageLineSet$Type<T> = ($IImageLineSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IImageLineSet_<T> = $IImageLineSet$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/payload/$DeMaskProcessor" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$PayloadProcessor, $PayloadProcessor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/payload/$PayloadProcessor"

export class $DeMaskProcessor implements $PayloadProcessor {

constructor()

public "reset"(arg0: $Frame$Type): void
public "reset"(arg0: (byte)[]): void
public "process"(arg0: $ByteBuffer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeMaskProcessor$Type = ($DeMaskProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeMaskProcessor_ = $DeMaskProcessor$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$DigestAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export class $DigestAuthenticator extends $LoginAuthenticator {

constructor()

public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "newNonce"(arg0: $Request$Type): string
public "setConfiguration"(arg0: $Authenticator$AuthConfiguration$Type): void
public "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $UserIdentity
public "getAuthMethod"(): string
public "getMaxNonceAge"(): long
public "getMaxNonceCount"(): integer
public "setMaxNonceCount"(arg0: integer): void
public "setMaxNonceAge"(arg0: long): void
set "configuration"(value: $Authenticator$AuthConfiguration$Type)
get "authMethod"(): string
get "maxNonceAge"(): long
get "maxNonceCount"(): integer
set "maxNonceCount"(value: integer)
set "maxNonceAge"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DigestAuthenticator$Type = ($DigestAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DigestAuthenticator_ = $DigestAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinNothingValueException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $KotlinNothingValueException extends $RuntimeException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinNothingValueException$Type = ($KotlinNothingValueException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinNothingValueException_ = $KotlinNothingValueException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState$ConnectionStateListener" {
import {$ConnectionState, $ConnectionState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$ConnectionState"

export interface $IOState$ConnectionStateListener {

 "onConnectionStateChange"(arg0: $ConnectionState$Type): void

(arg0: $ConnectionState$Type): void
}

export namespace $IOState$ConnectionStateListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOState$ConnectionStateListener$Type = ($IOState$ConnectionStateListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOState$ConnectionStateListener_ = $IOState$ConnectionStateListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/experimental/$ExperimentalTypeInference" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ExperimentalTypeInference extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ExperimentalTypeInference {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperimentalTypeInference$Type = ($ExperimentalTypeInference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperimentalTypeInference_ = $ExperimentalTypeInference$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchNamedGroupCollection" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$MatchGroupCollection, $MatchGroupCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroupCollection"
import {$MatchGroup, $MatchGroup$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroup"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export interface $MatchNamedGroupCollection extends $MatchGroupCollection {

 "get"(arg0: string): $MatchGroup
 "get"(arg0: integer): $MatchGroup
 "add"(arg0: $MatchGroup$Type): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "iterator"(): $Iterator<($MatchGroup)>
 "stream"(): $Stream<($MatchGroup)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<($MatchGroup)>
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<($MatchGroup)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $MatchNamedGroupCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchNamedGroupCollection$Type = ($MatchNamedGroupCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchNamedGroupCollection_ = $MatchNamedGroupCollection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$SocketChannelEndPoint" {
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$Socket, $Socket$Type} from "packages/java/net/$Socket"
import {$ChannelEndPoint, $ChannelEndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ChannelEndPoint"
import {$ManagedSelector, $ManagedSelector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ManagedSelector"
import {$SelectableChannel, $SelectableChannel$Type} from "packages/java/nio/channels/$SelectableChannel"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $SocketChannelEndPoint extends $ChannelEndPoint {

constructor(arg0: $SelectableChannel$Type, arg1: $ManagedSelector$Type, arg2: $SelectionKey$Type, arg3: $Scheduler$Type)
constructor(arg0: $SocketChannel$Type, arg1: $ManagedSelector$Type, arg2: $SelectionKey$Type, arg3: $Scheduler$Type)

public "getLocalAddress"(): $InetSocketAddress
public "getSocket"(): $Socket
public "getRemoteAddress"(): $InetSocketAddress
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
get "localAddress"(): $InetSocketAddress
get "socket"(): $Socket
get "remoteAddress"(): $InetSocketAddress
set "idleTimeout"(value: long)
get "idleTimeout"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SocketChannelEndPoint$Type = ($SocketChannelEndPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SocketChannelEndPoint_ = $SocketChannelEndPoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$AfterFilters" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AfterFilters {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterFilters$Type = ($AfterFilters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterFilters_ = $AfterFilters$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Experimental" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Experimental$Level, $Experimental$Level$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Experimental$Level"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Experimental extends $Annotation {

 "level"(): $Experimental$Level
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Experimental {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Experimental$Type = ($Experimental);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Experimental_ = $Experimental$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User" {
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"

export interface $Authentication$User extends $Authentication {

 "getUserIdentity"(): $UserIdentity
 "isUserInRole"(arg0: $UserIdentity$Scope$Type, arg1: string): boolean
 "logout"(): void
 "getAuthMethod"(): string
}

export namespace $Authentication$User {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authentication$User$Type = ($Authentication$User);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authentication$User_ = $Authentication$User$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintAware" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConstraintMapping, $ConstraintMapping$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintMapping"

export interface $ConstraintAware {

 "getRoles"(): $Set<(string)>
 "addRole"(arg0: string): void
 "getConstraintMappings"(): $List<($ConstraintMapping)>
 "addConstraintMapping"(arg0: $ConstraintMapping$Type): void
 "setDenyUncoveredHttpMethods"(arg0: boolean): void
 "setConstraintMappings"(arg0: $List$Type<($ConstraintMapping$Type)>, arg1: $Set$Type<(string)>): void
 "checkPathsWithUncoveredHttpMethods"(): boolean
 "isDenyUncoveredHttpMethods"(): boolean
}

export namespace $ConstraintAware {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstraintAware$Type = ($ConstraintAware);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstraintAware_ = $ConstraintAware$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletMapping" {
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"

export class $ServletMapping {

constructor()
constructor(arg0: $Source$Type)

public "setPathSpec"(arg0: string): void
public "toString"(): string
public "isDefault"(): boolean
public "setDefault"(arg0: boolean): void
public "getSource"(): $Source
public "getServletName"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "getPathSpecs"(): (string)[]
public "setServletName"(arg0: string): void
public "setPathSpecs"(arg0: (string)[]): void
public "containsPathSpec"(arg0: string): boolean
set "pathSpec"(value: string)
get "default"(): boolean
set "default"(value: boolean)
get "source"(): $Source
get "servletName"(): string
get "pathSpecs"(): (string)[]
set "servletName"(value: string)
set "pathSpecs"(value: (string)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletMapping$Type = ($ServletMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletMapping_ = $ServletMapping$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayCharIterator" {
import {$CharIterator, $CharIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator"

export class $ArrayCharIterator extends $CharIterator {

constructor(arg0: (character)[])

public "hasNext"(): boolean
public "nextChar"(): character
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayCharIterator$Type = ($ArrayCharIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayCharIterator_ = $ArrayCharIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$RegexPathSpec" {
import {$Matcher, $Matcher$Type} from "packages/java/util/regex/$Matcher"
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"

export class $RegexPathSpec extends $PathSpec {

constructor(arg0: string)

public "getRelativePath"(arg0: string, arg1: string): string
public "getPathMatch"(arg0: string): string
public "matches"(arg0: string): boolean
public "getPattern"(): $Pattern
public "getMatcher"(arg0: string): $Matcher
public "getPathInfo"(arg0: string): string
get "pattern"(): $Pattern
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexPathSpec$Type = ($RegexPathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexPathSpec_ = $RegexPathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext" {
import {$ContextHandler$Context, $ContextHandler$Context$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$Context"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $SessionContext {
static readonly "NULL_VHOST": string

constructor(arg0: string, arg1: $ContextHandler$Context$Type)

public "run"(arg0: $Runnable$Type): void
public "toString"(): string
public "getContext"(): $ContextHandler$Context
public "getSessionHandler"(): $SessionHandler
public "getWorkerName"(): string
public "getVhost"(): string
public "getCanonicalContextPath"(): string
get "context"(): $ContextHandler$Context
get "sessionHandler"(): $SessionHandler
get "workerName"(): string
get "vhost"(): string
get "canonicalContextPath"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionContext$Type = ($SessionContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionContext_ = $SessionContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper" {
import {$AbstractHandlerContainer, $AbstractHandlerContainer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandlerContainer"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"

export class $HandlerWrapper extends $AbstractHandlerContainer {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "destroy"(): void
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "getHandler"(): $Handler
public "getHandlers"(): ($Handler)[]
public "setHandler"(arg0: $Handler$Type): void
public "insertHandler"(arg0: $HandlerWrapper$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "handler"(): $Handler
get "handlers"(): ($Handler)[]
set "handler"(value: $Handler$Type)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandlerWrapper$Type = ($HandlerWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandlerWrapper_ = $HandlerWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpecSet" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractSet, $AbstractSet$Type} from "packages/java/util/$AbstractSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $PathSpecSet extends $AbstractSet<(string)> implements $Predicate<(string)> {

constructor()

public "add"(arg0: string): boolean
public "remove"(arg0: any): boolean
public "test"(arg0: string): boolean
public "clear"(): void
public "size"(): integer
public "iterator"(): $Iterator<(string)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public "negate"(): $Predicate<(string)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public static "isEqual"<T>(arg0: any): $Predicate<(string)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathSpecSet$Type = ($PathSpecSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathSpecSet_ = $PathSpecSet$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$UnixCrypt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UnixCrypt {


public static "main"(arg0: (string)[]): void
public static "crypt"(arg0: string, arg1: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnixCrypt$Type = ($UnixCrypt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnixCrypt_ = $UnixCrypt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$ModuleNameRetriever" {
import {$BaseContinuationImpl, $BaseContinuationImpl$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$BaseContinuationImpl"

export class $ModuleNameRetriever {
static readonly "INSTANCE": $ModuleNameRetriever


public "getModuleName"(arg0: $BaseContinuationImpl$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleNameRetriever$Type = ($ModuleNameRetriever);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleNameRetriever_ = $ModuleNameRetriever$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic" {
import {$ServletSecurityElement, $ServletSecurityElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletSecurityElement"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ServletRegistration, $ServletRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration"
import {$MultipartConfigElement, $MultipartConfigElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$MultipartConfigElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Registration$Dynamic, $Registration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Registration$Dynamic"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ServletRegistration$Dynamic extends $ServletRegistration, $Registration$Dynamic {

 "setRunAsRole"(arg0: string): void
 "setMultipartConfig"(arg0: $MultipartConfigElement$Type): void
 "setLoadOnStartup"(arg0: integer): void
 "setServletSecurity"(arg0: $ServletSecurityElement$Type): $Set<(string)>
 "getRunAsRole"(): string
 "addMapping"(...arg0: (string)[]): $Set<(string)>
 "getMappings"(): $Collection<(string)>
 "setAsyncSupported"(arg0: boolean): void
 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $ServletRegistration$Dynamic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRegistration$Dynamic$Type = ($ServletRegistration$Dynamic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRegistration$Dynamic_ = $ServletRegistration$Dynamic$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngHelperInternal2" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PngHelperInternal2 {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngHelperInternal2$Type = ($PngHelperInternal2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngHelperInternal2_ = $PngHelperInternal2$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/unsigned/$UArraysKt___UArraysKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$UByte, $UByte$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UByte"
import {$UShort, $UShort$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UShort"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"
import {$UArraysKt___UArraysJvmKt, $UArraysKt___UArraysJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/unsigned/$UArraysKt___UArraysJvmKt"

export class $UArraysKt___UArraysKt extends $UArraysKt___UArraysJvmKt {

constructor()

public static "sortedDescending--ajY-9A"(arg0: (integer)[]): $List<($UInt)>
public static "sortedDescending-QwZRm1k"(arg0: (long)[]): $List<($ULong)>
public static "sortedDescending-rL5Bavg"(arg0: (short)[]): $List<($UShort)>
public static "minWithOrNull-XMRcp5o"(arg0: (byte)[], arg1: $Comparator$Type<(any)>): $UByte
public static "maxWithOrNull-zrEWJaI"(arg0: (long)[], arg1: $Comparator$Type<(any)>): $ULong
public static "maxWithOrNull-eOHTfZs"(arg0: (short)[], arg1: $Comparator$Type<(any)>): $UShort
public static "maxWithOrNull-XMRcp5o"(arg0: (byte)[], arg1: $Comparator$Type<(any)>): $UByte
public static "maxWithOrNull-YmdZ_VM"(arg0: (integer)[], arg1: $Comparator$Type<(any)>): $UInt
public static "minWithOrNull-YmdZ_VM"(arg0: (integer)[], arg1: $Comparator$Type<(any)>): $UInt
public static "minWithOrNull-zrEWJaI"(arg0: (long)[], arg1: $Comparator$Type<(any)>): $ULong
public static "minWithOrNull-eOHTfZs"(arg0: (short)[], arg1: $Comparator$Type<(any)>): $UShort
public static "randomOrNull-oSF2wD8"(arg0: (byte)[], arg1: $Random$Type): $UByte
public static "randomOrNull-JzugnMA"(arg0: (long)[], arg1: $Random$Type): $ULong
public static "randomOrNull-2D5oskM"(arg0: (integer)[], arg1: $Random$Type): $UInt
public static "sortedArray-QwZRm1k"(arg0: (long)[]): (long)[]
public static "sortedArray-rL5Bavg"(arg0: (short)[]): (short)[]
public static "sortedArray-GBYM_sE"(arg0: (byte)[]): (byte)[]
public static "sortedArray--ajY-9A"(arg0: (integer)[]): (integer)[]
public static "sortDescending-oBK06Vg"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "sortDescending-rL5Bavg"(arg0: (short)[]): void
public static "sortDescending--ajY-9A"(arg0: (integer)[]): void
public static "sortDescending-QwZRm1k"(arg0: (long)[]): void
public static "sortDescending--nroSd4"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "sortDescending-Aa5vz7o"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "sortedArrayDescending-QwZRm1k"(arg0: (long)[]): (long)[]
public static "sortedDescending-GBYM_sE"(arg0: (byte)[]): $List<($UByte)>
public static "sortedArrayDescending-rL5Bavg"(arg0: (short)[]): (short)[]
public static "sortedArrayDescending-GBYM_sE"(arg0: (byte)[]): (byte)[]
public static "sortedArrayDescending--ajY-9A"(arg0: (integer)[]): (integer)[]
public static "sumOfUInt"(arg0: ($UInt$Type)[]): integer
public static "sumOfULong"(arg0: ($ULong$Type)[]): long
public static "sortDescending-4UcCI2c"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "sortDescending-GBYM_sE"(arg0: (byte)[]): void
public static "singleOrNull-GBYM_sE"(arg0: (byte)[]): $UByte
public static "singleOrNull--ajY-9A"(arg0: (integer)[]): $UInt
public static "singleOrNull-QwZRm1k"(arg0: (long)[]): $ULong
public static "singleOrNull-rL5Bavg"(arg0: (short)[]): $UShort
public static "toTypedArray-GBYM_sE"(arg0: (byte)[]): ($UByte)[]
public static "toTypedArray-QwZRm1k"(arg0: (long)[]): ($ULong)[]
public static "toTypedArray-rL5Bavg"(arg0: (short)[]): ($UShort)[]
public static "toTypedArray--ajY-9A"(arg0: (integer)[]): ($UInt)[]
public static "lastOrNull-GBYM_sE"(arg0: (byte)[]): $UByte
public static "getIndices-QwZRm1k"(arg0: (long)[]): $IntRange
public static "getIndices-rL5Bavg"(arg0: (short)[]): $IntRange
public static "getIndices--ajY-9A"(arg0: (integer)[]): $IntRange
public static "getIndices-GBYM_sE"(arg0: (byte)[]): $IntRange
public static "drop-r7IrZao"(arg0: (long)[], arg1: integer): $List<($ULong)>
public static "drop-nggk6HY"(arg0: (short)[], arg1: integer): $List<($UShort)>
public static "dropLast-PpDY95g"(arg0: (byte)[], arg1: integer): $List<($UByte)>
public static "drop-qFRl0hI"(arg0: (integer)[], arg1: integer): $List<($UInt)>
public static "dropLast-qFRl0hI"(arg0: (integer)[], arg1: integer): $List<($UInt)>
public static "dropLast-r7IrZao"(arg0: (long)[], arg1: integer): $List<($ULong)>
public static "dropLast-nggk6HY"(arg0: (short)[], arg1: integer): $List<($UShort)>
public static "drop-PpDY95g"(arg0: (byte)[], arg1: integer): $List<($UByte)>
public static "fill-2fe2U9s"(arg0: (integer)[], arg1: integer, arg2: integer, arg3: integer): void
public static "fill-EtDCXyQ"(arg0: (short)[], arg1: short, arg2: integer, arg3: integer): void
public static "fill-K6DWlUc"(arg0: (long)[], arg1: long, arg2: integer, arg3: integer): void
public static "fill-WpHrYlw"(arg0: (byte)[], arg1: byte, arg2: integer, arg3: integer): void
public static "getOrNull-nggk6HY"(arg0: (short)[], arg1: integer): $UShort
public static "getOrNull-r7IrZao"(arg0: (long)[], arg1: integer): $ULong
public static "getOrNull-qFRl0hI"(arg0: (integer)[], arg1: integer): $UInt
public static "getOrNull-PpDY95g"(arg0: (byte)[], arg1: integer): $UByte
public static "lastOrNull-rL5Bavg"(arg0: (short)[]): $UShort
public static "lastOrNull--ajY-9A"(arg0: (integer)[]): $UInt
public static "lastOrNull-QwZRm1k"(arg0: (long)[]): $ULong
public static "maxOrNull--ajY-9A"(arg0: (integer)[]): $UInt
public static "maxOrNull-QwZRm1k"(arg0: (long)[]): $ULong
public static "maxOrNull-GBYM_sE"(arg0: (byte)[]): $UByte
public static "maxOrNull-rL5Bavg"(arg0: (short)[]): $UShort
public static "minOrNull--ajY-9A"(arg0: (integer)[]): $UInt
public static "minOrNull-GBYM_sE"(arg0: (byte)[]): $UByte
public static "minOrNull-rL5Bavg"(arg0: (short)[]): $UShort
public static "minOrNull-QwZRm1k"(arg0: (long)[]): $ULong
public static "random-oSF2wD8"(arg0: (byte)[], arg1: $Random$Type): byte
public static "plus-xo_DsdI"(arg0: (byte)[], arg1: $Collection$Type<($UByte$Type)>): (byte)[]
public static "plus-kzHmqpY"(arg0: (long)[], arg1: $Collection$Type<($ULong$Type)>): (long)[]
public static "plus-CFIt9YE"(arg0: (integer)[], arg1: $Collection$Type<($UInt$Type)>): (integer)[]
public static "plus-ojwP5H8"(arg0: (short)[], arg1: $Collection$Type<($UShort$Type)>): (short)[]
public static "random-JzugnMA"(arg0: (long)[], arg1: $Random$Type): long
public static "random-s5X_as8"(arg0: (short)[], arg1: $Random$Type): short
public static "random-2D5oskM"(arg0: (integer)[], arg1: $Random$Type): integer
public static "reversed--ajY-9A"(arg0: (integer)[]): $List<($UInt)>
public static "reversed-GBYM_sE"(arg0: (byte)[]): $List<($UByte)>
public static "reversed-QwZRm1k"(arg0: (long)[]): $List<($ULong)>
public static "reversed-rL5Bavg"(arg0: (short)[]): $List<($UShort)>
public static "shuffle-rL5Bavg"(arg0: (short)[]): void
public static "shuffle-oSF2wD8"(arg0: (byte)[], arg1: $Random$Type): void
public static "shuffle-JzugnMA"(arg0: (long)[], arg1: $Random$Type): void
public static "shuffle--ajY-9A"(arg0: (integer)[]): void
public static "shuffle-GBYM_sE"(arg0: (byte)[]): void
public static "shuffle-s5X_as8"(arg0: (short)[], arg1: $Random$Type): void
public static "shuffle-2D5oskM"(arg0: (integer)[], arg1: $Random$Type): void
public static "shuffle-QwZRm1k"(arg0: (long)[]): void
public static "slice-F7u83W8"(arg0: (long)[], arg1: $Iterable$Type<(integer)>): $List<($ULong)>
public static "slice-JGPC0-M"(arg0: (short)[], arg1: $Iterable$Type<(integer)>): $List<($UShort)>
public static "sliceArray-ZRhS8yI"(arg0: (long)[], arg1: $IntRange$Type): (long)[]
public static "sort-oBK06Vg"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "slice-Q6IL4kU"(arg0: (short)[], arg1: $IntRange$Type): $List<($UShort)>
public static "sort-4UcCI2c"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "slice-c0bezYM"(arg0: (byte)[], arg1: $IntRange$Type): $List<($UByte)>
public static "slice-ZRhS8yI"(arg0: (long)[], arg1: $IntRange$Type): $List<($ULong)>
public static "sliceArray-kzHmqpY"(arg0: (long)[], arg1: $Collection$Type<(integer)>): (long)[]
public static "slice-JQknh5Q"(arg0: (byte)[], arg1: $Iterable$Type<(integer)>): $List<($UByte)>
public static "sliceArray-xo_DsdI"(arg0: (byte)[], arg1: $Collection$Type<(integer)>): (byte)[]
public static "sliceArray-CFIt9YE"(arg0: (integer)[], arg1: $Collection$Type<(integer)>): (integer)[]
public static "slice-HwE9HBo"(arg0: (integer)[], arg1: $Iterable$Type<(integer)>): $List<($UInt)>
public static "sort--ajY-9A"(arg0: (integer)[]): void
public static "sliceArray-c0bezYM"(arg0: (byte)[], arg1: $IntRange$Type): (byte)[]
public static "sliceArray-ojwP5H8"(arg0: (short)[], arg1: $Collection$Type<(integer)>): (short)[]
public static "sort-QwZRm1k"(arg0: (long)[]): void
public static "sort--nroSd4"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "sort-Aa5vz7o"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "sliceArray-Q6IL4kU"(arg0: (short)[], arg1: $IntRange$Type): (short)[]
public static "sliceArray-tAntMlw"(arg0: (integer)[], arg1: $IntRange$Type): (integer)[]
public static "sort-GBYM_sE"(arg0: (byte)[]): void
public static "sort-rL5Bavg"(arg0: (short)[]): void
public static "slice-tAntMlw"(arg0: (integer)[], arg1: $IntRange$Type): $List<($UInt)>
public static "sorted-GBYM_sE"(arg0: (byte)[]): $List<($UByte)>
public static "take-PpDY95g"(arg0: (byte)[], arg1: integer): $List<($UByte)>
public static "sorted--ajY-9A"(arg0: (integer)[]): $List<($UInt)>
public static "sumOfUByte"(arg0: ($UByte$Type)[]): integer
public static "sumOfUShort"(arg0: ($UShort$Type)[]): integer
public static "sorted-rL5Bavg"(arg0: (short)[]): $List<($UShort)>
public static "sorted-QwZRm1k"(arg0: (long)[]): $List<($ULong)>
public static "withIndex-QwZRm1k"(arg0: (long)[]): $Iterable<($IndexedValue<($ULong)>)>
public static "withIndex-rL5Bavg"(arg0: (short)[]): $Iterable<($IndexedValue<($UShort)>)>
public static "takeLast-nggk6HY"(arg0: (short)[], arg1: integer): $List<($UShort)>
public static "toUIntArray"(arg0: ($UInt$Type)[]): (integer)[]
public static "take-nggk6HY"(arg0: (short)[], arg1: integer): $List<($UShort)>
public static "take-qFRl0hI"(arg0: (integer)[], arg1: integer): $List<($UInt)>
public static "take-r7IrZao"(arg0: (long)[], arg1: integer): $List<($ULong)>
public static "takeLast-PpDY95g"(arg0: (byte)[], arg1: integer): $List<($UByte)>
public static "takeLast-qFRl0hI"(arg0: (integer)[], arg1: integer): $List<($UInt)>
public static "takeLast-r7IrZao"(arg0: (long)[], arg1: integer): $List<($ULong)>
public static "toUByteArray"(arg0: ($UByte$Type)[]): (byte)[]
public static "toUShortArray"(arg0: ($UShort$Type)[]): (short)[]
public static "withIndex-GBYM_sE"(arg0: (byte)[]): $Iterable<($IndexedValue<($UByte)>)>
public static "toULongArray"(arg0: ($ULong$Type)[]): (long)[]
public static "withIndex--ajY-9A"(arg0: (integer)[]): $Iterable<($IndexedValue<($UInt)>)>
public static "zip-mazbYpA"(arg0: (short)[], arg1: (short)[]): $List<($Pair<($UShort), ($UShort)>)>
public static "zip-C-E_24M"<R>(arg0: (integer)[], arg1: (R)[]): $List<($Pair<($UInt), (R)>)>
public static "zip-ctEhBpI"(arg0: (integer)[], arg1: (integer)[]): $List<($Pair<($UInt), ($UInt)>)>
public static "zip-kdPth3s"(arg0: (byte)[], arg1: (byte)[]): $List<($Pair<($UByte), ($UByte)>)>
public static "zip-f7H3mmw"<R>(arg0: (long)[], arg1: (R)[]): $List<($Pair<($ULong), (R)>)>
public static "zip-nl983wc"<R>(arg0: (byte)[], arg1: (R)[]): $List<($Pair<($UByte), (R)>)>
public static "zip-us8wMrg"(arg0: (long)[], arg1: (long)[]): $List<($Pair<($ULong), ($ULong)>)>
public static "zip-F7u83W8"<R>(arg0: (long)[], arg1: $Iterable$Type<(any)>): $List<($Pair<($ULong), (R)>)>
public static "zip-JQknh5Q"<R>(arg0: (byte)[], arg1: $Iterable$Type<(any)>): $List<($Pair<($UByte), (R)>)>
public static "zip-uaTIQ5s"<R>(arg0: (short)[], arg1: (R)[]): $List<($Pair<($UShort), (R)>)>
public static "zip-HwE9HBo"<R>(arg0: (integer)[], arg1: $Iterable$Type<(any)>): $List<($Pair<($UInt), (R)>)>
public static "zip-JGPC0-M"<R>(arg0: (short)[], arg1: $Iterable$Type<(any)>): $List<($Pair<($UShort), (R)>)>
public static "randomOrNull-s5X_as8"(arg0: (short)[], arg1: $Random$Type): $UShort
public static "contentToString-XUkPCBk"(arg0: (integer)[]): string
public static "contentToString-d-6D3K8"(arg0: (short)[]): string
public static "firstOrNull-QwZRm1k"(arg0: (long)[]): $ULong
public static "contentToString-2csIQuQ"(arg0: (byte)[]): string
public static "firstOrNull-GBYM_sE"(arg0: (byte)[]): $UByte
public static "contentHashCode-XUkPCBk"(arg0: (integer)[]): integer
public static "firstOrNull-rL5Bavg"(arg0: (short)[]): $UShort
public static "contentToString-uLth9ew"(arg0: (long)[]): string
public static "firstOrNull--ajY-9A"(arg0: (integer)[]): $UInt
public static "contentHashCode-d-6D3K8"(arg0: (short)[]): integer
public static "contentHashCode-uLth9ew"(arg0: (long)[]): integer
public static "getLastIndex-GBYM_sE"(arg0: (byte)[]): integer
public static "getLastIndex--ajY-9A"(arg0: (integer)[]): integer
public static "contentEquals-lec5QzE"(arg0: (long)[], arg1: (long)[]): boolean
public static "contentEquals-FGO6Aew"(arg0: (short)[], arg1: (short)[]): boolean
public static "contentHashCode-2csIQuQ"(arg0: (byte)[]): integer
public static "getLastIndex-QwZRm1k"(arg0: (long)[]): integer
public static "getLastIndex-rL5Bavg"(arg0: (short)[]): integer
public static "contentEquals-kV0jMPg"(arg0: (byte)[], arg1: (byte)[]): boolean
public static "contentEquals-KJPZfPQ"(arg0: (integer)[], arg1: (integer)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UArraysKt___UArraysKt$Type = ($UArraysKt___UArraysKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UArraysKt___UArraysKt_ = $UArraysKt___UArraysKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$CoroutineStackFrame" {
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"

export interface $CoroutineStackFrame {

 "getCallerFrame"(): $CoroutineStackFrame
 "getStackTraceElement"(): $StackTraceElement
}

export namespace $CoroutineStackFrame {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoroutineStackFrame$Type = ($CoroutineStackFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoroutineStackFrame_ = $CoroutineStackFrame$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngWriter" {
import {$ChunksListForWrite, $ChunksListForWrite$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksListForWrite"
import {$PngMetadata, $PngMetadata$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngMetadata"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"
import {$ChunkPredicate, $ChunkPredicate$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkPredicate"
import {$IImageLineSet, $IImageLineSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSet"
import {$ChunksList, $ChunksList$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksList"
import {$File, $File$Type} from "packages/java/io/$File"
import {$PixelsWriter, $PixelsWriter$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$PixelsWriter"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"

export class $PngWriter {
readonly "imgInfo": $ImageInfo

constructor(arg0: $File$Type, arg1: $ImageInfo$Type)
constructor(arg0: $OutputStream$Type, arg1: $ImageInfo$Type)
constructor(arg0: $File$Type, arg1: $ImageInfo$Type, arg2: boolean)

public "setFilterPreserve"(arg0: boolean): void
public "getPixelsWriter"(): $PixelsWriter
public "writeRowInt"(arg0: (integer)[]): void
public "getDebuginfo"(): string
public "copyChunksFrom"(arg0: $ChunksList$Type, arg1: integer): void
public "copyChunksFrom"(arg0: $ChunksList$Type): void
public "copyChunksFrom"(arg0: $ChunksList$Type, arg1: $ChunkPredicate$Type): void
public "setCompLevel"(arg0: integer): void
public "setIdatMaxSize"(arg0: integer): void
public "writeRows"(arg0: $IImageLineSet$Type<(any)>): void
public "queueChunk"(arg0: $PngChunk$Type): void
public "writeRow"(arg0: $IImageLine$Type): void
public "writeRow"(arg0: $IImageLine$Type, arg1: integer): void
public "end"(): void
public "close"(): void
public "getMetadata"(): $PngMetadata
public "getChunksList"(): $ChunksListForWrite
public "computeCompressionRatio"(): double
public "setFilterType"(arg0: $FilterType$Type): void
public "setShouldCloseStream"(arg0: boolean): void
set "filterPreserve"(value: boolean)
get "pixelsWriter"(): $PixelsWriter
get "debuginfo"(): string
set "compLevel"(value: integer)
set "idatMaxSize"(value: integer)
get "metadata"(): $PngMetadata
get "chunksList"(): $ChunksListForWrite
set "filterType"(value: $FilterType$Type)
set "shouldCloseStream"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngWriter$Type = ($PngWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngWriter_ = $PngWriter$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharsKt__CharJVMKt" {
import {$CharDirectionality, $CharDirectionality$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharDirectionality"
import {$CharCategory, $CharCategory$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharCategory"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $CharsKt__CharJVMKt {

constructor()

public static "titlecase"(arg0: character, arg1: $Locale$Type): string
public static "isWhitespace"(arg0: character): boolean
public static "getDirectionality"(arg0: character): $CharDirectionality
public static "getCategory"(arg0: character): $CharCategory
public static "lowercase"(arg0: character, arg1: $Locale$Type): string
public static "digitOf"(arg0: character, arg1: integer): integer
public static "checkRadix"(arg0: integer): integer
public static "uppercase"(arg0: character, arg1: $Locale$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharsKt__CharJVMKt$Type = ($CharsKt__CharJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharsKt__CharJVMKt_ = $CharsKt__CharJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$ResponseWrapper" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"

export class $ResponseWrapper extends $Response {


public "type"(arg0: string): void
public "type"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "status"(): integer
public "status"(arg0: integer): void
public "setDelegate"(arg0: $Response$Type): void
public "body"(arg0: string): void
public "body"(): string
public "raw"(): $HttpServletResponse
public "header"(arg0: string, arg1: string): void
public "redirect"(arg0: string): void
public "redirect"(arg0: string, arg1: integer): void
public "cookie"(arg0: string, arg1: string, arg2: integer, arg3: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: integer, arg4: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: integer, arg4: boolean, arg5: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: integer): void
public "cookie"(arg0: string, arg1: string): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: integer, arg5: boolean, arg6: boolean): void
public "removeCookie"(arg0: string): void
public "removeCookie"(arg0: string, arg1: string): void
set "delegate"(value: $Response$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResponseWrapper$Type = ($ResponseWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResponseWrapper_ = $ResponseWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export interface $Authenticator {

 "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
 "prepareRequest"(arg0: $ServletRequest$Type): void
 "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
 "setConfiguration"(arg0: $Authenticator$AuthConfiguration$Type): void
 "getAuthMethod"(): string
}

export namespace $Authenticator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authenticator$Type = ($Authenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authenticator_ = $Authenticator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0$Setter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KMutableProperty$Setter, $KMutableProperty$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty0$Setter<V> extends $KMutableProperty$Setter<(V)>, $Function1<(V), ($Unit)> {

 "invoke"(arg0: V): $Unit
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): $Unit
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): $Unit
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty0$Setter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty0$Setter$Type<V> = ($KMutableProperty0$Setter<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty0$Setter_<V> = $KMutableProperty0$Setter$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IImageLine {

 "endReadFromPngRaw"(): void
 "readFromPngRaw"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): void
 "writeToPngRaw"(arg0: (byte)[]): void
}

export namespace $IImageLine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IImageLine$Type = ($IImageLine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IImageLine_ = $IImageLine$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$RegexKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RegexKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexKt$Type = ($RegexKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexKt_ = $RegexKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__IndentKt" {
import {$StringsKt__AppendableKt, $StringsKt__AppendableKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__AppendableKt"

export class $StringsKt__IndentKt extends $StringsKt__AppendableKt {

constructor()

public static "replaceIndentByMargin"(arg0: string, arg1: string, arg2: string): string
public static "prependIndent"(arg0: string, arg1: string): string
public static "trimMargin"(arg0: string, arg1: string): string
public static "replaceIndent"(arg0: string, arg1: string): string
public static "trimIndent"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__IndentKt$Type = ($StringsKt__IndentKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__IndentKt_ = $StringsKt__IndentKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler$Task" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Scheduler$Task {

 "cancel"(): boolean

(): boolean
}

export namespace $Scheduler$Task {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Scheduler$Task$Type = ($Scheduler$Task);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Scheduler$Task_ = $Scheduler$Task$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$SubstituteLogger" {
import {$Marker, $Marker$Type} from "packages/info/journeymap/shaded/org/slf4j/$Marker"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export class $SubstituteLogger implements $Logger {

constructor(arg0: string)

public "getName"(): string
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "info"(arg0: string, arg1: any, arg2: any): void
public "info"(arg0: string, ...arg1: (any)[]): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "info"(arg0: string, arg1: any): void
public "info"(arg0: string): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "info"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "info"(arg0: $Marker$Type, arg1: string): void
public "trace"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "trace"(arg0: string): void
public "trace"(arg0: string, arg1: $Throwable$Type): void
public "trace"(arg0: string, ...arg1: (any)[]): void
public "trace"(arg0: string, arg1: any, arg2: any): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "trace"(arg0: string, arg1: any): void
public "trace"(arg0: $Marker$Type, arg1: string): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "debug"(arg0: string, arg1: any, arg2: any): void
public "debug"(arg0: string, arg1: any): void
public "debug"(arg0: string): void
public "debug"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "debug"(arg0: $Marker$Type, arg1: string): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "setDelegate"(arg0: $Logger$Type): void
public "error"(arg0: string, arg1: $Throwable$Type): void
public "error"(arg0: string, ...arg1: (any)[]): void
public "error"(arg0: string, arg1: any, arg2: any): void
public "error"(arg0: string): void
public "error"(arg0: string, arg1: any): void
public "error"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "error"(arg0: $Marker$Type, arg1: string): void
public "warn"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "warn"(arg0: string, arg1: any, arg2: any): void
public "warn"(arg0: string, arg1: any): void
public "warn"(arg0: string): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "warn"(arg0: $Marker$Type, arg1: string): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "isTraceEnabled"(): boolean
public "isTraceEnabled"(arg0: $Marker$Type): boolean
public "isDebugEnabled"(arg0: $Marker$Type): boolean
public "isDebugEnabled"(): boolean
public "isInfoEnabled"(arg0: $Marker$Type): boolean
public "isInfoEnabled"(): boolean
public "isErrorEnabled"(arg0: $Marker$Type): boolean
public "isErrorEnabled"(): boolean
public "isWarnEnabled"(arg0: $Marker$Type): boolean
public "isWarnEnabled"(): boolean
get "name"(): string
set "delegate"(value: $Logger$Type)
get "traceEnabled"(): boolean
get "debugEnabled"(): boolean
get "infoEnabled"(): boolean
get "errorEnabled"(): boolean
get "warnEnabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubstituteLogger$Type = ($SubstituteLogger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubstituteLogger_ = $SubstituteLogger$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$IOState, $IOState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$SuspendToken, $SuspendToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$SuspendToken"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export interface $LogicalConnection extends $OutgoingFrames, $SuspendToken {

 "isOpen"(): boolean
 "suspend"(): $SuspendToken
 "getId"(): string
 "close"(): void
 "close"(arg0: integer, arg1: string): void
 "getExecutor"(): $Executor
 "getPolicy"(): $WebSocketPolicy
 "disconnect"(): void
 "getLocalAddress"(): $InetSocketAddress
 "getBufferPool"(): $ByteBufferPool
 "isReading"(): boolean
 "getRemoteAddress"(): $InetSocketAddress
 "getIOState"(): $IOState
 "getIdleTimeout"(): long
 "getMaxIdleTimeout"(): long
 "setMaxIdleTimeout"(arg0: long): void
 "setNextIncomingFrames"(arg0: $IncomingFrames$Type): void
 "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
 "resume"(): void
}

export namespace $LogicalConnection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogicalConnection$Type = ($LogicalConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogicalConnection_ = $LogicalConnection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$ConstrainedOnceSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $ConstrainedOnceSequence<T> implements $Sequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstrainedOnceSequence$Type<T> = ($ConstrainedOnceSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstrainedOnceSequence_<T> = $ConstrainedOnceSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder" {
import {$MapBuilder$ValuesItr, $MapBuilder$ValuesItr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$ValuesItr"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$MapBuilder$KeysItr, $MapBuilder$KeysItr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$KeysItr"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KMutableMap, $KMutableMap$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableMap"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MapBuilder$EntriesItr, $MapBuilder$EntriesItr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$EntriesItr"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapBuilder<K, V> implements $Map<(K), (V)>, $Serializable, $KMutableMap {

constructor()
constructor(arg0: integer)

public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $Collection<(V)>
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(K)>
public "containsValue"(arg0: any): boolean
public "getSize"(): integer
public "getEntries"(): $Set<($Map$Entry<(K), (V)>)>
public "build"(): $Map<(K), (V)>
public "getKeys"(): $Set<(K)>
public "getValues"(): $Collection<(V)>
public "removeEntry$kotlin_stdlib"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "removeKey$kotlin_stdlib"(arg0: K): integer
public "valuesIterator$kotlin_stdlib"(): $MapBuilder$ValuesItr<(K), (V)>
public "containsEntry$kotlin_stdlib"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "entriesIterator$kotlin_stdlib"(): $MapBuilder$EntriesItr<(K), (V)>
public "removeValue$kotlin_stdlib"(arg0: V): boolean
public "containsAllEntries$kotlin_stdlib"(arg0: $Collection$Type<(any)>): boolean
public "isReadOnly$kotlin_stdlib"(): boolean
public "checkIsMutable$kotlin_stdlib"(): void
public "addKey$kotlin_stdlib"(arg0: K): integer
public "keysIterator$kotlin_stdlib"(): $MapBuilder$KeysItr<(K), (V)>
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
get "entries"(): $Set<($Map$Entry<(K), (V)>)>
get "keys"(): $Set<(K)>
get "readOnly$kotlin_stdlib"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$Type<K, V> = ($MapBuilder<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder_<K, V> = $MapBuilder$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$DefaultUserIdentity" {
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$Subject, $Subject$Type} from "packages/javax/security/auth/$Subject"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"

export class $DefaultUserIdentity implements $UserIdentity {

constructor(arg0: $Subject$Type, arg1: $Principal$Type, arg2: (string)[])

public "toString"(): string
public "getSubject"(): $Subject
public "isUserInRole"(arg0: string, arg1: $UserIdentity$Scope$Type): boolean
public "getUserPrincipal"(): $Principal
get "subject"(): $Subject
get "userPrincipal"(): $Principal
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultUserIdentity$Type = ($DefaultUserIdentity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultUserIdentity_ = $DefaultUserIdentity$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$QuietServletException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$QuietException, $QuietException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$QuietException"
import {$ServletException, $ServletException$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletException"

export class $QuietServletException extends $ServletException implements $QuietException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuietServletException$Type = ($QuietServletException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuietServletException_ = $QuietServletException$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$ServletRequestEvent, $ServletRequestEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestEvent"

export interface $ServletRequestListener extends $EventListener {

 "requestInitialized"(arg0: $ServletRequestEvent$Type): void
 "requestDestroyed"(arg0: $ServletRequestEvent$Type): void
}

export namespace $ServletRequestListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestListener$Type = ($ServletRequestListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestListener_ = $ServletRequestListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DistinctSequence" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $DistinctSequence<T, K> implements $Sequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DistinctSequence$Type<T, K> = ($DistinctSequence<(T), (K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DistinctSequence_<T, K> = $DistinctSequence$Type<(T), (K)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$LazyKt__LazyKt" {
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"
import {$LazyKt__LazyJVMKt, $LazyKt__LazyJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$LazyKt__LazyJVMKt"

export class $LazyKt__LazyKt extends $LazyKt__LazyJVMKt {

constructor()

public static "lazyOf"<T>(arg0: T): $Lazy<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyKt__LazyKt$Type = ($LazyKt__LazyKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyKt__LazyKt_ = $LazyKt__LazyKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$FilterConfig" {
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export interface $FilterConfig {

 "getInitParameter"(arg0: string): string
 "getServletContext"(): $ServletContext
 "getFilterName"(): string
 "getInitParameterNames"(): $Enumeration<(string)>
}

export namespace $FilterConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterConfig$Type = ($FilterConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterConfig_ = $FilterConfig$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiPartInputStreamParser" {
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$File, $File$Type} from "packages/java/io/$File"
import {$MultipartConfigElement, $MultipartConfigElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$MultipartConfigElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$MultiMap, $MultiMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiMap"

export class $MultiPartInputStreamParser {
static readonly "__DEFAULT_MULTIPART_CONFIG": $MultipartConfigElement
static readonly "EMPTY_MAP": $MultiMap<($Part)>

constructor(arg0: $InputStream$Type, arg1: string, arg2: $MultipartConfigElement$Type, arg3: $File$Type)

public "deleteParts"(): void
public "setWriteFilesWithFilenames"(arg0: boolean): void
public "isWriteFilesWithFilenames"(): boolean
public "getParsedParts"(): $Collection<($Part)>
public "setDeleteOnExit"(arg0: boolean): void
public "isDeleteOnExit"(): boolean
public "getParts"(): $Collection<($Part)>
public "getPart"(arg0: string): $Part
set "writeFilesWithFilenames"(value: boolean)
get "writeFilesWithFilenames"(): boolean
get "parsedParts"(): $Collection<($Part)>
set "deleteOnExit"(value: boolean)
get "deleteOnExit"(): boolean
get "parts"(): $Collection<($Part)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiPartInputStreamParser$Type = ($MultiPartInputStreamParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiPartInputStreamParser_ = $MultiPartInputStreamParser$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$B64Code" {
import {$ByteArrayOutputStream, $ByteArrayOutputStream$Type} from "packages/java/io/$ByteArrayOutputStream"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $B64Code {


public static "decode"(arg0: string, arg1: string): string
public static "decode"(arg0: string, arg1: $Charset$Type): string
public static "decode"(arg0: (character)[]): (byte)[]
public static "decode"(arg0: string, arg1: $ByteArrayOutputStream$Type): void
public static "decode"(arg0: string): (byte)[]
public static "encode"(arg0: long, arg1: $Appendable$Type): void
public static "encode"(arg0: string, arg1: string): string
public static "encode"(arg0: integer, arg1: $Appendable$Type): void
public static "encode"(arg0: (byte)[], arg1: boolean): (character)[]
public static "encode"(arg0: (byte)[]): (character)[]
public static "encode"(arg0: string, arg1: $Charset$Type): string
public static "encode"(arg0: string): string
public static "decodeRFC4648URL"(arg0: string): (byte)[]
public static "decodeRFC4648URL"(arg0: string, arg1: $ByteArrayOutputStream$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $B64Code$Type = ($B64Code);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $B64Code_ = $B64Code$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$QueuedThreadPool" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$BlockingQueue, $BlockingQueue$Type} from "packages/java/util/concurrent/$BlockingQueue"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ThreadGroup, $ThreadGroup$Type} from "packages/java/lang/$ThreadGroup"
import {$ThreadPool$SizedThreadPool, $ThreadPool$SizedThreadPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadPool$SizedThreadPool"

export class $QueuedThreadPool extends $AbstractLifeCycle implements $ThreadPool$SizedThreadPool, $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockingQueue$Type<($Runnable$Type)>)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockingQueue$Type<($Runnable$Type)>, arg4: $ThreadGroup$Type)
constructor()
constructor(arg0: integer)
constructor(arg0: integer, arg1: integer)
constructor(arg0: integer, arg1: integer, arg2: integer)

public "getName"(): string
public "toString"(): string
public "join"(): void
public "execute"(arg0: $Runnable$Type): void
public "setDaemon"(arg0: boolean): void
public "isDaemon"(): boolean
public "getThreads"(): integer
public "setName"(arg0: string): void
public "getQueueSize"(): integer
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "getMaxThreads"(): integer
public "isLowOnThreads"(): boolean
public "getIdleThreads"(): integer
public "setIdleTimeout"(arg0: integer): void
public "getIdleTimeout"(): integer
public "interruptThread"(arg0: long): boolean
public "setLowThreadsThreshold"(arg0: integer): void
public "getLowThreadsThreshold"(): integer
public "setDetailedDump"(arg0: boolean): void
public "setMinThreads"(arg0: integer): void
public "getMinThreads"(): integer
public "setMaxThreads"(arg0: integer): void
public "isDetailedDump"(): boolean
public "getThreadsPriority"(): integer
public "getBusyThreads"(): integer
public "setThreadsPriority"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "setQueue"(arg0: $BlockingQueue$Type<($Runnable$Type)>): void
public "dumpThread"(arg0: long): string
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "name"(): string
set "daemon"(value: boolean)
get "daemon"(): boolean
get "threads"(): integer
set "name"(value: string)
get "queueSize"(): integer
get "maxThreads"(): integer
get "lowOnThreads"(): boolean
get "idleThreads"(): integer
set "idleTimeout"(value: integer)
get "idleTimeout"(): integer
set "lowThreadsThreshold"(value: integer)
get "lowThreadsThreshold"(): integer
set "detailedDump"(value: boolean)
set "minThreads"(value: integer)
get "minThreads"(): integer
set "maxThreads"(value: integer)
get "detailedDump"(): boolean
get "threadsPriority"(): integer
get "busyThreads"(): integer
set "threadsPriority"(value: integer)
set "queue"(value: $BlockingQueue$Type<($Runnable$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QueuedThreadPool$Type = ($QueuedThreadPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QueuedThreadPool_ = $QueuedThreadPool$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$Routes" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Routes {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Routes$Type = ($Routes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Routes_ = $Routes$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ProxyConnectionFactory" {
import {$AbstractConnectionFactory, $AbstractConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnectionFactory"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $ProxyConnectionFactory extends $AbstractConnectionFactory {
static readonly "TLS_VERSION": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(arg0: string)

public "newConnection"(arg0: $Connector$Type, arg1: $EndPoint$Type): $Connection
public "getMaxProxyHeader"(): integer
public "setMaxProxyHeader"(arg0: integer): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "maxProxyHeader"(): integer
set "maxProxyHeader"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProxyConnectionFactory$Type = ($ProxyConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProxyConnectionFactory_ = $ProxyConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPingPongListener" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WebSocketConnectionListener, $WebSocketConnectionListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $WebSocketPingPongListener extends $WebSocketConnectionListener {

 "onWebSocketPong"(arg0: $ByteBuffer$Type): void
 "onWebSocketPing"(arg0: $ByteBuffer$Type): void
 "onWebSocketConnect"(arg0: $Session$Type): void
 "onWebSocketClose"(arg0: integer, arg1: string): void
 "onWebSocketError"(arg0: $Throwable$Type): void
}

export namespace $WebSocketPingPongListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketPingPongListener$Type = ($WebSocketPingPongListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketPingPongListener_ = $WebSocketPingPongListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Unit" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Unit {
static readonly "INSTANCE": $Unit


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Unit$Type = ($Unit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Unit_ = $Unit$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Iso88591HttpWriter" {
import {$HttpWriter, $HttpWriter$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpWriter"
import {$HttpOutput, $HttpOutput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput"

export class $Iso88591HttpWriter extends $HttpWriter {
static readonly "MAX_OUTPUT_CHARS": integer

constructor(arg0: $HttpOutput$Type)

public "write"(arg0: (character)[], arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Iso88591HttpWriter$Type = ($Iso88591HttpWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Iso88591HttpWriter_ = $Iso88591HttpWriter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$StringUtil" {
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$List, $List$Type} from "packages/java/util/$List"

export class $StringUtil {
static readonly "ALL_INTERFACES": string
static readonly "CRLF": string
/**
 * 
 * @deprecated
 */
static readonly "__LINE_SEPARATOR": string
static readonly "__ISO_8859_1": string
static readonly "__UTF8": string
static readonly "__UTF16": string
static readonly "lowercases": (character)[]

constructor()

public static "append2digits"(arg0: $StringBuffer$Type, arg1: integer): void
public static "append2digits"(arg0: $StringBuilder$Type, arg1: integer): void
public static "getUtf8Bytes"(arg0: string): (byte)[]
public static "sidStringToBytes"(arg0: string): (byte)[]
public static "arrayFromString"(arg0: string): (string)[]
public static "toUTF8String"(arg0: (byte)[], arg1: integer, arg2: integer): string
public static "sidBytesToString"(arg0: (byte)[]): string
public static "equals"(arg0: string, arg1: (character)[], arg2: integer, arg3: integer): boolean
public static "toString"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: string): string
public static "append"(arg0: $StringBuilder$Type, arg1: string, arg2: integer, arg3: integer): void
public static "append"(arg0: $StringBuilder$Type, arg1: byte, arg2: integer): void
public static "valueOf"(arg0: any): string
public static "getBytes"(arg0: string): (byte)[]
public static "getBytes"(arg0: string, arg1: string): (byte)[]
public static "replace"(arg0: string, arg1: string, arg2: string): string
public static "isBlank"(arg0: string): boolean
public static "nonNull"(arg0: string): string
public static "isUTF8"(arg0: string): boolean
public static "truncate"(arg0: string, arg1: integer): string
public static "toLong"(arg0: string): long
public static "startsWithIgnoreCase"(arg0: string, arg1: string): boolean
public static "toInt"(arg0: string, arg1: integer): integer
public static "endsWithIgnoreCase"(arg0: string, arg1: string): boolean
public static "printable"(arg0: string): string
public static "printable"(arg0: (byte)[]): string
public static "normalizeCharset"(arg0: string): string
public static "normalizeCharset"(arg0: string, arg1: integer, arg2: integer): string
public static "csvSplit"(arg0: string): (string)[]
public static "csvSplit"(arg0: string, arg1: integer, arg2: integer): (string)[]
public static "csvSplit"(arg0: $List$Type<(string)>, arg1: string, arg2: integer, arg3: integer): $List<(string)>
/**
 * 
 * @deprecated
 */
public static "unquote"(arg0: string): string
public static "isNotBlank"(arg0: string): boolean
public static "asciiToLowerCase"(arg0: string): string
public static "sanitizeXmlString"(arg0: string): string
public static "indexFrom"(arg0: string, arg1: string): integer
public static "indexOfControlChars"(arg0: string): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUtil$Type = ($StringUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringUtil_ = $StringUtil$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysUtilJVM" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ArraysUtilJVM {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysUtilJVM$Type = ($ArraysUtilJVM);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysUtilJVM_ = $ArraysUtilJVM$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DecoratedObjectFactory" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Decorator, $Decorator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Decorator"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $DecoratedObjectFactory implements $Iterable<($Decorator)> {
static readonly "ATTR": string

constructor()

public "toString"(): string
public "clear"(): void
public "iterator"(): $Iterator<($Decorator)>
public "destroy"(arg0: any): void
public "createInstance"<T>(arg0: $Class$Type<(T)>): T
public "addDecorator"(arg0: $Decorator$Type): void
public "getDecorators"(): $List<($Decorator)>
public "setDecorators"(arg0: $List$Type<(any)>): void
public "decorate"<T>(arg0: T): T
public "spliterator"(): $Spliterator<($Decorator)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Decorator>;
get "decorators"(): $List<($Decorator)>
set "decorators"(value: $List$Type<(any)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedObjectFactory$Type = ($DecoratedObjectFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DecoratedObjectFactory_ = $DecoratedObjectFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandlerCollection" {
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HandlerCollection, $HandlerCollection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerCollection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $ContextHandlerCollection extends $HandlerCollection {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(...arg0: ($ContextHandler$Type)[])

public "setHandlers"(arg0: ($Handler$Type)[]): void
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "setContextClass"(arg0: $Class$Type<(any)>): void
public "addContext"(arg0: string, arg1: string): $ContextHandler
public "mapContexts"(): void
public "getContextClass"(): $Class<(any)>
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "handlers"(value: ($Handler$Type)[])
set "contextClass"(value: $Class$Type<(any)>)
get "contextClass"(): $Class<(any)>
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextHandlerCollection$Type = ($ContextHandlerCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextHandlerCollection_ = $ContextHandlerCollection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinVersionCurrentValue" {
import {$KotlinVersion, $KotlinVersion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinVersion"

export class $KotlinVersionCurrentValue {
static readonly "INSTANCE": $KotlinVersionCurrentValue


public static "get"(): $KotlinVersion
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinVersionCurrentValue$Type = ($KotlinVersionCurrentValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinVersionCurrentValue_ = $KotlinVersionCurrentValue$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$SpnegoAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"

export class $SpnegoAuthenticator extends $LoginAuthenticator {

constructor()
constructor(arg0: string)

public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "getAuthMethod"(): string
get "authMethod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpnegoAuthenticator$Type = ($SpnegoAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpnegoAuthenticator_ = $SpnegoAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UByte$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $UByte$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UByte$Companion$Type = ($UByte$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UByte$Companion_ = $UByte$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngMetadata" {
import {$ChunksList, $ChunksList$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksList"
import {$PngChunkTRNS, $PngChunkTRNS$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTRNS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"
import {$PngChunkPLTE, $PngChunkPLTE$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkPLTE"
import {$PngChunkTextVar, $PngChunkTextVar$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTextVar"
import {$PngChunkTIME, $PngChunkTIME$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTIME"

export class $PngMetadata {

constructor(arg0: $ChunksList$Type)

public "setTimeNow"(): $PngChunkTIME
public "setTimeNow"(arg0: integer): $PngChunkTIME
public "getDpi"(): (double)[]
public "queueChunk"(arg0: $PngChunk$Type): void
public "queueChunk"(arg0: $PngChunk$Type, arg1: boolean): void
public "setDpi"(arg0: double, arg1: double): void
public "setDpi"(arg0: double): void
public "getTimeAsString"(): string
public "getPLTE"(): $PngChunkPLTE
public "getTRNS"(): $PngChunkTRNS
public "getTxtsForKey"(arg0: string): $List<(any)>
public "getTxtForKey"(arg0: string): string
public "createPLTEChunk"(): $PngChunkPLTE
public "setTimeYMDHMS"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $PngChunkTIME
public "createTRNSChunk"(): $PngChunkTRNS
public "getTime"(): $PngChunkTIME
public "setText"(arg0: string, arg1: string, arg2: boolean, arg3: boolean): $PngChunkTextVar
public "setText"(arg0: string, arg1: string): $PngChunkTextVar
set "timeNow"(value: integer)
get "dpi"(): (double)[]
set "dpi"(value: double)
get "timeAsString"(): string
get "pLTE"(): $PngChunkPLTE
get "tRNS"(): $PngChunkTRNS
get "time"(): $PngChunkTIME
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngMetadata$Type = ($PngMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngMetadata_ = $PngMetadata$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedDoubleRange" {
import {$ClosedFloatingPointRange, $ClosedFloatingPointRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatingPointRange"

export class $ClosedDoubleRange implements $ClosedFloatingPointRange<(double)> {

constructor(arg0: double, arg1: double)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: double): boolean
public "lessThanOrEquals"(arg0: double, arg1: double): boolean
public "getStart"(): double
get "empty"(): boolean
get "start"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClosedDoubleRange$Type = ($ClosedDoubleRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClosedDoubleRange_ = $ClosedDoubleRange$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$UShortIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UShort, $UShort$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UShort"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $UShortIterator implements $Iterator<($UShort)>, $KMappedMarker {

constructor()

public "remove"(): void
public "next-Mh2AYeg"(): short
public "nextUShort-Mh2AYeg"(): short
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UShortIterator$Type = ($UShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UShortIterator_ = $UShortIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Password" {
import {$Credential, $Credential$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Credential"

export class $Password extends $Credential {
static readonly "__OBFUSCATE": string

constructor(arg0: string)

public static "main"(arg0: (string)[]): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "check"(arg0: any): boolean
public static "getPassword"(arg0: string, arg1: string, arg2: string): $Password
public "toStarString"(): string
public static "deobfuscate"(arg0: string): string
public static "obfuscate"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Password$Type = ($Password);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Password_ = $Password$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random" {
import {$Random$Default, $Random$Default$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default"

export class $Random {
static readonly "Default": $Random$Default

constructor()

public "nextDouble"(arg0: double, arg1: double): double
public "nextDouble"(): double
public "nextDouble"(arg0: double): double
public "nextInt"(arg0: integer): integer
public "nextInt"(arg0: integer, arg1: integer): integer
public "nextInt"(): integer
public "nextBytes"(arg0: (byte)[]): (byte)[]
public "nextBytes"(arg0: integer): (byte)[]
public "nextBytes"(arg0: (byte)[], arg1: integer, arg2: integer): (byte)[]
public "nextLong"(): long
public "nextLong"(arg0: long, arg1: long): long
public "nextLong"(arg0: long): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public "nextBits"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Random$Type = ($Random);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Random_ = $Random$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$NoSuchFileException" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$File, $File$Type} from "packages/java/io/$File"
import {$FileSystemException, $FileSystemException$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileSystemException"

export class $NoSuchFileException extends $FileSystemException {

constructor(arg0: $File$Type, arg1: $File$Type, arg2: string)
constructor(arg0: $File$Type, arg1: $File$Type, arg2: string, arg3: integer, arg4: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoSuchFileException$Type = ($NoSuchFileException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoSuchFileException_ = $NoSuchFileException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SecureRequestCustomizer" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"
import {$HttpConfiguration$Customizer, $HttpConfiguration$Customizer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$Customizer"

export class $SecureRequestCustomizer implements $HttpConfiguration$Customizer {
static readonly "CACHED_INFO_ATTR": string

constructor(arg0: boolean, arg1: long, arg2: boolean)
constructor(arg0: boolean)
constructor()

public "toString"(): string
public "customize"(arg0: $Connector$Type, arg1: $HttpConfiguration$Type, arg2: $Request$Type): void
public "getStsMaxAge"(): long
public "setStsMaxAge"(arg0: long): void
public "setStsMaxAge"(arg0: long, arg1: $TimeUnit$Type): void
public "isSniHostCheck"(): boolean
public "setSniHostCheck"(arg0: boolean): void
public "setStsIncludeSubDomains"(arg0: boolean): void
public "isStsIncludeSubDomains"(): boolean
public "getSslSessionAttribute"(): string
public "setSslSessionAttribute"(arg0: string): void
get "stsMaxAge"(): long
set "stsMaxAge"(value: long)
get "sniHostCheck"(): boolean
set "sniHostCheck"(value: boolean)
set "stsIncludeSubDomains"(value: boolean)
get "stsIncludeSubDomains"(): boolean
get "sslSessionAttribute"(): string
set "sslSessionAttribute"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecureRequestCustomizer$Type = ($SecureRequestCustomizer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecureRequestCustomizer_ = $SecureRequestCustomizer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketHandshake" {
import {$ServletUpgradeResponse, $ServletUpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeResponse"
import {$ServletUpgradeRequest, $ServletUpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeRequest"

export interface $WebSocketHandshake {

 "doHandshakeResponse"(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): void

(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): void
}

export namespace $WebSocketHandshake {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketHandshake$Type = ($WebSocketHandshake);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketHandshake_ = $WebSocketHandshake$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$RestrictedContinuationImpl" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$BaseContinuationImpl, $BaseContinuationImpl$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$BaseContinuationImpl"

export class $RestrictedContinuationImpl extends $BaseContinuationImpl {

constructor(arg0: $Continuation$Type<(any)>)

public "getContext"(): $CoroutineContext
get "context"(): $CoroutineContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RestrictedContinuationImpl$Type = ($RestrictedContinuationImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RestrictedContinuationImpl_ = $RestrictedContinuationImpl$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$X509Certificate, $X509Certificate$Type} from "packages/java/security/cert/$X509Certificate"
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$SSLSession, $SSLSession$Type} from "packages/javax/net/ssl/$SSLSession"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$SSLSocket, $SSLSocket$Type} from "packages/javax/net/ssl/$SSLSocket"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SSLServerSocket, $SSLServerSocket$Type} from "packages/javax/net/ssl/$SSLServerSocket"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$Password, $Password$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Password"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SSLContext, $SSLContext$Type} from "packages/javax/net/ssl/$SSLContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$X509, $X509$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$X509"
import {$SSLParameters, $SSLParameters$Type} from "packages/javax/net/ssl/$SSLParameters"
import {$KeyStore, $KeyStore$Type} from "packages/java/security/$KeyStore"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"
import {$TrustManager, $TrustManager$Type} from "packages/javax/net/ssl/$TrustManager"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $SslContextFactory extends $AbstractLifeCycle implements $Dumpable {
static readonly "TRUST_ALL_CERTS": ($TrustManager)[]
static readonly "DEFAULT_KEYMANAGERFACTORY_ALGORITHM": string
static readonly "DEFAULT_TRUSTMANAGERFACTORY_ALGORITHM": string
static readonly "KEYPASSWORD_PROPERTY": string
static readonly "PASSWORD_PROPERTY": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(arg0: string)
constructor(arg0: boolean)

public "setTrustAll"(arg0: boolean): void
public "selectProtocols"(arg0: (string)[], arg1: (string)[]): void
public "getCrlPath"(): string
public "isValidateCerts"(): boolean
public "setKeyStorePath"(arg0: string): void
public "isTrustAll"(): boolean
public "getCertAlias"(): string
public "setKeyStoreType"(arg0: string): void
public "setCertAlias"(arg0: string): void
public "setTrustStoreType"(arg0: string): void
public "setValidateCerts"(arg0: boolean): void
public "getKeyStorePath"(): string
public "setCrlPath"(arg0: string): void
public "setSslContext"(arg0: $SSLContext$Type): void
public "getTrustStoreType"(): string
public "newPassword"(arg0: string): $Password
public "setTrustStorePath"(arg0: string): void
public "newSslServerSocket"(arg0: string, arg1: integer, arg2: integer): $SSLServerSocket
public "newSslSocket"(): $SSLSocket
public "setKeyStore"(arg0: $KeyStore$Type): void
public "setTrustStore"(arg0: $KeyStore$Type): void
public "toString"(): string
public "customize"(arg0: $SSLEngine$Type): void
public "customize"(arg0: $SSLParameters$Type): $SSLParameters
public "getProtocol"(): string
public "getProvider"(): string
public "reload"(arg0: $Consumer$Type<($SslContextFactory$Type)>): void
public "getAliases"(): $Set<(string)>
public "setEndpointIdentificationAlgorithm"(arg0: string): void
public "setNeedClientAuth"(arg0: boolean): void
public "getNeedClientAuth"(): boolean
public "setWantClientAuth"(arg0: boolean): void
public "getWantClientAuth"(): boolean
public "getKeyStore"(): $KeyStore
public "getKeyStoreType"(): string
public "newSSLEngine"(arg0: $InetSocketAddress$Type): $SSLEngine
public "newSSLEngine"(arg0: string, arg1: integer): $SSLEngine
public "newSSLEngine"(): $SSLEngine
public "getKeyManagerFactoryAlgorithm"(): string
public "setProtocol"(arg0: string): void
public "getSslContext"(): $SSLContext
public "getTrustManagerFactoryAlgorithm"(): string
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "getEndpointIdentificationAlgorithm"(): string
public static "getCertChain"(arg0: $SSLSession$Type): ($X509Certificate)[]
public static "deduceKeyLength"(arg0: string): integer
public "setProvider"(arg0: string): void
public "setOcspResponderURL"(arg0: string): void
public "getMaxCertPathLength"(): integer
public "getOcspResponderURL"(): string
public "setMaxCertPathLength"(arg0: integer): void
public "setUseCipherSuitesOrder"(arg0: boolean): void
public "getX509"(arg0: string): $X509
public "isRenegotiationAllowed"(): boolean
public "setRenegotiationLimit"(arg0: integer): void
public "setRenegotiationAllowed"(arg0: boolean): void
public "getRenegotiationLimit"(): integer
public "getSelectedCipherSuites"(): (string)[]
public "addExcludeProtocols"(...arg0: (string)[]): void
public "setExcludeCipherSuites"(...arg0: (string)[]): void
public "getSslSessionCacheSize"(): integer
public "getExcludeProtocols"(): (string)[]
public "getIncludeProtocols"(): (string)[]
public "getExcludeCipherSuites"(): (string)[]
public "getIncludeCipherSuites"(): (string)[]
public "getSelectedProtocols"(): (string)[]
public "getCipherComparator"(): $Comparator<(string)>
public "getSslSessionTimeout"(): integer
public "setCipherComparator"(arg0: $Comparator$Type<(string)>): void
public "setExcludeProtocols"(...arg0: (string)[]): void
public "setIncludeProtocols"(...arg0: (string)[]): void
public "addExcludeCipherSuites"(...arg0: (string)[]): void
public "getSecureRandomAlgorithm"(): string
public "setTrustStoreProvider"(arg0: string): void
public "isSessionCachingEnabled"(): boolean
public "setKeyStoreProvider"(arg0: string): void
public "setTrustStorePassword"(arg0: string): void
public "setIncludeCipherSuites"(...arg0: (string)[]): void
public "getKeyStoreProvider"(): string
public "setTrustManagerFactoryAlgorithm"(arg0: string): void
public "setTrustStoreResource"(arg0: $Resource$Type): void
public "isUseCipherSuitesOrder"(): boolean
public "setSslSessionTimeout"(arg0: integer): void
public "setSessionCachingEnabled"(arg0: boolean): void
public "setKeyStorePassword"(arg0: string): void
public "setKeyStoreResource"(arg0: $Resource$Type): void
public "setKeyManagerFactoryAlgorithm"(arg0: string): void
public "isValidatePeerCerts"(): boolean
public "setSecureRandomAlgorithm"(arg0: string): void
public "setSslSessionCacheSize"(arg0: integer): void
public "setKeyManagerPassword"(arg0: string): void
public "setValidatePeerCerts"(arg0: boolean): void
public "getTrustStoreResource"(): $Resource
public "getTrustStoreProvider"(): string
public "getKeyStoreResource"(): $Resource
public "isEnableCRLDP"(): boolean
public "setEnableCRLDP"(arg0: boolean): void
public "getTrustStore"(): $KeyStore
public "isEnableOCSP"(): boolean
public "setEnableOCSP"(arg0: boolean): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
set "trustAll"(value: boolean)
get "crlPath"(): string
get "validateCerts"(): boolean
set "keyStorePath"(value: string)
get "trustAll"(): boolean
get "certAlias"(): string
set "keyStoreType"(value: string)
set "certAlias"(value: string)
set "trustStoreType"(value: string)
set "validateCerts"(value: boolean)
get "keyStorePath"(): string
set "crlPath"(value: string)
set "sslContext"(value: $SSLContext$Type)
get "trustStoreType"(): string
set "trustStorePath"(value: string)
set "keyStore"(value: $KeyStore$Type)
set "trustStore"(value: $KeyStore$Type)
get "protocol"(): string
get "provider"(): string
get "aliases"(): $Set<(string)>
set "endpointIdentificationAlgorithm"(value: string)
set "needClientAuth"(value: boolean)
get "needClientAuth"(): boolean
set "wantClientAuth"(value: boolean)
get "wantClientAuth"(): boolean
get "keyStore"(): $KeyStore
get "keyStoreType"(): string
get "keyManagerFactoryAlgorithm"(): string
set "protocol"(value: string)
get "sslContext"(): $SSLContext
get "trustManagerFactoryAlgorithm"(): string
get "endpointIdentificationAlgorithm"(): string
set "provider"(value: string)
set "ocspResponderURL"(value: string)
get "maxCertPathLength"(): integer
get "ocspResponderURL"(): string
set "maxCertPathLength"(value: integer)
set "useCipherSuitesOrder"(value: boolean)
get "renegotiationAllowed"(): boolean
set "renegotiationLimit"(value: integer)
set "renegotiationAllowed"(value: boolean)
get "renegotiationLimit"(): integer
get "selectedCipherSuites"(): (string)[]
set "excludeCipherSuites"(value: (string)[])
get "sslSessionCacheSize"(): integer
get "excludeProtocols"(): (string)[]
get "includeProtocols"(): (string)[]
get "excludeCipherSuites"(): (string)[]
get "includeCipherSuites"(): (string)[]
get "selectedProtocols"(): (string)[]
get "cipherComparator"(): $Comparator<(string)>
get "sslSessionTimeout"(): integer
set "cipherComparator"(value: $Comparator$Type<(string)>)
set "excludeProtocols"(value: (string)[])
set "includeProtocols"(value: (string)[])
get "secureRandomAlgorithm"(): string
set "trustStoreProvider"(value: string)
get "sessionCachingEnabled"(): boolean
set "keyStoreProvider"(value: string)
set "trustStorePassword"(value: string)
set "includeCipherSuites"(value: (string)[])
get "keyStoreProvider"(): string
set "trustManagerFactoryAlgorithm"(value: string)
set "trustStoreResource"(value: $Resource$Type)
get "useCipherSuitesOrder"(): boolean
set "sslSessionTimeout"(value: integer)
set "sessionCachingEnabled"(value: boolean)
set "keyStorePassword"(value: string)
set "keyStoreResource"(value: $Resource$Type)
set "keyManagerFactoryAlgorithm"(value: string)
get "validatePeerCerts"(): boolean
set "secureRandomAlgorithm"(value: string)
set "sslSessionCacheSize"(value: integer)
set "keyManagerPassword"(value: string)
set "validatePeerCerts"(value: boolean)
get "trustStoreResource"(): $Resource
get "trustStoreProvider"(): string
get "keyStoreResource"(): $Resource
get "enableCRLDP"(): boolean
set "enableCRLDP"(value: boolean)
get "trustStore"(): $KeyStore
get "enableOCSP"(): boolean
set "enableOCSP"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslContextFactory$Type = ($SslContextFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslContextFactory_ = $SslContextFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$HttpConstraint" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$ServletSecurity$TransportGuarantee, $ServletSecurity$TransportGuarantee$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$TransportGuarantee"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletSecurity$EmptyRoleSemantic, $ServletSecurity$EmptyRoleSemantic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$EmptyRoleSemantic"

export interface $HttpConstraint extends $Annotation {

 "rolesAllowed"(): (string)[]
 "transportGuarantee"(): $ServletSecurity$TransportGuarantee
 "value"(): $ServletSecurity$EmptyRoleSemantic
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $HttpConstraint {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConstraint$Type = ($HttpConstraint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConstraint_ = $HttpConstraint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Session" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"

export class $Session {


public "lastAccessedTime"(): long
public "id"(): string
public "raw"(): $HttpSession
public "attributes"(): $Set<(string)>
public "attribute"<T>(arg0: string): T
public "attribute"(arg0: string, arg1: any): void
public "creationTime"(): long
public "invalidate"(): void
public "isNew"(): boolean
public "removeAttribute"(arg0: string): void
public "maxInactiveInterval"(arg0: integer): void
public "maxInactiveInterval"(): integer
get "new"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Session$Type = ($Session);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Session_ = $Session$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$FlatteningSequence" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $FlatteningSequence<T, R, E> implements $Sequence<(E)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>)

public "iterator"(): $Iterator<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlatteningSequence$Type<T, R, E> = ($FlatteningSequence<(T), (R), (E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlatteningSequence_<T, R, E> = $FlatteningSequence$Type<(T), (R), (E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$FrameFlusher" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$BinaryFrame, $BinaryFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$BinaryFrame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Generator, $Generator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Generator"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $FrameFlusher {
static readonly "FLUSH_FRAME": $BinaryFrame

constructor(arg0: $ByteBufferPool$Type, arg1: $Generator$Type, arg2: $EndPoint$Type, arg3: integer, arg4: integer)

public "toString"(): string
public "enqueue"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrameFlusher$Type = ($FrameFlusher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrameFlusher_ = $FrameFlusher$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpWriter" {
import {$HttpOutput, $HttpOutput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput"
import {$Writer, $Writer$Type} from "packages/java/io/$Writer"

export class $HttpWriter extends $Writer {
static readonly "MAX_OUTPUT_CHARS": integer

constructor(arg0: $HttpOutput$Type)

public "flush"(): void
public "write"(arg0: string, arg1: integer, arg2: integer): void
public "write"(arg0: (character)[], arg1: integer, arg2: integer): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpWriter$Type = ($HttpWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpWriter_ = $HttpWriter$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UninitializedPropertyAccessException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $UninitializedPropertyAccessException extends $RuntimeException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UninitializedPropertyAccessException$Type = ($UninitializedPropertyAccessException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UninitializedPropertyAccessException_ = $UninitializedPropertyAccessException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinNullPointerException" {
import {$NullPointerException, $NullPointerException$Type} from "packages/java/lang/$NullPointerException"

export class $KotlinNullPointerException extends $NullPointerException {

constructor()
constructor(arg0: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinNullPointerException$Type = ($KotlinNullPointerException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinNullPointerException_ = $KotlinNullPointerException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ResponseTransformer {

 "render"(arg0: any): string

(arg0: any): string
}

export namespace $ResponseTransformer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResponseTransformer$Type = ($ResponseTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResponseTransformer_ = $ResponseTransformer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$StdErrLog" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Properties, $Properties$Type} from "packages/java/util/$Properties"
import {$AbstractLogger, $AbstractLogger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$AbstractLogger"
import {$PrintStream, $PrintStream$Type} from "packages/java/io/$PrintStream"

export class $StdErrLog extends $AbstractLogger {
static readonly "LEVEL_DEFAULT": integer
static readonly "LEVEL_ALL": integer
static readonly "LEVEL_DEBUG": integer
static readonly "LEVEL_INFO": integer
static readonly "LEVEL_WARN": integer
static readonly "LEVEL_OFF": integer

constructor()
constructor(arg0: string)
constructor(arg0: string, arg1: $Properties$Type)

public "getName"(): string
public "toString"(): string
public "info"(arg0: $Throwable$Type): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "info"(arg0: string, ...arg1: (any)[]): void
public static "getLogger"(arg0: $Class$Type<(any)>): $StdErrLog
public "debug"(arg0: $Throwable$Type): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "debug"(arg0: string, arg1: long): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "ignore"(arg0: $Throwable$Type): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "warn"(arg0: $Throwable$Type): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "getLevel"(): integer
public "setLevel"(arg0: integer): void
public "isDebugEnabled"(): boolean
public "setSource"(arg0: boolean): void
public "setDebugEnabled"(arg0: boolean): void
public static "getLoggingLevel"(arg0: $Properties$Type, arg1: string): integer
public "isSource"(): boolean
public static "setTagPad"(arg0: integer): void
public "setPrintLongNames"(arg0: boolean): void
public "isPrintLongNames"(): boolean
public "setHideStacks"(arg0: boolean): void
public "isHideStacks"(): boolean
public "setStdErrStream"(arg0: $PrintStream$Type): void
get "name"(): string
get "level"(): integer
set "level"(value: integer)
get "debugEnabled"(): boolean
set "source"(value: boolean)
set "debugEnabled"(value: boolean)
get "source"(): boolean
set "tagPad"(value: integer)
set "printLongNames"(value: boolean)
get "printLongNames"(): boolean
set "hideStacks"(value: boolean)
get "hideStacks"(): boolean
set "stdErrStream"(value: $PrintStream$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StdErrLog$Type = ($StdErrLog);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StdErrLog_ = $StdErrLog$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$OptionalSessionCallableMethod" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"
import {$CallableMethod, $CallableMethod$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$CallableMethod"

export class $OptionalSessionCallableMethod extends $CallableMethod {

constructor(arg0: $Class$Type<(any)>, arg1: $Method$Type)

public "toString"(): string
public "call"(arg0: any, arg1: $Session$Type, ...arg2: (any)[]): void
public "isStreaming"(): boolean
public "isSessionAware"(): boolean
get "streaming"(): boolean
get "sessionAware"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OptionalSessionCallableMethod$Type = ($OptionalSessionCallableMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OptionalSessionCallableMethod_ = $OptionalSessionCallableMethod$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Result$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $Result$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Result$Companion$Type = ($Result$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Result$Companion_ = $Result$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"

export interface $LifeCycle$Listener extends $EventListener {

 "lifeCycleStopping"(arg0: $LifeCycle$Type): void
 "lifeCycleFailure"(arg0: $LifeCycle$Type, arg1: $Throwable$Type): void
 "lifeCycleStarting"(arg0: $LifeCycle$Type): void
 "lifeCycleStarted"(arg0: $LifeCycle$Type): void
 "lifeCycleStopped"(arg0: $LifeCycle$Type): void
}

export namespace $LifeCycle$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LifeCycle$Listener$Type = ($LifeCycle$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LifeCycle$Listener_ = $LifeCycle$Listener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$DataFrame" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WebSocketFrame, $WebSocketFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketFrame"

export class $DataFrame extends $WebSocketFrame {

constructor(arg0: $Frame$Type, arg1: boolean)
constructor(arg0: $Frame$Type)

public "assertValid"(): void
public "isControlFrame"(): boolean
public "setIsContinuation"(): void
public "isDataFrame"(): boolean
get "controlFrame"(): boolean
get "dataFrame"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataFrame$Type = ($DataFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataFrame_ = $DataFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexingIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"

export class $IndexingIterator<T> implements $Iterator<($IndexedValue<(any)>)>, $KMappedMarker {

constructor(arg0: $Iterator$Type<(any)>)

public "remove"(): void
public "hasNext"(): boolean
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexingIterator$Type<T> = ($IndexingIterator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexingIterator_<T> = $IndexingIterator$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference2" {
import {$KProperty2, $KProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$PropertyReference, $PropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference"

export class $PropertyReference2 extends $PropertyReference implements $KProperty2<(any), (any), (any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: $Class$Type<(any)>, arg1: string, arg2: string, arg3: integer)

public "invoke"(arg0: any, arg1: any): any
public "getDelegate"(arg0: any, arg1: any): any
public "get"(arg0: any, arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyReference2$Type = ($PropertyReference2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyReference2_ = $PropertyReference2$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference0" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KProperty0, $KProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0"
import {$PropertyReference, $PropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference"

export class $PropertyReference0 extends $PropertyReference implements $KProperty0<(any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: any)

public "invoke"(): any
public "getDelegate"(): any
public "get"(): any
get "delegate"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyReference0$Type = ($PropertyReference0);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyReference0_ = $PropertyReference0$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference1" {
import {$KProperty1, $KProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$PropertyReference, $PropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference"

export class $PropertyReference1 extends $PropertyReference implements $KProperty1<(any), (any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: any)

public "invoke"(arg0: any): any
public "getDelegate"(arg0: any): any
public "get"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyReference1$Type = ($PropertyReference1);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyReference1_ = $PropertyReference1$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$MustBeDocumented" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $MustBeDocumented extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $MustBeDocumented {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MustBeDocumented$Type = ($MustBeDocumented);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MustBeDocumented_ = $MustBeDocumented$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringBuilderJVMKt" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$StringsKt__RegexExtensionsKt, $StringsKt__RegexExtensionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__RegexExtensionsKt"

export class $StringsKt__StringBuilderJVMKt extends $StringsKt__RegexExtensionsKt {

constructor()

public static "clear"(arg0: $StringBuilder$Type): $StringBuilder
public static "appendln"(arg0: $Appendable$Type): $Appendable
public static "appendln"(arg0: $StringBuilder$Type): $StringBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringBuilderJVMKt$Type = ($StringsKt__StringBuilderJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringBuilderJVMKt_ = $StringsKt__StringBuilderJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgression$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$ULongProgression, $ULongProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgression"

export class $ULongProgression$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "fromClosedRange-7ftBX0g"(arg0: long, arg1: long, arg2: long): $ULongProgression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongProgression$Companion$Type = ($ULongProgression$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongProgression$Companion_ = $ULongProgression$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayIteratorKt" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ArrayIteratorKt {


public static "iterator"<T>(arg0: (T)[]): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayIteratorKt$Type = ($ArrayIteratorKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayIteratorKt_ = $ArrayIteratorKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator$Result" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpGenerator$Result extends $Enum<($HttpGenerator$Result)> {
static readonly "NEED_CHUNK": $HttpGenerator$Result
static readonly "NEED_INFO": $HttpGenerator$Result
static readonly "NEED_HEADER": $HttpGenerator$Result
static readonly "NEED_CHUNK_TRAILER": $HttpGenerator$Result
static readonly "FLUSH": $HttpGenerator$Result
static readonly "CONTINUE": $HttpGenerator$Result
static readonly "SHUTDOWN_OUT": $HttpGenerator$Result
static readonly "DONE": $HttpGenerator$Result


public static "values"(): ($HttpGenerator$Result)[]
public static "valueOf"(arg0: string): $HttpGenerator$Result
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpGenerator$Result$Type = (("need_chunk") | ("need_info") | ("need_chunk_trailer") | ("flush") | ("continue") | ("shutdown_out") | ("done") | ("need_header")) | ($HttpGenerator$Result);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpGenerator$Result_ = $HttpGenerator$Result$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SessionData implements $Serializable {

constructor(arg0: string, arg1: string, arg2: string, arg3: long, arg4: long, arg5: long, arg6: long)
constructor(arg0: string, arg1: string, arg2: string, arg3: long, arg4: long, arg5: long, arg6: long, arg7: $Map$Type<(string), (any)>)

public "toString"(): string
public "getId"(): string
public "copy"(arg0: $SessionData$Type): void
public "setAttribute"(arg0: string, arg1: any): any
public "getAttribute"(arg0: string): any
public "isDirty"(): boolean
public "getKeys"(): $Set<(string)>
public "setDirty"(arg0: boolean): void
public "setDirty"(arg0: string): void
public "setContextPath"(arg0: string): void
public "getContextPath"(): string
public "setId"(arg0: string): void
public "getExpiry"(): long
public "setLastNode"(arg0: string): void
public "getCreated"(): long
public "setCreated"(arg0: long): void
public "setLastAccessed"(arg0: long): void
public "calcAndSetExpiry"(): void
public "calcAndSetExpiry"(arg0: long): void
public "setVhost"(arg0: string): void
public "setCookieSet"(arg0: long): void
public "getLastAccessed"(): long
public "getMaxInactiveMs"(): long
public "getCookieSet"(): long
public "getLastNode"(): string
public "getVhost"(): string
public "getAccessed"(): long
public "setAccessed"(arg0: long): void
public "setMaxInactiveMs"(arg0: long): void
public "isExpiredAt"(arg0: long): boolean
public "calcExpiry"(arg0: long): long
public "calcExpiry"(): long
public "setExpiry"(arg0: long): void
public "setLastSaved"(arg0: long): void
public "putAllAttributes"(arg0: $Map$Type<(string), (any)>): void
public "getLastSaved"(): long
public "clearAllAttributes"(): void
public "getAllAttributes"(): $Map<(string), (any)>
get "id"(): string
get "dirty"(): boolean
get "keys"(): $Set<(string)>
set "dirty"(value: boolean)
set "dirty"(value: string)
set "contextPath"(value: string)
get "contextPath"(): string
set "id"(value: string)
get "expiry"(): long
set "lastNode"(value: string)
get "created"(): long
set "created"(value: long)
set "lastAccessed"(value: long)
set "vhost"(value: string)
set "cookieSet"(value: long)
get "lastAccessed"(): long
get "maxInactiveMs"(): long
get "cookieSet"(): long
get "lastNode"(): string
get "vhost"(): string
get "accessed"(): long
set "accessed"(value: long)
set "maxInactiveMs"(value: long)
set "expiry"(value: long)
set "lastSaved"(value: long)
get "lastSaved"(): long
get "allAttributes"(): $Map<(string), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionData$Type = ($SessionData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionData_ = $SessionData$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/route/$RouteEntry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RouteEntry {


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteEntry$Type = ($RouteEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteEntry_ = $RouteEntry$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Access" {
import {$RouteMatch, $RouteMatch$Type} from "packages/info/journeymap/shaded/kotlin/spark/routematch/$RouteMatch"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"

export class $Access {


public static "changeMatch"(arg0: $Request$Type, arg1: $RouteMatch$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Access$Type = ($Access);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Access_ = $Access$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$DumpableCollection" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"

export class $DumpableCollection implements $Dumpable {

constructor(arg0: string, arg1: $Collection$Type<(any)>)

public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DumpableCollection$Type = ($DumpableCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DumpableCollection_ = $DumpableCollection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$KAnnotatedElement, $KAnnotatedElement$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KAnnotatedElement"

export interface $KCallable<R> extends $KAnnotatedElement {

 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): R
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): R
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KCallable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KCallable$Type<R> = ($KCallable<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KCallable_<R> = $KCallable$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpStatus" {
import {$HttpStatus$Code, $HttpStatus$Code$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpStatus$Code"

export class $HttpStatus {
static readonly "CONTINUE_100": integer
static readonly "SWITCHING_PROTOCOLS_101": integer
static readonly "PROCESSING_102": integer
static readonly "OK_200": integer
static readonly "CREATED_201": integer
static readonly "ACCEPTED_202": integer
static readonly "NON_AUTHORITATIVE_INFORMATION_203": integer
static readonly "NO_CONTENT_204": integer
static readonly "RESET_CONTENT_205": integer
static readonly "PARTIAL_CONTENT_206": integer
static readonly "MULTI_STATUS_207": integer
static readonly "MULTIPLE_CHOICES_300": integer
static readonly "MOVED_PERMANENTLY_301": integer
static readonly "MOVED_TEMPORARILY_302": integer
static readonly "FOUND_302": integer
static readonly "SEE_OTHER_303": integer
static readonly "NOT_MODIFIED_304": integer
static readonly "USE_PROXY_305": integer
static readonly "TEMPORARY_REDIRECT_307": integer
static readonly "PERMANENT_REDIRECT_308": integer
static readonly "BAD_REQUEST_400": integer
static readonly "UNAUTHORIZED_401": integer
static readonly "PAYMENT_REQUIRED_402": integer
static readonly "FORBIDDEN_403": integer
static readonly "NOT_FOUND_404": integer
static readonly "METHOD_NOT_ALLOWED_405": integer
static readonly "NOT_ACCEPTABLE_406": integer
static readonly "PROXY_AUTHENTICATION_REQUIRED_407": integer
static readonly "REQUEST_TIMEOUT_408": integer
static readonly "CONFLICT_409": integer
static readonly "GONE_410": integer
static readonly "LENGTH_REQUIRED_411": integer
static readonly "PRECONDITION_FAILED_412": integer
/**
 * 
 * @deprecated
 */
static readonly "REQUEST_ENTITY_TOO_LARGE_413": integer
static readonly "PAYLOAD_TOO_LARGE_413": integer
/**
 * 
 * @deprecated
 */
static readonly "REQUEST_URI_TOO_LONG_414": integer
static readonly "URI_TOO_LONG_414": integer
static readonly "UNSUPPORTED_MEDIA_TYPE_415": integer
/**
 * 
 * @deprecated
 */
static readonly "REQUESTED_RANGE_NOT_SATISFIABLE_416": integer
static readonly "RANGE_NOT_SATISFIABLE_416": integer
static readonly "EXPECTATION_FAILED_417": integer
static readonly "IM_A_TEAPOT_418": integer
static readonly "ENHANCE_YOUR_CALM_420": integer
static readonly "MISDIRECTED_REQUEST_421": integer
static readonly "UNPROCESSABLE_ENTITY_422": integer
static readonly "LOCKED_423": integer
static readonly "FAILED_DEPENDENCY_424": integer
static readonly "UPGRADE_REQUIRED_426": integer
static readonly "PRECONDITION_REQUIRED_428": integer
static readonly "TOO_MANY_REQUESTS_429": integer
static readonly "REQUEST_HEADER_FIELDS_TOO_LARGE_431": integer
static readonly "UNAVAILABLE_FOR_LEGAL_REASONS_451": integer
static readonly "INTERNAL_SERVER_ERROR_500": integer
static readonly "NOT_IMPLEMENTED_501": integer
static readonly "BAD_GATEWAY_502": integer
static readonly "SERVICE_UNAVAILABLE_503": integer
static readonly "GATEWAY_TIMEOUT_504": integer
static readonly "HTTP_VERSION_NOT_SUPPORTED_505": integer
static readonly "INSUFFICIENT_STORAGE_507": integer
static readonly "LOOP_DETECTED_508": integer
static readonly "NOT_EXTENDED_510": integer
static readonly "NETWORK_AUTHENTICATION_REQUIRED_511": integer
static readonly "MAX_CODE": integer

constructor()

public static "getMessage"(arg0: integer): string
public static "isSuccess"(arg0: integer): boolean
public static "isRedirection"(arg0: integer): boolean
public static "isClientError"(arg0: integer): boolean
public static "isServerError"(arg0: integer): boolean
public static "getCode"(arg0: integer): $HttpStatus$Code
public static "isInformational"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpStatus$Type = ($HttpStatus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpStatus_ = $HttpStatus$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$CallableReference" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CallableReference implements $KCallable<(any)>, $Serializable {
static readonly "NO_RECEIVER": any

constructor()

public "getName"(): string
public "getTypeParameters"(): $List<($KTypeParameter)>
public "getReturnType"(): $KType
public "isOpen"(): boolean
public "getAnnotations"(): $List<($Annotation)>
public "compute"(): $KCallable<(any)>
public "getParameters"(): $List<($KParameter)>
public "getSignature"(): string
public "isFinal"(): boolean
public "isAbstract"(): boolean
public "getOwner"(): $KDeclarationContainer
public "call"(...arg0: (any)[]): any
public "callBy"(arg0: $Map$Type<(any), (any)>): any
public "getBoundReceiver"(): any
public "isSuspend"(): boolean
public "getVisibility"(): $KVisibility
get "name"(): string
get "typeParameters"(): $List<($KTypeParameter)>
get "returnType"(): $KType
get "open"(): boolean
get "annotations"(): $List<($Annotation)>
get "parameters"(): $List<($KParameter)>
get "signature"(): string
get "final"(): boolean
get "abstract"(): boolean
get "owner"(): $KDeclarationContainer
get "boundReceiver"(): any
get "suspend"(): boolean
get "visibility"(): $KVisibility
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CallableReference$Type = ($CallableReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CallableReference_ = $CallableReference$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"

export class $HttpHeader extends $Enum<($HttpHeader)> {
static readonly "CONNECTION": $HttpHeader
static readonly "CACHE_CONTROL": $HttpHeader
static readonly "DATE": $HttpHeader
static readonly "PRAGMA": $HttpHeader
static readonly "PROXY_CONNECTION": $HttpHeader
static readonly "TRAILER": $HttpHeader
static readonly "TRANSFER_ENCODING": $HttpHeader
static readonly "UPGRADE": $HttpHeader
static readonly "VIA": $HttpHeader
static readonly "WARNING": $HttpHeader
static readonly "NEGOTIATE": $HttpHeader
static readonly "ALLOW": $HttpHeader
static readonly "CONTENT_ENCODING": $HttpHeader
static readonly "CONTENT_LANGUAGE": $HttpHeader
static readonly "CONTENT_LENGTH": $HttpHeader
static readonly "CONTENT_LOCATION": $HttpHeader
static readonly "CONTENT_MD5": $HttpHeader
static readonly "CONTENT_RANGE": $HttpHeader
static readonly "CONTENT_TYPE": $HttpHeader
static readonly "EXPIRES": $HttpHeader
static readonly "LAST_MODIFIED": $HttpHeader
static readonly "ACCEPT": $HttpHeader
static readonly "ACCEPT_CHARSET": $HttpHeader
static readonly "ACCEPT_ENCODING": $HttpHeader
static readonly "ACCEPT_LANGUAGE": $HttpHeader
static readonly "AUTHORIZATION": $HttpHeader
static readonly "EXPECT": $HttpHeader
static readonly "FORWARDED": $HttpHeader
static readonly "FROM": $HttpHeader
static readonly "HOST": $HttpHeader
static readonly "IF_MATCH": $HttpHeader
static readonly "IF_MODIFIED_SINCE": $HttpHeader
static readonly "IF_NONE_MATCH": $HttpHeader
static readonly "IF_RANGE": $HttpHeader
static readonly "IF_UNMODIFIED_SINCE": $HttpHeader
static readonly "KEEP_ALIVE": $HttpHeader
static readonly "MAX_FORWARDS": $HttpHeader
static readonly "PROXY_AUTHORIZATION": $HttpHeader
static readonly "RANGE": $HttpHeader
static readonly "REQUEST_RANGE": $HttpHeader
static readonly "REFERER": $HttpHeader
static readonly "TE": $HttpHeader
static readonly "USER_AGENT": $HttpHeader
static readonly "X_FORWARDED_FOR": $HttpHeader
static readonly "X_FORWARDED_PROTO": $HttpHeader
static readonly "X_FORWARDED_SERVER": $HttpHeader
static readonly "X_FORWARDED_HOST": $HttpHeader
static readonly "ACCEPT_RANGES": $HttpHeader
static readonly "AGE": $HttpHeader
static readonly "ETAG": $HttpHeader
static readonly "LOCATION": $HttpHeader
static readonly "PROXY_AUTHENTICATE": $HttpHeader
static readonly "RETRY_AFTER": $HttpHeader
static readonly "SERVER": $HttpHeader
static readonly "SERVLET_ENGINE": $HttpHeader
static readonly "VARY": $HttpHeader
static readonly "WWW_AUTHENTICATE": $HttpHeader
static readonly "ORIGIN": $HttpHeader
static readonly "SEC_WEBSOCKET_KEY": $HttpHeader
static readonly "SEC_WEBSOCKET_VERSION": $HttpHeader
static readonly "SEC_WEBSOCKET_EXTENSIONS": $HttpHeader
static readonly "SEC_WEBSOCKET_SUBPROTOCOL": $HttpHeader
static readonly "SEC_WEBSOCKET_ACCEPT": $HttpHeader
static readonly "COOKIE": $HttpHeader
static readonly "SET_COOKIE": $HttpHeader
static readonly "SET_COOKIE2": $HttpHeader
static readonly "MIME_VERSION": $HttpHeader
static readonly "IDENTITY": $HttpHeader
static readonly "X_POWERED_BY": $HttpHeader
static readonly "HTTP2_SETTINGS": $HttpHeader
static readonly "STRICT_TRANSPORT_SECURITY": $HttpHeader
static readonly "C_METHOD": $HttpHeader
static readonly "C_SCHEME": $HttpHeader
static readonly "C_AUTHORITY": $HttpHeader
static readonly "C_PATH": $HttpHeader
static readonly "C_STATUS": $HttpHeader
static readonly "UNKNOWN": $HttpHeader
static readonly "CACHE": $Trie<($HttpHeader)>


public "getBytesColonSpace"(): (byte)[]
public "toString"(): string
public static "values"(): ($HttpHeader)[]
public static "valueOf"(arg0: string): $HttpHeader
public "getBytes"(): (byte)[]
public "is"(arg0: string): boolean
public "asString"(): string
public "toBuffer"(): $ByteBuffer
get "bytesColonSpace"(): (byte)[]
get "bytes"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpHeader$Type = (("date") | ("x_powered_by") | ("referer") | ("vary") | ("x_forwarded_host") | ("retry_after") | ("via") | ("authorization") | ("content_range") | ("sec_websocket_key") | ("accept_language") | ("host") | ("servlet_engine") | ("warning") | ("connection") | ("from") | ("proxy_authenticate") | ("c_status") | ("last_modified") | ("proxy_authorization") | ("sec_websocket_subprotocol") | ("content_length") | ("if_none_match") | ("negotiate") | ("sec_websocket_version") | ("upgrade") | ("cookie") | ("max_forwards") | ("strict_transport_security") | ("cache_control") | ("pragma") | ("forwarded") | ("accept") | ("x_forwarded_for") | ("x_forwarded_server") | ("content_location") | ("etag") | ("if_range") | ("allow") | ("server") | ("c_authority") | ("expires") | ("if_match") | ("if_modified_since") | ("origin") | ("accept_encoding") | ("range") | ("content_language") | ("unknown") | ("trailer") | ("accept_ranges") | ("content_type") | ("set_cookie") | ("if_unmodified_since") | ("identity") | ("x_forwarded_proto") | ("user_agent") | ("http2_settings") | ("c_path") | ("sec_websocket_extensions") | ("c_scheme") | ("sec_websocket_accept") | ("content_encoding") | ("www_authenticate") | ("content_md5") | ("request_range") | ("expect") | ("te") | ("transfer_encoding") | ("accept_charset") | ("mime_version") | ("c_method") | ("set_cookie2") | ("proxy_connection") | ("location") | ("keep_alive") | ("age")) | ($HttpHeader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpHeader_ = $HttpHeader$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$AnnotationTarget" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AnnotationTarget extends $Enum<($AnnotationTarget)> {
static readonly "CLASS": $AnnotationTarget
static readonly "ANNOTATION_CLASS": $AnnotationTarget
static readonly "TYPE_PARAMETER": $AnnotationTarget
static readonly "PROPERTY": $AnnotationTarget
static readonly "FIELD": $AnnotationTarget
static readonly "LOCAL_VARIABLE": $AnnotationTarget
static readonly "VALUE_PARAMETER": $AnnotationTarget
static readonly "CONSTRUCTOR": $AnnotationTarget
static readonly "FUNCTION": $AnnotationTarget
static readonly "PROPERTY_GETTER": $AnnotationTarget
static readonly "PROPERTY_SETTER": $AnnotationTarget
static readonly "TYPE": $AnnotationTarget
static readonly "EXPRESSION": $AnnotationTarget
static readonly "FILE": $AnnotationTarget
static readonly "TYPEALIAS": $AnnotationTarget


public static "values"(): ($AnnotationTarget)[]
public static "valueOf"(arg0: string): $AnnotationTarget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnnotationTarget$Type = (("expression") | ("value_parameter") | ("constructor") | ("type") | ("local_variable") | ("annotation_class") | ("file") | ("field") | ("property_setter") | ("function") | ("property_getter") | ("property") | ("type_parameter") | ("typealias") | ("class")) | ($AnnotationTarget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnnotationTarget_ = $AnnotationTarget$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$DoubleIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $DoubleIterator implements $Iterator<(double)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextDouble"(): double
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterator$Type = ($DoubleIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterator_ = $DoubleIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayIteratorsKt" {
import {$LongIterator, $LongIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$LongIterator"
import {$FloatIterator, $FloatIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$FloatIterator"
import {$ByteIterator, $ByteIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ByteIterator"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$DoubleIterator"
import {$IntIterator, $IntIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IntIterator"
import {$ShortIterator, $ShortIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ShortIterator"
import {$BooleanIterator, $BooleanIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$BooleanIterator"
import {$CharIterator, $CharIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator"

export class $ArrayIteratorsKt {


public static "iterator"(arg0: (long)[]): $LongIterator
public static "iterator"(arg0: (float)[]): $FloatIterator
public static "iterator"(arg0: (double)[]): $DoubleIterator
public static "iterator"(arg0: (boolean)[]): $BooleanIterator
public static "iterator"(arg0: (byte)[]): $ByteIterator
public static "iterator"(arg0: (character)[]): $CharIterator
public static "iterator"(arg0: (short)[]): $ShortIterator
public static "iterator"(arg0: (integer)[]): $IntIterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayIteratorsKt$Type = ($ArrayIteratorsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayIteratorsKt_ = $ArrayIteratorsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServlet" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$GenericServlet, $GenericServlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$GenericServlet"

export class $HttpServlet extends $GenericServlet {

constructor()

public "service"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServlet$Type = ($HttpServlet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServlet_ = $HttpServlet$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HostPortHttpField" {
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"

export class $HostPortHttpField extends $HttpField {

constructor(arg0: string)

public "getHost"(): string
public "getPort"(): integer
public "getPort"(arg0: integer): integer
get "host"(): string
get "port"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HostPortHttpField$Type = ($HostPortHttpField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HostPortHttpField_ = $HostPortHttpField$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverImpl" {
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"

export interface $EventDriverImpl {

 "create"(arg0: any, arg1: $WebSocketPolicy$Type): $EventDriver
 "describeRule"(): string
 "supports"(arg0: any): boolean
}

export namespace $EventDriverImpl {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventDriverImpl$Type = ($EventDriverImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventDriverImpl_ = $EventDriverImpl$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Uptime$Impl" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Uptime$Impl {

 "getUptime"(): long

(): long
}

export namespace $Uptime$Impl {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Uptime$Impl$Type = ($Uptime$Impl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Uptime$Impl_ = $Uptime$Impl$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo" {
import {$CloseFrame, $CloseFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$CloseFrame"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $CloseInfo {

constructor(arg0: integer, arg1: string)
constructor(arg0: integer)
constructor(arg0: $Frame$Type, arg1: boolean)
constructor()
constructor(arg0: $ByteBuffer$Type, arg1: boolean)
constructor(arg0: $Frame$Type)

public "toString"(): string
public "getReason"(): string
public "getStatusCode"(): integer
public "isHarsh"(): boolean
public "isAbnormal"(): boolean
public "asFrame"(): $CloseFrame
get "reason"(): string
get "statusCode"(): integer
get "harsh"(): boolean
get "abnormal"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseInfo$Type = ($CloseInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseInfo_ = $CloseInfo$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerClassWrapper" {
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $WebSocketHandlerClassWrapper implements $WebSocketHandlerWrapper {

constructor(arg0: $Class$Type<(any)>)

public "getHandler"(): any
public static "validateHandlerClass"(arg0: $Class$Type<(any)>): void
get "handler"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketHandlerClassWrapper$Type = ($WebSocketHandlerClassWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketHandlerClassWrapper_ = $WebSocketHandlerClassWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IteratorsJVMKt" {
import {$CollectionsKt__IterablesKt, $CollectionsKt__IterablesKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IterablesKt"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $CollectionsKt__IteratorsJVMKt extends $CollectionsKt__IterablesKt {

constructor()

public static "iterator"<T>(arg0: $Enumeration$Type<(T)>): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__IteratorsJVMKt$Type = ($CollectionsKt__IteratorsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__IteratorsJVMKt_ = $CollectionsKt__IteratorsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ComparableRange" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export class $ComparableRange<T extends $Comparable<(any)>> implements $ClosedRange<(T)> {

constructor(arg0: T, arg1: T)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: T): boolean
public "getEndInclusive"(): T
public "getStart"(): T
get "empty"(): boolean
get "endInclusive"(): T
get "start"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparableRange$Type<T> = ($ComparableRange<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparableRange_<T> = $ComparableRange$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/serialization/$BytesSerializer" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Serializer, $Serializer$Type} from "packages/info/journeymap/shaded/kotlin/spark/serialization/$Serializer"

export class $BytesSerializer extends $Serializer {


public "process"(arg0: $OutputStream$Type, arg1: any): void
public "canProcess"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesSerializer$Type = ($BytesSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesSerializer_ = $BytesSerializer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$ObjectUtils" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ObjectUtils {

constructor()

public static "isEmpty"(arg0: (any)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectUtils$Type = ($ObjectUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectUtils_ = $ObjectUtils$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IterablesKt" {
import {$CollectionsKt__CollectionsKt, $CollectionsKt__CollectionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__CollectionsKt"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"

export class $CollectionsKt__IterablesKt extends $CollectionsKt__CollectionsKt {

constructor()

public static "flatten"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "unzip"<T, R>(arg0: $Iterable$Type<(any)>): $Pair<($List<(T)>), ($List<(R)>)>
public static "collectionSizeOrDefault"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): integer
public static "collectionSizeOrNull"<T>(arg0: $Iterable$Type<(any)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__IterablesKt$Type = ($CollectionsKt__IterablesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__IterablesKt_ = $CollectionsKt__IterablesKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__ReversedViewsKt" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$CollectionsKt__MutableCollectionsKt, $CollectionsKt__MutableCollectionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__MutableCollectionsKt"

export class $CollectionsKt__ReversedViewsKt extends $CollectionsKt__MutableCollectionsKt {

constructor()

public static "asReversed"<T>(arg0: $List$Type<(any)>): $List<(T)>
public static "asReversedMutable"<T>(arg0: $List$Type<(T)>): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__ReversedViewsKt$Type = ($CollectionsKt__ReversedViewsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__ReversedViewsKt_ = $CollectionsKt__ReversedViewsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope" {
import {$DecoratedObjectFactory, $DecoratedObjectFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DecoratedObjectFactory"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$SslContextFactory, $SslContextFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export interface $WebSocketContainerScope {

 "getExecutor"(): $Executor
 "getPolicy"(): $WebSocketPolicy
 "getBufferPool"(): $ByteBufferPool
 "onSessionOpened"(arg0: $WebSocketSession$Type): void
 "onSessionClosed"(arg0: $WebSocketSession$Type): void
 "isRunning"(): boolean
 "getObjectFactory"(): $DecoratedObjectFactory
 "getSslContextFactory"(): $SslContextFactory
}

export namespace $WebSocketContainerScope {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketContainerScope$Type = ($WebSocketContainerScope);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketContainerScope_ = $WebSocketContainerScope$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Redirect" {
import {$Redirect$Status, $Redirect$Status$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Redirect$Status"

export class $Redirect {


public "get"(arg0: string, arg1: string): void
public "get"(arg0: string, arg1: string, arg2: $Redirect$Status$Type): void
public "put"(arg0: string, arg1: string, arg2: $Redirect$Status$Type): void
public "put"(arg0: string, arg1: string): void
public "delete"(arg0: string, arg1: string, arg2: $Redirect$Status$Type): void
public "delete"(arg0: string, arg1: string): void
public "post"(arg0: string, arg1: string, arg2: $Redirect$Status$Type): void
public "post"(arg0: string, arg1: string): void
public "any"(arg0: string, arg1: string, arg2: $Redirect$Status$Type): void
public "any"(arg0: string, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Redirect$Type = ($Redirect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Redirect_ = $Redirect$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$ClassPathResourceHandler" {
import {$AbstractResourceHandler, $AbstractResourceHandler$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractResourceHandler"

export class $ClassPathResourceHandler extends $AbstractResourceHandler {

constructor(arg0: string)
constructor(arg0: string, arg1: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassPathResourceHandler$Type = ($ClassPathResourceHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassPathResourceHandler_ = $ClassPathResourceHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$AliasCheck" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"

export interface $ContextHandler$AliasCheck {

 "check"(arg0: string, arg1: $Resource$Type): boolean

(arg0: string, arg1: $Resource$Type): boolean
}

export namespace $ContextHandler$AliasCheck {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextHandler$AliasCheck$Type = ($ContextHandler$AliasCheck);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextHandler$AliasCheck_ = $ContextHandler$AliasCheck$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler" {
import {$SessionTrackingMode, $SessionTrackingMode$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionTrackingMode"
import {$ScopedHandler, $ScopedHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ScopedHandler"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BigDecimal, $BigDecimal$Type} from "packages/java/math/$BigDecimal"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HttpCookie, $HttpCookie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCookie"
import {$SessionIdManager, $SessionIdManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SessionIdManager"
import {$SessionCookieConfig, $SessionCookieConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionCookieConfig"
import {$SessionCache, $SessionCache$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionCache"

export class $SessionHandler extends $ScopedHandler {
static readonly "DEFAULT_TRACKING": $EnumSet<($SessionTrackingMode)>
static readonly "__SessionCookieProperty": string
static readonly "__DefaultSessionCookie": string
static readonly "__SessionIdPathParameterNameProperty": string
static readonly "__DefaultSessionIdPathParameterName": string
static readonly "__CheckRemoteSessionEncoding": string
static readonly "__SessionDomainProperty": string
static readonly "__DefaultSessionDomain": string
static readonly "__SessionPathProperty": string
static readonly "__MaxAgeProperty": string
 "__defaultSessionTrackingModes": $Set<($SessionTrackingMode)>
static readonly "SESSION_LISTENER_TYPES": ($Class<(any)>)[]
static readonly "MAX_INACTIVE_MINUTES": $BigDecimal
 "_sessionTrackingModes": $Set<($SessionTrackingMode)>
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "toString"(): string
public "access"(arg0: $HttpSession$Type, arg1: boolean): $HttpCookie
public "getId"(arg0: $HttpSession$Type): string
public "complete"(arg0: $HttpSession$Type): void
public "complete"(arg0: $Session$Type, arg1: $Request$Type): void
public "isValid"(arg0: $HttpSession$Type): boolean
public "invalidate"(arg0: string): void
public "removeEventListener"(arg0: $EventListener$Type): void
public "addEventListener"(arg0: $EventListener$Type): void
public "getSessionCookie"(): string
public "getSessionCookie"(arg0: $HttpSession$Type, arg1: string, arg2: boolean): $HttpCookie
public "newHttpSession"(arg0: $HttpServletRequest$Type): $HttpSession
public "isUsingCookies"(): boolean
public "isUsingURLs"(): boolean
public "getSessionIdManager"(): $SessionIdManager
public "setSessionIdManager"(arg0: $SessionIdManager$Type): void
public "getSession"(arg0: string): $Session
public "getScheduler"(): $Scheduler
public "getExtendedId"(arg0: $HttpSession$Type): string
public "renewSessionId"(arg0: string, arg1: string, arg2: string, arg3: string): void
public "isIdInUse"(arg0: string): boolean
public "getSessionIdPathParameterNamePrefix"(): string
public "isCheckingRemoteSessionIdEncoding"(): boolean
public "setHttpOnly"(arg0: boolean): void
public "getSessionCache"(): $SessionCache
public "doHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "doScope"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "getSessionPath"(): string
public "setSessionCache"(arg0: $SessionCache$Type): void
public "getMaxCookieAge"(): integer
public "getHttpOnly"(): boolean
public "setSessionCookie"(arg0: string): void
public "getHttpSession"(arg0: string): $HttpSession
public "getSessionsCreated"(): integer
public "getSessionDomain"(): string
public "setUsingCookies"(arg0: boolean): void
public "statsReset"(): void
public "getSecureCookies"(): boolean
public "removeSession"(arg0: string, arg1: boolean): $Session
public "getSessionTimeMean"(): double
public "getSessionTimeMax"(): long
public "scavenge"(): void
public "getMaxInactiveInterval"(): integer
public "setMaxInactiveInterval"(arg0: integer): void
public "doSessionAttributeListeners"(arg0: $Session$Type, arg1: string, arg2: any, arg3: any): void
public "clearEventListeners"(): void
public "setSecureRequestOnly"(arg0: boolean): void
public "getSessionIdPathParameterName"(): string
public "getRefreshCookieAge"(): integer
public "isNodeIdInSessionId"(): boolean
public "isSecureRequestOnly"(): boolean
public "setNodeIdInSessionId"(arg0: boolean): void
public "setCheckingRemoteSessionIdEncoding"(arg0: boolean): void
public "setRefreshCookieAge"(arg0: integer): void
public "setSessionIdPathParameterName"(arg0: string): void
public "getSessionTimeTotal"(): long
public "getSessionTimeStdDev"(): double
public "sessionInactivityTimerExpired"(arg0: $Session$Type): void
public "setSessionTrackingModes"(arg0: $Set$Type<($SessionTrackingMode$Type)>): void
public "getSessionCookieConfig"(): $SessionCookieConfig
public "getEffectiveSessionTrackingModes"(): $Set<($SessionTrackingMode)>
public "getDefaultSessionTrackingModes"(): $Set<($SessionTrackingMode)>
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "sessionCookie"(): string
get "usingCookies"(): boolean
get "usingURLs"(): boolean
get "sessionIdManager"(): $SessionIdManager
set "sessionIdManager"(value: $SessionIdManager$Type)
get "scheduler"(): $Scheduler
get "sessionIdPathParameterNamePrefix"(): string
get "checkingRemoteSessionIdEncoding"(): boolean
set "httpOnly"(value: boolean)
get "sessionCache"(): $SessionCache
get "sessionPath"(): string
set "sessionCache"(value: $SessionCache$Type)
get "maxCookieAge"(): integer
get "httpOnly"(): boolean
set "sessionCookie"(value: string)
get "sessionsCreated"(): integer
get "sessionDomain"(): string
set "usingCookies"(value: boolean)
get "secureCookies"(): boolean
get "sessionTimeMean"(): double
get "sessionTimeMax"(): long
get "maxInactiveInterval"(): integer
set "maxInactiveInterval"(value: integer)
set "secureRequestOnly"(value: boolean)
get "sessionIdPathParameterName"(): string
get "refreshCookieAge"(): integer
get "nodeIdInSessionId"(): boolean
get "secureRequestOnly"(): boolean
set "nodeIdInSessionId"(value: boolean)
set "checkingRemoteSessionIdEncoding"(value: boolean)
set "refreshCookieAge"(value: integer)
set "sessionIdPathParameterName"(value: string)
get "sessionTimeTotal"(): long
get "sessionTimeStdDev"(): double
set "sessionTrackingModes"(value: $Set$Type<($SessionTrackingMode$Type)>)
get "sessionCookieConfig"(): $SessionCookieConfig
get "effectiveSessionTrackingModes"(): $Set<($SessionTrackingMode)>
get "defaultSessionTrackingModes"(): $Set<($SessionTrackingMode)>
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionHandler$Type = ($SessionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionHandler_ = $SessionHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ArrayTernaryTrie" {
import {$AbstractTrie, $AbstractTrie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AbstractTrie"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $ArrayTernaryTrie<V> extends $AbstractTrie<(V)> {

constructor(arg0: $ArrayTernaryTrie$Type<(V)>, arg1: double)
constructor(arg0: boolean, arg1: integer)
constructor(arg0: integer)
constructor(arg0: boolean)
constructor()

public "get"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "get"(arg0: string, arg1: integer, arg2: integer): V
public "put"(arg0: string, arg1: V): boolean
public "toString"(): string
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<(string), (V)>)>
public "keySet"(): $Set<(string)>
public static "hilo"(arg0: integer): integer
public "isFull"(): boolean
public "dump"(): void
public "getBest"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "getBest"(arg0: string): V
public "getBest"(arg0: string, arg1: integer, arg2: integer): V
get "empty"(): boolean
get "full"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayTernaryTrie$Type<V> = ($ArrayTernaryTrie<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayTernaryTrie_<V> = $ArrayTernaryTrie$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/$LoggerFactory" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ILoggerFactory, $ILoggerFactory$Type} from "packages/info/journeymap/shaded/org/slf4j/$ILoggerFactory"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export class $LoggerFactory {


public static "getLogger"(arg0: string): $Logger
public static "getLogger"(arg0: $Class$Type<(any)>): $Logger
public static "getILoggerFactory"(): $ILoggerFactory
get "iLoggerFactory"(): $ILoggerFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoggerFactory$Type = ($LoggerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoggerFactory_ = $LoggerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$TakeSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$DropTakeSequence, $DropTakeSequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropTakeSequence"

export class $TakeSequence<T> implements $Sequence<(T)>, $DropTakeSequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: integer)

public "iterator"(): $Iterator<(T)>
public "drop"(arg0: integer): $Sequence<(T)>
public "take"(arg0: integer): $Sequence<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TakeSequence$Type<T> = ($TakeSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TakeSequence_<T> = $TakeSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeaderValue" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"

export class $HttpHeaderValue extends $Enum<($HttpHeaderValue)> {
static readonly "CLOSE": $HttpHeaderValue
static readonly "CHUNKED": $HttpHeaderValue
static readonly "GZIP": $HttpHeaderValue
static readonly "IDENTITY": $HttpHeaderValue
static readonly "KEEP_ALIVE": $HttpHeaderValue
static readonly "CONTINUE": $HttpHeaderValue
static readonly "PROCESSING": $HttpHeaderValue
static readonly "TE": $HttpHeaderValue
static readonly "BYTES": $HttpHeaderValue
static readonly "NO_CACHE": $HttpHeaderValue
static readonly "UPGRADE": $HttpHeaderValue
static readonly "UNKNOWN": $HttpHeaderValue
static readonly "CACHE": $Trie<($HttpHeaderValue)>


public "toString"(): string
public static "values"(): ($HttpHeaderValue)[]
public static "valueOf"(arg0: string): $HttpHeaderValue
public "is"(arg0: string): boolean
public "asString"(): string
public static "hasKnownValues"(arg0: $HttpHeader$Type): boolean
public "toBuffer"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpHeaderValue$Type = (("te") | ("upgrade") | ("identity") | ("continue") | ("bytes") | ("no_cache") | ("chunked") | ("processing") | ("gzip") | ("keep_alive") | ("close") | ("unknown")) | ($HttpHeaderValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpHeaderValue_ = $HttpHeaderValue$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$State" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpParser$State extends $Enum<($HttpParser$State)> {
static readonly "START": $HttpParser$State
static readonly "METHOD": $HttpParser$State
static readonly "RESPONSE_VERSION": $HttpParser$State
static readonly "SPACE1": $HttpParser$State
static readonly "STATUS": $HttpParser$State
static readonly "URI": $HttpParser$State
static readonly "SPACE2": $HttpParser$State
static readonly "REQUEST_VERSION": $HttpParser$State
static readonly "REASON": $HttpParser$State
static readonly "PROXY": $HttpParser$State
static readonly "HEADER": $HttpParser$State
static readonly "CONTENT": $HttpParser$State
static readonly "EOF_CONTENT": $HttpParser$State
static readonly "CHUNKED_CONTENT": $HttpParser$State
static readonly "CHUNK_SIZE": $HttpParser$State
static readonly "CHUNK_PARAMS": $HttpParser$State
static readonly "CHUNK": $HttpParser$State
static readonly "TRAILER": $HttpParser$State
static readonly "END": $HttpParser$State
static readonly "CLOSE": $HttpParser$State
static readonly "CLOSED": $HttpParser$State


public static "values"(): ($HttpParser$State)[]
public static "valueOf"(arg0: string): $HttpParser$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$State$Type = (("reason") | ("chunk_size") | ("method") | ("start") | ("chunk") | ("eof_content") | ("uri") | ("content") | ("trailer") | ("proxy") | ("response_version") | ("request_version") | ("chunk_params") | ("space2") | ("header") | ("closed") | ("end") | ("chunked_content") | ("close") | ("space1") | ("status")) | ($HttpParser$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser$State_ = $HttpParser$State$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$Util" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $Util {


public static "report"(arg0: string, arg1: $Throwable$Type): void
public static "report"(arg0: string): void
public static "getCallingClass"(): $Class<(any)>
public static "safeGetBooleanSystemProperty"(arg0: string): boolean
public static "safeGetSystemProperty"(arg0: string): string
get "callingClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Util$Type = ($Util);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Util_ = $Util$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletContextHandler$Decorator" {
import {$Decorator, $Decorator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Decorator"

/**
 * 
 * @deprecated
 */
export interface $ServletContextHandler$Decorator extends $Decorator {

 "destroy"(arg0: any): void
 "decorate"<T>(arg0: T): T
}

export namespace $ServletContextHandler$Decorator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextHandler$Decorator$Type = ($ServletContextHandler$Decorator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextHandler$Decorator_ = $ServletContextHandler$Decorator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$BlockingArrayQueue" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/java/util/$AbstractList"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$BlockingQueue, $BlockingQueue$Type} from "packages/java/util/concurrent/$BlockingQueue"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"

export class $BlockingArrayQueue<E> extends $AbstractList<(E)> implements $BlockingQueue<(E)> {
static readonly "DEFAULT_CAPACITY": integer
static readonly "DEFAULT_GROWTH": integer

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer)
constructor(arg0: integer)
constructor()

public "add"(arg0: E): boolean
public "add"(arg0: integer, arg1: E): void
public "remove"(): E
public "remove"(arg0: any): boolean
public "remove"(arg0: integer): E
public "get"(arg0: integer): E
public "put"(arg0: E): void
public "clear"(): void
public "size"(): integer
public "iterator"(): $Iterator<(E)>
public "set"(arg0: integer, arg1: E): E
public "poll"(): E
public "poll"(arg0: long, arg1: $TimeUnit$Type): E
public "peek"(): E
public "element"(): E
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "offer"(arg0: E, arg1: long, arg2: $TimeUnit$Type): boolean
public "offer"(arg0: E): boolean
public "take"(): E
public "getCapacity"(): integer
public "getMaxCapacity"(): integer
public "remainingCapacity"(): integer
public "drainTo"(arg0: $Collection$Type<(any)>, arg1: integer): integer
public "drainTo"(arg0: $Collection$Type<(any)>): integer
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "capacity"(): integer
get "maxCapacity"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockingArrayQueue$Type<E> = ($BlockingArrayQueue<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockingArrayQueue_<E> = $BlockingArrayQueue$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt___ComparisonsKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$ComparisonsKt___ComparisonsJvmKt, $ComparisonsKt___ComparisonsJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt___ComparisonsJvmKt"

export class $ComparisonsKt___ComparisonsKt extends $ComparisonsKt___ComparisonsJvmKt {

constructor()

public static "minOf"<T>(arg0: T, arg1: T, arg2: T, arg3: $Comparator$Type<(any)>): T
public static "minOf"<T>(arg0: T, arg1: T, arg2: $Comparator$Type<(any)>): T
public static "minOf"<T>(arg0: T, arg1: (T)[], arg2: $Comparator$Type<(any)>): T
public static "maxOf"<T>(arg0: T, arg1: (T)[], arg2: $Comparator$Type<(any)>): T
public static "maxOf"<T>(arg0: T, arg1: T, arg2: $Comparator$Type<(any)>): T
public static "maxOf"<T>(arg0: T, arg1: T, arg2: T, arg3: $Comparator$Type<(any)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparisonsKt___ComparisonsKt$Type = ($ComparisonsKt___ComparisonsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparisonsKt___ComparisonsKt_ = $ComparisonsKt___ComparisonsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerInstanceWrapper" {
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $WebSocketHandlerInstanceWrapper implements $WebSocketHandlerWrapper {

constructor(arg0: any)

public "getHandler"(): any
public static "validateHandlerClass"(arg0: $Class$Type<(any)>): void
get "handler"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketHandlerInstanceWrapper$Type = ($WebSocketHandlerInstanceWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketHandlerInstanceWrapper_ = $WebSocketHandlerInstanceWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$SecurityHandler" {
import {$HandlerWrapper, $HandlerWrapper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$LoginService, $LoginService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"
import {$Authenticator, $Authenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authenticator$Factory, $Authenticator$Factory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$Factory"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"

export class $SecurityHandler extends $HandlerWrapper implements $Authenticator$AuthConfiguration {
static readonly "__NO_USER": $Principal
static readonly "__NOBODY": $Principal
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener


public "setIdentityService"(arg0: $IdentityService$Type): void
public "getAuthenticator"(): $Authenticator
public "getIdentityService"(): $IdentityService
public "getLoginService"(): $LoginService
public "getRealmName"(): string
public "setRealmName"(arg0: string): void
public "setAuthMethod"(arg0: string): void
public "setLoginService"(arg0: $LoginService$Type): void
public "getInitParameter"(arg0: string): string
public "setInitParameter"(arg0: string, arg1: string): string
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "setAuthenticator"(arg0: $Authenticator$Type): void
public "logout"(arg0: $Authentication$User$Type): void
public "getAuthMethod"(): string
public "getAuthenticatorFactory"(): $Authenticator$Factory
public "setSessionRenewedOnAuthentication"(arg0: boolean): void
public "isSessionRenewedOnAuthentication"(): boolean
public "setCheckWelcomeFiles"(arg0: boolean): void
public "setAuthenticatorFactory"(arg0: $Authenticator$Factory$Type): void
public "getInitParameterNames"(): $Set<(string)>
public static "getCurrentSecurityHandler"(): $SecurityHandler
public "isCheckWelcomeFiles"(): boolean
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "identityService"(value: $IdentityService$Type)
get "authenticator"(): $Authenticator
get "identityService"(): $IdentityService
get "loginService"(): $LoginService
get "realmName"(): string
set "realmName"(value: string)
set "authMethod"(value: string)
set "loginService"(value: $LoginService$Type)
set "authenticator"(value: $Authenticator$Type)
get "authMethod"(): string
get "authenticatorFactory"(): $Authenticator$Factory
set "sessionRenewedOnAuthentication"(value: boolean)
get "sessionRenewedOnAuthentication"(): boolean
set "checkWelcomeFiles"(value: boolean)
set "authenticatorFactory"(value: $Authenticator$Factory$Type)
get "initParameterNames"(): $Set<(string)>
get "currentSecurityHandler"(): $SecurityHandler
get "checkWelcomeFiles"(): boolean
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecurityHandler$Type = ($SecurityHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecurityHandler_ = $SecurityHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"

export interface $CoroutineContext$Element extends $CoroutineContext {

 "get"<E extends $CoroutineContext$Element>(arg0: $CoroutineContext$Key$Type<(E)>): E
 "getKey"(): $CoroutineContext$Key<(any)>
 "minusKey"(arg0: $CoroutineContext$Key$Type<(any)>): $CoroutineContext
 "fold"<R>(arg0: R, arg1: $Function2$Type<(any), (any), (any)>): R
 "plus"(arg0: $CoroutineContext$Type): $CoroutineContext
}

export namespace $CoroutineContext$Element {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoroutineContext$Element$Type = ($CoroutineContext$Element);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoroutineContext$Element_ = $CoroutineContext$Element$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSetFactory" {
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$IImageLineSet, $IImageLineSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSet"

export interface $IImageLineSetFactory<T extends $IImageLine> {

 "create"(arg0: $ImageInfo$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: integer): $IImageLineSet<(T)>

(arg0: $ImageInfo$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: integer): $IImageLineSet<(T)>
}

export namespace $IImageLineSetFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IImageLineSetFactory$Type<T> = ($IImageLineSetFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IImageLineSetFactory_<T> = $IImageLineSetFactory$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionCacheFactory" {
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$SessionCache, $SessionCache$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionCache"

export interface $SessionCacheFactory {

 "getSessionCache"(arg0: $SessionHandler$Type): $SessionCache

(arg0: $SessionHandler$Type): $SessionCache
}

export namespace $SessionCacheFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionCacheFactory$Type = ($SessionCacheFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionCacheFactory_ = $SessionCacheFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $WebSocketConnectionListener {

 "onWebSocketConnect"(arg0: $Session$Type): void
 "onWebSocketClose"(arg0: integer, arg1: string): void
 "onWebSocketError"(arg0: $Throwable$Type): void
}

export namespace $WebSocketConnectionListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketConnectionListener$Type = ($WebSocketConnectionListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketConnectionListener_ = $WebSocketConnectionListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt___SequencesKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$Function3, $Function3$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Grouping, $Grouping$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$Grouping"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$SequencesKt___SequencesJvmKt, $SequencesKt___SequencesJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt___SequencesJvmKt"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SequencesKt___SequencesKt extends $SequencesKt___SequencesJvmKt {

constructor()

public static "firstOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "firstOrNull"<T>(arg0: $Sequence$Type<(any)>): T
public static "mapTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "reduceIndexedOrNull"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "runningReduceIndexed"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): $Sequence<(S)>
public static "mapIndexedNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "flatMapIndexedSequence"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "flatMapIndexedIterable"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "indexOf"<T>(arg0: $Sequence$Type<(any)>, arg1: T): integer
public static "lastIndexOf"<T>(arg0: $Sequence$Type<(any)>, arg1: T): integer
public static "map"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "toList"<T>(arg0: $Sequence$Type<(any)>): $List<(T)>
public static "count"<T>(arg0: $Sequence$Type<(any)>): integer
public static "count"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "contains"<T>(arg0: $Sequence$Type<(any)>, arg1: T): boolean
public static "last"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "last"<T>(arg0: $Sequence$Type<(any)>): T
public static "single"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "single"<T>(arg0: $Sequence$Type<(any)>): T
public static "filter"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Sequence<(T)>
public static "first"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "first"<T>(arg0: $Sequence$Type<(any)>): T
public static "flatMap"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "forEach"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "toSet"<T>(arg0: $Sequence$Type<(any)>): $Set<(T)>
public static "reduce"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "elementAt"<T>(arg0: $Sequence$Type<(any)>, arg1: integer): T
public static "distinct"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "sorted"<T extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "scan"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "groupingBy"<T, K>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Grouping<(T), (K)>
public static "plus"<T>(arg0: $Sequence$Type<(any)>, arg1: T): $Sequence<(T)>
public static "plus"<T>(arg0: $Sequence$Type<(any)>, arg1: $Sequence$Type<(any)>): $Sequence<(T)>
public static "plus"<T>(arg0: $Sequence$Type<(any)>, arg1: (T)[]): $Sequence<(T)>
public static "plus"<T>(arg0: $Sequence$Type<(any)>, arg1: $Iterable$Type<(any)>): $Sequence<(T)>
public static "drop"<T>(arg0: $Sequence$Type<(any)>, arg1: integer): $Sequence<(T)>
public static "all"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "minus"<T>(arg0: $Sequence$Type<(any)>, arg1: $Iterable$Type<(any)>): $Sequence<(T)>
public static "minus"<T>(arg0: $Sequence$Type<(any)>, arg1: $Sequence$Type<(any)>): $Sequence<(T)>
public static "minus"<T>(arg0: $Sequence$Type<(any)>, arg1: (T)[]): $Sequence<(T)>
public static "minus"<T>(arg0: $Sequence$Type<(any)>, arg1: T): $Sequence<(T)>
public static "take"<T>(arg0: $Sequence$Type<(any)>, arg1: integer): $Sequence<(T)>
public static "toCollection"<T, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C): C
public static "takeWhile"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Sequence<(T)>
public static "dropWhile"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Sequence<(T)>
public static "zip"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Sequence$Type<(any)>): $Sequence<($Pair<(T), (R)>)>
public static "zip"<T, R, V>(arg0: $Sequence$Type<(any)>, arg1: $Sequence$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $Sequence<(V)>
public static "any"<T>(arg0: $Sequence$Type<(any)>): boolean
public static "any"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "associate"<T, K, V>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "chunked"<T, R>(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "chunked"<T>(arg0: $Sequence$Type<(any)>, arg1: integer): $Sequence<($List<(T)>)>
public static "none"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"<T>(arg0: $Sequence$Type<(any)>): boolean
public static "partition"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(T)>), ($List<(T)>)>
public static "indexOfFirst"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "joinTo"<T, A extends $Appendable>(arg0: $Sequence$Type<(any)>, arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "associateByTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<T, K, M extends $Map<(any), (any)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "averageOfByte"(arg0: $Sequence$Type<(byte)>): double
public static "averageOfFloat"(arg0: $Sequence$Type<(float)>): double
public static "averageOfInt"(arg0: $Sequence$Type<(integer)>): double
public static "associateBy"<T, K, V>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<T, K>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (T)>
public static "associateWithTo"<K, V, M extends $Map<(any), (any)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "averageOfShort"(arg0: $Sequence$Type<(short)>): double
public static "averageOfLong"(arg0: $Sequence$Type<(long)>): double
public static "asIterable"<T>(arg0: $Sequence$Type<(any)>): $Iterable<(T)>
public static "associateWith"<K, V>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "averageOfDouble"(arg0: $Sequence$Type<(double)>): double
public static "forEachIndexed"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "flatMapIterableTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapIndexed"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "mapIndexedNotNull"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "elementAtOrElse"<T>(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: $Function1$Type<(any), (any)>): T
public static "filterIndexed"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (boolean)>): $Sequence<(T)>
public static "filterNot"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Sequence<(T)>
public static "flatMapIterable"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "distinctBy"<T, K>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(T)>
public static "elementAtOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: integer): T
public static "filterNotNullTo"<C extends $Collection<(any)>, T>(arg0: $Sequence$Type<(any)>, arg1: C): C
public static "filterTo"<T, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "flatMapTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "filterIndexedTo"<T, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "groupBy"<T, K>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(T)>)>
public static "groupBy"<T, K, V>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "foldIndexed"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "groupByTo"<T, K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<T, K, M extends $Map<(any), ($List<(T)>)>>(arg0: $Sequence$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "filterNotTo"<T, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "indexOfLast"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "joinToString"<T>(arg0: $Sequence$Type<(any)>, arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "minOrNull"<T extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>): T
public static "mapNotNull"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "onEach"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), ($Unit$Type)>): $Sequence<(T)>
public static "onEachIndexed"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): $Sequence<(T)>
public static "minByOrNull"<T, R extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): T
public static "reduceIndexed"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceOrNull"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "maxWithOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: $Comparator$Type<(any)>): T
public static "minWithOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: $Comparator$Type<(any)>): T
public static "mapNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "maxOrNull"(arg0: $Sequence$Type<(float)>): float
public static "mapIndexedTo"<T, R, C extends $Collection<(any)>>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "maxByOrNull"<T, R extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): T
public static "sumOfLong"(arg0: $Sequence$Type<(long)>): long
public static "sortedBy"<T, R extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(T)>
public static "sumOfDouble"(arg0: $Sequence$Type<(double)>): double
public static "runningFoldIndexed"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $Sequence<(R)>
public static "requireNoNulls"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "singleOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "singleOrNull"<T>(arg0: $Sequence$Type<(any)>): T
public static "sumBy"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (integer)>): integer
public static "sortedWith"<T>(arg0: $Sequence$Type<(any)>, arg1: $Comparator$Type<(any)>): $Sequence<(T)>
public static "sumOfByte"(arg0: $Sequence$Type<(byte)>): integer
public static "sumOfShort"(arg0: $Sequence$Type<(short)>): integer
public static "scanIndexed"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $Sequence<(R)>
public static "sumOfInt"(arg0: $Sequence$Type<(integer)>): integer
public static "toMutableSet"<T>(arg0: $Sequence$Type<(any)>): $Set<(T)>
public static "runningFold"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "sumByDouble"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (double)>): double
public static "zipWithNext"<T, R>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(R)>
public static "zipWithNext"<T>(arg0: $Sequence$Type<(any)>): $Sequence<($Pair<(T), (T)>)>
public static "sortedByDescending"<T, R extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Sequence<(T)>
public static "runningReduce"<S, T extends S>(arg0: $Sequence$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $Sequence<(S)>
public static "sortedDescending"<T extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "sumOfFloat"(arg0: $Sequence$Type<(float)>): float
public static "toHashSet"<T>(arg0: $Sequence$Type<(any)>): $HashSet<(T)>
public static "fold"<T, R>(arg0: $Sequence$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "windowed"<T, R>(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean, arg4: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "windowed"<T>(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean): $Sequence<($List<(T)>)>
public static "toMutableList"<T>(arg0: $Sequence$Type<(any)>): $List<(T)>
public static "filterNotNull"<T>(arg0: $Sequence$Type<(any)>): $Sequence<(T)>
public static "withIndex"<T>(arg0: $Sequence$Type<(any)>): $Sequence<($IndexedValue<(T)>)>
public static "lastOrNull"<T>(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "lastOrNull"<T>(arg0: $Sequence$Type<(any)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt___SequencesKt$Type = ($SequencesKt___SequencesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt___SequencesKt_ = $SequencesKt___SequencesKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$KotlinRandom" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$RandomGenerator, $RandomGenerator$Type} from "packages/java/util/random/$RandomGenerator"
import {$Random as $Random$0, $Random$Type as $Random$0$Type} from "packages/java/util/$Random"

export class $KotlinRandom extends $Random$0 {

constructor(arg0: $Random$Type)

public "nextDouble"(): double
public "nextInt"(arg0: integer): integer
public "nextInt"(): integer
public "nextBytes"(arg0: (byte)[]): void
public "getImpl"(): $Random
public "setSeed"(arg0: long): void
public "nextLong"(): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public static "getDefault"(): $RandomGenerator
public static "of"(arg0: string): $RandomGenerator
get "impl"(): $Random
set "seed"(value: long)
get "default"(): $RandomGenerator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinRandom$Type = ($KotlinRandom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinRandom_ = $KotlinRandom$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageInputStream" {
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageAppender, $MessageAppender$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageAppender"

export class $MessageInputStream extends $InputStream implements $MessageAppender {

constructor()
constructor(arg0: integer)

public "read"(): integer
public "close"(): void
public "mark"(arg0: integer): void
public "markSupported"(): boolean
public "reset"(): void
public "messageComplete"(): void
public "appendFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageInputStream$Type = ($MessageInputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageInputStream_ = $MessageInputStream$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkBKGD" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkBKGD extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setGray"(arg0: integer): void
public "getGray"(): integer
public "setPaletteIndex"(arg0: integer): void
public "getPaletteIndex"(): integer
public "setRGB"(arg0: integer, arg1: integer, arg2: integer): void
public "getRGB"(): (integer)[]
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "gray"(value: integer)
get "gray"(): integer
set "paletteIndex"(value: integer)
get "paletteIndex"(): integer
get "rGB"(): (integer)[]
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkBKGD$Type = ($PngChunkBKGD);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkBKGD_ = $PngChunkBKGD$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ShutdownThread" {
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"

export class $ShutdownThread extends $Thread {
static readonly "MIN_PRIORITY": integer
static readonly "NORM_PRIORITY": integer
static readonly "MAX_PRIORITY": integer


public "run"(): void
public static "getInstance"(): $ShutdownThread
public static "isRegistered"(arg0: $LifeCycle$Type): boolean
public static "register"(arg0: integer, ...arg1: ($LifeCycle$Type)[]): void
public static "register"(...arg0: ($LifeCycle$Type)[]): void
public static "deregister"(arg0: $LifeCycle$Type): void
get "instance"(): $ShutdownThread
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShutdownThread$Type = ($ShutdownThread);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShutdownThread_ = $ShutdownThread$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestEvent" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$EventObject, $EventObject$Type} from "packages/java/util/$EventObject"

export class $ServletRequestEvent extends $EventObject {

constructor(arg0: $ServletContext$Type, arg1: $ServletRequest$Type)

public "getServletRequest"(): $ServletRequest
public "getServletContext"(): $ServletContext
get "servletRequest"(): $ServletRequest
get "servletContext"(): $ServletContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestEvent$Type = ($ServletRequestEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestEvent_ = $ServletRequestEvent$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArrayDeque$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $ArrayDeque$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "newCapacity$kotlin_stdlib"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDeque$Companion$Type = ($ArrayDeque$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDeque$Companion_ = $ArrayDeque$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionAttributeListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$HttpSessionBindingEvent, $HttpSessionBindingEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingEvent"

export interface $HttpSessionAttributeListener extends $EventListener {

 "attributeAdded"(arg0: $HttpSessionBindingEvent$Type): void
 "attributeReplaced"(arg0: $HttpSessionBindingEvent$Type): void
 "attributeRemoved"(arg0: $HttpSessionBindingEvent$Type): void
}

export namespace $HttpSessionAttributeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionAttributeListener$Type = ($HttpSessionAttributeListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionAttributeListener_ = $HttpSessionAttributeListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Extension" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"

export interface $Extension extends $IncomingFrames, $OutgoingFrames {

 "isRsv3User"(): boolean
 "isRsv2User"(): boolean
 "isRsv1User"(): boolean
 "getName"(): string
 "getConfig"(): $ExtensionConfig
 "setNextIncomingFrames"(arg0: $IncomingFrames$Type): void
 "setNextOutgoingFrames"(arg0: $OutgoingFrames$Type): void
 "incomingFrame"(arg0: $Frame$Type): void
 "incomingError"(arg0: $Throwable$Type): void
 "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
}

export namespace $Extension {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Extension$Type = ($Extension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Extension_ = $Extension$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$EncodingHttpWriter" {
import {$HttpWriter, $HttpWriter$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpWriter"
import {$HttpOutput, $HttpOutput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput"

export class $EncodingHttpWriter extends $HttpWriter {
static readonly "MAX_OUTPUT_CHARS": integer

constructor(arg0: $HttpOutput$Type, arg1: string)

public "write"(arg0: (character)[], arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncodingHttpWriter$Type = ($EncodingHttpWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EncodingHttpWriter_ = $EncodingHttpWriter$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__MutableCollectionsKt" {
import {$CollectionsKt__MutableCollectionsJVMKt, $CollectionsKt__MutableCollectionsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__MutableCollectionsJVMKt"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $CollectionsKt__MutableCollectionsKt extends $CollectionsKt__MutableCollectionsJVMKt {

constructor()

public static "addAll"<T>(arg0: $Collection$Type<(any)>, arg1: (T)[]): boolean
public static "addAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Iterable$Type<(any)>): boolean
public static "addAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Sequence$Type<(any)>): boolean
public static "removeAll"<T>(arg0: $Collection$Type<(any)>, arg1: (T)[]): boolean
public static "removeAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Iterable$Type<(any)>): boolean
public static "removeAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Sequence$Type<(any)>): boolean
public static "removeAll"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "removeAll"<T>(arg0: $List$Type<(T)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "retainAll"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "retainAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Sequence$Type<(any)>): boolean
public static "retainAll"<T>(arg0: $List$Type<(T)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "retainAll"<T>(arg0: $Collection$Type<(any)>, arg1: $Iterable$Type<(any)>): boolean
public static "retainAll"<T>(arg0: $Collection$Type<(any)>, arg1: (T)[]): boolean
public static "removeFirst"<T>(arg0: $List$Type<(T)>): T
public static "removeLast"<T>(arg0: $List$Type<(T)>): T
public static "removeFirstOrNull"<T>(arg0: $List$Type<(T)>): T
public static "removeLastOrNull"<T>(arg0: $List$Type<(T)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__MutableCollectionsKt$Type = ($CollectionsKt__MutableCollectionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__MutableCollectionsKt_ = $CollectionsKt__MutableCollectionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$NotImplementedError" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Error, $Error$Type} from "packages/java/lang/$Error"

export class $NotImplementedError extends $Error {

constructor(arg0: string)
constructor(arg0: string, arg1: integer, arg2: $DefaultConstructorMarker$Type)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotImplementedError$Type = ($NotImplementedError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotImplementedError_ = $NotImplementedError$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ManagedSelector$Selectable" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $ManagedSelector$Selectable {

 "onSelected"(): $Runnable
 "updateKey"(): void
}

export namespace $ManagedSelector$Selectable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedSelector$Selectable$Type = ($ManagedSelector$Selectable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedSelector$Selectable_ = $ManagedSelector$Selectable$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngBadCharsetException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$PngjException, $PngjException$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjException"

export class $PngBadCharsetException extends $PngjException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngBadCharsetException$Type = ($PngBadCharsetException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngBadCharsetException_ = $PngBadCharsetException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$Retention" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$AnnotationRetention, $AnnotationRetention$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$AnnotationRetention"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Retention extends $Annotation {

 "value"(): $AnnotationRetention
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Retention {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Retention$Type = ($Retention);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Retention_ = $Retention$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketFrameListener" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WebSocketConnectionListener, $WebSocketConnectionListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener"

export interface $WebSocketFrameListener extends $WebSocketConnectionListener {

 "onWebSocketFrame"(arg0: $Frame$Type): void
 "onWebSocketConnect"(arg0: $Session$Type): void
 "onWebSocketClose"(arg0: integer, arg1: string): void
 "onWebSocketError"(arg0: $Throwable$Type): void
}

export namespace $WebSocketFrameListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketFrameListener$Type = ($WebSocketFrameListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketFrameListener_ = $WebSocketFrameListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableList" {
import {$KMutableList, $KMutableList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/java/util/$AbstractList"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $AbstractMutableList<E> extends $AbstractList<(E)> implements $List<(E)>, $KMutableList {


public "add"(arg0: integer, arg1: E): void
public "remove"(arg0: integer): E
public "size"(): integer
public "set"(arg0: integer, arg1: E): E
public "getSize"(): integer
public "removeAt"(arg0: integer): E
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): E
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "subList"(arg0: integer, arg1: integer): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "listIterator"(): $ListIterator<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMutableList$Type<E> = ($AbstractMutableList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMutableList_<E> = $AbstractMutableList$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineHelper" {
import {$PngChunkTRNS, $PngChunkTRNS$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTRNS"
import {$PngChunkPLTE, $PngChunkPLTE$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkPLTE"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$ImageLineInt, $ImageLineInt$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineInt"
import {$IImageLineArray, $IImageLineArray$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineArray"

export class $ImageLineHelper {

constructor()

public static "scaleUp"(arg0: integer, arg1: byte): byte
public static "scaleUp"(arg0: $IImageLineArray$Type): void
public static "double2int"(arg0: $ImageLineInt$Type, arg1: double): integer
public static "setValD"(arg0: $ImageLineInt$Type, arg1: integer, arg2: double): void
public static "palette2rgba"(arg0: $ImageLineInt$Type, arg1: $PngChunkPLTE$Type, arg2: $PngChunkTRNS$Type, arg3: (integer)[]): (integer)[]
public static "setPixelRGB8"(arg0: $ImageLineInt$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer): void
public static "setPixelRGB8"(arg0: $ImageLineInt$Type, arg1: integer, arg2: integer): void
public static "palette2rgb"(arg0: $ImageLineInt$Type, arg1: $PngChunkPLTE$Type, arg2: (integer)[]): (integer)[]
public static "palette2rgb"(arg0: $ImageLineInt$Type, arg1: $PngChunkPLTE$Type, arg2: $PngChunkTRNS$Type, arg3: (integer)[]): (integer)[]
public static "getPixelRGB8"(arg0: $IImageLine$Type, arg1: integer): integer
public static "scaleDown"(arg0: integer, arg1: byte): byte
public static "scaleDown"(arg0: $IImageLineArray$Type): void
public static "setPixelsRGB8"(arg0: $ImageLineInt$Type, arg1: (integer)[]): void
public static "getPixelARGB8"(arg0: $IImageLine$Type, arg1: integer): integer
public static "setPixelsRGBA8"(arg0: $ImageLineInt$Type, arg1: (integer)[]): void
public static "setPixelRGBA8"(arg0: $ImageLineInt$Type, arg1: integer, arg2: integer): void
public static "setPixelRGBA8"(arg0: $ImageLineInt$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
public static "int2doubleClamped"(arg0: $ImageLineInt$Type, arg1: integer): double
public static "interpol"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: double, arg5: double): integer
public static "int2double"(arg0: $ImageLineInt$Type, arg1: integer): double
public static "clampTo_0_65535"(arg0: integer): integer
public static "clampTo_0_255"(arg0: integer): integer
public static "clampTo_128_127"(arg0: integer): integer
public static "double2intClamped"(arg0: $ImageLineInt$Type, arg1: double): integer
public static "infoFirstLastPixels"(arg0: $ImageLineInt$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageLineHelper$Type = ($ImageLineHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageLineHelper_ = $ImageLineHelper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$Resource" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$InputStreamResource, $InputStreamResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$InputStreamResource"

export interface $Resource extends $InputStreamResource {

 "isOpen"(): boolean
 "getFile"(): $File
 "exists"(): boolean
 "lastModified"(): long
 "isReadable"(): boolean
 "getURL"(): $URL
 "contentLength"(): long
 "getDescription"(): string
 "getURI"(): $URI
 "getFilename"(): string
 "createRelative"(arg0: string): $Resource
 "getInputStream"(): $InputStream
}

export namespace $Resource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Resource$Type = ($Resource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Resource_ = $Resource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$ClassPathResource" {
import {$AbstractFileResolvingResource, $AbstractFileResolvingResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractFileResolvingResource"
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$Resource"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $ClassPathResource extends $AbstractFileResolvingResource {

constructor(arg0: string, arg1: $ClassLoader$Type)
constructor(arg0: string)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getInputStream"(): $InputStream
public "getPath"(): string
public "exists"(): boolean
public "getURL"(): $URL
public "getDescription"(): string
public "getFilename"(): string
public "createRelative"(arg0: string): $Resource
get "inputStream"(): $InputStream
get "path"(): string
get "uRL"(): $URL
get "description"(): string
get "filename"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassPathResource$Type = ($ClassPathResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassPathResource_ = $ClassPathResource$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$QuietException" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $QuietException {

}

export namespace $QuietException {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuietException$Type = ($QuietException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuietException_ = $QuietException$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineFactory" {
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"

export interface $IImageLineFactory<T extends $IImageLine> {

 "createImageLine"(arg0: $ImageInfo$Type): T

(arg0: $ImageInfo$Type): T
}

export namespace $IImageLineFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IImageLineFactory$Type<T> = ($IImageLineFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IImageLineFactory_<T> = $IImageLineFactory$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$ExposingBufferByteArrayOutputStream" {
import {$ByteArrayOutputStream, $ByteArrayOutputStream$Type} from "packages/java/io/$ByteArrayOutputStream"

export class $ExposingBufferByteArrayOutputStream extends $ByteArrayOutputStream {

constructor(arg0: integer)

public "getBuffer"(): (byte)[]
get "buffer"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExposingBufferByteArrayOutputStream$Type = ($ExposingBufferByteArrayOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExposingBufferByteArrayOutputStream_ = $ExposingBufferByteArrayOutputStream$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$ClientCertAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"

export class $ClientCertAuthenticator extends $LoginAuthenticator {

constructor()

public "getCrlPath"(): string
public "isValidateCerts"(): boolean
public "setTrustStoreType"(arg0: string): void
public "setValidateCerts"(arg0: boolean): void
public "setCrlPath"(arg0: string): void
public "getTrustStoreType"(): string
public "setTrustStore"(arg0: string): void
public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "setOcspResponderURL"(arg0: string): void
public "getMaxCertPathLength"(): integer
public "getOcspResponderURL"(): string
public "setMaxCertPathLength"(arg0: integer): void
public "getAuthMethod"(): string
public "setTrustStoreProvider"(arg0: string): void
public "setTrustStorePassword"(arg0: string): void
public "getTrustStoreProvider"(): string
public "isEnableCRLDP"(): boolean
public "setEnableCRLDP"(arg0: boolean): void
public "getTrustStore"(): string
public "isEnableOCSP"(): boolean
public "setEnableOCSP"(arg0: boolean): void
get "crlPath"(): string
get "validateCerts"(): boolean
set "trustStoreType"(value: string)
set "validateCerts"(value: boolean)
set "crlPath"(value: string)
get "trustStoreType"(): string
set "trustStore"(value: string)
set "ocspResponderURL"(value: string)
get "maxCertPathLength"(): integer
get "ocspResponderURL"(): string
set "maxCertPathLength"(value: integer)
get "authMethod"(): string
set "trustStoreProvider"(value: string)
set "trustStorePassword"(value: string)
get "trustStoreProvider"(): string
get "enableCRLDP"(): boolean
set "enableCRLDP"(value: boolean)
get "trustStore"(): string
get "enableOCSP"(): boolean
set "enableOCSP"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientCertAuthenticator$Type = ($ClientCertAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientCertAuthenticator_ = $ClientCertAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$OnErrorAction" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $OnErrorAction extends $Enum<($OnErrorAction)> {
static readonly "SKIP": $OnErrorAction
static readonly "TERMINATE": $OnErrorAction


public static "values"(): ($OnErrorAction)[]
public static "valueOf"(arg0: string): $OnErrorAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnErrorAction$Type = (("skip") | ("terminate")) | ($OnErrorAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnErrorAction_ = $OnErrorAction$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponseWrapper" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ServletResponseWrapper, $ServletResponseWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponseWrapper"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HttpServletResponseWrapper extends $ServletResponseWrapper implements $HttpServletResponse {

constructor(arg0: $HttpServletResponse$Type)

public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $Collection<(string)>
public "sendError"(arg0: integer): void
public "sendError"(arg0: integer, arg1: string): void
public "setStatus"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "setStatus"(arg0: integer, arg1: string): void
public "getStatus"(): integer
public "addHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: string, arg1: string): void
public "sendRedirect"(arg0: string): void
public "setIntHeader"(arg0: string, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "encodeUrl"(arg0: string): string
public "encodeRedirectURL"(arg0: string): string
public "getHeaderNames"(): $Collection<(string)>
/**
 * 
 * @deprecated
 */
public "encodeRedirectUrl"(arg0: string): string
public "addCookie"(arg0: $Cookie$Type): void
public "containsHeader"(arg0: string): boolean
public "setTrailerFields"(arg0: $Supplier$Type<($Map$Type<(string), (string)>)>): void
public "getTrailerFields"(): $Supplier<($Map<(string), (string)>)>
public "setDateHeader"(arg0: string, arg1: long): void
public "addIntHeader"(arg0: string, arg1: integer): void
public "addDateHeader"(arg0: string, arg1: long): void
public "encodeURL"(arg0: string): string
set "status"(value: integer)
get "status"(): integer
get "headerNames"(): $Collection<(string)>
set "trailerFields"(value: $Supplier$Type<($Map$Type<(string), (string)>)>)
get "trailerFields"(): $Supplier<($Map<(string), (string)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServletResponseWrapper$Type = ($HttpServletResponseWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServletResponseWrapper_ = $HttpServletResponseWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandler" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export interface $ExceptionHandler<T extends $Exception> {

 "handle"(arg0: T, arg1: $Request$Type, arg2: $Response$Type): void

(arg0: T, arg1: $Request$Type, arg2: $Response$Type): void
}

export namespace $ExceptionHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionHandler$Type<T> = ($ExceptionHandler<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionHandler_<T> = $ExceptionHandler$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ULong$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $ULong$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULong$Companion$Type = ($ULong$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULong$Companion_ = $ULong$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroup" {
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $MatchGroup {

constructor(arg0: string, arg1: $IntRange$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): string
public "copy"(arg0: string, arg1: $IntRange$Type): $MatchGroup
public "getRange"(): $IntRange
public "component2"(): $IntRange
public "component1"(): string
get "value"(): string
get "range"(): $IntRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchGroup$Type = ($MatchGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchGroup_ = $MatchGroup$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropWhileSequence" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $DropWhileSequence<T> implements $Sequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropWhileSequence$Type<T> = ($DropWhileSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropWhileSequence_<T> = $DropWhileSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__CollectionsKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$CollectionsKt__CollectionsJVMKt, $CollectionsKt__CollectionsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__CollectionsJVMKt"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $CollectionsKt__CollectionsKt extends $CollectionsKt__CollectionsJVMKt {

constructor()

public static "emptyList"<T>(): $List<(T)>
public static "binarySearch"<T>(arg0: $List$Type<(any)>, arg1: T, arg2: $Comparator$Type<(any)>, arg3: integer, arg4: integer): integer
public static "binarySearch"<T extends $Comparable<(any)>>(arg0: $List$Type<(any)>, arg1: T, arg2: integer, arg3: integer): integer
public static "binarySearch"<T>(arg0: $List$Type<(any)>, arg1: integer, arg2: integer, arg3: $Function1$Type<(any), (integer)>): integer
public static "listOf"<T>(...arg0: (T)[]): $List<(T)>
public static "getLastIndex"<T>(arg0: $List$Type<(any)>): integer
public static "throwCountOverflow"(): void
public static "throwIndexOverflow"(): void
public static "getIndices"(arg0: $Collection$Type<(any)>): $IntRange
public static "shuffled"<T>(arg0: $Iterable$Type<(any)>, arg1: $Random$Type): $List<(T)>
public static "asCollection"<T>(arg0: (T)[]): $Collection<(T)>
public static "binarySearchBy"<T, K extends $Comparable<(any)>>(arg0: $List$Type<(any)>, arg1: K, arg2: integer, arg3: integer, arg4: $Function1$Type<(any), (any)>): integer
public static "arrayListOf"<T>(...arg0: (T)[]): $ArrayList<(T)>
public static "listOfNotNull"<T>(arg0: T): $List<(T)>
public static "listOfNotNull"<T>(...arg0: (T)[]): $List<(T)>
public static "mutableListOf"<T>(...arg0: (T)[]): $List<(T)>
public static "optimizeReadOnlyList"<T>(arg0: $List$Type<(any)>): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__CollectionsKt$Type = ($CollectionsKt__CollectionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__CollectionsKt_ = $CollectionsKt__CollectionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"

export class $ChunkRaw {
readonly "len": integer
readonly "idbytes": (byte)[]
readonly "id": string
 "data": (byte)[]
 "crcval": (byte)[]

constructor(arg0: integer, arg1: string, arg2: boolean)
constructor(arg0: integer, arg1: (byte)[], arg2: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getOffset"(): long
public "setOffset"(arg0: long): void
public "checkCrc"(): void
public "updateCrc"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "allocData"(): void
public "writeChunk"(arg0: $OutputStream$Type): void
public "writeChunkCrc"(arg0: $OutputStream$Type): void
public "writeChunkHeader"(arg0: $OutputStream$Type): void
get "offset"(): long
set "offset"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkRaw$Type = ($ChunkRaw);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkRaw_ = $ChunkRaw$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$HttpSessionBindingEvent, $HttpSessionBindingEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingEvent"

export interface $HttpSessionBindingListener extends $EventListener {

 "valueUnbound"(arg0: $HttpSessionBindingEvent$Type): void
 "valueBound"(arg0: $HttpSessionBindingEvent$Type): void
}

export namespace $HttpSessionBindingListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionBindingListener$Type = ($HttpSessionBindingListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionBindingListener_ = $HttpSessionBindingListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler$SessionIf" {
import {$HttpSessionContext, $HttpSessionContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionContext"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"

export interface $SessionHandler$SessionIf extends $HttpSession {

 "getSession"(): $Session
/**
 * 
 * @deprecated
 */
 "getValue"(arg0: string): any
 "getId"(): string
 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
/**
 * 
 * @deprecated
 */
 "putValue"(arg0: string, arg1: any): void
 "getCreationTime"(): long
 "invalidate"(): void
 "isNew"(): boolean
 "removeAttribute"(arg0: string): void
 "getServletContext"(): $ServletContext
 "getAttributeNames"(): $Enumeration<(string)>
/**
 * 
 * @deprecated
 */
 "getSessionContext"(): $HttpSessionContext
 "getLastAccessedTime"(): long
/**
 * 
 * @deprecated
 */
 "removeValue"(arg0: string): void
/**
 * 
 * @deprecated
 */
 "getValueNames"(): (string)[]
 "getMaxInactiveInterval"(): integer
 "setMaxInactiveInterval"(arg0: integer): void
}

export namespace $SessionHandler$SessionIf {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionHandler$SessionIf$Type = ($SessionHandler$SessionIf);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionHandler$SessionIf_ = $SessionHandler$SessionIf$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Decorator" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Decorator {

 "destroy"(arg0: any): void
 "decorate"<T>(arg0: T): T
}

export namespace $Decorator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Decorator$Type = ($Decorator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Decorator_ = $Decorator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeParameterReference$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"

export class $TypeParameterReference$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "toString"(arg0: $KTypeParameter$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeParameterReference$Companion$Type = ($TypeParameterReference$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeParameterReference$Companion_ = $TypeParameterReference$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractFileResolvingResource" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$AbstractResource, $AbstractResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractResource"

export class $AbstractFileResolvingResource extends $AbstractResource {

constructor()

public "getFile"(): $File
public "exists"(): boolean
public "lastModified"(): long
public "isReadable"(): boolean
public "contentLength"(): long
get "file"(): $File
get "readable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFileResolvingResource$Type = ($AbstractFileResolvingResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractFileResolvingResource_ = $AbstractFileResolvingResource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedCollection$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $SerializedCollection$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializedCollection$Companion$Type = ($SerializedCollection$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializedCollection$Companion_ = $SerializedCollection$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Lambda" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$FunctionBase, $FunctionBase$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase"

export class $Lambda<R> implements $FunctionBase<(R)>, $Serializable {

constructor(arg0: integer)

public "toString"(): string
public "getArity"(): integer
get "arity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lambda$Type<R> = ($Lambda<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lambda_<R> = $Lambda$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$CredentialProvider" {
import {$Credential, $Credential$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Credential"

export interface $CredentialProvider {

 "getPrefix"(): string
 "getCredential"(arg0: string): $Credential
}

export namespace $CredentialProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CredentialProvider$Type = ($CredentialProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CredentialProvider_ = $CredentialProvider$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ResponseWriter" {
import {$HttpWriter, $HttpWriter$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpWriter"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $ResponseWriter extends $PrintWriter {

constructor(arg0: $HttpWriter$Type, arg1: $Locale$Type, arg2: string)

public "println"(arg0: character): void
public "println"(arg0: boolean): void
public "println"(arg0: float): void
public "println"(arg0: string): void
public "println"(arg0: double): void
public "println"(arg0: (character)[]): void
public "println"(arg0: long): void
public "println"(arg0: integer): void
public "println"(arg0: any): void
public "println"(): void
public "flush"(): void
public "format"(arg0: string, ...arg1: (any)[]): $PrintWriter
public "format"(arg0: $Locale$Type, arg1: string, ...arg2: (any)[]): $PrintWriter
public "printf"(arg0: string, ...arg1: (any)[]): $PrintWriter
public "printf"(arg0: $Locale$Type, arg1: string, ...arg2: (any)[]): $PrintWriter
public "write"(arg0: integer): void
public "write"(arg0: (character)[], arg1: integer, arg2: integer): void
public "write"(arg0: (character)[]): void
public "write"(arg0: string, arg1: integer, arg2: integer): void
public "write"(arg0: string): void
public "print"(arg0: any): void
public "print"(arg0: long): void
public "print"(arg0: integer): void
public "print"(arg0: character): void
public "print"(arg0: boolean): void
public "print"(arg0: double): void
public "print"(arg0: string): void
public "print"(arg0: float): void
public "print"(arg0: (character)[]): void
public "close"(): void
public "checkError"(): boolean
public "isFor"(arg0: $Locale$Type, arg1: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResponseWriter$Type = ($ResponseWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResponseWriter_ = $ResponseWriter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpURI" {
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$MultiMap, $MultiMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiMap"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $HttpURI {

constructor(arg0: $URI$Type)
constructor(arg0: string)
constructor(arg0: $HttpURI$Type)
constructor(arg0: string, arg1: string, arg2: integer, arg3: string)
constructor()
constructor(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: string, arg5: string, arg6: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "clear"(): void
public "isAbsolute"(): boolean
public "getScheme"(): string
public "getHost"(): string
public "getPort"(): integer
public "getAuthority"(): string
public "getQuery"(): string
public "getPath"(): string
public "toURI"(): $URI
public "parse"(arg0: string): void
public "parse"(arg0: string, arg1: integer, arg2: integer): void
public "getFragment"(): string
public "getUser"(): string
public "setScheme"(arg0: string): void
public "setPath"(arg0: string): void
public "setAuthority"(arg0: string, arg1: integer): void
public "getPathQuery"(): string
public "setQuery"(arg0: string): void
public "setPathQuery"(arg0: string): void
public static "createHttpURI"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: string, arg5: string, arg6: string): $HttpURI
/**
 * 
 * @deprecated
 */
public "parseConnect"(arg0: string): void
public "getParam"(): string
public "getDecodedPath"(): string
public "hasQuery"(): boolean
public "decodeQueryTo"(arg0: $MultiMap$Type<(string)>): void
public "decodeQueryTo"(arg0: $MultiMap$Type<(string)>, arg1: string): void
public "decodeQueryTo"(arg0: $MultiMap$Type<(string)>, arg1: $Charset$Type): void
public "parseRequestTarget"(arg0: string, arg1: string): void
get "absolute"(): boolean
get "scheme"(): string
get "host"(): string
get "port"(): integer
get "authority"(): string
get "query"(): string
get "path"(): string
get "fragment"(): string
get "user"(): string
set "scheme"(value: string)
set "path"(value: string)
get "pathQuery"(): string
set "query"(value: string)
set "pathQuery"(value: string)
get "param"(): string
get "decodedPath"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpURI$Type = ($HttpURI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpURI_ = $HttpURI$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadClassLoaderScope" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"

export class $ThreadClassLoaderScope implements $Closeable {

constructor(arg0: $ClassLoader$Type)

public "close"(): void
public "getScopedClassLoader"(): $ClassLoader
get "scopedClassLoader"(): $ClassLoader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadClassLoaderScope$Type = ($ThreadClassLoaderScope);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadClassLoaderScope_ = $ThreadClassLoaderScope$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArrayDeque" {
import {$ArrayDeque$Companion, $ArrayDeque$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArrayDeque$Companion"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$AbstractMutableList, $AbstractMutableList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableList"

export class $ArrayDeque<E> extends $AbstractMutableList<(E)> {
static readonly "Companion": $ArrayDeque$Companion

constructor(arg0: $Collection$Type<(any)>)
constructor()
constructor(arg0: integer)

public "firstOrNull"(): E
public "add"(arg0: integer, arg1: E): void
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): E
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "contains"(arg0: any): boolean
public "last"(): E
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "first"(): E
public "set"(arg0: integer, arg1: E): E
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "addFirst"(arg0: E): void
public "addLast"(arg0: E): void
public "removeFirst"(): E
public "removeLast"(): E
public "removeAt"(arg0: integer): E
public "removeFirstOrNull"(): E
public "removeLastOrNull"(): E
public "lastOrNull"(): E
public "internalStructure$kotlin_stdlib"(arg0: $Function2$Type<(any), (any), ($Unit$Type)>): void
public "testToArray$kotlin_stdlib"<T>(arg0: (T)[]): (T)[]
public "testToArray$kotlin_stdlib"(): (any)[]
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "subList"(arg0: integer, arg1: integer): $List<(E)>
public "iterator"(): $Iterator<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "listIterator"(): $ListIterator<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDeque$Type<E> = ($ArrayDeque<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDeque_<E> = $ArrayDeque$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$MetaData, $MetaData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData"

export class $MetaData$Response extends $MetaData {

constructor()
constructor(arg0: $HttpVersion$Type, arg1: integer, arg2: string, arg3: $HttpFields$Type, arg4: long)
constructor(arg0: $HttpVersion$Type, arg1: integer, arg2: $HttpFields$Type, arg3: long)
constructor(arg0: $HttpVersion$Type, arg1: integer, arg2: $HttpFields$Type)

public "setReason"(arg0: string): void
public "isResponse"(): boolean
public "toString"(): string
public "getReason"(): string
public "setStatus"(arg0: integer): void
public "getStatus"(): integer
set "reason"(value: string)
get "response"(): boolean
get "reason"(): string
set "status"(value: integer)
get "status"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaData$Response$Type = ($MetaData$Response);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaData$Response_ = $MetaData$Response$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Ref" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Ref {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Ref$Type = ($Ref);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Ref_ = $Ref$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongRange" {
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$ULongRange$Companion, $ULongRange$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongRange$Companion"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$ULongProgression, $ULongProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgression"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export class $ULongRange extends $ULongProgression implements $ClosedRange<($ULong)> {
static readonly "Companion": $ULongRange$Companion

constructor(arg0: long, arg1: long, arg2: $DefaultConstructorMarker$Type)

public "getEndInclusive-s-VKNKU"(): long
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "getStart-s-VKNKU"(): long
public "contains-VKZWuLQ"(arg0: long): boolean
get "endInclusive-s-VKNKU"(): long
get "empty"(): boolean
get "start-s-VKNKU"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongRange$Type = ($ULongRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongRange_ = $ULongRange$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Utf8StringBuilder" {
import {$Utf8Appendable, $Utf8Appendable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Utf8Appendable"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export class $Utf8StringBuilder extends $Utf8Appendable {
static readonly "REPLACEMENT": character
static readonly "REPLACEMENT_UTF8": (byte)[]

constructor()
constructor(arg0: integer)

public "length"(): integer
public "toString"(): string
public "reset"(): void
public "getStringBuilder"(): $StringBuilder
get "stringBuilder"(): $StringBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8StringBuilder$Type = ($Utf8StringBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8StringBuilder_ = $Utf8StringBuilder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ForwardedRequestCustomizer" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$HttpConfiguration$Customizer, $HttpConfiguration$Customizer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$Customizer"

export class $ForwardedRequestCustomizer implements $HttpConfiguration$Customizer {

constructor()

public "toString"(): string
public "customize"(arg0: $Connector$Type, arg1: $HttpConfiguration$Type, arg2: $Request$Type): void
public "setSslIsSecure"(arg0: boolean): void
public "setForwardedOnly"(arg0: boolean): void
public "isSslIsSecure"(): boolean
public "getForcedHost"(): string
public "getForwardedHeader"(): string
public "setForwardedHeader"(arg0: string): void
public "setForcedHost"(arg0: string): void
/**
 * 
 * @deprecated
 */
public "getHostHeader"(): string
/**
 * 
 * @deprecated
 */
public "setHostHeader"(arg0: string): void
public "getForwardedHostHeader"(): string
public "setForwardedServerHeader"(arg0: string): void
public "getForwardedForHeader"(): string
public "getForwardedProtoHeader"(): string
public "setForwardedProtoHeader"(arg0: string): void
public "getForwardedCipherSuiteHeader"(): string
public "setProxyAsAuthority"(arg0: boolean): void
public "setForwardedHostHeader"(arg0: string): void
public "setForwardedForHeader"(arg0: string): void
public "getProxyAsAuthority"(): boolean
public "setForwardedCipherSuiteHeader"(arg0: string): void
public "getForwardedHttpsHeader"(): string
public "setForwardedSslSessionIdHeader"(arg0: string): void
public "setForwardedHttpsHeader"(arg0: string): void
public "getForwardedSslSessionIdHeader"(): string
public "getForwardedServerHeader"(): string
set "sslIsSecure"(value: boolean)
set "forwardedOnly"(value: boolean)
get "sslIsSecure"(): boolean
get "forcedHost"(): string
get "forwardedHeader"(): string
set "forwardedHeader"(value: string)
set "forcedHost"(value: string)
get "hostHeader"(): string
set "hostHeader"(value: string)
get "forwardedHostHeader"(): string
set "forwardedServerHeader"(value: string)
get "forwardedForHeader"(): string
get "forwardedProtoHeader"(): string
set "forwardedProtoHeader"(value: string)
get "forwardedCipherSuiteHeader"(): string
set "proxyAsAuthority"(value: boolean)
set "forwardedHostHeader"(value: string)
set "forwardedForHeader"(value: string)
get "proxyAsAuthority"(): boolean
set "forwardedCipherSuiteHeader"(value: string)
get "forwardedHttpsHeader"(): string
set "forwardedSslSessionIdHeader"(value: string)
set "forwardedHttpsHeader"(value: string)
get "forwardedSslSessionIdHeader"(): string
get "forwardedServerHeader"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForwardedRequestCustomizer$Type = ($ForwardedRequestCustomizer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForwardedRequestCustomizer_ = $ForwardedRequestCustomizer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Accessor" {
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"

export interface $KProperty$Accessor<V> {

 "getProperty"(): $KProperty<(V)>

(): $KProperty<(V)>
}

export namespace $KProperty$Accessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty$Accessor$Type<V> = ($KProperty$Accessor<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty$Accessor_<V> = $KProperty$Accessor$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$TakeWhileSequence" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $TakeWhileSequence<T> implements $Sequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TakeWhileSequence$Type<T> = ($TakeWhileSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TakeWhileSequence_<T> = $TakeWhileSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Jetty" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Jetty {
static readonly "VERSION": string
static readonly "POWERED_BY": string
static readonly "STABLE": boolean


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Jetty$Type = ($Jetty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Jetty_ = $Jetty$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$IdleTimeout" {
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"

export class $IdleTimeout {

constructor(arg0: $Scheduler$Type)

public "isOpen"(): boolean
public "onClose"(): void
public "getIdleTimestamp"(): long
public "getIdleFor"(): long
public "onOpen"(): void
public "getScheduler"(): $Scheduler
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "notIdle"(): void
get "open"(): boolean
get "idleTimestamp"(): long
get "idleFor"(): long
get "scheduler"(): $Scheduler
set "idleTimeout"(value: long)
get "idleTimeout"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdleTimeout$Type = ($IdleTimeout);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdleTimeout_ = $IdleTimeout$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$ExternalResource" {
import {$AbstractFileResolvingResource, $AbstractFileResolvingResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractFileResolvingResource"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $ExternalResource extends $AbstractFileResolvingResource {

constructor(arg0: string)

public "getInputStream"(): $InputStream
public "getPath"(): string
public "exists"(): boolean
public "isDirectory"(): boolean
public "getURL"(): $URL
public "getDescription"(): string
public "getFilename"(): string
get "inputStream"(): $InputStream
get "path"(): string
get "directory"(): boolean
get "uRL"(): $URL
get "description"(): string
get "filename"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExternalResource$Type = ($ExternalResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExternalResource_ = $ExternalResource$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkZTXT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkTextVar, $PngChunkTextVar$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTextVar"

export class $PngChunkZTXT extends $PngChunkTextVar {
static readonly "ID": string
static readonly "KEY_Title": string
static readonly "KEY_Author": string
static readonly "KEY_Description": string
static readonly "KEY_Copyright": string
static readonly "KEY_Creation_Time": string
static readonly "KEY_Software": string
static readonly "KEY_Disclaimer": string
static readonly "KEY_Warning": string
static readonly "KEY_Source": string
static readonly "KEY_Comment": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkZTXT$Type = ($PngChunkZTXT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkZTXT_ = $PngChunkZTXT$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ReflectionFactory" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$KProperty1, $KProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1"
import {$KProperty2, $KProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2"
import {$Lambda, $Lambda$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Lambda"
import {$MutablePropertyReference0, $MutablePropertyReference0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference0"
import {$MutablePropertyReference1, $MutablePropertyReference1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference1"
import {$MutablePropertyReference2, $MutablePropertyReference2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference2"
import {$FunctionBase, $FunctionBase$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase"
import {$KClass, $KClass$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClass"
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$KTypeProjection, $KTypeProjection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection"
import {$KVariance, $KVariance$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PropertyReference2, $PropertyReference2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference2"
import {$FunctionReference, $FunctionReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionReference"
import {$PropertyReference0, $PropertyReference0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference0"
import {$PropertyReference1, $PropertyReference1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference1"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$KMutableProperty2, $KMutableProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2"
import {$KMutableProperty1, $KMutableProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1"
import {$KMutableProperty0, $KMutableProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0"
import {$KProperty0, $KProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0"

export class $ReflectionFactory {

constructor()

public "function"(arg0: $FunctionReference$Type): $KFunction<(any)>
public "mutableProperty2"(arg0: $MutablePropertyReference2$Type): $KMutableProperty2<(any), (any), (any)>
public "setUpperBounds"(arg0: $KTypeParameter$Type, arg1: $List$Type<($KType$Type)>): void
public "nothingType"(arg0: $KType$Type): $KType
public "createKotlinClass"(arg0: $Class$Type<(any)>, arg1: string): $KClass<(any)>
public "createKotlinClass"(arg0: $Class$Type<(any)>): $KClass<(any)>
public "property0"(arg0: $PropertyReference0$Type): $KProperty0<(any)>
public "mutableProperty0"(arg0: $MutablePropertyReference0$Type): $KMutableProperty0<(any)>
public "property1"(arg0: $PropertyReference1$Type): $KProperty1<(any), (any)>
public "property2"(arg0: $PropertyReference2$Type): $KProperty2<(any), (any), (any)>
public "mutableProperty1"(arg0: $MutablePropertyReference1$Type): $KMutableProperty1<(any), (any)>
public "typeOf"(arg0: $KClassifier$Type, arg1: $List$Type<($KTypeProjection$Type)>, arg2: boolean): $KType
public "platformType"(arg0: $KType$Type, arg1: $KType$Type): $KType
public "mutableCollectionType"(arg0: $KType$Type): $KType
public "typeParameter"(arg0: any, arg1: string, arg2: $KVariance$Type, arg3: boolean): $KTypeParameter
public "renderLambdaToString"(arg0: $Lambda$Type<(any)>): string
public "renderLambdaToString"(arg0: $FunctionBase$Type<(any)>): string
public "getOrCreateKotlinPackage"(arg0: $Class$Type<(any)>, arg1: string): $KDeclarationContainer
public "getOrCreateKotlinClass"(arg0: $Class$Type<(any)>): $KClass<(any)>
public "getOrCreateKotlinClass"(arg0: $Class$Type<(any)>, arg1: string): $KClass<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReflectionFactory$Type = ($ReflectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReflectionFactory_ = $ReflectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$MarkerIgnoringBase" {
import {$Marker, $Marker$Type} from "packages/info/journeymap/shaded/org/slf4j/$Marker"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$NamedLoggerBase, $NamedLoggerBase$Type} from "packages/info/journeymap/shaded/org/slf4j/helpers/$NamedLoggerBase"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export class $MarkerIgnoringBase extends $NamedLoggerBase implements $Logger {

constructor()

public "toString"(): string
public "info"(arg0: $Marker$Type, arg1: string): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "info"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "info"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "trace"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "trace"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "trace"(arg0: $Marker$Type, arg1: string): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "debug"(arg0: $Marker$Type, arg1: string): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "debug"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "debug"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "error"(arg0: $Marker$Type, arg1: string): void
public "error"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "error"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: $Throwable$Type): void
public "warn"(arg0: $Marker$Type, arg1: string): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any): void
public "warn"(arg0: $Marker$Type, arg1: string, arg2: any, arg3: any): void
public "warn"(arg0: $Marker$Type, arg1: string, ...arg2: (any)[]): void
public "isTraceEnabled"(arg0: $Marker$Type): boolean
public "isDebugEnabled"(arg0: $Marker$Type): boolean
public "isInfoEnabled"(arg0: $Marker$Type): boolean
public "isErrorEnabled"(arg0: $Marker$Type): boolean
public "isWarnEnabled"(arg0: $Marker$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MarkerIgnoringBase$Type = ($MarkerIgnoringBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MarkerIgnoringBase_ = $MarkerIgnoringBase$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$HttpMethodConstraintElement" {
import {$HttpConstraintElement, $HttpConstraintElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$HttpConstraintElement"

export class $HttpMethodConstraintElement extends $HttpConstraintElement {

constructor(arg0: string)
constructor(arg0: string, arg1: $HttpConstraintElement$Type)

public "getMethodName"(): string
get "methodName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpMethodConstraintElement$Type = ($HttpMethodConstraintElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpMethodConstraintElement_ = $HttpMethodConstraintElement$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$PushBuilderImpl" {
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$PushBuilder"

export class $PushBuilderImpl implements $PushBuilder {

constructor(arg0: $Request$Type, arg1: $HttpFields$Type, arg2: string, arg3: string, arg4: string, arg5: boolean)

public "method"(arg0: string): $PushBuilder
public "getMethod"(): string
public "path"(arg0: string): $PushBuilder
public "getPath"(): string
public "lastModified"(arg0: string): $PushBuilder
public "push"(): void
public "getLastModified"(): string
public "getHeader"(arg0: string): string
public "getQueryString"(): string
public "queryString"(arg0: string): $PushBuilder
public "etag"(arg0: string): $PushBuilder
public "addHeader"(arg0: string, arg1: string): $PushBuilder
public "conditional"(arg0: boolean): $PushBuilder
public "getSessionId"(): string
public "setHeader"(arg0: string, arg1: string): $PushBuilder
public "getHeaderNames"(): $Set<(string)>
public "sessionId"(arg0: string): $PushBuilder
public "removeHeader"(arg0: string): $PushBuilder
public "getEtag"(): string
public "isConditional"(): boolean
get "headerNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PushBuilderImpl$Type = ($PushBuilderImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PushBuilderImpl_ = $PushBuilderImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$InlineOnly" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $InlineOnly extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $InlineOnly {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InlineOnly$Type = ($InlineOnly);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InlineOnly_ = $InlineOnly$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Service$StaticFiles" {
import {$Service, $Service$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Service$StaticFiles {

constructor(arg0: $Service$Type)

public "registerMimeType"(arg0: string, arg1: string): void
public "location"(arg0: string): void
public "header"(arg0: string, arg1: string): void
public "headers"(arg0: $Map$Type<(string), (string)>): void
public "externalLocation"(arg0: string): void
public "expireTime"(arg0: long): void
public "disableMimeTypeGuessing"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Service$StaticFiles$Type = ($Service$StaticFiles);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Service$StaticFiles_ = $Service$StaticFiles$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$ScopedHandler, $ScopedHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ScopedHandler"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$MimeTypes, $MimeTypes$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MimeTypes"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Graceful, $Graceful$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Graceful"
import {$ContextHandler$AliasCheck, $ContextHandler$AliasCheck$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$AliasCheck"
import {$ContextHandler$Context, $ContextHandler$Context$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$Context"
import {$HandlerContainer, $HandlerContainer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HandlerContainer"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$List, $List$Type} from "packages/java/util/$List"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Attributes, $Attributes$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Attributes"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$ErrorHandler, $ErrorHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ErrorHandler"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ContextHandler extends $ScopedHandler implements $Attributes, $Graceful {
static readonly "SERVLET_MAJOR_VERSION": integer
static readonly "SERVLET_MINOR_VERSION": integer
static readonly "SERVLET_LISTENER_TYPES": ($Class<(any)>)[]
static readonly "DEFAULT_LISTENER_TYPE_INDEX": integer
static readonly "EXTENDED_LISTENER_TYPE_INDEX": integer
static readonly "MANAGED_ATTRIBUTES": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $HandlerContainer$Type, arg1: string)
constructor()
constructor(arg0: string)

public "getInitParameter"(arg0: string): string
public "setInitParameter"(arg0: string, arg1: string): string
public "getResourcePaths"(arg0: string): $Set<(string)>
public "shutdown"(): $Future<(void)>
public "loadClass"(arg0: string): $Class<(any)>
public "toString"(): string
public "getClassLoader"(): $ClassLoader
public "getResource"(arg0: string): $Resource
public "getLogger"(): $Logger
public "checkContext"(arg0: string, arg1: $Request$Type, arg2: $HttpServletResponse$Type): boolean
public "handle"(arg0: $Runnable$Type): void
public "handle"(arg0: $Request$Type, arg1: $Runnable$Type): void
public "getAttributes"(): $Attributes
public "isShutdown"(): boolean
public "getClassPath"(): string
public "getDisplayName"(): string
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "newResource"(arg0: $URL$Type): $Resource
public "newResource"(arg0: string): $Resource
public "newResource"(arg0: $URI$Type): $Resource
public "isAvailable"(): boolean
public "setDisplayName"(arg0: string): void
public "removeEventListener"(arg0: $EventListener$Type): void
public "getEventListeners"(): ($EventListener)[]
public "setEventListeners"(arg0: ($EventListener$Type)[]): void
public "addEventListener"(arg0: $EventListener$Type): void
public "setAttributes"(arg0: $Attributes$Type): void
public "setClassLoader"(arg0: $ClassLoader$Type): void
public "setContextPath"(arg0: string): void
public "getLocaleEncoding"(arg0: string): string
public "getLocaleEncoding"(arg0: $Locale$Type): string
public static "getCurrentContext"(): $ContextHandler$Context
public "removeAttribute"(arg0: string): void
public "setServer"(arg0: $Server$Type): void
public "setErrorHandler"(arg0: $ErrorHandler$Type): void
public "getErrorHandler"(): $ErrorHandler
public "getContextPath"(): string
public static "getServerInfo"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "getMimeTypes"(): $MimeTypes
public "setResourceBase"(arg0: string): void
public "getVirtualHosts"(): (string)[]
public "getServletContext"(): $ContextHandler$Context
public "clearAttributes"(): void
public static "getContextHandler"(arg0: $ServletContext$Type): $ContextHandler
public "getMaxFormKeys"(): integer
public "getMaxFormContentSize"(): integer
public "getAttributeNames"(): $Enumeration<(string)>
public "addVirtualHosts"(arg0: (string)[]): void
public "addAliasCheck"(arg0: $ContextHandler$AliasCheck$Type): void
public "getInitParams"(): $Map<(string), (string)>
public "setVirtualHosts"(arg0: (string)[]): void
public static "setServerInfo"(arg0: string): void
public "removeVirtualHosts"(arg0: (string)[]): void
public "checkContextPath"(arg0: string): boolean
public "checkVirtualHost"(arg0: $Request$Type): boolean
public "setAvailable"(arg0: boolean): void
public "setLogger"(arg0: $Logger$Type): void
public "getWelcomeFiles"(): (string)[]
public "getAliasChecks"(): $List<($ContextHandler$AliasCheck)>
public "setBaseResource"(arg0: $Resource$Type): void
public "getBaseResource"(): $Resource
public "setWelcomeFiles"(arg0: (string)[]): void
public "isProtectedTarget"(arg0: string): boolean
public "addLocaleEncoding"(arg0: string, arg1: string): void
public "checkAlias"(arg0: string, arg1: $Resource$Type): boolean
public "getResourceBase"(): string
public "isCompactPath"(): boolean
public "setCompactPath"(arg0: boolean): void
public "getLocaleEncodings"(): $Map<(string), (string)>
public "setMimeTypes"(arg0: $MimeTypes$Type): void
public "setMaxFormKeys"(arg0: integer): void
public "setAliasChecks"(arg0: $List$Type<($ContextHandler$AliasCheck$Type)>): void
public "clearAliasChecks"(): void
public "getContextPathEncoded"(): string
public "setUsingSecurityManager"(arg0: boolean): void
public "setProtectedTargets"(arg0: (string)[]): void
public "getProtectedTargets"(): (string)[]
public "setManagedAttribute"(arg0: string, arg1: any): void
public "getAllowNullPathInfo"(): boolean
public "setAllowNullPathInfo"(arg0: boolean): void
public "isUsingSecurityManager"(): boolean
public "setMaxFormContentSize"(arg0: integer): void
public "doHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "doScope"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "getInitParameterNames"(): $Enumeration<(string)>
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "classLoader"(): $ClassLoader
get "logger"(): $Logger
get "attributes"(): $Attributes
get "classPath"(): string
get "displayName"(): string
get "available"(): boolean
set "displayName"(value: string)
get "eventListeners"(): ($EventListener)[]
set "eventListeners"(value: ($EventListener$Type)[])
set "attributes"(value: $Attributes$Type)
set "classLoader"(value: $ClassLoader$Type)
set "contextPath"(value: string)
get "currentContext"(): $ContextHandler$Context
set "server"(value: $Server$Type)
set "errorHandler"(value: $ErrorHandler$Type)
get "errorHandler"(): $ErrorHandler
get "contextPath"(): string
get "serverInfo"(): string
get "mimeTypes"(): $MimeTypes
set "resourceBase"(value: string)
get "virtualHosts"(): (string)[]
get "servletContext"(): $ContextHandler$Context
get "maxFormKeys"(): integer
get "maxFormContentSize"(): integer
get "attributeNames"(): $Enumeration<(string)>
get "initParams"(): $Map<(string), (string)>
set "virtualHosts"(value: (string)[])
set "serverInfo"(value: string)
set "available"(value: boolean)
set "logger"(value: $Logger$Type)
get "welcomeFiles"(): (string)[]
get "aliasChecks"(): $List<($ContextHandler$AliasCheck)>
set "baseResource"(value: $Resource$Type)
get "baseResource"(): $Resource
set "welcomeFiles"(value: (string)[])
get "resourceBase"(): string
get "compactPath"(): boolean
set "compactPath"(value: boolean)
get "localeEncodings"(): $Map<(string), (string)>
set "mimeTypes"(value: $MimeTypes$Type)
set "maxFormKeys"(value: integer)
set "aliasChecks"(value: $List$Type<($ContextHandler$AliasCheck$Type)>)
get "contextPathEncoded"(): string
set "usingSecurityManager"(value: boolean)
set "protectedTargets"(value: (string)[])
get "protectedTargets"(): (string)[]
get "allowNullPathInfo"(): boolean
set "allowNullPathInfo"(value: boolean)
get "usingSecurityManager"(): boolean
set "maxFormContentSize"(value: integer)
get "initParameterNames"(): $Enumeration<(string)>
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextHandler$Type = ($ContextHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextHandler_ = $ContextHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/util/$QuoteUtil" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $QuoteUtil {
static readonly "ABNF_REQUIRED_QUOTING": string

constructor()

public static "dequote"(arg0: string): string
public static "join"(arg0: (any)[], arg1: string): string
public static "join"(arg0: $Collection$Type<(any)>, arg1: string): string
public static "quote"(arg0: $StringBuilder$Type, arg1: string): void
public static "escape"(arg0: $StringBuilder$Type, arg1: string): void
public static "unescape"(arg0: string): string
public static "quoteIfNeeded"(arg0: $StringBuilder$Type, arg1: string, arg2: string): void
public static "splitAt"(arg0: string, arg1: string): $Iterator<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuoteUtil$Type = ($QuoteUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuoteUtil_ = $QuoteUtil$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$ResourceFactory" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"

export interface $ResourceFactory {

 "getResource"(arg0: string): $Resource

(arg0: string): $Resource
}

export namespace $ResourceFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResourceFactory$Type = ($ResourceFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResourceFactory_ = $ResourceFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$EmptySet" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $EmptySet implements $Set<(any)>, $Serializable, $KMappedMarker {
static readonly "INSTANCE": $EmptySet


public "add"(arg0: void): boolean
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(any)>
public "contains"(arg0: void): boolean
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any): $Set<(any)>
public static "of"<E>(arg0: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any): $Set<(any)>
public static "of"<E>(...arg0: (any)[]): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any): $Set<(any)>
public static "of"<E>(): $Set<(any)>
public static "of"<E>(arg0: any, arg1: any): $Set<(any)>
public "spliterator"(): $Spliterator<(any)>
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(any)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(any)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptySet$Type = ($EmptySet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptySet_ = $EmptySet$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ServletRequestHttpWrapper" {
import {$HttpUpgradeHandler, $HttpUpgradeHandler$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler"
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletMapping, $HttpServletMapping$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletRequestWrapper, $ServletRequestWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestWrapper"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServletRequestHttpWrapper extends $ServletRequestWrapper implements $HttpServletRequest {

constructor(arg0: $ServletRequest$Type)

public "getMethod"(): string
public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $Enumeration<(string)>
public "authenticate"(arg0: $HttpServletResponse$Type): boolean
public "getRequestURI"(): string
public "getAuthType"(): string
public "getQueryString"(): string
public "isRequestedSessionIdValid"(): boolean
public "isRequestedSessionIdFromCookie"(): boolean
public "isRequestedSessionIdFromURL"(): boolean
public "isRequestedSessionIdFromUrl"(): boolean
public "getRequestedSessionId"(): string
public "getContextPath"(): string
public "getSession"(): $HttpSession
public "getSession"(arg0: boolean): $HttpSession
public "upgrade"<T extends $HttpUpgradeHandler>(arg0: $Class$Type<(T)>): T
public "getPathInfo"(): string
public "getHeaderNames"(): $Enumeration<(string)>
public "getIntHeader"(arg0: string): integer
public "getPathTranslated"(): string
public "isUserInRole"(arg0: string): boolean
public "getDateHeader"(arg0: string): long
public "getRemoteUser"(): string
public "getUserPrincipal"(): $Principal
public "getCookies"(): ($Cookie)[]
public "getRequestURL"(): $StringBuffer
public "changeSessionId"(): string
public "getServletPath"(): string
public "login"(arg0: string, arg1: string): void
public "logout"(): void
public "getParts"(): $Collection<($Part)>
public "getPart"(arg0: string): $Part
public "getHttpServletMapping"(): $HttpServletMapping
public "isTrailerFieldsReady"(): boolean
public "getTrailerFields"(): $Map<(string), (string)>
public "newPushBuilder"(): $PushBuilder
get "method"(): string
get "requestURI"(): string
get "authType"(): string
get "queryString"(): string
get "requestedSessionIdValid"(): boolean
get "requestedSessionIdFromCookie"(): boolean
get "requestedSessionIdFromURL"(): boolean
get "requestedSessionIdFromUrl"(): boolean
get "requestedSessionId"(): string
get "contextPath"(): string
get "session"(): $HttpSession
get "pathInfo"(): string
get "headerNames"(): $Enumeration<(string)>
get "pathTranslated"(): string
get "remoteUser"(): string
get "userPrincipal"(): $Principal
get "cookies"(): ($Cookie)[]
get "requestURL"(): $StringBuffer
get "servletPath"(): string
get "parts"(): $Collection<($Part)>
get "httpServletMapping"(): $HttpServletMapping
get "trailerFieldsReady"(): boolean
get "trailerFields"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestHttpWrapper$Type = ($ServletRequestHttpWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestHttpWrapper_ = $ServletRequestHttpWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequenceBuilderKt" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SequencesKt__SequenceBuilderKt {

constructor()

public static "iterator"<T>(arg0: $Function2$Type<(any), (any), (any)>): $Iterator<(T)>
public static "sequence"<T>(arg0: $Function2$Type<(any), (any), (any)>): $Sequence<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt__SequenceBuilderKt$Type = ($SequencesKt__SequenceBuilderKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt__SequenceBuilderKt_ = $SequencesKt__SequenceBuilderKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$KVariance, $KVariance$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"

export interface $KTypeParameter extends $KClassifier {

 "getName"(): string
 "isReified"(): boolean
 "getVariance"(): $KVariance
 "getUpperBounds"(): $List<($KType)>
}

export namespace $KTypeParameter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KTypeParameter$Type = ($KTypeParameter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KTypeParameter_ = $KTypeParameter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container$Listener" {
import {$Container, $Container$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container"

export interface $Container$Listener {

 "beanRemoved"(arg0: $Container$Type, arg1: any): void
 "beanAdded"(arg0: $Container$Type, arg1: any): void
}

export namespace $Container$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Container$Listener$Type = ($Container$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Container$Listener_ = $Container$Listener$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponseWrapper" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $ServletResponseWrapper implements $ServletResponse {

constructor(arg0: $ServletResponse$Type)

public "reset"(): void
public "flushBuffer"(): void
public "getLocale"(): $Locale
public "setLocale"(arg0: $Locale$Type): void
public "getContentType"(): string
public "getOutputStream"(): $ServletOutputStream
public "setContentType"(arg0: string): void
public "setContentLength"(arg0: integer): void
public "getResponse"(): $ServletResponse
public "getCharacterEncoding"(): string
public "setContentLengthLong"(arg0: long): void
public "setCharacterEncoding"(arg0: string): void
public "setBufferSize"(arg0: integer): void
public "getBufferSize"(): integer
public "getWriter"(): $PrintWriter
public "isCommitted"(): boolean
public "resetBuffer"(): void
public "setResponse"(arg0: $ServletResponse$Type): void
public "isWrapperFor"(arg0: $Class$Type<(any)>): boolean
public "isWrapperFor"(arg0: $ServletResponse$Type): boolean
get "locale"(): $Locale
set "locale"(value: $Locale$Type)
get "contentType"(): string
get "outputStream"(): $ServletOutputStream
set "contentType"(value: string)
set "contentLength"(value: integer)
get "response"(): $ServletResponse
get "characterEncoding"(): string
set "contentLengthLong"(value: long)
set "characterEncoding"(value: string)
set "bufferSize"(value: integer)
get "bufferSize"(): integer
get "writer"(): $PrintWriter
get "committed"(): boolean
set "response"(value: $ServletResponse$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletResponseWrapper$Type = ($ServletResponseWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletResponseWrapper_ = $ServletResponseWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ServletRequest {

 "getScheme"(): string
 "getInputStream"(): $ServletInputStream
 "getProtocol"(): string
 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
 "getLocale"(): $Locale
 "getContentLength"(): integer
 "getRealPath"(arg0: string): string
 "getContentLengthLong"(): long
 "getContentType"(): string
 "isSecure"(): boolean
 "getParameter"(arg0: string): string
 "getLocalName"(): string
 "getLocalPort"(): integer
 "removeAttribute"(arg0: string): void
 "getCharacterEncoding"(): string
 "setCharacterEncoding"(arg0: string): void
 "getRequestDispatcher"(arg0: string): $RequestDispatcher
 "getServerName"(): string
 "getReader"(): $BufferedReader
 "getDispatcherType"(): $DispatcherType
 "getServletContext"(): $ServletContext
 "isAsyncStarted"(): boolean
 "getRemotePort"(): integer
 "getParameterNames"(): $Enumeration<(string)>
 "getParameterValues"(arg0: string): (string)[]
 "getLocalAddr"(): string
 "startAsync"(): $AsyncContext
 "startAsync"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $AsyncContext
 "getRemoteAddr"(): string
 "getParameterMap"(): $Map<(string), ((string)[])>
 "getLocales"(): $Enumeration<($Locale)>
 "getRemoteHost"(): string
 "getServerPort"(): integer
 "isAsyncSupported"(): boolean
 "getAsyncContext"(): $AsyncContext
 "getAttributeNames"(): $Enumeration<(string)>
}

export namespace $ServletRequest {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequest$Type = ($ServletRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequest_ = $ServletRequest$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$AbstractSessionDataStore" {
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$SessionDataStore, $SessionDataStore$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStore"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"

export class $AbstractSessionDataStore extends $ContainerLifeCycle implements $SessionDataStore {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "toString"(): string
public "store"(arg0: string, arg1: $SessionData$Type): void
public "initialize"(arg0: $SessionContext$Type): void
public "doStore"(arg0: string, arg1: $SessionData$Type, arg2: long): void
public "setSavePeriodSec"(arg0: integer): void
public "getGracePeriodSec"(): integer
public "getSavePeriodSec"(): integer
public "doGetExpired"(arg0: $Set$Type<(string)>): $Set<(string)>
public "setGracePeriodSec"(arg0: integer): void
public "getExpired"(arg0: $Set$Type<(string)>): $Set<(string)>
public "newSessionData"(arg0: string, arg1: long, arg2: long, arg3: long, arg4: long): $SessionData
public "exists"(arg0: string): boolean
public "isPassivating"(): boolean
public "load"(arg0: string): $SessionData
public "delete"(arg0: string): boolean
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
set "savePeriodSec"(value: integer)
get "gracePeriodSec"(): integer
get "savePeriodSec"(): integer
set "gracePeriodSec"(value: integer)
get "passivating"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSessionDataStore$Type = ($AbstractSessionDataStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractSessionDataStore_ = $AbstractSessionDataStore$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function4" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function4<P1, P2, P3, P4, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4): R
}

export namespace $Function4 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function4$Type<P1, P2, P3, P4, R> = ($Function4<(P1), (P2), (P3), (P4), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function4_<P1, P2, P3, P4, R> = $Function4$Type<(P1), (P2), (P3), (P4), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function5" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function5<P1, P2, P3, P4, P5, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5): R
}

export namespace $Function5 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function5$Type<P1, P2, P3, P4, P5, R> = ($Function5<(P1), (P2), (P3), (P4), (P5), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function5_<P1, P2, P3, P4, P5, R> = $Function5$Type<(P1), (P2), (P3), (P4), (P5), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function2<P1, P2, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2): R

(arg0: P1, arg1: P2): R
}

export namespace $Function2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function2$Type<P1, P2, R> = ($Function2<(P1), (P2), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function2_<P1, P2, R> = $Function2$Type<(P1), (P2), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function3<P1, P2, P3, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3): R

(arg0: P1, arg1: P2, arg2: P3): R
}

export namespace $Function3 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function3$Type<P1, P2, P3, R> = ($Function3<(P1), (P2), (P3), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function3_<P1, P2, P3, R> = $Function3$Type<(P1), (P2), (P3), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function0<R> extends $Function<(R)> {

 "invoke"(): R

(): R
}

export namespace $Function0 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function0$Type<R> = ($Function0<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function0_<R> = $Function0$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function1<P1, R> extends $Function<(R)> {

 "invoke"(arg0: P1): R

(arg0: P1): R
}

export namespace $Function1 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function1$Type<P1, R> = ($Function1<(P1), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function1_<P1, R> = $Function1$Type<(P1), (R)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Authentication {

}

export namespace $Authentication {
const UNAUTHENTICATED: $Authentication
const NOT_CHECKED: $Authentication
const SEND_CONTINUE: $Authentication
const SEND_FAILURE: $Authentication
const SEND_SUCCESS: $Authentication
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authentication$Type = ($Authentication);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authentication_ = $Authentication$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function8" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function8<P1, P2, P3, P4, P5, P6, P7, P8, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8): R
}

export namespace $Function8 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function8$Type<P1, P2, P3, P4, P5, P6, P7, P8, R> = ($Function8<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function8_<P1, P2, P3, P4, P5, P6, P7, P8, R> = $Function8$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function9" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9): R
}

export namespace $Function9 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function9$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, R> = ($Function9<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function9_<P1, P2, P3, P4, P5, P6, P7, P8, P9, R> = $Function9$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function6" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function6<P1, P2, P3, P4, P5, P6, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6): R
}

export namespace $Function6 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function6$Type<P1, P2, P3, P4, P5, P6, R> = ($Function6<(P1), (P2), (P3), (P4), (P5), (P6), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function6_<P1, P2, P3, P4, P5, P6, R> = $Function6$Type<(P1), (P2), (P3), (P4), (P5), (P6), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$LazyKt" {
import {$LazyKt__LazyKt, $LazyKt__LazyKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$LazyKt__LazyKt"

export class $LazyKt extends $LazyKt__LazyKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyKt$Type = ($LazyKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyKt_ = $LazyKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function7" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function7<P1, P2, P3, P4, P5, P6, P7, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7): R
}

export namespace $Function7 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function7$Type<P1, P2, P3, P4, P5, P6, P7, R> = ($Function7<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function7_<P1, P2, P3, P4, P5, P6, P7, R> = $Function7$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (R)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$UnavailableException" {
import {$Servlet, $Servlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Servlet"
import {$ServletException, $ServletException$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletException"

export class $UnavailableException extends $ServletException {

constructor(arg0: string, arg1: integer)
constructor(arg0: string)
/**
 * 
 * @deprecated
 */
constructor(arg0: $Servlet$Type, arg1: string)
/**
 * 
 * @deprecated
 */
constructor(arg0: integer, arg1: $Servlet$Type, arg2: string)

/**
 * 
 * @deprecated
 */
public "getServlet"(): $Servlet
public "isPermanent"(): boolean
public "getUnavailableSeconds"(): integer
get "servlet"(): $Servlet
get "permanent"(): boolean
get "unavailableSeconds"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnavailableException$Type = ($UnavailableException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnavailableException_ = $UnavailableException$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkICCP" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkICCP extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getProfileName"(): string
public "getProfile"(): (byte)[]
public "getProfileAsString"(): string
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
public "setProfileNameAndContent"(arg0: string, arg1: string): void
public "setProfileNameAndContent"(arg0: string, arg1: (byte)[]): void
get "profileName"(): string
get "profile"(): (byte)[]
get "profileAsString"(): string
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkICCP$Type = ($PngChunkICCP);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkICCP_ = $PngChunkICCP$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$MappedResource" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"

export class $MappedResource<E> implements $Comparable<($MappedResource<(E)>)> {

constructor(arg0: $PathSpec$Type, arg1: E)

public "getPathSpec"(): $PathSpec
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $MappedResource$Type<(E)>): integer
public "getResource"(): E
get "pathSpec"(): $PathSpec
get "resource"(): E
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MappedResource$Type<E> = ($MappedResource<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MappedResource_<E> = $MappedResource$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkIDAT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$PngChunkMultiple, $PngChunkMultiple$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkMultiple"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PngChunkIDAT extends $PngChunkMultiple {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkIDAT$Type = ($PngChunkIDAT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkIDAT_ = $PngChunkIDAT$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ULong" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ULong$Companion, $ULong$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong$Companion"

export class $ULong implements $Comparable<($ULong)> {
static readonly "Companion": $ULong$Companion
static readonly "MIN_VALUE": long
static readonly "MAX_VALUE": long
static readonly "SIZE_BYTES": integer
static readonly "SIZE_BITS": integer


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "constructor-impl"(arg0: long): long
public static "equals-impl"(arg0: long, arg1: any): boolean
public static "hashCode-impl"(arg0: long): integer
public static "toString-impl"(arg0: long): string
public static "equals-impl0"(arg0: long, arg1: long): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULong$Type = ($ULong);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULong_ = $ULong$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput" {
import {$ReadableByteChannel, $ReadableByteChannel$Type} from "packages/java/nio/channels/$ReadableByteChannel"
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpContent, $HttpContent$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpContent"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$HttpOutput$Interceptor, $HttpOutput$Interceptor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput$Interceptor"
import {$WriteListener, $WriteListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$WriteListener"

export class $HttpOutput extends $ServletOutputStream implements $Runnable {

constructor(arg0: $HttpChannel$Type)

public "run"(): void
public "toString"(): string
public "flush"(): void
public "write"(arg0: integer): void
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "write"(arg0: $ByteBuffer$Type): void
public "print"(arg0: string): void
public "close"(): void
public "isReady"(): boolean
public "isClosed"(): boolean
public "recycle"(): void
public "isAsync"(): boolean
public "setBufferSize"(arg0: integer): void
public "getBufferSize"(): integer
public "isWritten"(): boolean
public "sendContent"(arg0: $InputStream$Type, arg1: $Callback$Type): void
public "sendContent"(arg0: $ByteBuffer$Type, arg1: $Callback$Type): void
public "sendContent"(arg0: $ReadableByteChannel$Type): void
public "sendContent"(arg0: $ByteBuffer$Type): void
public "sendContent"(arg0: $InputStream$Type): void
public "sendContent"(arg0: $HttpContent$Type): void
public "sendContent"(arg0: $HttpContent$Type, arg1: $Callback$Type): void
public "sendContent"(arg0: $ReadableByteChannel$Type, arg1: $Callback$Type): void
public "setInterceptor"(arg0: $HttpOutput$Interceptor$Type): void
public "getInterceptor"(): $HttpOutput$Interceptor
public "resetBuffer"(): void
public "getWritten"(): long
public "reopen"(): void
public "getHttpChannel"(): $HttpChannel
public "isAllContentWritten"(): boolean
public "setWriteListener"(arg0: $WriteListener$Type): void
get "ready"(): boolean
get "closed"(): boolean
get "async"(): boolean
set "bufferSize"(value: integer)
get "bufferSize"(): integer
get "written"(): boolean
set "interceptor"(value: $HttpOutput$Interceptor$Type)
get "interceptor"(): $HttpOutput$Interceptor
get "written"(): long
get "httpChannel"(): $HttpChannel
get "allContentWritten"(): boolean
set "writeListener"(value: $WriteListener$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpOutput$Type = ($HttpOutput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpOutput_ = $HttpOutput$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $Trie<V> {

 "remove"(arg0: string): V
 "get"(arg0: $ByteBuffer$Type): V
 "get"(arg0: string): V
 "get"(arg0: string, arg1: integer, arg2: integer): V
 "get"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
 "put"(arg0: string, arg1: V): boolean
 "put"(arg0: V): boolean
 "clear"(): void
 "keySet"(): $Set<(string)>
 "isFull"(): boolean
 "getBest"(arg0: string): V
 "getBest"(arg0: string, arg1: integer, arg2: integer): V
 "getBest"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
 "getBest"(arg0: (byte)[], arg1: integer, arg2: integer): V
 "isCaseInsensitive"(): boolean
}

export namespace $Trie {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Trie$Type<V> = ($Trie<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Trie_<V> = $Trie$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$OnWebSocketFrame" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OnWebSocketFrame extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OnWebSocketFrame {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnWebSocketFrame$Type = ($OnWebSocketFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnWebSocketFrame_ = $OnWebSocketFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CombinedContext" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export class $CombinedContext implements $CoroutineContext, $Serializable {

constructor(arg0: $CoroutineContext$Type, arg1: $CoroutineContext$Element$Type)

public "get"<E extends $CoroutineContext$Element>(arg0: $CoroutineContext$Key$Type<(E)>): E
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "plus"(arg0: $CoroutineContext$Type): $CoroutineContext
public "minusKey"(arg0: $CoroutineContext$Key$Type<(any)>): $CoroutineContext
public "fold"<R>(arg0: R, arg1: $Function2$Type<(any), (any), (any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombinedContext$Type = ($CombinedContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombinedContext_ = $CombinedContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$NoBodyResponse" {
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$HttpServletResponseWrapper, $HttpServletResponseWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponseWrapper"

export class $NoBodyResponse extends $HttpServletResponseWrapper {


public "getOutputStream"(): $ServletOutputStream
public "setContentLength"(arg0: integer): void
public "setContentLengthLong"(arg0: long): void
public "getWriter"(): $PrintWriter
public "addHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: string, arg1: string): void
public "setIntHeader"(arg0: string, arg1: integer): void
public "addIntHeader"(arg0: string, arg1: integer): void
get "outputStream"(): $ServletOutputStream
set "contentLength"(value: integer)
set "contentLengthLong"(value: long)
get "writer"(): $PrintWriter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoBodyResponse$Type = ($NoBodyResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoBodyResponse_ = $NoBodyResponse$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$GzipUtils" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $GzipUtils {


public static "checkAndWrap"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type, arg2: boolean): $OutputStream
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GzipUtils$Type = ($GzipUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GzipUtils_ = $GzipUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$Connection$Listener, $Connection$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$Listener"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export interface $Connection extends $Closeable {

 "getCreatedTimeStamp"(): long
 "close"(): void
 "onClose"(): void
 "onIdleExpired"(): boolean
 "removeListener"(arg0: $Connection$Listener$Type): void
 "onOpen"(): void
 "addListener"(arg0: $Connection$Listener$Type): void
 "getEndPoint"(): $EndPoint
 "getBytesIn"(): long
 "getMessagesIn"(): long
 "getMessagesOut"(): long
 "getBytesOut"(): long
}

export namespace $Connection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Connection$Type = ($Connection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Connection_ = $Connection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$MetaData$Request, $MetaData$Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$HttpServletMapping, $HttpServletMapping$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping"
import {$HttpInput, $HttpInput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$ContextHandler$Context, $ContextHandler$Context$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$Context"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$HttpURI, $HttpURI$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpURI"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Response"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"
import {$HttpUpgradeHandler, $HttpUpgradeHandler$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler"
import {$Attributes, $Attributes$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Attributes"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$MultiMap, $MultiMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiMap"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$PushBuilder as $PushBuilder$0, $PushBuilder$Type as $PushBuilder$0$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$PushBuilder"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Request implements $HttpServletRequest {
static readonly "__MULTIPART_CONFIG_ELEMENT": string
static readonly "__MULTIPART_INPUT_STREAM": string
static readonly "__MULTIPART_CONTEXT": string

constructor(arg0: $HttpChannel$Type, arg1: $HttpInput$Type)

public "toString"(): string
public "getMethod"(): string
public "getContext"(): $ContextHandler$Context
public "getScheme"(): string
public "getInputStream"(): $ServletInputStream
public "getProtocol"(): string
public "getAttributes"(): $Attributes
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "getLocale"(): $Locale
public "setMethod"(arg0: string): void
public "getHeader"(arg0: string): string
public "getContentLength"(): integer
public "getRealPath"(arg0: string): string
public "getContentLengthLong"(): long
public "getContentType"(): string
public "getHeaders"(arg0: string): $Enumeration<(string)>
public "setContentType"(arg0: string): void
public "isSecure"(): boolean
public "getResponse"(): $Response
public "authenticate"(arg0: $HttpServletResponse$Type): boolean
public "getParameter"(arg0: string): string
public "getRequestURI"(): string
public "getLocalName"(): string
public "getInputState"(): integer
public "removeEventListener"(arg0: $EventListener$Type): void
public "addEventListener"(arg0: $EventListener$Type): void
public "isHead"(): boolean
public "getLocalPort"(): integer
public "getAuthType"(): string
public "setAttributes"(arg0: $Attributes$Type): void
public "setScheme"(arg0: string): void
public "setQueryString"(arg0: string): void
public "getQueryString"(): string
public "setQueryParameters"(arg0: $MultiMap$Type<(string)>): void
public "resetParameters"(): void
public "setAuthority"(arg0: string, arg1: integer): void
public "getServletName"(): string
public "getServletResponse"(): $ServletResponse
public "getRootURL"(): $StringBuilder
public "getQueryEncoding"(): string
public "setAsyncSupported"(arg0: boolean, arg1: string): void
public "getSessionHandler"(): $SessionHandler
public "setQueryEncoding"(arg0: string): void
public "takeNewContext"(): boolean
public "getMetaData"(): $MetaData$Request
public "setCookies"(arg0: ($Cookie$Type)[]): void
public "getUserIdentity"(): $UserIdentity
public "setSecure"(arg0: boolean): void
public "setContextPath"(arg0: string): void
public "getOriginalURI"(): string
public "setHttpURI"(arg0: $HttpURI$Type): void
public "setSession"(arg0: $HttpSession$Type): void
public "setSessionHandler"(arg0: $SessionHandler$Type): void
public "setServletPath"(arg0: string): void
public "setHttpVersion"(arg0: $HttpVersion$Type): void
public "setRemoteAddr"(arg0: $InetSocketAddress$Type): void
public "isHandled"(): boolean
public "removeAttribute"(arg0: string): void
public "getQueryParameters"(): $MultiMap<(string)>
public "getCharacterEncoding"(): string
public "isRequestedSessionIdValid"(): boolean
public "setCharacterEncoding"(arg0: string): void
public "isRequestedSessionIdFromCookie"(): boolean
public "isRequestedSessionIdFromURL"(): boolean
public "mergeQueryParameters"(arg0: string, arg1: string, arg2: boolean): void
public "isRequestedSessionIdFromUrl"(): boolean
public "getRequestedSessionId"(): string
public "getRequestDispatcher"(arg0: string): $RequestDispatcher
public "getHttpChannelState"(): $HttpChannelState
public "getServerName"(): string
public "getContextPath"(): string
public "getTimeStamp"(): long
public "setTimeStamp"(arg0: long): void
public "getReader"(): $BufferedReader
public "getSession"(arg0: boolean): $HttpSession
public "getSession"(): $HttpSession
public "setContext"(arg0: $ContextHandler$Context$Type): void
public "upgrade"<T extends $HttpUpgradeHandler>(arg0: $Class$Type<(T)>): T
public "getPathInfo"(): string
public "getDispatcherType"(): $DispatcherType
public "setURIPathQuery"(arg0: string): void
public "getHttpURI"(): $HttpURI
public "getServletContext"(): $ServletContext
public "isAsyncStarted"(): boolean
public "setPathInfo"(arg0: string): void
public "getHeaderNames"(): $Enumeration<(string)>
public "getIntHeader"(arg0: string): integer
public "getPathTranslated"(): string
public "isUserInRole"(arg0: string): boolean
public "getDateHeader"(arg0: string): long
public "getRemoteUser"(): string
public "getUserPrincipal"(): $Principal
public "getCookies"(): ($Cookie)[]
public "getRequestURL"(): $StringBuffer
public "changeSessionId"(): string
public "getServletPath"(): string
public "getRemotePort"(): integer
public "getParameterNames"(): $Enumeration<(string)>
public "getParameterValues"(arg0: string): (string)[]
public "getLocalAddr"(): string
public "startAsync"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $AsyncContext
public "startAsync"(): $AsyncContext
public "getRemoteAddr"(): string
public "getParameterMap"(): $Map<(string), ((string)[])>
public "getLocales"(): $Enumeration<($Locale)>
public "getRemoteHost"(): string
public "getServerPort"(): integer
public "isAsyncSupported"(): boolean
public "getAsyncContext"(): $AsyncContext
public "getHttpVersion"(): $HttpVersion
public "hasMetaData"(): boolean
public "setHandled"(arg0: boolean): void
public "setDispatcherType"(arg0: $DispatcherType$Type): void
public "getHttpInput"(): $HttpInput
public "getHttpFields"(): $HttpFields
public "setTrailers"(arg0: $HttpFields$Type): void
public "setMetaData"(arg0: $MetaData$Request$Type): void
public static "getBaseRequest"(arg0: $ServletRequest$Type): $Request
public "getHttpChannel"(): $HttpChannel
public "isPushSupported"(): boolean
public "getTrailers"(): $HttpFields
public "isPush"(): boolean
public "getPushBuilder"(): $PushBuilder$0
public "login"(arg0: string, arg1: string): void
public "logout"(): void
public "getUserIdentityScope"(): $UserIdentity$Scope
public "setRequestedSessionId"(arg0: string): void
public "setUserIdentityScope"(arg0: $UserIdentity$Scope$Type): void
public "setCharacterEncodingUnchecked"(arg0: string): void
public "getRemoteInetSocketAddress"(): $InetSocketAddress
public "extractFormParameters"(arg0: $MultiMap$Type<(string)>): void
public "setContentParameters"(arg0: $MultiMap$Type<(string)>): void
public "setRequestedSessionIdFromCookie"(arg0: boolean): void
public "getResolvedUserIdentity"(): $UserIdentity
public "getAttributeNames"(): $Enumeration<(string)>
public "getParts"(): $Collection<($Part)>
public "getAuthentication"(): $Authentication
public "setAuthentication"(arg0: $Authentication$Type): void
public "getContentRead"(): long
public "getPart"(arg0: string): $Part
public "getHttpServletMapping"(): $HttpServletMapping
public "isTrailerFieldsReady"(): boolean
public "getTrailerFields"(): $Map<(string), (string)>
public "newPushBuilder"(): $PushBuilder
get "method"(): string
get "context"(): $ContextHandler$Context
get "scheme"(): string
get "inputStream"(): $ServletInputStream
get "protocol"(): string
get "attributes"(): $Attributes
get "locale"(): $Locale
set "method"(value: string)
get "contentLength"(): integer
get "contentLengthLong"(): long
get "contentType"(): string
set "contentType"(value: string)
get "secure"(): boolean
get "response"(): $Response
get "requestURI"(): string
get "localName"(): string
get "inputState"(): integer
get "head"(): boolean
get "localPort"(): integer
get "authType"(): string
set "attributes"(value: $Attributes$Type)
set "scheme"(value: string)
set "queryString"(value: string)
get "queryString"(): string
set "queryParameters"(value: $MultiMap$Type<(string)>)
get "servletName"(): string
get "servletResponse"(): $ServletResponse
get "rootURL"(): $StringBuilder
get "queryEncoding"(): string
get "sessionHandler"(): $SessionHandler
set "queryEncoding"(value: string)
get "metaData"(): $MetaData$Request
set "cookies"(value: ($Cookie$Type)[])
get "userIdentity"(): $UserIdentity
set "secure"(value: boolean)
set "contextPath"(value: string)
get "originalURI"(): string
set "httpURI"(value: $HttpURI$Type)
set "session"(value: $HttpSession$Type)
set "sessionHandler"(value: $SessionHandler$Type)
set "servletPath"(value: string)
set "httpVersion"(value: $HttpVersion$Type)
set "remoteAddr"(value: $InetSocketAddress$Type)
get "handled"(): boolean
get "queryParameters"(): $MultiMap<(string)>
get "characterEncoding"(): string
get "requestedSessionIdValid"(): boolean
set "characterEncoding"(value: string)
get "requestedSessionIdFromCookie"(): boolean
get "requestedSessionIdFromURL"(): boolean
get "requestedSessionIdFromUrl"(): boolean
get "requestedSessionId"(): string
get "httpChannelState"(): $HttpChannelState
get "serverName"(): string
get "contextPath"(): string
get "timeStamp"(): long
set "timeStamp"(value: long)
get "reader"(): $BufferedReader
get "session"(): $HttpSession
set "context"(value: $ContextHandler$Context$Type)
get "pathInfo"(): string
get "dispatcherType"(): $DispatcherType
set "uRIPathQuery"(value: string)
get "httpURI"(): $HttpURI
get "servletContext"(): $ServletContext
get "asyncStarted"(): boolean
set "pathInfo"(value: string)
get "headerNames"(): $Enumeration<(string)>
get "pathTranslated"(): string
get "remoteUser"(): string
get "userPrincipal"(): $Principal
get "cookies"(): ($Cookie)[]
get "requestURL"(): $StringBuffer
get "servletPath"(): string
get "remotePort"(): integer
get "parameterNames"(): $Enumeration<(string)>
get "localAddr"(): string
get "remoteAddr"(): string
get "parameterMap"(): $Map<(string), ((string)[])>
get "locales"(): $Enumeration<($Locale)>
get "remoteHost"(): string
get "serverPort"(): integer
get "asyncSupported"(): boolean
get "asyncContext"(): $AsyncContext
get "httpVersion"(): $HttpVersion
set "handled"(value: boolean)
set "dispatcherType"(value: $DispatcherType$Type)
get "httpInput"(): $HttpInput
get "httpFields"(): $HttpFields
set "trailers"(value: $HttpFields$Type)
set "metaData"(value: $MetaData$Request$Type)
get "httpChannel"(): $HttpChannel
get "pushSupported"(): boolean
get "trailers"(): $HttpFields
get "push"(): boolean
get "pushBuilder"(): $PushBuilder$0
get "userIdentityScope"(): $UserIdentity$Scope
set "requestedSessionId"(value: string)
set "userIdentityScope"(value: $UserIdentity$Scope$Type)
set "characterEncodingUnchecked"(value: string)
get "remoteInetSocketAddress"(): $InetSocketAddress
set "contentParameters"(value: $MultiMap$Type<(string)>)
set "requestedSessionIdFromCookie"(value: boolean)
get "resolvedUserIdentity"(): $UserIdentity
get "attributeNames"(): $Enumeration<(string)>
get "parts"(): $Collection<($Part)>
get "authentication"(): $Authentication
set "authentication"(value: $Authentication$Type)
get "contentRead"(): long
get "httpServletMapping"(): $HttpServletMapping
get "trailerFieldsReady"(): boolean
get "trailerFields"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Request$Type = ($Request);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Request_ = $Request$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $MultiException extends $Exception {

constructor()

public "add"(arg0: $Throwable$Type): void
public "toString"(): string
public "size"(): integer
public "getThrowables"(): $List<($Throwable)>
public "getThrowable"(arg0: integer): $Throwable
public "ifExceptionThrow"(): void
public "ifExceptionThrowRuntime"(): void
public "ifExceptionThrowMulti"(): void
get "throwables"(): $List<($Throwable)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiException$Type = ($MultiException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiException_ = $MultiException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$URIUtil" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $URIUtil implements $Cloneable {
static readonly "SLASH": string
static readonly "HTTP": string
static readonly "HTTPS": string
static readonly "__CHARSET": $Charset


public static "newURI"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: string): string
public static "encodeString"(arg0: $StringBuilder$Type, arg1: string, arg2: string): $StringBuilder
public static "newURIBuilder"(arg0: string, arg1: string, arg2: integer): $StringBuilder
public static "decodePath"(arg0: string): string
public static "decodePath"(arg0: string, arg1: integer, arg2: integer): string
public static "equalsIgnoreEncodings"(arg0: $URI$Type, arg1: $URI$Type): boolean
public static "equalsIgnoreEncodings"(arg0: string, arg1: string): boolean
public static "encodePath"(arg0: string): string
public static "encodePath"(arg0: $StringBuilder$Type, arg1: string): $StringBuilder
public static "addDecodedPath"(arg0: $URI$Type, arg1: string): $URI
public static "compactPath"(arg0: string): string
public static "hasScheme"(arg0: string): boolean
public static "parentPath"(arg0: string): string
public static "addPaths"(arg0: string, arg1: string): string
public static "canonicalPath"(arg0: string): string
public static "appendSchemeHostPort"(arg0: $StringBuffer$Type, arg1: string, arg2: string, arg3: integer): void
public static "appendSchemeHostPort"(arg0: $StringBuilder$Type, arg1: string, arg2: string, arg3: integer): void
public static "getJarSource"(arg0: string): string
public static "getJarSource"(arg0: $URI$Type): $URI
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $URIUtil$Type = ($URIUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $URIUtil_ = $URIUtil$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Spark" {
import {$ResponseTransformer, $ResponseTransformer$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer"
import {$TemplateEngine, $TemplateEngine$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ModelAndView, $ModelAndView$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ModelAndView"
import {$Service$StaticFiles, $Service$StaticFiles$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service$StaticFiles"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Redirect, $Redirect$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Redirect"
import {$HaltException, $HaltException$Type} from "packages/info/journeymap/shaded/kotlin/spark/$HaltException"
import {$RouteGroup, $RouteGroup$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteGroup"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Filter"
import {$Route, $Route$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Route"
import {$TemplateViewRoute, $TemplateViewRoute$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateViewRoute"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$ExceptionHandler, $ExceptionHandler$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandler"

export class $Spark {
static readonly "redirect": $Redirect
static readonly "staticFiles": $Service$StaticFiles


public static "get"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "get"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "get"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "get"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "get"(arg0: string, arg1: $Route$Type): void
public static "get"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "put"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "put"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "put"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "put"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "put"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "put"(arg0: string, arg1: $Route$Type): void
public static "init"(): void
public static "trace"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "trace"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "trace"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "trace"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "trace"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "trace"(arg0: string, arg1: $Route$Type): void
public static "exception"<T extends $Exception>(arg0: $Class$Type<(T)>, arg1: $ExceptionHandler$Type<(any)>): void
public static "delete"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "delete"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "delete"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "delete"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "delete"(arg0: string, arg1: $Route$Type): void
public static "delete"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "connect"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "connect"(arg0: string, arg1: $Route$Type): void
public static "connect"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "connect"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "connect"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "connect"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "port"(): integer
public static "port"(arg0: integer): void
public static "stop"(): void
public static "path"(arg0: string, arg1: $RouteGroup$Type): void
public static "options"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "options"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "options"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "options"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "options"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "options"(arg0: string, arg1: $Route$Type): void
public static "before"(arg0: string, arg1: $Filter$Type): void
public static "before"(arg0: string, ...arg1: ($Filter$Type)[]): void
public static "before"(arg0: string, arg1: string, ...arg2: ($Filter$Type)[]): void
public static "before"(...arg0: ($Filter$Type)[]): void
public static "after"(arg0: string, ...arg1: ($Filter$Type)[]): void
public static "after"(arg0: string, arg1: $Filter$Type): void
public static "after"(...arg0: ($Filter$Type)[]): void
public static "after"(arg0: string, arg1: string, ...arg2: ($Filter$Type)[]): void
public static "halt"(arg0: string): $HaltException
public static "halt"(arg0: integer, arg1: string): $HaltException
public static "halt"(arg0: integer): $HaltException
public static "halt"(): $HaltException
public static "head"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "head"(arg0: string, arg1: $Route$Type): void
public static "head"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "head"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "head"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "head"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "patch"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "patch"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "patch"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "patch"(arg0: string, arg1: $Route$Type): void
public static "patch"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "patch"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "post"(arg0: string, arg1: string, arg2: $Route$Type): void
public static "post"(arg0: string, arg1: $Route$Type): void
public static "post"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): void
public static "post"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): void
public static "post"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): void
public static "post"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): void
public static "secure"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: boolean): void
public static "secure"(arg0: string, arg1: string, arg2: string, arg3: string): void
public static "setSecure"(arg0: string, arg1: string, arg2: string, arg3: string): void
public static "ipAddress"(arg0: string): void
public static "notFound"(arg0: string): void
public static "notFound"(arg0: $Route$Type): void
public static "staticFileLocation"(arg0: string): void
public static "modelAndView"(arg0: any, arg1: string): $ModelAndView
public static "threadPool"(arg0: integer): void
public static "threadPool"(arg0: integer, arg1: integer, arg2: integer): void
public static "afterAfter"(arg0: string, arg1: $Filter$Type): void
public static "afterAfter"(arg0: $Filter$Type): void
public static "setIpAddress"(arg0: string): void
public static "setPort"(arg0: integer): void
public static "webSocket"(arg0: string, arg1: $Class$Type<(any)>): void
public static "webSocket"(arg0: string, arg1: any): void
public static "initExceptionHandler"(arg0: $Consumer$Type<($Exception$Type)>): void
public static "webSocketIdleTimeoutMillis"(arg0: integer): void
public static "internalServerError"(arg0: $Route$Type): void
public static "internalServerError"(arg0: string): void
public static "externalStaticFileLocation"(arg0: string): void
public static "awaitInitialization"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Spark$Type = ($Spark);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Spark_ = $Spark$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/globalstate/$ServletFlag" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ServletFlag {

constructor()

public static "runFromServlet"(): void
public static "isRunningFromServlet"(): boolean
get "runningFromServlet"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletFlag$Type = ($ServletFlag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletFlag_ = $ServletFlag$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DateCache" {
import {$DateCache$Tick, $DateCache$Tick$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DateCache$Tick"
import {$Date, $Date$Type} from "packages/java/util/$Date"
import {$TimeZone, $TimeZone$Type} from "packages/java/util/$TimeZone"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $DateCache {
static readonly "DEFAULT_FORMAT": string

constructor(arg0: string, arg1: $Locale$Type, arg2: $TimeZone$Type)
constructor(arg0: string, arg1: $Locale$Type, arg2: string)
constructor(arg0: string, arg1: $Locale$Type)
constructor(arg0: string)
constructor()

public "format"(arg0: $Date$Type): string
public "format"(arg0: long): string
public "now"(): string
public "getTimeZone"(): $TimeZone
public "tick"(): $DateCache$Tick
public "formatNow"(arg0: long): string
public "getFormatString"(): string
get "timeZone"(): $TimeZone
get "formatString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DateCache$Type = ($DateCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DateCache_ = $DateCache$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractResourceHandler" {
import {$AbstractFileResolvingResource, $AbstractFileResolvingResource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractFileResolvingResource"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $AbstractResourceHandler {

constructor()

public "getResource"(arg0: $HttpServletRequest$Type): $AbstractFileResolvingResource
public static "addPaths"(arg0: string, arg1: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractResourceHandler$Type = ($AbstractResourceHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractResourceHandler_ = $AbstractResourceHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedMetadata" {
import {$OptionalSessionCallableMethod, $OptionalSessionCallableMethod$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$OptionalSessionCallableMethod"
import {$CallableMethod, $CallableMethod$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$CallableMethod"

export class $JettyAnnotatedMetadata {
 "onConnect": $CallableMethod
 "onBinary": $OptionalSessionCallableMethod
 "onText": $OptionalSessionCallableMethod
 "onFrame": $OptionalSessionCallableMethod
 "onError": $OptionalSessionCallableMethod
 "onClose": $OptionalSessionCallableMethod

constructor()

public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyAnnotatedMetadata$Type = ($JettyAnnotatedMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyAnnotatedMetadata_ = $JettyAnnotatedMetadata$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt" {
import {$ArraysKt___ArraysKt, $ArraysKt___ArraysKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt___ArraysKt"

export class $ArraysKt extends $ArraysKt___ArraysKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysKt$Type = ($ArraysKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysKt_ = $ArraysKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$QueryParamsMap" {
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $QueryParamsMap {

constructor(arg0: $HttpServletRequest$Type)

public "get"(...arg0: (string)[]): $QueryParamsMap
public "value"(): string
public "value"(...arg0: (string)[]): string
public "values"(): (string)[]
public "booleanValue"(): boolean
public "longValue"(): long
public "floatValue"(): float
public "doubleValue"(): double
public "toMap"(): $Map<(string), ((string)[])>
public "hasValue"(): boolean
public "integerValue"(): integer
public "hasKeys"(): boolean
public "hasKey"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QueryParamsMap$Type = ($QueryParamsMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QueryParamsMap_ = $QueryParamsMap$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$PathMap$MappedEntry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $PathMap$MappedEntry<O> implements $Map$Entry<(string), (O)> {


public "getMapped"(): string
public "toString"(): string
public "getValue"(): O
public "setValue"(arg0: O): O
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(string), (O)>
public static "comparingByKey"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(string), (O)>)>
public static "comparingByKey"<K extends $Comparable<(any)>, V>(): $Comparator<($Map$Entry<(string), (O)>)>
public static "comparingByValue"<K, V extends $Comparable<(any)>>(): $Comparator<($Map$Entry<(string), (O)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(string), (O)>)>
get "mapped"(): string
get "value"(): O
set "value"(value: O)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathMap$MappedEntry$Type<O> = ($PathMap$MappedEntry<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathMap$MappedEntry_<O> = $PathMap$MappedEntry$Type<(O)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$UProgressionUtilKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UProgressionUtilKt {


public static "getProgressionLastElement-7ftBX0g"(arg0: long, arg1: long, arg2: long): long
public static "getProgressionLastElement-Nkh28Cs"(arg0: integer, arg1: integer, arg2: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UProgressionUtilKt$Type = ($UProgressionUtilKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UProgressionUtilKt_ = $UProgressionUtilKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$WriteListener" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"

export interface $WriteListener extends $EventListener {

 "onError"(arg0: $Throwable$Type): void
 "onWritePossible"(): void
}

export namespace $WriteListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WriteListener$Type = ($WriteListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WriteListener_ = $WriteListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$EntryRef" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$KMutableMap$Entry, $KMutableMap$Entry$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableMap$Entry"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapBuilder$EntryRef<K, V> implements $Map$Entry<(K), (V)>, $KMutableMap$Entry {

constructor(arg0: $MapBuilder$Type<(K), (V)>, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): V
public "getKey"(): K
public "setValue"(arg0: V): V
public static "copyOf"<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
public static "comparingByKey"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
public static "comparingByKey"<K extends $Comparable<(any)>, V>(): $Comparator<($Map$Entry<(K), (V)>)>
public static "comparingByValue"<K, V extends $Comparable<(any)>>(): $Comparator<($Map$Entry<(K), (V)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
get "value"(): V
get "key"(): K
set "value"(value: V)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$EntryRef$Type<K, V> = ($MapBuilder$EntryRef<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder$EntryRef_<K, V> = $MapBuilder$EntryRef$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ULongArray" {
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $ULongArray implements $Collection<($ULong)>, $KMappedMarker {


public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<($ULong)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "constructor-impl"(arg0: (long)[]): (long)[]
public static "constructor-impl"(arg0: integer): (long)[]
public static "getSize-impl"(arg0: (long)[]): integer
public static "contains-VKZWuLQ"(arg0: (long)[], arg1: long): boolean
public "contains-VKZWuLQ"(arg0: long): boolean
public static "equals-impl"(arg0: (long)[], arg1: any): boolean
public static "containsAll-impl"(arg0: (long)[], arg1: $Collection$Type<($ULong$Type)>): boolean
public "add-VKZWuLQ"(arg0: long): boolean
public static "hashCode-impl"(arg0: (long)[]): integer
public static "iterator-impl"(arg0: (long)[]): $Iterator<($ULong)>
public static "get-s-VKNKU"(arg0: (long)[], arg1: integer): long
public static "set-k8EXiF4"(arg0: (long)[], arg1: integer, arg2: long): void
public static "toString-impl"(arg0: (long)[]): string
public static "isEmpty-impl"(arg0: (long)[]): boolean
public static "equals-impl0"(arg0: (long)[], arg1: (long)[]): boolean
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<($ULong)>
public "spliterator"(): $Spliterator<($ULong)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<($ULong)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ULong>;
get "empty"(): boolean
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongArray$Type = ($ULongArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongArray_ = $ULongArray$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilderKeys" {
import {$AbstractMutableSet, $AbstractMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$KMutableSet, $KMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $MapBuilderKeys<E> extends $AbstractMutableSet<(E)> implements $Set<(E)>, $KMutableSet {

constructor(arg0: $MapBuilder$Type<(E), (any)>)

public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilderKeys$Type<E> = ($MapBuilderKeys<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilderKeys_<E> = $MapBuilderKeys$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Invocable, $Invocable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $Callback extends $Invocable {

 "succeeded"(): void
 "failed"(arg0: $Throwable$Type): void
 "getInvocationType"(): $Invocable$InvocationType
}

export namespace $Callback {
const NOOP: $Callback
function from(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
function from(arg0: $CompletableFuture$Type<(any)>): $Callback
function getInvocationType(arg0: any): $Invocable$InvocationType
function asPreferred(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
function invokePreferred(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
function invokeNonBlocking(arg0: $Runnable$Type): void
function isNonBlockingInvocation(): boolean
function invokePreferNonBlocking(arg0: $Runnable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Callback$Type = ($Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Callback_ = $Callback$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent" {
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$EventObject, $EventObject$Type} from "packages/java/util/$EventObject"

export class $HttpSessionEvent extends $EventObject {

constructor(arg0: $HttpSession$Type)

public "getSession"(): $HttpSession
get "session"(): $HttpSession
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionEvent$Type = ($HttpSessionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionEvent_ = $HttpSessionEvent$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ServletResponseHttpWrapper" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$ServletResponseWrapper, $ServletResponseWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponseWrapper"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServletResponseHttpWrapper extends $ServletResponseWrapper implements $HttpServletResponse {

constructor(arg0: $ServletResponse$Type)

public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $Collection<(string)>
public "sendError"(arg0: integer): void
public "sendError"(arg0: integer, arg1: string): void
public "setStatus"(arg0: integer, arg1: string): void
public "setStatus"(arg0: integer): void
public "getStatus"(): integer
public "addHeader"(arg0: string, arg1: string): void
public "setHeader"(arg0: string, arg1: string): void
public "sendRedirect"(arg0: string): void
public "setIntHeader"(arg0: string, arg1: integer): void
public "encodeUrl"(arg0: string): string
public "encodeRedirectURL"(arg0: string): string
public "getHeaderNames"(): $Collection<(string)>
public "encodeRedirectUrl"(arg0: string): string
public "addCookie"(arg0: $Cookie$Type): void
public "containsHeader"(arg0: string): boolean
public "setDateHeader"(arg0: string, arg1: long): void
public "addIntHeader"(arg0: string, arg1: integer): void
public "addDateHeader"(arg0: string, arg1: long): void
public "encodeURL"(arg0: string): string
public "setTrailerFields"(arg0: $Supplier$Type<($Map$Type<(string), (string)>)>): void
public "getTrailerFields"(): $Supplier<($Map<(string), (string)>)>
set "status"(value: integer)
get "status"(): integer
get "headerNames"(): $Collection<(string)>
set "trailerFields"(value: $Supplier$Type<($Map$Type<(string), (string)>)>)
get "trailerFields"(): $Supplier<($Map<(string), (string)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletResponseHttpWrapper$Type = ($ServletResponseHttpWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletResponseHttpWrapper_ = $ServletResponseHttpWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MovingSubList" {
import {$AbstractList$Companion, $AbstractList$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList$Companion"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$AbstractList, $AbstractList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList"

export class $MovingSubList<E> extends $AbstractList<(E)> implements $RandomAccess {
static readonly "Companion": $AbstractList$Companion

constructor(arg0: $List$Type<(any)>)

public "get"(arg0: integer): E
public "getSize"(): integer
public "move"(arg0: integer, arg1: integer): void
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MovingSubList$Type<E> = ($MovingSubList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MovingSubList_<E> = $MovingSubList$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkIEND" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkIEND extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkIEND$Type = ($PngChunkIEND);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkIEND_ = $PngChunkIEND$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory" {
import {$Extension, $Extension$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Extension"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ExtensionFactory implements $Iterable<($Class<(any)>)> {

constructor()

public "iterator"(): $Iterator<($Class<(any)>)>
public "newInstance"(arg0: $ExtensionConfig$Type): $Extension
public "register"(arg0: string, arg1: $Class$Type<(any)>): void
public "unregister"(arg0: string): void
public "getExtension"(arg0: string): $Class<(any)>
public "isAvailable"(arg0: string): boolean
public "getExtensionNames"(): $Set<(string)>
public "getAvailableExtensions"(): $Map<(string), ($Class<(any)>)>
public "spliterator"(): $Spliterator<($Class<(any)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Class<(any)>>;
get "extensionNames"(): $Set<(string)>
get "availableExtensions"(): $Map<(string), ($Class<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionFactory$Type = ($ExtensionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionFactory_ = $ExtensionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexingIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"

export class $IndexingIterable<T> implements $Iterable<($IndexedValue<(any)>)>, $KMappedMarker {

constructor(arg0: $Function0$Type<(any)>)

public "iterator"(): $Iterator<($IndexedValue<(T)>)>
public "spliterator"(): $Spliterator<($IndexedValue<(any)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$IndexedValue<(T)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexingIterable$Type<T> = ($IndexingIterable<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexingIterable_<T> = $IndexingIterable$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableSet" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$KMutableSet, $KMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractSet, $AbstractSet$Type} from "packages/java/util/$AbstractSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $AbstractMutableSet<E> extends $AbstractSet<(E)> implements $Set<(E)>, $KMutableSet {


public "add"(arg0: E): boolean
public "size"(): integer
public "getSize"(): integer
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMutableSet$Type<E> = ($AbstractMutableSet<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMutableSet_<E> = $AbstractMutableSet$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool$Bucket" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $ByteBufferPool$Bucket {

constructor(arg0: $ByteBufferPool$Type, arg1: integer, arg2: integer)

public "toString"(): string
public "clear"(): void
public "release"(arg0: $ByteBuffer$Type): void
public "acquire"(arg0: boolean): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBufferPool$Bucket$Type = ($ByteBufferPool$Bucket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBufferPool$Bucket_ = $ByteBufferPool$Bucket$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/math/$MathKt__MathJVMKt" {
import {$MathKt__MathHKt, $MathKt__MathHKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/math/$MathKt__MathHKt"

export class $MathKt__MathJVMKt extends $MathKt__MathHKt {

constructor()

public static "log"(arg0: double, arg1: double): double
public static "log"(arg0: float, arg1: float): float
public static "truncate"(arg0: double): double
public static "truncate"(arg0: float): float
public static "getSign"(arg0: long): integer
public static "getSign"(arg0: integer): integer
public static "acosh"(arg0: double): double
public static "atanh"(arg0: double): double
public static "asinh"(arg0: double): double
public static "log2"(arg0: double): double
public static "log2"(arg0: float): float
public static "roundToLong"(arg0: double): long
public static "roundToLong"(arg0: float): long
public static "roundToInt"(arg0: double): integer
public static "roundToInt"(arg0: float): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MathKt__MathJVMKt$Type = ($MathKt__MathJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MathKt__MathJVMKt_ = $MathKt__MathJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiMap" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MultiMap<V> extends $HashMap<(string), ($List<(V)>)> {

constructor(arg0: $MultiMap$Type<(V)>)
constructor(arg0: $Map$Type<(string), ($List$Type<(V)>)>)
constructor()

public "add"(arg0: string, arg1: V): void
public "put"(arg0: string, arg1: V): $List<(V)>
public "toString"(): string
public "getValue"(arg0: string, arg1: integer): V
public "getString"(arg0: string): string
public "toStringArrayMap"(): $Map<(string), ((string)[])>
public "putAllValues"(arg0: $Map$Type<(string), (V)>): void
public "addAllValues"(arg0: $MultiMap$Type<(V)>): boolean
public "addValues"(arg0: string, arg1: (V)[]): void
public "addValues"(arg0: string, arg1: $List$Type<(V)>): void
public "containsSimpleValue"(arg0: V): boolean
public "removeValue"(arg0: string, arg1: V): boolean
public "getValues"(arg0: string): $List<(V)>
public "putValues"(arg0: string, ...arg1: (V)[]): $List<(V)>
public "putValues"(arg0: string, arg1: $List$Type<(V)>): $List<(V)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiMap$Type<V> = ($MultiMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiMap_<V> = $MultiMap$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$Wrapper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Wrapper {

 "delegate"(): any

(): any
}

export namespace $Wrapper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Wrapper$Type = ($Wrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Wrapper_ = $Wrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SetBuilder" {
import {$AbstractMutableSet, $AbstractMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableSet"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$KMutableSet, $KMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $SetBuilder<E> extends $AbstractMutableSet<(E)> implements $Set<(E)>, $Serializable, $KMutableSet {

constructor(arg0: integer)
constructor()
constructor(arg0: $MapBuilder$Type<(E), (any)>)

public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "build"(): $Set<(E)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetBuilder$Type<E> = ($SetBuilder<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetBuilder_<E> = $SetBuilder$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $ByteBufferPool {

 "release"(arg0: $ByteBuffer$Type): void
 "acquire"(arg0: integer, arg1: boolean): $ByteBuffer
 "newByteBuffer"(arg0: integer, arg1: boolean): $ByteBuffer
}

export namespace $ByteBufferPool {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBufferPool$Type = ($ByteBufferPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBufferPool_ = $ByteBufferPool$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharsKt__CharKt" {
import {$CharsKt__CharJVMKt, $CharsKt__CharJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharsKt__CharJVMKt"

export class $CharsKt__CharKt extends $CharsKt__CharJVMKt {

constructor()

public static "titlecase"(arg0: character): string
public static "equals"(arg0: character, arg1: character, arg2: boolean): boolean
public static "isSurrogate"(arg0: character): boolean
public static "digitToIntOrNull"(arg0: character): integer
public static "digitToIntOrNull"(arg0: character, arg1: integer): integer
public static "digitToChar"(arg0: integer): character
public static "digitToChar"(arg0: integer, arg1: integer): character
public static "digitToInt"(arg0: character): integer
public static "digitToInt"(arg0: character, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharsKt__CharKt$Type = ($CharsKt__CharKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharsKt__CharKt_ = $CharsKt__CharKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharsKt" {
import {$CharsKt__CharKt, $CharsKt__CharKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharsKt__CharKt"

export class $CharsKt extends $CharsKt__CharKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharsKt$Type = ($CharsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharsKt_ = $CharsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$LowPriorityInOverloadResolution" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $LowPriorityInOverloadResolution extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $LowPriorityInOverloadResolution {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LowPriorityInOverloadResolution$Type = ($LowPriorityInOverloadResolution);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LowPriorityInOverloadResolution_ = $LowPriorityInOverloadResolution$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$AbstractList$Companion, $AbstractList$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList$Companion"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractCollection"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $AbstractList<E> extends $AbstractCollection<(E)> implements $List<(E)>, $KMappedMarker {
static readonly "Companion": $AbstractList$Companion


public "add"(arg0: integer, arg1: E): void
public "remove"(arg0: integer): E
public "get"(arg0: integer): E
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: E): integer
public "lastIndexOf"(arg0: E): integer
public "subList"(arg0: integer, arg1: integer): $List<(E)>
public "iterator"(): $Iterator<(E)>
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: E): E
public "getSize"(): integer
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "listIterator"(): $ListIterator<(E)>
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "replaceAll"(arg0: $UnaryOperator$Type<(E)>): void
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "spliterator"(): $Spliterator<(E)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "sort"(arg0: $Comparator$Type<(any)>): void
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
[index: number]: E
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractList$Type<E> = ($AbstractList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractList_<E> = $AbstractList$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Utf8StringBuffer" {
import {$Utf8Appendable, $Utf8Appendable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Utf8Appendable"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"

export class $Utf8StringBuffer extends $Utf8Appendable {
static readonly "REPLACEMENT": character
static readonly "REPLACEMENT_UTF8": (byte)[]

constructor()
constructor(arg0: integer)

public "length"(): integer
public "toString"(): string
public "reset"(): void
public "getStringBuffer"(): $StringBuffer
get "stringBuffer"(): $StringBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8StringBuffer$Type = ($Utf8StringBuffer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8StringBuffer_ = $Utf8StringBuffer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionReference" {
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CallableReference, $CallableReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$CallableReference"
import {$FunctionBase, $FunctionBase$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase"

export class $FunctionReference extends $CallableReference implements $FunctionBase<(any)>, $KFunction<(any)> {
static readonly "NO_RECEIVER": any

constructor(arg0: integer, arg1: any, arg2: $Class$Type<(any)>, arg3: string, arg4: string, arg5: integer)
constructor(arg0: integer, arg1: any)
constructor(arg0: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isInline"(): boolean
public "isSuspend"(): boolean
public "isOperator"(): boolean
public "isExternal"(): boolean
public "isInfix"(): boolean
public "getArity"(): integer
get "inline"(): boolean
get "suspend"(): boolean
get "operator"(): boolean
get "external"(): boolean
get "infix"(): boolean
get "arity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionReference$Type = ($FunctionReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionReference_ = $FunctionReference$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTEXT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkTextVar, $PngChunkTextVar$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTextVar"

export class $PngChunkTEXT extends $PngChunkTextVar {
static readonly "ID": string
static readonly "KEY_Title": string
static readonly "KEY_Author": string
static readonly "KEY_Description": string
static readonly "KEY_Copyright": string
static readonly "KEY_Creation_Time": string
static readonly "KEY_Software": string
static readonly "KEY_Disclaimer": string
static readonly "KEY_Warning": string
static readonly "KEY_Source": string
static readonly "KEY_Comment": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkTEXT$Type = ($PngChunkTEXT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkTEXT_ = $PngChunkTEXT$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$KeysItr" {
import {$KMutableIterator, $KMutableIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MapBuilder$Itr, $MapBuilder$Itr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$Itr"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $MapBuilder$KeysItr<K, V> extends $MapBuilder$Itr<(K), (V)> implements $Iterator<(K)>, $KMutableIterator {

constructor(arg0: $MapBuilder$Type<(K), (V)>)

public "next"(): K
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$KeysItr$Type<K, V> = ($MapBuilder$KeysItr<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder$KeysItr_<K, V> = $MapBuilder$KeysItr$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$OnWebSocketError" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OnWebSocketError extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OnWebSocketError {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnWebSocketError$Type = ($OnWebSocketError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnWebSocketError_ = $OnWebSocketError$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Credential" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"

export class $Credential implements $Serializable {

constructor()

public "check"(arg0: any): boolean
public static "getCredential"(arg0: string): $Credential
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Credential$Type = ($Credential);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Credential_ = $Credential$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilderEntries" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$AbstractMapBuilderEntrySet, $AbstractMapBuilderEntrySet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$AbstractMapBuilderEntrySet"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapBuilderEntries<K, V> extends $AbstractMapBuilderEntrySet<($Map$Entry<(K), (V)>), (K), (V)> {

constructor(arg0: $MapBuilder$Type<(K), (V)>)

public "add"(arg0: $Map$Entry$Type<(K), (V)>): boolean
public "remove"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($Map$Entry<(K), (V)>)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsEntry"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "getBacking"(): $MapBuilder<(K), (V)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
get "empty"(): boolean
get "size"(): integer
get "backing"(): $MapBuilder<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilderEntries$Type<K, V> = ($MapBuilderEntries<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilderEntries_<K, V> = $MapBuilderEntries$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$GenericServlet" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ServletConfig, $ServletConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletConfig"
import {$Servlet, $Servlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Servlet"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export class $GenericServlet implements $Servlet, $ServletConfig, $Serializable {

constructor()

public "getInitParameter"(arg0: string): string
public "getServletConfig"(): $ServletConfig
public "getServletInfo"(): string
public "log"(arg0: string): void
public "log"(arg0: string, arg1: $Throwable$Type): void
public "init"(): void
public "init"(arg0: $ServletConfig$Type): void
public "destroy"(): void
public "service"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
public "getServletName"(): string
public "getServletContext"(): $ServletContext
public "getInitParameterNames"(): $Enumeration<(string)>
get "servletConfig"(): $ServletConfig
get "servletInfo"(): string
get "servletName"(): string
get "servletContext"(): $ServletContext
get "initParameterNames"(): $Enumeration<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericServlet$Type = ($GenericServlet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericServlet_ = $GenericServlet$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassBasedDeclarationContainer" {
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ClassBasedDeclarationContainer extends $KDeclarationContainer {

 "getJClass"(): $Class<(any)>
 "getMembers"(): $Collection<($KCallable<(any)>)>
}

export namespace $ClassBasedDeclarationContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassBasedDeclarationContainer$Type = ($ClassBasedDeclarationContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassBasedDeclarationContainer_ = $ClassBasedDeclarationContainer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesFolder" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $StaticFilesFolder {

constructor()

public static "localConfiguredTo"(arg0: string): void
public static "local"(): string
public static "external"(): string
public static "externalConfiguredTo"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StaticFilesFolder$Type = ($StaticFilesFolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StaticFilesFolder_ = $StaticFilesFolder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$BinaryFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$DataFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $BinaryFrame extends $DataFrame {

constructor()

public "getType"(): $Frame$Type
public "setPayload"(arg0: string): $BinaryFrame
public "setPayload"(arg0: (byte)[]): $BinaryFrame
get "type"(): $Frame$Type
set "payload"(value: string)
set "payload"(value: (byte)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryFrame$Type = ($BinaryFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryFrame_ = $BinaryFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ExceptionsKt__ExceptionsKt" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ExceptionsKt__ExceptionsKt {

constructor()

public static "getStackTrace"(arg0: $Throwable$Type): ($StackTraceElement)[]
public static "addSuppressed"(arg0: $Throwable$Type, arg1: $Throwable$Type): void
public static "getSuppressedExceptions"(arg0: $Throwable$Type): $List<($Throwable)>
public static "stackTraceToString"(arg0: $Throwable$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionsKt__ExceptionsKt$Type = ($ExceptionsKt__ExceptionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionsKt__ExceptionsKt_ = $ExceptionsKt__ExceptionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$FilterHolder" {
import {$Holder, $Holder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Holder"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"
import {$FilterRegistration$Dynamic, $FilterRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration$Dynamic"

export class $FilterHolder extends $Holder<($Filter)> {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(arg0: $Filter$Type)
constructor(arg0: $Class$Type<(any)>)
constructor(arg0: $Source$Type)

public "destroyInstance"(arg0: any): void
public "toString"(): string
public "initialize"(): void
public "getFilter"(): $Filter
public "setFilter"(arg0: $Filter$Type): void
public "getRegistration"(): $FilterRegistration$Dynamic
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "doStart"(): void
public "doStop"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "filter"(): $Filter
set "filter"(value: $Filter$Type)
get "registration"(): $FilterRegistration$Dynamic
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterHolder$Type = ($FilterHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterHolder_ = $FilterHolder$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping" {
import {$MappingMatch, $MappingMatch$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$MappingMatch"

export interface $HttpServletMapping {

 "getPattern"(): string
 "getServletName"(): string
 "getMappingMatch"(): $MappingMatch
 "getMatchValue"(): string
}

export namespace $HttpServletMapping {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServletMapping$Type = ($HttpServletMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServletMapping_ = $HttpServletMapping$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkGAMA" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkGAMA extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setGamma"(arg0: double): void
public "getGamma"(): double
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "gamma"(value: double)
get "gamma"(): double
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkGAMA$Type = ($PngChunkGAMA);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkGAMA_ = $PngChunkGAMA$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$KProperty$Accessor, $KProperty$Accessor$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Accessor"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty$Setter<V> extends $KProperty$Accessor<(V)>, $KFunction<($Unit)> {

 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): $Unit
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): $Unit
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty$Setter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty$Setter$Type<V> = ($KMutableProperty$Setter<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty$Setter_<V> = $KMutableProperty$Setter$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$PathSpecGroup, $PathSpecGroup$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpecGroup"

export class $PathSpec implements $Comparable<($PathSpec)> {

constructor()

public "getPathDepth"(): integer
public "getRelativePath"(arg0: string, arg1: string): string
public "getPathMatch"(arg0: string): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $PathSpec$Type): integer
public "matches"(arg0: string): boolean
public "getSuffix"(): string
public "getPrefix"(): string
public "getDeclaration"(): string
public "getGroup"(): $PathSpecGroup
public "getPathInfo"(arg0: string): string
get "pathDepth"(): integer
get "suffix"(): string
get "prefix"(): string
get "declaration"(): string
get "group"(): $PathSpecGroup
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathSpec$Type = ($PathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathSpec_ = $PathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequenceBuilderIterator" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$SequenceScope, $SequenceScope$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequenceScope"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $SequenceBuilderIterator<T> extends $SequenceScope<(T)> implements $Iterator<(T)>, $Continuation<($Unit)>, $KMappedMarker {

constructor()

public "remove"(): void
public "hasNext"(): boolean
public "next"(): T
public "getContext"(): $CoroutineContext
public "yield"(arg0: T, arg1: $Continuation$Type<(any)>): any
public "resumeWith"(arg0: any): void
public "setNextStep"(arg0: $Continuation$Type<(any)>): void
public "getNextStep"(): $Continuation<($Unit)>
public "yieldAll"(arg0: $Iterator$Type<(any)>, arg1: $Continuation$Type<(any)>): any
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
get "context"(): $CoroutineContext
set "nextStep"(value: $Continuation$Type<(any)>)
get "nextStep"(): $Continuation<($Unit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequenceBuilderIterator$Type<T> = ($SequenceBuilderIterator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequenceBuilderIterator_<T> = $SequenceBuilderIterator$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ManagedSelector" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Selector, $Selector$Type} from "packages/java/nio/channels/$Selector"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SelectorManager, $SelectorManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$SelectorManager"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $ManagedSelector extends $ContainerLifeCycle implements $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $SelectorManager$Type, arg1: integer)

public "toString"(): string
public "size"(): integer
public "submit"(arg0: $Runnable$Type): void
public "destroyEndPoint"(arg0: $EndPoint$Type): void
public "getSelector"(): $Selector
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "selector"(): $Selector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedSelector$Type = ($ManagedSelector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedSelector_ = $ManagedSelector$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$PushBuilder" {
import {$Set, $Set$Type} from "packages/java/util/$Set"

export interface $PushBuilder {

 "method"(arg0: string): $PushBuilder
 "getMethod"(): string
 "path"(arg0: string): $PushBuilder
 "getPath"(): string
 "lastModified"(arg0: string): $PushBuilder
 "push"(): void
 "getLastModified"(): string
 "getHeader"(arg0: string): string
 "getQueryString"(): string
 "queryString"(arg0: string): $PushBuilder
 "etag"(arg0: string): $PushBuilder
 "addHeader"(arg0: string, arg1: string): $PushBuilder
 "conditional"(arg0: boolean): $PushBuilder
 "getSessionId"(): string
 "setHeader"(arg0: string, arg1: string): $PushBuilder
 "getHeaderNames"(): $Set<(string)>
 "sessionId"(arg0: string): $PushBuilder
 "removeHeader"(arg0: string): $PushBuilder
 "getEtag"(): string
 "isConditional"(): boolean
}

export namespace $PushBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PushBuilder$Type = ($PushBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PushBuilder_ = $PushBuilder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ScopedHandler" {
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HandlerWrapper, $HandlerWrapper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $ScopedHandler extends $HandlerWrapper {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "nextScope"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "doHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "doScope"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "nextHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScopedHandler$Type = ($ScopedHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScopedHandler_ = $ScopedHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$DeprecationLevel" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $DeprecationLevel extends $Enum<($DeprecationLevel)> {
static readonly "WARNING": $DeprecationLevel
static readonly "ERROR": $DeprecationLevel
static readonly "HIDDEN": $DeprecationLevel


public static "values"(): ($DeprecationLevel)[]
public static "valueOf"(arg0: string): $DeprecationLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeprecationLevel$Type = (("hidden") | ("warning") | ("error")) | ($DeprecationLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeprecationLevel_ = $DeprecationLevel$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$PingFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ControlFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $PingFrame extends $ControlFrame {
static readonly "MAX_CONTROL_PAYLOAD": integer

constructor()

public "getType"(): $Frame$Type
public "setPayload"(arg0: (byte)[]): $PingFrame
public "setPayload"(arg0: string): $PingFrame
get "type"(): $Frame$Type
set "payload"(value: (byte)[])
set "payload"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PingFrame$Type = ($PingFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PingFrame_ = $PingFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$LazyKt__LazyJVMKt" {
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"
import {$LazyThreadSafetyMode, $LazyThreadSafetyMode$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$LazyThreadSafetyMode"

export class $LazyKt__LazyJVMKt {

constructor()

public static "lazy"<T>(arg0: $Function0$Type<(any)>): $Lazy<(T)>
public static "lazy"<T>(arg0: any, arg1: $Function0$Type<(any)>): $Lazy<(T)>
public static "lazy"<T>(arg0: $LazyThreadSafetyMode$Type, arg1: $Function0$Type<(any)>): $Lazy<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyKt__LazyJVMKt$Type = ($LazyKt__LazyJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyKt__LazyJVMKt_ = $LazyKt__LazyJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$JvmName" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JvmName extends $Annotation {

 "name"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JvmName {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JvmName$Type = ($JvmName);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JvmName_ = $JvmName$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkIHDR" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkIHDR extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getInterlaced"(): integer
public "getBitspc"(): integer
public "getCompmeth"(): integer
public "setBitspc"(arg0: integer): void
public "setCompmeth"(arg0: integer): void
public "getFilmeth"(): integer
public "setColormodel"(arg0: integer): void
public "setFilmeth"(arg0: integer): void
public "getColormodel"(): integer
public "setCols"(arg0: integer): void
public "check"(): void
public "setRows"(arg0: integer): void
public "getRows"(): integer
public "getCols"(): integer
public "createImageInfo"(): $ImageInfo
public "setInterlaced"(arg0: integer): void
public "isInterlaced"(): boolean
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "interlaced"(): integer
get "bitspc"(): integer
get "compmeth"(): integer
set "bitspc"(value: integer)
set "compmeth"(value: integer)
get "filmeth"(): integer
set "colormodel"(value: integer)
set "filmeth"(value: integer)
get "colormodel"(): integer
set "cols"(value: integer)
set "rows"(value: integer)
get "rows"(): integer
get "cols"(): integer
set "interlaced"(value: integer)
get "interlaced"(): boolean
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkIHDR$Type = ($PngChunkIHDR);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkIHDR_ = $PngChunkIHDR$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $AbstractList$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "orderedHashCode$kotlin_stdlib"(arg0: $Collection$Type<(any)>): integer
public "checkElementIndex$kotlin_stdlib"(arg0: integer, arg1: integer): void
public "orderedEquals$kotlin_stdlib"(arg0: $Collection$Type<(any)>, arg1: $Collection$Type<(any)>): boolean
public "checkBoundsIndexes$kotlin_stdlib"(arg0: integer, arg1: integer, arg2: integer): void
public "checkPositionIndex$kotlin_stdlib"(arg0: integer, arg1: integer): void
public "checkRangeIndexes$kotlin_stdlib"(arg0: integer, arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractList$Companion$Type = ($AbstractList$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractList$Companion_ = $AbstractList$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration" {
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Registration, $Registration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Registration"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $FilterRegistration extends $Registration {

 "addMappingForUrlPatterns"(arg0: $EnumSet$Type<($DispatcherType$Type)>, arg1: boolean, ...arg2: (string)[]): void
 "getUrlPatternMappings"(): $Collection<(string)>
 "addMappingForServletNames"(arg0: $EnumSet$Type<($DispatcherType$Type)>, arg1: boolean, ...arg2: (string)[]): void
 "getServletNameMappings"(): $Collection<(string)>
 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $FilterRegistration {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterRegistration$Type = ($FilterRegistration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterRegistration_ = $FilterRegistration$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$DeflatedChunkReader" {
import {$ChunkReader$ChunkReaderMode, $ChunkReader$ChunkReaderMode$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader$ChunkReaderMode"
import {$DeflatedChunksSet, $DeflatedChunksSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$DeflatedChunksSet"
import {$ChunkReader, $ChunkReader$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader"

export class $DeflatedChunkReader extends $ChunkReader {
readonly "mode": $ChunkReader$ChunkReaderMode

constructor(arg0: integer, arg1: string, arg2: boolean, arg3: long, arg4: $DeflatedChunksSet$Type)

public "setAlsoBuffer"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeflatedChunkReader$Type = ($DeflatedChunkReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeflatedChunkReader_ = $DeflatedChunkReader$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt" {
import {$MapsKt___MapsKt, $MapsKt___MapsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt___MapsKt"

export class $MapsKt extends $MapsKt___MapsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapsKt$Type = ($MapsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapsKt_ = $MapsKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$CompressorStreamDeflater" {
import {$Deflater, $Deflater$Type} from "packages/java/util/zip/$Deflater"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$CompressorStream, $CompressorStream$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$CompressorStream"

export class $CompressorStreamDeflater extends $CompressorStream {
readonly "blockLen": integer
readonly "totalbytes": long

constructor(arg0: $OutputStream$Type, arg1: integer, arg2: long, arg3: integer, arg4: integer)
constructor(arg0: $OutputStream$Type, arg1: integer, arg2: long, arg3: $Deflater$Type)
constructor(arg0: $OutputStream$Type, arg1: integer, arg2: long)

public "mywrite"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "close"(): void
public "reset"(): void
public "done"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompressorStreamDeflater$Type = ($CompressorStreamDeflater);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompressorStreamDeflater_ = $CompressorStreamDeflater$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Attributes" {
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"

export interface $Attributes {

 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
 "removeAttribute"(arg0: string): void
 "clearAttributes"(): void
 "getAttributeNames"(): $Enumeration<(string)>
}

export namespace $Attributes {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Attributes$Type = ($Attributes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Attributes_ = $Attributes$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$InvalidSignatureException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$InvalidWebSocketException, $InvalidWebSocketException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$InvalidWebSocketException"
import {$ParamList, $ParamList$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$ParamList"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $InvalidSignatureException extends $InvalidWebSocketException {

constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)

public static "build"(arg0: $Method$Type, arg1: $Class$Type<(any)>, ...arg2: ($ParamList$Type)[]): $InvalidSignatureException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidSignatureException$Type = ($InvalidSignatureException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidSignatureException_ = $InvalidSignatureException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$HaltException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $HaltException extends $RuntimeException {


public "body"(): string
public "statusCode"(): integer
public "getStatusCode"(): integer
public "getBody"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HaltException$Type = ($HaltException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HaltException_ = $HaltException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt__SetsKt" {
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$LinkedHashSet, $LinkedHashSet$Type} from "packages/java/util/$LinkedHashSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$SetsKt__SetsJVMKt, $SetsKt__SetsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt__SetsJVMKt"

export class $SetsKt__SetsKt extends $SetsKt__SetsJVMKt {

constructor()

public static "optimizeReadOnlySet"<T>(arg0: $Set$Type<(any)>): $Set<(T)>
public static "linkedSetOf"<T>(...arg0: (T)[]): $LinkedHashSet<(T)>
public static "setOfNotNull"<T>(arg0: T): $Set<(T)>
public static "setOfNotNull"<T>(...arg0: (T)[]): $Set<(T)>
public static "mutableSetOf"<T>(...arg0: (T)[]): $Set<(T)>
public static "hashSetOf"<T>(...arg0: (T)[]): $HashSet<(T)>
public static "emptySet"<T>(): $Set<(T)>
public static "setOf"<T>(...arg0: (T)[]): $Set<(T)>
set "ofNotNull"(value: T)
set "ofNotNull"(value: (T)[])
set "of"(value: (T)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetsKt__SetsKt$Type = ($SetsKt__SetsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetsKt__SetsKt_ = $SetsKt__SetsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MimeTypes$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $MimeTypes$Type extends $Enum<($MimeTypes$Type)> {
static readonly "FORM_ENCODED": $MimeTypes$Type
static readonly "MESSAGE_HTTP": $MimeTypes$Type
static readonly "MULTIPART_BYTERANGES": $MimeTypes$Type
static readonly "TEXT_HTML": $MimeTypes$Type
static readonly "TEXT_PLAIN": $MimeTypes$Type
static readonly "TEXT_XML": $MimeTypes$Type
static readonly "TEXT_JSON": $MimeTypes$Type
static readonly "APPLICATION_JSON": $MimeTypes$Type
static readonly "TEXT_HTML_8859_1": $MimeTypes$Type
static readonly "TEXT_HTML_UTF_8": $MimeTypes$Type
static readonly "TEXT_PLAIN_8859_1": $MimeTypes$Type
static readonly "TEXT_PLAIN_UTF_8": $MimeTypes$Type
static readonly "TEXT_XML_8859_1": $MimeTypes$Type
static readonly "TEXT_XML_UTF_8": $MimeTypes$Type
static readonly "TEXT_JSON_8859_1": $MimeTypes$Type
static readonly "TEXT_JSON_UTF_8": $MimeTypes$Type
static readonly "APPLICATION_JSON_8859_1": $MimeTypes$Type
static readonly "APPLICATION_JSON_UTF_8": $MimeTypes$Type


public "toString"(): string
public static "values"(): ($MimeTypes$Type)[]
public static "valueOf"(arg0: string): $MimeTypes$Type
public "is"(arg0: string): boolean
public "asBuffer"(): $ByteBuffer
public "asString"(): string
public "getCharsetString"(): string
public "isCharsetAssumed"(): boolean
public "getBaseType"(): $MimeTypes$Type
public "getCharset"(): $Charset
public "getContentTypeField"(): $HttpField
get "charsetString"(): string
get "charsetAssumed"(): boolean
get "baseType"(): $MimeTypes$Type
get "charset"(): $Charset
get "contentTypeField"(): $HttpField
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MimeTypes$Type$Type = (("text_xml_8859_1") | ("application_json_utf_8") | ("text_json_8859_1") | ("text_html_utf_8") | ("application_json") | ("message_http") | ("multipart_byteranges") | ("text_html_8859_1") | ("application_json_8859_1") | ("text_json_utf_8") | ("text_plain_utf_8") | ("text_xml_utf_8") | ("text_xml") | ("text_plain") | ("text_plain_8859_1") | ("form_encoded") | ("text_json") | ("text_html")) | ($MimeTypes$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MimeTypes$Type_ = $MimeTypes$Type$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStoreFactory" {
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$SessionDataStore, $SessionDataStore$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStore"

export interface $SessionDataStoreFactory {

 "getSessionDataStore"(arg0: $SessionHandler$Type): $SessionDataStore

(arg0: $SessionHandler$Type): $SessionDataStore
}

export namespace $SessionDataStoreFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionDataStoreFactory$Type = ($SessionDataStoreFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionDataStoreFactory_ = $SessionDataStoreFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ExecutionStrategy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ExecutionStrategy {

 "dispatch"(): void
 "produce"(): void
}

export namespace $ExecutionStrategy {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExecutionStrategy$Type = ($ExecutionStrategy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExecutionStrategy_ = $ExecutionStrategy$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$AfterAfterFilters" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AfterAfterFilters {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterAfterFilters$Type = ($AfterAfterFilters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterAfterFilters_ = $AfterAfterFilters$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$BlockingWriteCallback$WriteBlocker" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $BlockingWriteCallback$WriteBlocker implements $WriteCallback, $Callback, $AutoCloseable {


public "writeFailed"(arg0: $Throwable$Type): void
public "writeSuccess"(): void
public "close"(): void
public "getInvocationType"(): $Invocable$InvocationType
public "block"(): void
public "succeeded"(): void
public "failed"(arg0: $Throwable$Type): void
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "invocationType"(): $Invocable$InvocationType
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockingWriteCallback$WriteBlocker$Type = ($BlockingWriteCallback$WriteBlocker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockingWriteCallback$WriteBlocker_ = $BlockingWriteCallback$WriteBlocker$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"

export class $HttpVersion extends $Enum<($HttpVersion)> {
static readonly "HTTP_0_9": $HttpVersion
static readonly "HTTP_1_0": $HttpVersion
static readonly "HTTP_1_1": $HttpVersion
static readonly "HTTP_2": $HttpVersion
static readonly "CACHE": $Trie<($HttpVersion)>


public static "lookAheadGet"(arg0: (byte)[], arg1: integer, arg2: integer): $HttpVersion
public static "lookAheadGet"(arg0: $ByteBuffer$Type): $HttpVersion
public "toString"(): string
public static "values"(): ($HttpVersion)[]
public "toBytes"(): (byte)[]
public static "valueOf"(arg0: string): $HttpVersion
public "is"(arg0: string): boolean
public "getVersion"(): integer
public static "fromString"(arg0: string): $HttpVersion
public "asString"(): string
public static "fromVersion"(arg0: integer): $HttpVersion
public "toBuffer"(): $ByteBuffer
get "version"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpVersion$Type = (("http_0_9") | ("http_1_1") | ("http_2") | ("http_1_0")) | ($HttpVersion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpVersion_ = $HttpVersion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container" {
import {$Container$Listener, $Container$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container$Listener"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Container {

 "removeEventListener"(arg0: $Container$Listener$Type): void
 "addEventListener"(arg0: $Container$Listener$Type): void
 "getBeans"(): $Collection<(any)>
 "getBeans"<T>(arg0: $Class$Type<(T)>): $Collection<(T)>
 "addBean"(arg0: any): boolean
 "removeBean"(arg0: any): boolean
 "getBean"<T>(arg0: $Class$Type<(T)>): T
}

export namespace $Container {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Container$Type = ($Container);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Container_ = $Container$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$SessionCookieConfig" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SessionCookieConfig {

 "getName"(): string
 "setName"(arg0: string): void
 "getPath"(): string
 "setComment"(arg0: string): void
 "getComment"(): string
 "getDomain"(): string
 "isSecure"(): boolean
 "isHttpOnly"(): boolean
 "setPath"(arg0: string): void
 "setSecure"(arg0: boolean): void
 "setMaxAge"(arg0: integer): void
 "getMaxAge"(): integer
 "setDomain"(arg0: string): void
 "setHttpOnly"(arg0: boolean): void
}

export namespace $SessionCookieConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionCookieConfig$Type = ($SessionCookieConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionCookieConfig_ = $SessionCookieConfig$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$AsyncEvent" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"

export class $AsyncEvent {

constructor(arg0: $AsyncContext$Type, arg1: $ServletRequest$Type, arg2: $ServletResponse$Type, arg3: $Throwable$Type)
constructor(arg0: $AsyncContext$Type, arg1: $Throwable$Type)
constructor(arg0: $AsyncContext$Type, arg1: $ServletRequest$Type, arg2: $ServletResponse$Type)
constructor(arg0: $AsyncContext$Type)

public "getThrowable"(): $Throwable
public "getSuppliedResponse"(): $ServletResponse
public "getSuppliedRequest"(): $ServletRequest
public "getAsyncContext"(): $AsyncContext
get "throwable"(): $Throwable
get "suppliedResponse"(): $ServletResponse
get "suppliedRequest"(): $ServletRequest
get "asyncContext"(): $AsyncContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncEvent$Type = ($AsyncEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncEvent_ = $AsyncEvent$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilePathComponents" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$List, $List$Type} from "packages/java/util/$List"

export class $FilePathComponents {

constructor(arg0: $File$Type, arg1: $List$Type<(any)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getRoot"(): $File
public "copy"(arg0: $File$Type, arg1: $List$Type<(any)>): $FilePathComponents
public "getSize"(): integer
public "getRootName"(): string
public "subPath"(arg0: integer, arg1: integer): $File
public "getSegments"(): $List<($File)>
public "component2"(): $List<($File)>
public "component1"(): $File
public "isRooted"(): boolean
get "root"(): $File
get "size"(): integer
get "rootName"(): string
get "segments"(): $List<($File)>
get "rooted"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilePathComponents$Type = ($FilePathComponents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilePathComponents_ = $FilePathComponents$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection" {
import {$KTypeProjection$Companion, $KTypeProjection$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection$Companion"
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$KVariance, $KVariance$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance"

export class $KTypeProjection {
static readonly "Companion": $KTypeProjection$Companion
static readonly "star": $KTypeProjection

constructor(arg0: $KVariance$Type, arg1: $KType$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getType"(): $KType
public "copy"(arg0: $KVariance$Type, arg1: $KType$Type): $KTypeProjection
public "component2"(): $KType
public "getVariance"(): $KVariance
public static "invariant"(arg0: $KType$Type): $KTypeProjection
public static "covariant"(arg0: $KType$Type): $KTypeProjection
public static "contravariant"(arg0: $KType$Type): $KTypeProjection
public "component1"(): $KVariance
get "type"(): $KType
get "variance"(): $KVariance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KTypeProjection$Type = ($KTypeProjection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KTypeProjection_ = $KTypeProjection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$FillInterest" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"

export class $FillInterest {


public "getCallbackInvocationType"(): $Invocable$InvocationType
public "toString"(): string
public "register"(arg0: $Callback$Type): void
public "onClose"(): void
public "onFail"(arg0: $Throwable$Type): boolean
public "fillable"(): void
public "isInterested"(): boolean
public "toStateString"(): string
public "tryRegister"(arg0: $Callback$Type): boolean
get "callbackInvocationType"(): $Invocable$InvocationType
get "interested"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FillInterest$Type = ($FillInterest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FillInterest_ = $FillInterest$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractResource" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$Resource"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $AbstractResource implements $Resource {

constructor()

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isOpen"(): boolean
public "getFile"(): $File
public "exists"(): boolean
public "lastModified"(): long
public "isReadable"(): boolean
public "getURL"(): $URL
public "contentLength"(): long
public "getURI"(): $URI
public "getFilename"(): string
public "createRelative"(arg0: string): $Resource
public "getDescription"(): string
public "getInputStream"(): $InputStream
get "open"(): boolean
get "file"(): $File
get "readable"(): boolean
get "uRL"(): $URL
get "uRI"(): $URI
get "filename"(): string
get "description"(): string
get "inputStream"(): $InputStream
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractResource$Type = ($AbstractResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractResource_ = $AbstractResource$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$CallableMethod" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $CallableMethod {

constructor(arg0: $Class$Type<(any)>, arg1: $Method$Type)

public "toString"(): string
public "getMethod"(): $Method
public "call"(arg0: any, ...arg1: (any)[]): any
public "getParamTypes"(): ($Class<(any)>)[]
public "formatMethodCallError"(...arg0: (any)[]): string
public "getPojo"(): $Class<(any)>
get "method"(): $Method
get "paramTypes"(): ($Class<(any)>)[]
get "pojo"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CallableMethod$Type = ($CallableMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CallableMethod_ = $CallableMethod$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$NOPLogger" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$MarkerIgnoringBase, $MarkerIgnoringBase$Type} from "packages/info/journeymap/shaded/org/slf4j/helpers/$MarkerIgnoringBase"

export class $NOPLogger extends $MarkerIgnoringBase {
static readonly "NOP_LOGGER": $NOPLogger


public "getName"(): string
public "info"(arg0: string): void
public "info"(arg0: string, arg1: any, arg2: any): void
public "info"(arg0: string, arg1: any): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "info"(arg0: string, ...arg1: (any)[]): void
public "trace"(arg0: string, ...arg1: (any)[]): void
public "trace"(arg0: string, arg1: any, arg2: any): void
public "trace"(arg0: string, arg1: any): void
public "trace"(arg0: string): void
public "trace"(arg0: string, arg1: $Throwable$Type): void
public "debug"(arg0: string, arg1: any, arg2: any): void
public "debug"(arg0: string, arg1: any): void
public "debug"(arg0: string): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "error"(arg0: string, ...arg1: (any)[]): void
public "error"(arg0: string, arg1: any): void
public "error"(arg0: string): void
public "error"(arg0: string, arg1: any, arg2: any): void
public "error"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: string): void
public "warn"(arg0: string, arg1: any): void
public "warn"(arg0: string, arg1: any, arg2: any): void
public "isTraceEnabled"(): boolean
public "isDebugEnabled"(): boolean
public "isInfoEnabled"(): boolean
public "isErrorEnabled"(): boolean
public "isWarnEnabled"(): boolean
get "name"(): string
get "traceEnabled"(): boolean
get "debugEnabled"(): boolean
get "infoEnabled"(): boolean
get "errorEnabled"(): boolean
get "warnEnabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NOPLogger$Type = ($NOPLogger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NOPLogger_ = $NOPLogger$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandlerContainer" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$HandlerContainer, $HandlerContainer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HandlerContainer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$AbstractHandler, $AbstractHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandler"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"

export class $AbstractHandlerContainer extends $AbstractHandler implements $HandlerContainer {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "setServer"(arg0: $Server$Type): void
public "getChildHandlerByClass"<T extends $Handler>(arg0: $Class$Type<(T)>): T
public "getChildHandlersByClass"(arg0: $Class$Type<(any)>): ($Handler)[]
public "getChildHandlers"(): ($Handler)[]
public static "findContainerOf"<T extends $HandlerContainer>(arg0: $HandlerContainer$Type, arg1: $Class$Type<(T)>, arg2: $Handler$Type): T
public "getHandlers"(): ($Handler)[]
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "server"(value: $Server$Type)
get "childHandlers"(): ($Handler)[]
get "handlers"(): ($Handler)[]
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractHandlerContainer$Type = ($AbstractHandlerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractHandlerContainer_ = $AbstractHandlerContainer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy" {
import {$WebSocketBehavior, $WebSocketBehavior$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketBehavior"

export class $WebSocketPolicy {

constructor(arg0: $WebSocketBehavior$Type)

public "setMaxTextMessageSize"(arg0: integer): void
public "setMaxBinaryMessageSize"(arg0: integer): void
public "toString"(): string
public "setInputBufferSize"(arg0: integer): void
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "getInputBufferSize"(): integer
public "getBehavior"(): $WebSocketBehavior
public static "newClientPolicy"(): $WebSocketPolicy
public "clonePolicy"(): $WebSocketPolicy
public "getAsyncWriteTimeout"(): long
public "assertValidTextMessageSize"(arg0: integer): void
public "getMaxTextMessageBufferSize"(): integer
public "setAsyncWriteTimeout"(arg0: long): void
public "setMaxBinaryMessageBufferSize"(arg0: integer): void
public "getMaxBinaryMessageSize"(): integer
public "setMaxTextMessageBufferSize"(arg0: integer): void
public "getMaxTextMessageSize"(): integer
public "assertValidBinaryMessageSize"(arg0: integer): void
public static "newServerPolicy"(): $WebSocketPolicy
public "getMaxBinaryMessageBufferSize"(): integer
set "maxTextMessageSize"(value: integer)
set "maxBinaryMessageSize"(value: integer)
set "inputBufferSize"(value: integer)
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "inputBufferSize"(): integer
get "behavior"(): $WebSocketBehavior
get "asyncWriteTimeout"(): long
get "maxTextMessageBufferSize"(): integer
set "asyncWriteTimeout"(value: long)
set "maxBinaryMessageBufferSize"(value: integer)
get "maxBinaryMessageSize"(): integer
set "maxTextMessageBufferSize"(value: integer)
get "maxTextMessageSize"(): integer
get "maxBinaryMessageBufferSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketPolicy$Type = ($WebSocketPolicy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketPolicy_ = $WebSocketPolicy$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$AbstractSessionCache" {
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session"
import {$SessionDataStore, $SessionDataStore$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStore"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$SessionCache, $SessionCache$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionCache"

export class $AbstractSessionCache extends $ContainerLifeCycle implements $SessionCache {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $SessionHandler$Type)

public "get"(arg0: string): $Session
public "put"(arg0: string, arg1: $Session$Type): void
public "toString"(): string
public "doReplace"(arg0: string, arg1: $Session$Type, arg2: $Session$Type): boolean
public "contains"(arg0: string): boolean
public "initialize"(arg0: $SessionContext$Type): void
public "delete"(arg0: string): $Session
public "exists"(arg0: string): boolean
public "doGet"(arg0: string): $Session
public "getSessionHandler"(): $SessionHandler
public "renewSessionId"(arg0: string, arg1: string): $Session
public "newSession"(arg0: $HttpServletRequest$Type, arg1: string, arg2: long, arg3: long): $Session
public "newSession"(arg0: $SessionData$Type): $Session
public "newSession"(arg0: $HttpServletRequest$Type, arg1: $SessionData$Type): $Session
public "doDelete"(arg0: string): $Session
public "doPutIfAbsent"(arg0: string, arg1: $Session$Type): $Session
public "setSaveOnCreate"(arg0: boolean): void
public "getEvictionPolicy"(): integer
public "isSaveOnCreate"(): boolean
public "setEvictionPolicy"(arg0: integer): void
public "checkExpiration"(arg0: $Set$Type<(string)>): $Set<(string)>
public "setRemoveUnloadableSessions"(arg0: boolean): void
public "checkInactiveSession"(arg0: $Session$Type): void
public "isRemoveUnloadableSessions"(): boolean
public "isSaveOnInactiveEviction"(): boolean
public "getSessionDataStore"(): $SessionDataStore
public "setSessionDataStore"(arg0: $SessionDataStore$Type): void
public "setSaveOnInactiveEviction"(arg0: boolean): void
public "shutdown"(): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "sessionHandler"(): $SessionHandler
set "saveOnCreate"(value: boolean)
get "evictionPolicy"(): integer
get "saveOnCreate"(): boolean
set "evictionPolicy"(value: integer)
set "removeUnloadableSessions"(value: boolean)
get "removeUnloadableSessions"(): boolean
get "saveOnInactiveEviction"(): boolean
get "sessionDataStore"(): $SessionDataStore
set "sessionDataStore"(value: $SessionDataStore$Type)
set "saveOnInactiveEviction"(value: boolean)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSessionCache$Type = ($AbstractSessionCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractSessionCache_ = $AbstractSessionCache$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$JvmStatic" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JvmStatic extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JvmStatic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JvmStatic$Type = ($JvmStatic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JvmStatic_ = $JvmStatic$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt___ArraysJvmKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$ArraysKt__ArraysKt, $ArraysKt__ArraysKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt__ArraysKt"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ArraysKt___ArraysJvmKt extends $ArraysKt__ArraysKt {

constructor()

public static "copyOfRange"(arg0: (double)[], arg1: integer, arg2: integer): (double)[]
public static "copyOfRange"(arg0: (float)[], arg1: integer, arg2: integer): (float)[]
public static "copyOfRange"(arg0: (long)[], arg1: integer, arg2: integer): (long)[]
public static "copyOfRange"(arg0: (integer)[], arg1: integer, arg2: integer): (integer)[]
public static "copyOfRange"(arg0: (short)[], arg1: integer, arg2: integer): (short)[]
public static "copyOfRange"<T>(arg0: (T)[], arg1: integer, arg2: integer): (T)[]
public static "copyOfRange"(arg0: (byte)[], arg1: integer, arg2: integer): (byte)[]
public static "copyOfRange"(arg0: (character)[], arg1: integer, arg2: integer): (character)[]
public static "copyOfRange"(arg0: (boolean)[], arg1: integer, arg2: integer): (boolean)[]
public static "fill"(arg0: (character)[], arg1: character, arg2: integer, arg3: integer): void
public static "fill"(arg0: (boolean)[], arg1: boolean, arg2: integer, arg3: integer): void
public static "fill"(arg0: (short)[], arg1: short, arg2: integer, arg3: integer): void
public static "fill"(arg0: (byte)[], arg1: byte, arg2: integer, arg3: integer): void
public static "fill"<T>(arg0: (T)[], arg1: T, arg2: integer, arg3: integer): void
public static "fill"(arg0: (integer)[], arg1: integer, arg2: integer, arg3: integer): void
public static "fill"(arg0: (long)[], arg1: long, arg2: integer, arg3: integer): void
public static "fill"(arg0: (float)[], arg1: float, arg2: integer, arg3: integer): void
public static "fill"(arg0: (double)[], arg1: double, arg2: integer, arg3: integer): void
public static "asList"<T>(arg0: (T)[]): $List<(T)>
public static "asList"(arg0: (byte)[]): $List<(byte)>
public static "asList"(arg0: (float)[]): $List<(float)>
public static "asList"(arg0: (long)[]): $List<(long)>
public static "asList"(arg0: (integer)[]): $List<(integer)>
public static "asList"(arg0: (short)[]): $List<(short)>
public static "asList"(arg0: (double)[]): $List<(double)>
public static "asList"(arg0: (character)[]): $List<(character)>
public static "asList"(arg0: (boolean)[]): $List<(boolean)>
public static "sort"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (byte)[]): void
public static "sort"(arg0: (double)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (short)[]): void
public static "sort"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (integer)[]): void
public static "sort"(arg0: (float)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (long)[]): void
public static "sort"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "sort"<T>(arg0: (T)[], arg1: integer, arg2: integer): void
public static "sort"<T>(arg0: (T)[]): void
public static "sort"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "sort"<T extends $Comparable<(any)>>(arg0: (T)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (double)[]): void
public static "sort"(arg0: (float)[]): void
public static "sort"(arg0: (character)[], arg1: integer, arg2: integer): void
public static "sort"(arg0: (character)[]): void
public static "binarySearch"(arg0: (integer)[], arg1: integer, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (long)[], arg1: long, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (float)[], arg1: float, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (double)[], arg1: double, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (character)[], arg1: character, arg2: integer, arg3: integer): integer
public static "binarySearch"<T>(arg0: (T)[], arg1: T, arg2: $Comparator$Type<(any)>, arg3: integer, arg4: integer): integer
public static "binarySearch"<T>(arg0: (T)[], arg1: T, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (byte)[], arg1: byte, arg2: integer, arg3: integer): integer
public static "binarySearch"(arg0: (short)[], arg1: short, arg2: integer, arg3: integer): integer
public static "plus"(arg0: (float)[], arg1: float): (float)[]
public static "plus"(arg0: (double)[], arg1: double): (double)[]
public static "plus"(arg0: (long)[], arg1: long): (long)[]
public static "plus"(arg0: (boolean)[], arg1: boolean): (boolean)[]
public static "plus"(arg0: (character)[], arg1: character): (character)[]
public static "plus"(arg0: (long)[], arg1: (long)[]): (long)[]
public static "plus"(arg0: (integer)[], arg1: (integer)[]): (integer)[]
public static "plus"(arg0: (short)[], arg1: (short)[]): (short)[]
public static "plus"(arg0: (byte)[], arg1: (byte)[]): (byte)[]
public static "plus"<T>(arg0: (T)[], arg1: (T)[]): (T)[]
public static "plus"(arg0: (character)[], arg1: (character)[]): (character)[]
public static "plus"(arg0: (boolean)[], arg1: (boolean)[]): (boolean)[]
public static "plus"(arg0: (double)[], arg1: (double)[]): (double)[]
public static "plus"(arg0: (float)[], arg1: (float)[]): (float)[]
public static "plus"(arg0: (long)[], arg1: $Collection$Type<(long)>): (long)[]
public static "plus"(arg0: (integer)[], arg1: $Collection$Type<(integer)>): (integer)[]
public static "plus"(arg0: (short)[], arg1: $Collection$Type<(short)>): (short)[]
public static "plus"(arg0: (byte)[], arg1: $Collection$Type<(byte)>): (byte)[]
public static "plus"<T>(arg0: (T)[], arg1: $Collection$Type<(any)>): (T)[]
public static "plus"(arg0: (character)[], arg1: $Collection$Type<(character)>): (character)[]
public static "plus"(arg0: (boolean)[], arg1: $Collection$Type<(boolean)>): (boolean)[]
public static "plus"(arg0: (double)[], arg1: $Collection$Type<(double)>): (double)[]
public static "plus"(arg0: (float)[], arg1: $Collection$Type<(float)>): (float)[]
public static "plus"<T>(arg0: (T)[], arg1: T): (T)[]
public static "plus"(arg0: (byte)[], arg1: byte): (byte)[]
public static "plus"(arg0: (short)[], arg1: short): (short)[]
public static "plus"(arg0: (integer)[], arg1: integer): (integer)[]
public static "copyInto"(arg0: (float)[], arg1: (float)[], arg2: integer, arg3: integer, arg4: integer): (float)[]
public static "copyInto"(arg0: (double)[], arg1: (double)[], arg2: integer, arg3: integer, arg4: integer): (double)[]
public static "copyInto"(arg0: (long)[], arg1: (long)[], arg2: integer, arg3: integer, arg4: integer): (long)[]
public static "copyInto"(arg0: (boolean)[], arg1: (boolean)[], arg2: integer, arg3: integer, arg4: integer): (boolean)[]
public static "copyInto"(arg0: (character)[], arg1: (character)[], arg2: integer, arg3: integer, arg4: integer): (character)[]
public static "copyInto"<T>(arg0: (T)[], arg1: (T)[], arg2: integer, arg3: integer, arg4: integer): (T)[]
public static "copyInto"(arg0: (byte)[], arg1: (byte)[], arg2: integer, arg3: integer, arg4: integer): (byte)[]
public static "copyInto"(arg0: (short)[], arg1: (short)[], arg2: integer, arg3: integer, arg4: integer): (short)[]
public static "copyInto"(arg0: (integer)[], arg1: (integer)[], arg2: integer, arg3: integer, arg4: integer): (integer)[]
public static "toTypedArray"(arg0: (integer)[]): (integer)[]
public static "toTypedArray"(arg0: (boolean)[]): (boolean)[]
public static "toTypedArray"(arg0: (double)[]): (double)[]
public static "toTypedArray"(arg0: (float)[]): (float)[]
public static "toTypedArray"(arg0: (long)[]): (long)[]
public static "toTypedArray"(arg0: (byte)[]): (byte)[]
public static "toTypedArray"(arg0: (short)[]): (short)[]
public static "toTypedArray"(arg0: (character)[]): (character)[]
public static "toSortedSet"(arg0: (boolean)[]): $SortedSet<(boolean)>
public static "toSortedSet"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): $SortedSet<(T)>
public static "toSortedSet"(arg0: (character)[]): $SortedSet<(character)>
public static "toSortedSet"(arg0: (integer)[]): $SortedSet<(integer)>
public static "toSortedSet"<T extends $Comparable<(any)>>(arg0: (T)[]): $SortedSet<(T)>
public static "toSortedSet"(arg0: (short)[]): $SortedSet<(short)>
public static "toSortedSet"(arg0: (byte)[]): $SortedSet<(byte)>
public static "toSortedSet"(arg0: (double)[]): $SortedSet<(double)>
public static "toSortedSet"(arg0: (float)[]): $SortedSet<(float)>
public static "toSortedSet"(arg0: (long)[]): $SortedSet<(long)>
public static "filterIsInstanceTo"<C extends $Collection<(any)>, R>(arg0: (any)[], arg1: C, arg2: $Class$Type<(R)>): C
public static "filterIsInstance"<R>(arg0: (any)[], arg1: $Class$Type<(R)>): $List<(R)>
public static "sortWith"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): void
public static "sortWith"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysKt___ArraysJvmKt$Type = ($ArraysKt___ArraysJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysKt___ArraysJvmKt_ = $ArraysKt___ArraysJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$PathResource" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$File, $File$Type} from "packages/java/io/$File"
import {$ReadableByteChannel, $ReadableByteChannel$Type} from "packages/java/nio/channels/$ReadableByteChannel"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $PathResource extends $Resource {
static "__defaultUseCaches": boolean

constructor(arg0: $URI$Type)
constructor(arg0: $URL$Type)
constructor(arg0: $File$Type)
constructor(arg0: $Path$Type)

public "getReadableByteChannel"(): $ReadableByteChannel
public "getName"(): string
public "equals"(arg0: any): boolean
public "length"(): long
public "toString"(): string
public "hashCode"(): integer
public "list"(): (string)[]
public "delete"(): boolean
public "close"(): void
public "getInputStream"(): $InputStream
public "getFile"(): $File
public "getPath"(): $Path
public "exists"(): boolean
public "renameTo"(arg0: $Resource$Type): boolean
public "isDirectory"(): boolean
public "lastModified"(): long
public "getURL"(): $URL
public "getURI"(): $URI
public "isAlias"(): boolean
public "addPath"(arg0: string): $Resource
public "isContainedIn"(arg0: $Resource$Type): boolean
public "getAliasPath"(): $Path
public "copyTo"(arg0: $File$Type): void
public "getAlias"(): $URI
get "readableByteChannel"(): $ReadableByteChannel
get "name"(): string
get "inputStream"(): $InputStream
get "file"(): $File
get "path"(): $Path
get "directory"(): boolean
get "uRL"(): $URL
get "uRI"(): $URI
get "alias"(): boolean
get "aliasPath"(): $Path
get "alias"(): $URI
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathResource$Type = ($PathResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathResource_ = $PathResource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$RequestResponseFactory" {
import {$RouteMatch, $RouteMatch$Type} from "packages/info/journeymap/shaded/kotlin/spark/routematch/$RouteMatch"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $RequestResponseFactory {


public static "create"(arg0: $HttpServletResponse$Type): $Response
public static "create"(arg0: $RouteMatch$Type, arg1: $HttpServletRequest$Type): $Request
public static "create"(arg0: $HttpServletRequest$Type): $Request
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestResponseFactory$Type = ($RequestResponseFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequestResponseFactory_ = $RequestResponseFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$SafePublicationLazyImpl" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$SafePublicationLazyImpl$Companion, $SafePublicationLazyImpl$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$SafePublicationLazyImpl$Companion"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"

export class $SafePublicationLazyImpl<T> implements $Lazy<(T)>, $Serializable {
static readonly "Companion": $SafePublicationLazyImpl$Companion

constructor(arg0: $Function0$Type<(any)>)

public "toString"(): string
public "getValue"(): T
public "isInitialized"(): boolean
get "value"(): T
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SafePublicationLazyImpl$Type<T> = ($SafePublicationLazyImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SafePublicationLazyImpl_<T> = $SafePublicationLazyImpl$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$OnWebSocketClose" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OnWebSocketClose extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OnWebSocketClose {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnWebSocketClose$Type = ($OnWebSocketClose);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnWebSocketClose_ = $OnWebSocketClose$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$FilteringSequence" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $FilteringSequence<T> implements $Sequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: boolean, arg2: $Function1$Type<(any), (boolean)>)
constructor(arg0: $Sequence$Type<(any)>, arg1: boolean, arg2: $Function1$Type<(any), (any)>, arg3: integer, arg4: $DefaultConstructorMarker$Type)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilteringSequence$Type<T> = ($FilteringSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilteringSequence_<T> = $FilteringSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$SuspendFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SuspendFunction {

}

export namespace $SuspendFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuspendFunction$Type = ($SuspendFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuspendFunction_ = $SuspendFunction$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFieldPreEncoder" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"

export interface $HttpFieldPreEncoder {

 "getEncodedField"(arg0: $HttpHeader$Type, arg1: string, arg2: string): (byte)[]
 "getHttpVersion"(): $HttpVersion
}

export namespace $HttpFieldPreEncoder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpFieldPreEncoder$Type = ($HttpFieldPreEncoder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpFieldPreEncoder_ = $HttpFieldPreEncoder$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$CoroutineSingletons" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $CoroutineSingletons extends $Enum<($CoroutineSingletons)> {
static readonly "COROUTINE_SUSPENDED": $CoroutineSingletons
static readonly "UNDECIDED": $CoroutineSingletons
static readonly "RESUMED": $CoroutineSingletons


public static "values"(): ($CoroutineSingletons)[]
public static "valueOf"(arg0: string): $CoroutineSingletons
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoroutineSingletons$Type = (("coroutine_suspended") | ("undecided") | ("resumed")) | ($CoroutineSingletons);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoroutineSingletons_ = $CoroutineSingletons$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService" {
import {$RunAsToken, $RunAsToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RunAsToken"
import {$Subject, $Subject$Type} from "packages/javax/security/auth/$Subject"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"

export interface $IdentityService {

 "setRunAs"(arg0: $UserIdentity$Type, arg1: $RunAsToken$Type): any
 "unsetRunAs"(arg0: any): void
 "newUserIdentity"(arg0: $Subject$Type, arg1: $Principal$Type, arg2: (string)[]): $UserIdentity
 "newRunAsToken"(arg0: string): $RunAsToken
 "associate"(arg0: $UserIdentity$Type): any
 "disassociate"(arg0: any): void
 "getSystemUserIdentity"(): $UserIdentity
}

export namespace $IdentityService {
const NO_ROLES: (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdentityService$Type = ($IdentityService);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdentityService_ = $IdentityService$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestAttributeListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$ServletRequestAttributeEvent, $ServletRequestAttributeEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestAttributeEvent"

export interface $ServletRequestAttributeListener extends $EventListener {

 "attributeAdded"(arg0: $ServletRequestAttributeEvent$Type): void
 "attributeReplaced"(arg0: $ServletRequestAttributeEvent$Type): void
 "attributeRemoved"(arg0: $ServletRequestAttributeEvent$Type): void
}

export namespace $ServletRequestAttributeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestAttributeListener$Type = ($ServletRequestAttributeListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestAttributeListener_ = $ServletRequestAttributeListener$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTIME" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkTIME extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setYMDHMS"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
public "setNow"(arg0: integer): void
public "getYMDHMS"(): (integer)[]
public "getAsString"(): string
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "now"(value: integer)
get "yMDHMS"(): (integer)[]
get "asString"(): string
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkTIME$Type = ($PngChunkTIME);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkTIME_ = $PngChunkTIME$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$MappingMatch" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MappingMatch extends $Enum<($MappingMatch)> {
static readonly "CONTEXT_ROOT": $MappingMatch
static readonly "DEFAULT": $MappingMatch
static readonly "EXACT": $MappingMatch
static readonly "EXTENSION": $MappingMatch
static readonly "PATH": $MappingMatch


public static "values"(): ($MappingMatch)[]
public static "valueOf"(arg0: string): $MappingMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MappingMatch$Type = (("context_root") | ("path") | ("default") | ("extension") | ("exact")) | ($MappingMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MappingMatch_ = $MappingMatch$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ReplaceWith" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ReplaceWith extends $Annotation {

 "imports"(): (string)[]
 "expression"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ReplaceWith {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceWith$Type = ($ReplaceWith);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplaceWith_ = $ReplaceWith$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt" {
import {$ComparisonsKt___ComparisonsKt, $ComparisonsKt___ComparisonsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ComparisonsKt___ComparisonsKt"

export class $ComparisonsKt extends $ComparisonsKt___ComparisonsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparisonsKt$Type = ($ComparisonsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparisonsKt_ = $ComparisonsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Locker$Lock" {
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"

export class $Locker$Lock implements $AutoCloseable {

constructor()

public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Locker$Lock$Type = ($Locker$Lock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Locker$Lock_ = $Locker$Lock$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1$Getter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty1$Getter<T, V> extends $KProperty$Getter<(V)>, $Function1<(T), (V)> {

 "invoke"(arg0: T): V
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty1$Getter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty1$Getter$Type<T, V> = ($KProperty1$Getter<(T), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty1$Getter_<T, V> = $KProperty1$Getter$Type<(T), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$ExternalResourceHandler" {
import {$AbstractResourceHandler, $AbstractResourceHandler$Type} from "packages/info/journeymap/shaded/kotlin/spark/resource/$AbstractResourceHandler"

export class $ExternalResourceHandler extends $AbstractResourceHandler {

constructor(arg0: string)
constructor(arg0: string, arg1: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExternalResourceHandler$Type = ($ExternalResourceHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExternalResourceHandler_ = $ExternalResourceHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PackageReference" {
import {$ClassBasedDeclarationContainer, $ClassBasedDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassBasedDeclarationContainer"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $PackageReference implements $ClassBasedDeclarationContainer {

constructor(arg0: $Class$Type<(any)>, arg1: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getMembers"(): $Collection<($KCallable<(any)>)>
public "getJClass"(): $Class<(any)>
get "members"(): $Collection<($KCallable<(any)>)>
get "jClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageReference$Type = ($PackageReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PackageReference_ = $PackageReference$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty1$Getter, $KProperty1$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty1<T, V> extends $KProperty<(V)>, $Function1<(T), (V)> {

 "get"(arg0: T): V
 "getDelegate"(arg0: T): any
 "getGetter"(): $KProperty1$Getter<(T), (V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(arg0: T): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty1 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty1$Type<T, V> = ($KProperty1<(T), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty1_<T, V> = $KProperty1$Type<(T), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty2$Getter, $KProperty2$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty2<D, E, V> extends $KProperty<(V)>, $Function2<(D), (E), (V)> {

 "get"(arg0: D, arg1: E): V
 "getDelegate"(arg0: D, arg1: E): any
 "getGetter"(): $KProperty2$Getter<(D), (E), (V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(arg0: D, arg1: E): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty2$Type<D, E, V> = ($KProperty2<(D), (E), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty2_<D, E, V> = $KProperty2$Type<(D), (E), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty0$Getter, $KProperty0$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty0<V> extends $KProperty<(V)>, $Function0<(V)> {

 "get"(): V
 "getDelegate"(): any
 "getGetter"(): $KProperty0$Getter<(V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty0 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty0$Type<V> = ($KProperty0<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty0_<V> = $KProperty0$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$PlatformRandomKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Random as $Random$0, $Random$Type as $Random$0$Type} from "packages/java/util/$Random"

export class $PlatformRandomKt {


public static "doubleFromParts"(arg0: integer, arg1: integer): double
public static "asJavaRandom"(arg0: $Random$Type): $Random$0
public static "asKotlinRandom"(arg0: $Random$0$Type): $Random
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformRandomKt$Type = ($PlatformRandomKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformRandomKt_ = $PlatformRandomKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/kotlin/$Http" {
import {$ResponseTransformer, $ResponseTransformer$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer"
import {$Service, $Service$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Redirect, $Redirect$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Redirect"
import {$TemplateEngine, $TemplateEngine$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Filter"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Service$StaticFiles, $Service$StaticFiles$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service$StaticFiles"

export class $Http {

constructor(arg0: $Service$Type)

public "getDEFAULT_ACCEPT"(): string
public "get"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "get"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "get"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "put"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "put"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "put"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "trace"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "trace"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "trace"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "delete"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "delete"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "delete"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "connect"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "connect"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "connect"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "port"(arg0: integer): $Http
public "port"(): integer
public "stop"(): void
public "options"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "options"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "options"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "before"(arg0: $Filter$Type, arg1: string): void
public "before"(arg0: string, arg1: string, arg2: $Function1$Type<(any), ($Unit$Type)>): void
public "after"(arg0: string, arg1: string, arg2: $Function1$Type<(any), ($Unit$Type)>): void
public "head"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "head"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "head"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "patch"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "patch"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "patch"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "post"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public "post"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public "post"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public "finally"(arg0: string, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public "getService"(): $Service
public "secure"(arg0: string, arg1: string, arg2: string, arg3: string): $Http
public "secure"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: boolean): $Http
public "ipAddress"(arg0: string): $Http
public "notFound"(arg0: $Function1$Type<(any), (any)>): void
public "getStaticFiles"(): $Service$StaticFiles
public "threadPool"(arg0: integer): $Http
public "threadPool"(arg0: integer, arg1: integer, arg2: integer): $Http
public "getRedirect"(): $Redirect
public "internalServerError"(arg0: $Function1$Type<(any), (any)>): void
get "dEFAULT_ACCEPT"(): string
get "service"(): $Service
get "staticFiles"(): $Service$StaticFiles
get "redirect"(): $Redirect
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Http$Type = ($Http);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Http_ = $Http$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformerRouteImpl" {
import {$RouteImpl, $RouteImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteImpl"
import {$ResponseTransformer, $ResponseTransformer$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer"
import {$Route, $Route$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Route"

export class $ResponseTransformerRouteImpl extends $RouteImpl {


public static "create"(arg0: string, arg1: $Route$Type, arg2: $ResponseTransformer$Type): $ResponseTransformerRouteImpl
public static "create"(arg0: string, arg1: string, arg2: $Route$Type, arg3: $ResponseTransformer$Type): $ResponseTransformerRouteImpl
public "render"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResponseTransformerRouteImpl$Type = ($ResponseTransformerRouteImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResponseTransformerRouteImpl_ = $ResponseTransformerRouteImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServers" {
import {$EmbeddedServer, $EmbeddedServer$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServer"
import {$EmbeddedServerFactory, $EmbeddedServerFactory$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServerFactory"
import {$EmbeddedServers$Identifiers, $EmbeddedServers$Identifiers$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServers$Identifiers"
import {$StaticFilesConfiguration, $StaticFilesConfiguration$Type} from "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesConfiguration"
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"

export class $EmbeddedServers {

constructor()

public static "add"(arg0: any, arg1: $EmbeddedServerFactory$Type): void
public static "initialize"(): void
public static "create"(arg0: any, arg1: $Routes$Type, arg2: $StaticFilesConfiguration$Type, arg3: boolean): $EmbeddedServer
public static "defaultIdentifier"(): $EmbeddedServers$Identifiers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedServers$Type = ($EmbeddedServers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedServers_ = $EmbeddedServers$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UShort" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$UShort$Companion, $UShort$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UShort$Companion"

export class $UShort implements $Comparable<($UShort)> {
static readonly "Companion": $UShort$Companion
static readonly "MIN_VALUE": short
static readonly "MAX_VALUE": short
static readonly "SIZE_BYTES": integer
static readonly "SIZE_BITS": integer


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "constructor-impl"(arg0: short): short
public static "equals-impl"(arg0: short, arg1: any): boolean
public static "hashCode-impl"(arg0: short): integer
public static "toString-impl"(arg0: short): string
public static "equals-impl0"(arg0: short, arg1: short): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UShort$Type = ($UShort);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UShort_ = $UShort$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IteratingNestedCallback" {
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$IteratingCallback, $IteratingCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IteratingCallback"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $IteratingNestedCallback extends $IteratingCallback {

constructor(arg0: $Callback$Type)

public "toString"(): string
public "getInvocationType"(): $Invocable$InvocationType
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "invocationType"(): $Invocable$InvocationType
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IteratingNestedCallback$Type = ($IteratingNestedCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IteratingNestedCallback_ = $IteratingNestedCallback$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FileReadWriteKt" {
import {$FilesKt__FilePathComponentsKt, $FilesKt__FilePathComponentsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FilePathComponentsKt"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$File, $File$Type} from "packages/java/io/$File"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $FilesKt__FileReadWriteKt extends $FilesKt__FilePathComponentsKt {

constructor()

public static "readBytes"(arg0: $File$Type): (byte)[]
public static "writeBytes"(arg0: $File$Type, arg1: (byte)[]): void
public static "appendText"(arg0: $File$Type, arg1: string, arg2: $Charset$Type): void
public static "forEachLine"(arg0: $File$Type, arg1: $Charset$Type, arg2: $Function1$Type<(any), ($Unit$Type)>): void
public static "readLines"(arg0: $File$Type, arg1: $Charset$Type): $List<(string)>
public static "useLines"<T>(arg0: $File$Type, arg1: $Charset$Type, arg2: $Function1$Type<(any), (any)>): T
public static "readText"(arg0: $File$Type, arg1: $Charset$Type): string
public static "appendBytes"(arg0: $File$Type, arg1: (byte)[]): void
public static "forEachBlock"(arg0: $File$Type, arg1: integer, arg2: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachBlock"(arg0: $File$Type, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "writeText"(arg0: $File$Type, arg1: string, arg2: $Charset$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilesKt__FileReadWriteKt$Type = ($FilesKt__FileReadWriteKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilesKt__FileReadWriteKt_ = $FilesKt__FileReadWriteKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BadPayloadException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CloseException, $CloseException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseException"

export class $BadPayloadException extends $CloseException {

constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BadPayloadException$Type = ($BadPayloadException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BadPayloadException_ = $BadPayloadException$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContainerInitializer" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export interface $ServletContainerInitializer {

 "onStartup"(arg0: $Set$Type<($Class$Type<(any)>)>, arg1: $ServletContext$Type): void

(arg0: $Set$Type<($Class$Type<(any)>)>, arg1: $ServletContext$Type): void
}

export namespace $ServletContainerInitializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContainerInitializer$Type = ($ServletContainerInitializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContainerInitializer_ = $ServletContainerInitializer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ArrayTrie" {
import {$AbstractTrie, $AbstractTrie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AbstractTrie"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $ArrayTrie<V> extends $AbstractTrie<(V)> {

constructor()
constructor(arg0: integer)

public "get"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "get"(arg0: string, arg1: integer, arg2: integer): V
public "put"(arg0: string, arg1: V): boolean
public "toString"(): string
public "clear"(): void
public "keySet"(): $Set<(string)>
public "isFull"(): boolean
public "getBest"(arg0: (byte)[], arg1: integer, arg2: integer): V
public "getBest"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "getBest"(arg0: string, arg1: integer, arg2: integer): V
get "full"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayTrie$Type<V> = ($ArrayTrie<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayTrie_<V> = $ArrayTrie$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$RequiresOptIn$Level" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $RequiresOptIn$Level extends $Enum<($RequiresOptIn$Level)> {
static readonly "WARNING": $RequiresOptIn$Level
static readonly "ERROR": $RequiresOptIn$Level


public static "values"(): ($RequiresOptIn$Level)[]
public static "valueOf"(arg0: string): $RequiresOptIn$Level
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequiresOptIn$Level$Type = (("warning") | ("error")) | ($RequiresOptIn$Level);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequiresOptIn$Level_ = $RequiresOptIn$Level$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Graceful" {
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"

export interface $Graceful {

 "shutdown"(): $Future<(void)>

(): $Future<(void)>
}

export namespace $Graceful {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Graceful$Type = ($Graceful);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Graceful_ = $Graceful$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageReader" {
import {$MessageInputStream, $MessageInputStream$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageInputStream"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageAppender, $MessageAppender$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageAppender"
import {$InputStreamReader, $InputStreamReader$Type} from "packages/java/io/$InputStreamReader"

export class $MessageReader extends $InputStreamReader implements $MessageAppender {

constructor(arg0: $MessageInputStream$Type)

public "messageComplete"(): void
public "appendFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageReader$Type = ($MessageReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageReader_ = $MessageReader$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$ByteStreamsKt" {
import {$ByteIterator, $ByteIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ByteIterator"
import {$BufferedInputStream, $BufferedInputStream$Type} from "packages/java/io/$BufferedInputStream"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $ByteStreamsKt {


public static "iterator"(arg0: $BufferedInputStream$Type): $ByteIterator
public static "readBytes"(arg0: $InputStream$Type): (byte)[]
public static "readBytes"(arg0: $InputStream$Type, arg1: integer): (byte)[]
public static "copyTo"(arg0: $InputStream$Type, arg1: $OutputStream$Type, arg2: integer): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteStreamsKt$Type = ($ByteStreamsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteStreamsKt_ = $ByteStreamsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$BooleanIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $BooleanIterator implements $Iterator<(boolean)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextBoolean"(): boolean
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanIterator$Type = ($BooleanIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanIterator_ = $BooleanIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$NoWhenBranchMatchedException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $NoWhenBranchMatchedException extends $RuntimeException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoWhenBranchMatchedException$Type = ($NoWhenBranchMatchedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoWhenBranchMatchedException_ = $NoWhenBranchMatchedException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$IntrinsicsKt" {
import {$IntrinsicsKt__IntrinsicsKt, $IntrinsicsKt__IntrinsicsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$IntrinsicsKt__IntrinsicsKt"

export class $IntrinsicsKt extends $IntrinsicsKt__IntrinsicsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntrinsicsKt$Type = ($IntrinsicsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntrinsicsKt_ = $IntrinsicsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$UByteIterator" {
import {$UByte, $UByte$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UByte"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $UByteIterator implements $Iterator<($UByte)>, $KMappedMarker {

constructor()

public "remove"(): void
public "next-w2LRezQ"(): byte
public "nextUByte-w2LRezQ"(): byte
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UByteIterator$Type = ($UByteIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UByteIterator_ = $UByteIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$_OneToManyTitlecaseMappingsKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $_OneToManyTitlecaseMappingsKt {


public static "titlecaseImpl"(arg0: character): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $_OneToManyTitlecaseMappingsKt$Type = ($_OneToManyTitlecaseMappingsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $_OneToManyTitlecaseMappingsKt_ = $_OneToManyTitlecaseMappingsKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineInt" {
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLineFactory, $IImageLineFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineFactory"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$IImageLineArray, $IImageLineArray$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineArray"

export class $ImageLineInt implements $IImageLine, $IImageLineArray {
readonly "imgInfo": $ImageInfo

constructor(arg0: $ImageInfo$Type)
constructor(arg0: $ImageInfo$Type, arg1: (integer)[])

public "toString"(): string
public static "getFactory"(arg0: $ImageInfo$Type): $IImageLineFactory<($ImageLineInt)>
public "getSize"(): integer
public "getElem"(arg0: integer): integer
public "getImageInfo"(): $ImageInfo
public "endReadFromPngRaw"(): void
public "readFromPngRaw"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): void
public "writeToPngRaw"(arg0: (byte)[]): void
public "getScanline"(): (integer)[]
public "getFilterType"(): $FilterType
get "size"(): integer
get "imageInfo"(): $ImageInfo
get "scanline"(): (integer)[]
get "filterType"(): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageLineInt$Type = ($ImageLineInt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageLineInt_ = $ImageLineInt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkFactory" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$IChunkFactory, $IChunkFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IChunkFactory"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export class $ChunkFactory implements $IChunkFactory {

constructor()
constructor(arg0: boolean)

public "createChunk"(arg0: $ChunkRaw$Type, arg1: $ImageInfo$Type): $PngChunk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkFactory$Type = ($ChunkFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkFactory_ = $ChunkFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MemoryUtils" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MemoryUtils {


public static "getCacheLineBytes"(): integer
public static "getLongsPerCacheLine"(): integer
public static "getIntegersPerCacheLine"(): integer
get "cacheLineBytes"(): integer
get "longsPerCacheLine"(): integer
get "integersPerCacheLine"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MemoryUtils$Type = ($MemoryUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MemoryUtils_ = $MemoryUtils$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$RingBuffer" {
import {$AbstractList$Companion, $AbstractList$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList$Companion"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$AbstractList, $AbstractList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractList"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $RingBuffer<T> extends $AbstractList<(T)> implements $RandomAccess {
static readonly "Companion": $AbstractList$Companion

constructor(arg0: (any)[], arg1: integer)
constructor(arg0: integer)

public "add"(arg0: T): void
public "get"(arg0: integer): T
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(T)>
public "getSize"(): integer
public "removeFirst"(arg0: integer): void
public "expanded"(arg0: integer): $RingBuffer<(T)>
public "isFull"(): boolean
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "full"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RingBuffer$Type<T> = ($RingBuffer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RingBuffer_<T> = $RingBuffer$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SessionIdManager" {
import {$HouseKeeper, $HouseKeeper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$HouseKeeper"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export interface $SessionIdManager extends $LifeCycle {

 "getId"(arg0: string): string
 "setSessionHouseKeeper"(arg0: $HouseKeeper$Type): void
 "getSessionHouseKeeper"(): $HouseKeeper
 "getExtendedId"(arg0: string, arg1: $HttpServletRequest$Type): string
 "renewSessionId"(arg0: string, arg1: string, arg2: $HttpServletRequest$Type): string
 "getSessionHandlers"(): $Set<($SessionHandler)>
 "isIdInUse"(arg0: string): boolean
 "newSessionId"(arg0: $HttpServletRequest$Type, arg1: long): string
 "expireAll"(arg0: string): void
 "getWorkerName"(): string
 "invalidateAll"(arg0: string): void
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $SessionIdManager {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionIdManager$Type = ($SessionIdManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionIdManager_ = $SessionIdManager$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$Itr" {
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"

export class $MapBuilder$Itr<K, V> {

constructor(arg0: $MapBuilder$Type<(K), (V)>)

public "remove"(): void
public "hasNext"(): boolean
public "getIndex$kotlin_stdlib"(): integer
public "getMap$kotlin_stdlib"(): $MapBuilder<(K), (V)>
public "initNext$kotlin_stdlib"(): void
public "getLastIndex$kotlin_stdlib"(): integer
public "setIndex$kotlin_stdlib"(arg0: integer): void
public "setLastIndex$kotlin_stdlib"(arg0: integer): void
get "index$kotlin_stdlib"(): integer
get "map$kotlin_stdlib"(): $MapBuilder<(K), (V)>
get "lastIndex$kotlin_stdlib"(): integer
set "index$kotlin_stdlib"(value: integer)
set "lastIndex$kotlin_stdlib"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$Itr$Type<K, V> = ($MapBuilder$Itr<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder$Itr_<K, V> = $MapBuilder$Itr$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$SinceKotlin" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $SinceKotlin extends $Annotation {

 "version"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $SinceKotlin {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinceKotlin$Type = ($SinceKotlin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SinceKotlin_ = $SinceKotlin$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyListenerImpl" {
import {$EventDriverImpl, $EventDriverImpl$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverImpl"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"

export class $JettyListenerImpl implements $EventDriverImpl {

constructor()

public "create"(arg0: any, arg1: $WebSocketPolicy$Type): $EventDriver
public "describeRule"(): string
public "supports"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyListenerImpl$Type = ($JettyListenerImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyListenerImpl_ = $JettyListenerImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$BeforeFilters" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BeforeFilters {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeforeFilters$Type = ($BeforeFilters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeforeFilters_ = $BeforeFilters$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinVersion$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $KotlinVersion$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinVersion$Companion$Type = ($KotlinVersion$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinVersion$Companion_ = $KotlinVersion$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$BufferedStreamFeeder" {
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$IBytesConsumer, $IBytesConsumer$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IBytesConsumer"

export class $BufferedStreamFeeder {

constructor(arg0: $InputStream$Type)
constructor(arg0: $InputStream$Type, arg1: integer)

public "close"(): void
public "setInputStream"(arg0: $InputStream$Type): void
public "getStream"(): $InputStream
public "setCloseStream"(arg0: boolean): void
public "feedFixed"(arg0: $IBytesConsumer$Type, arg1: integer): boolean
public "setFailIfNoFeed"(arg0: boolean): void
public "isEof"(): boolean
public "hasMoreToFeed"(): boolean
public "feed"(arg0: $IBytesConsumer$Type): integer
public "feed"(arg0: $IBytesConsumer$Type, arg1: integer): integer
set "inputStream"(value: $InputStream$Type)
get "stream"(): $InputStream
set "closeStream"(value: boolean)
set "failIfNoFeed"(value: boolean)
get "eof"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BufferedStreamFeeder$Type = ($BufferedStreamFeeder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BufferedStreamFeeder_ = $BufferedStreamFeeder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpStatus$Code" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpStatus$Code extends $Enum<($HttpStatus$Code)> {
static readonly "CONTINUE": $HttpStatus$Code
static readonly "SWITCHING_PROTOCOLS": $HttpStatus$Code
static readonly "PROCESSING": $HttpStatus$Code
static readonly "OK": $HttpStatus$Code
static readonly "CREATED": $HttpStatus$Code
static readonly "ACCEPTED": $HttpStatus$Code
static readonly "NON_AUTHORITATIVE_INFORMATION": $HttpStatus$Code
static readonly "NO_CONTENT": $HttpStatus$Code
static readonly "RESET_CONTENT": $HttpStatus$Code
static readonly "PARTIAL_CONTENT": $HttpStatus$Code
static readonly "MULTI_STATUS": $HttpStatus$Code
static readonly "MULTIPLE_CHOICES": $HttpStatus$Code
static readonly "MOVED_PERMANENTLY": $HttpStatus$Code
static readonly "MOVED_TEMPORARILY": $HttpStatus$Code
static readonly "FOUND": $HttpStatus$Code
static readonly "SEE_OTHER": $HttpStatus$Code
static readonly "NOT_MODIFIED": $HttpStatus$Code
static readonly "USE_PROXY": $HttpStatus$Code
static readonly "TEMPORARY_REDIRECT": $HttpStatus$Code
static readonly "PERMANET_REDIRECT": $HttpStatus$Code
static readonly "BAD_REQUEST": $HttpStatus$Code
static readonly "UNAUTHORIZED": $HttpStatus$Code
static readonly "PAYMENT_REQUIRED": $HttpStatus$Code
static readonly "FORBIDDEN": $HttpStatus$Code
static readonly "NOT_FOUND": $HttpStatus$Code
static readonly "METHOD_NOT_ALLOWED": $HttpStatus$Code
static readonly "NOT_ACCEPTABLE": $HttpStatus$Code
static readonly "PROXY_AUTHENTICATION_REQUIRED": $HttpStatus$Code
static readonly "REQUEST_TIMEOUT": $HttpStatus$Code
static readonly "CONFLICT": $HttpStatus$Code
static readonly "GONE": $HttpStatus$Code
static readonly "LENGTH_REQUIRED": $HttpStatus$Code
static readonly "PRECONDITION_FAILED": $HttpStatus$Code
static readonly "PAYLOAD_TOO_LARGE": $HttpStatus$Code
static readonly "URI_TOO_LONG": $HttpStatus$Code
static readonly "UNSUPPORTED_MEDIA_TYPE": $HttpStatus$Code
static readonly "RANGE_NOT_SATISFIABLE": $HttpStatus$Code
static readonly "EXPECTATION_FAILED": $HttpStatus$Code
static readonly "IM_A_TEAPOT": $HttpStatus$Code
static readonly "ENHANCE_YOUR_CALM": $HttpStatus$Code
static readonly "MISDIRECTED_REQUEST": $HttpStatus$Code
static readonly "UNPROCESSABLE_ENTITY": $HttpStatus$Code
static readonly "LOCKED": $HttpStatus$Code
static readonly "FAILED_DEPENDENCY": $HttpStatus$Code
static readonly "UPGRADE_REQUIRED": $HttpStatus$Code
static readonly "PRECONDITION_REQUIRED": $HttpStatus$Code
static readonly "TOO_MANY_REQUESTS": $HttpStatus$Code
static readonly "REQUEST_HEADER_FIELDS_TOO_LARGE": $HttpStatus$Code
static readonly "UNAVAILABLE_FOR_LEGAL_REASONS": $HttpStatus$Code
static readonly "INTERNAL_SERVER_ERROR": $HttpStatus$Code
static readonly "NOT_IMPLEMENTED": $HttpStatus$Code
static readonly "BAD_GATEWAY": $HttpStatus$Code
static readonly "SERVICE_UNAVAILABLE": $HttpStatus$Code
static readonly "GATEWAY_TIMEOUT": $HttpStatus$Code
static readonly "HTTP_VERSION_NOT_SUPPORTED": $HttpStatus$Code
static readonly "INSUFFICIENT_STORAGE": $HttpStatus$Code
static readonly "LOOP_DETECTED": $HttpStatus$Code
static readonly "NOT_EXTENDED": $HttpStatus$Code
static readonly "NETWORK_AUTHENTICATION_REQUIRED": $HttpStatus$Code


public "equals"(arg0: integer): boolean
public "toString"(): string
public static "values"(): ($HttpStatus$Code)[]
public static "valueOf"(arg0: string): $HttpStatus$Code
public "getMessage"(): string
public "isSuccess"(): boolean
public "isRedirection"(): boolean
public "isClientError"(): boolean
public "isServerError"(): boolean
public "getCode"(): integer
public "isInformational"(): boolean
get "message"(): string
get "success"(): boolean
get "redirection"(): boolean
get "clientError"(): boolean
get "serverError"(): boolean
get "code"(): integer
get "informational"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpStatus$Code$Type = (("unprocessable_entity") | ("request_timeout") | ("not_extended") | ("use_proxy") | ("permanet_redirect") | ("payment_required") | ("not_acceptable") | ("continue") | ("expectation_failed") | ("precondition_failed") | ("locked") | ("partial_content") | ("length_required") | ("method_not_allowed") | ("created") | ("range_not_satisfiable") | ("accepted") | ("precondition_required") | ("bad_request") | ("gone") | ("upgrade_required") | ("temporary_redirect") | ("processing") | ("uri_too_long") | ("switching_protocols") | ("request_header_fields_too_large") | ("conflict") | ("proxy_authentication_required") | ("loop_detected") | ("moved_permanently") | ("too_many_requests") | ("non_authoritative_information") | ("not_modified") | ("not_implemented") | ("found") | ("multiple_choices") | ("payload_too_large") | ("http_version_not_supported") | ("network_authentication_required") | ("ok") | ("not_found") | ("enhance_your_calm") | ("gateway_timeout") | ("reset_content") | ("forbidden") | ("insufficient_storage") | ("unsupported_media_type") | ("misdirected_request") | ("failed_dependency") | ("bad_gateway") | ("unauthorized") | ("im_a_teapot") | ("unavailable_for_legal_reasons") | ("service_unavailable") | ("multi_status") | ("moved_temporarily") | ("no_content") | ("internal_server_error") | ("see_other")) | ($HttpStatus$Code);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpStatus$Code_ = $HttpStatus$Code$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Experimental" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Experimental extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Experimental {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Experimental$Type = ($Experimental);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Experimental_ = $Experimental$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/util/$Utf8PartialBuilder" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Utf8PartialBuilder {

constructor()

public "toPartialString"(arg0: $ByteBuffer$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8PartialBuilder$Type = ($Utf8PartialBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8PartialBuilder_ = $Utf8PartialBuilder$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$DeflatedChunksSet" {
import {$Inflater, $Inflater$Type} from "packages/java/util/zip/$Inflater"

export class $DeflatedChunksSet {
readonly "chunkid": string

constructor(arg0: string, arg1: integer, arg2: integer, arg3: $Inflater$Type, arg4: (byte)[])
constructor(arg0: string, arg1: integer, arg2: integer)

public "toString"(): string
public "close"(): void
public "isDone"(): boolean
public "isTerminated"(): boolean
public "done"(): void
public "ackNextChunkId"(arg0: string): boolean
public "setCallbackMode"(arg0: boolean): void
public "isCallbackMode"(): boolean
public "getInflatedRow"(): (byte)[]
public "prepareForNextRow"(arg0: integer): void
public "getRown"(): integer
public "getRowFilled"(): integer
public "getRowLen"(): integer
public "isRowReady"(): boolean
public "isWaitingForMoreInput"(): boolean
public "allowOtherChunksInBetween"(arg0: string): boolean
public "getBytesIn"(): long
public "getBytesOut"(): long
get "terminated"(): boolean
set "callbackMode"(value: boolean)
get "callbackMode"(): boolean
get "inflatedRow"(): (byte)[]
get "rown"(): integer
get "rowFilled"(): integer
get "rowLen"(): integer
get "rowReady"(): boolean
get "waitingForMoreInput"(): boolean
get "bytesIn"(): long
get "bytesOut"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeflatedChunksSet$Type = ($DeflatedChunksSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeflatedChunksSet_ = $DeflatedChunksSet$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractCollection" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $AbstractCollection<E> implements $Collection<(E)>, $KMappedMarker {


public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "toString"(): string
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(E)>
public "contains"(arg0: E): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(E)>
public "spliterator"(): $Spliterator<(E)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(E)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<E>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCollection$Type<E> = ($AbstractCollection<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractCollection_<E> = $AbstractCollection$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequestWrapper" {
import {$HttpUpgradeHandler, $HttpUpgradeHandler$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler"
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletMapping, $HttpServletMapping$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$ServletRequestWrapper, $ServletRequestWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestWrapper"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HttpServletRequestWrapper extends $ServletRequestWrapper implements $HttpServletRequest {

constructor(arg0: $HttpServletRequest$Type)

public "getMethod"(): string
public "getHeader"(arg0: string): string
public "getHeaders"(arg0: string): $Enumeration<(string)>
public "authenticate"(arg0: $HttpServletResponse$Type): boolean
public "getRequestURI"(): string
public "getAuthType"(): string
public "getQueryString"(): string
public "getHttpServletMapping"(): $HttpServletMapping
public "isRequestedSessionIdValid"(): boolean
public "isRequestedSessionIdFromCookie"(): boolean
public "isRequestedSessionIdFromURL"(): boolean
/**
 * 
 * @deprecated
 */
public "isRequestedSessionIdFromUrl"(): boolean
public "isTrailerFieldsReady"(): boolean
public "getRequestedSessionId"(): string
public "getContextPath"(): string
public "getSession"(arg0: boolean): $HttpSession
public "getSession"(): $HttpSession
public "upgrade"<T extends $HttpUpgradeHandler>(arg0: $Class$Type<(T)>): T
public "getPathInfo"(): string
public "getHeaderNames"(): $Enumeration<(string)>
public "getTrailerFields"(): $Map<(string), (string)>
public "getIntHeader"(arg0: string): integer
public "newPushBuilder"(): $PushBuilder
public "getPathTranslated"(): string
public "isUserInRole"(arg0: string): boolean
public "getDateHeader"(arg0: string): long
public "getRemoteUser"(): string
public "getUserPrincipal"(): $Principal
public "getCookies"(): ($Cookie)[]
public "getRequestURL"(): $StringBuffer
public "changeSessionId"(): string
public "getServletPath"(): string
public "login"(arg0: string, arg1: string): void
public "logout"(): void
public "getParts"(): $Collection<($Part)>
public "getPart"(arg0: string): $Part
get "method"(): string
get "requestURI"(): string
get "authType"(): string
get "queryString"(): string
get "httpServletMapping"(): $HttpServletMapping
get "requestedSessionIdValid"(): boolean
get "requestedSessionIdFromCookie"(): boolean
get "requestedSessionIdFromURL"(): boolean
get "requestedSessionIdFromUrl"(): boolean
get "trailerFieldsReady"(): boolean
get "requestedSessionId"(): string
get "contextPath"(): string
get "session"(): $HttpSession
get "pathInfo"(): string
get "headerNames"(): $Enumeration<(string)>
get "trailerFields"(): $Map<(string), (string)>
get "pathTranslated"(): string
get "remoteUser"(): string
get "userPrincipal"(): $Principal
get "cookies"(): ($Cookie)[]
get "requestURL"(): $StringBuffer
get "servletPath"(): string
get "parts"(): $Collection<($Part)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServletRequestWrapper$Type = ($HttpServletRequestWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServletRequestWrapper_ = $HttpServletRequestWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$UrlEncoded" {
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$MultiMap, $MultiMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$MultiMap"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $UrlEncoded extends $MultiMap<(string)> implements $Cloneable {
static readonly "ENCODING": $Charset

constructor(arg0: $UrlEncoded$Type)
constructor(arg0: string)
constructor()

public static "encodeString"(arg0: string, arg1: $Charset$Type): string
public static "encodeString"(arg0: string): string
public "clone"(): any
public "decode"(arg0: string, arg1: $Charset$Type): void
public "decode"(arg0: string): void
public "encode"(): string
public "encode"(arg0: $Charset$Type): string
public "encode"(arg0: $Charset$Type, arg1: boolean): string
public static "encode"(arg0: $MultiMap$Type<(string)>, arg1: $Charset$Type, arg2: boolean): string
public static "decodeTo"(arg0: $InputStream$Type, arg1: $MultiMap$Type<(string)>, arg2: $Charset$Type, arg3: integer, arg4: integer): void
public static "decodeTo"(arg0: $InputStream$Type, arg1: $MultiMap$Type<(string)>, arg2: string, arg3: integer, arg4: integer): void
public static "decodeTo"(arg0: string, arg1: $MultiMap$Type<(string)>, arg2: $Charset$Type): void
public static "decodeTo"(arg0: string, arg1: $MultiMap$Type<(string)>, arg2: string): void
public static "decodeString"(arg0: string, arg1: integer, arg2: integer, arg3: $Charset$Type): string
public static "decodeString"(arg0: string): string
public static "decode88591To"(arg0: $InputStream$Type, arg1: $MultiMap$Type<(string)>, arg2: integer, arg3: integer): void
public static "decodeUtf16To"(arg0: $InputStream$Type, arg1: $MultiMap$Type<(string)>, arg2: integer, arg3: integer): void
public static "decodeUtf8To"(arg0: string, arg1: $MultiMap$Type<(string)>): void
public static "decodeUtf8To"(arg0: $InputStream$Type, arg1: $MultiMap$Type<(string)>, arg2: integer, arg3: integer): void
public static "decodeUtf8To"(arg0: string, arg1: integer, arg2: integer, arg3: $MultiMap$Type<(string)>): void
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UrlEncoded$Type = ($UrlEncoded);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UrlEncoded_ = $UrlEncoded$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ShutdownMonitor" {
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"

export class $ShutdownMonitor {


public "toString"(): string
public "getKey"(): string
public static "getInstance"(): $ShutdownMonitor
public static "isRegistered"(arg0: $LifeCycle$Type): boolean
public static "register"(...arg0: ($LifeCycle$Type)[]): void
public "getPort"(): integer
public "setKey"(arg0: string): void
public "setDebug"(arg0: boolean): void
public "isExitVm"(): boolean
public "setExitVm"(arg0: boolean): void
public static "deregister"(arg0: $LifeCycle$Type): void
public "setPort"(arg0: integer): void
get "key"(): string
get "instance"(): $ShutdownMonitor
get "port"(): integer
set "key"(value: string)
set "debug"(value: boolean)
get "exitVm"(): boolean
set "exitVm"(value: boolean)
set "port"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShutdownMonitor$Type = ($ShutdownMonitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShutdownMonitor_ = $ShutdownMonitor$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__CollectionsJVMKt" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $CollectionsKt__CollectionsJVMKt {

constructor()

public static "build"<E>(arg0: $List$Type<(E)>): $List<(E)>
public static "listOf"<T>(arg0: T): $List<(T)>
public static "copyToArrayOfAny"<T>(arg0: (T)[], arg1: boolean): (any)[]
public static "createListBuilder"<E>(): $List<(E)>
public static "createListBuilder"<E>(arg0: integer): $List<(E)>
public static "shuffled"<T>(arg0: $Iterable$Type<(any)>, arg1: $Random$Type): $List<(T)>
public static "shuffled"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "brittleContainsOptimizationEnabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__CollectionsJVMKt$Type = ($CollectionsKt__CollectionsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__CollectionsJVMKt_ = $CollectionsKt__CollectionsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $AbstractIterator<T> implements $Iterator<(T)>, $KMappedMarker {

constructor()

public "remove"(): void
public "hasNext"(): boolean
public "next"(): T
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIterator$Type<T> = ($AbstractIterator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIterator_<T> = $AbstractIterator$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source$Origin" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Source$Origin extends $Enum<($Source$Origin)> {
static readonly "EMBEDDED": $Source$Origin
static readonly "JAVAX_API": $Source$Origin
static readonly "DESCRIPTOR": $Source$Origin
static readonly "ANNOTATION": $Source$Origin


public static "values"(): ($Source$Origin)[]
public static "valueOf"(arg0: string): $Source$Origin
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Source$Origin$Type = (("annotation") | ("javax_api") | ("descriptor") | ("embedded")) | ($Source$Origin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Source$Origin_ = $Source$Origin$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$RangesKt__RangesKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ClosedFloatingPointRange, $ClosedFloatingPointRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatingPointRange"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export class $RangesKt__RangesKt {

constructor()

public static "checkStepIsPositive"(arg0: boolean, arg1: number): void
public static "rangeTo"<T extends $Comparable<(any)>>(arg0: T, arg1: T): $ClosedRange<(T)>
public static "rangeTo"(arg0: float, arg1: float): $ClosedFloatingPointRange<(float)>
public static "rangeTo"(arg0: double, arg1: double): $ClosedFloatingPointRange<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangesKt__RangesKt$Type = ($RangesKt__RangesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangesKt__RangesKt_ = $RangesKt__RangesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintMapping" {
import {$Constraint, $Constraint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Constraint"

export class $ConstraintMapping {

constructor()

public "getPathSpec"(): string
public "setConstraint"(arg0: $Constraint$Type): void
public "setPathSpec"(arg0: string): void
public "setMethodOmissions"(arg0: (string)[]): void
public "getMethodOmissions"(): (string)[]
public "getMethod"(): string
public "setMethod"(arg0: string): void
public "getConstraint"(): $Constraint
get "pathSpec"(): string
set "constraint"(value: $Constraint$Type)
set "pathSpec"(value: string)
set "methodOmissions"(value: (string)[])
get "methodOmissions"(): (string)[]
get "method"(): string
set "method"(value: string)
get "constraint"(): $Constraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstraintMapping$Type = ($ConstraintMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstraintMapping_ = $ConstraintMapping$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$InvalidWebSocketException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WebSocketException, $WebSocketException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketException"

export class $InvalidWebSocketException extends $WebSocketException {

constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidWebSocketException$Type = ($InvalidWebSocketException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidWebSocketException_ = $InvalidWebSocketException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketServletContextHandlerFactory" {
import {$ServletContextHandler, $ServletContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletContextHandler"
import {$WebSocketHandlerWrapper, $WebSocketHandlerWrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $WebSocketServletContextHandlerFactory {

constructor()

public static "create"(arg0: $Map$Type<(string), ($WebSocketHandlerWrapper$Type)>, arg1: $Optional$Type<(integer)>): $ServletContextHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServletContextHandlerFactory$Type = ($WebSocketServletContextHandlerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServletContextHandlerFactory_ = $WebSocketServletContextHandlerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$SingleThreadModel" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * 
 * @deprecated
 */
export interface $SingleThreadModel {

}

export namespace $SingleThreadModel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleThreadModel$Type = ($SingleThreadModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleThreadModel_ = $SingleThreadModel$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine" {
import {$ModelAndView, $ModelAndView$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ModelAndView"

export class $TemplateEngine {

constructor()

public "render"(arg0: $ModelAndView$Type): string
public "render"(arg0: any): string
public "modelAndView"(arg0: any, arg1: string): $ModelAndView
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemplateEngine$Type = ($TemplateEngine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemplateEngine_ = $TemplateEngine$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$FilterChain" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"

export interface $FilterChain {

 "doFilter"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void

(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
}

export namespace $FilterChain {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterChain$Type = ($FilterChain);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterChain_ = $FilterChain$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ExtensionConfig {

constructor(arg0: string)
constructor(arg0: $ExtensionConfig$Type)

public static "toHeaderValue"(arg0: $List$Type<($ExtensionConfig$Type)>): string
public "getParameterKeys"(): $Set<(string)>
public static "parseEnum"(arg0: $Enumeration$Type<(string)>): $List<($ExtensionConfig)>
public "getName"(): string
public "toString"(): string
public "init"(arg0: $ExtensionConfig$Type): void
public "getParameters"(): $Map<(string), (string)>
public static "parse"(arg0: string): $ExtensionConfig
public static "parseList"(...arg0: (string)[]): $List<($ExtensionConfig)>
public "setParameter"(arg0: string, arg1: integer): void
public "setParameter"(arg0: string, arg1: string): void
public "setParameter"(arg0: string): void
public "getParameter"(arg0: string, arg1: string): string
public "getParameter"(arg0: string, arg1: integer): integer
public "getParameterizedName"(): string
get "parameterKeys"(): $Set<(string)>
get "name"(): string
get "parameters"(): $Map<(string), (string)>
set "parameter"(value: string)
get "parameterizedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionConfig$Type = ($ExtensionConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionConfig_ = $ExtensionConfig$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$BufferUtil" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $BufferUtil {
static readonly "EMPTY_BUFFER": $ByteBuffer

constructor()

public static "flipToFill"(arg0: $ByteBuffer$Type): integer
public static "flipToFlush"(arg0: $ByteBuffer$Type, arg1: integer): void
public static "putHexInt"(arg0: $ByteBuffer$Type, arg1: integer): void
public static "putCRLF"(arg0: $ByteBuffer$Type): void
public static "clearToFill"(arg0: $ByteBuffer$Type): void
public static "putDecLong"(arg0: $ByteBuffer$Type, arg1: long): void
public static "toUTF8String"(arg0: $ByteBuffer$Type): string
public static "put"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): integer
public static "length"(arg0: $ByteBuffer$Type): integer
public static "toString"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer, arg3: $Charset$Type): string
public static "toString"(arg0: $ByteBuffer$Type): string
public static "toString"(arg0: $ByteBuffer$Type, arg1: $Charset$Type): string
public static "append"(arg0: $ByteBuffer$Type, arg1: (byte)[], arg2: integer, arg3: integer): void
public static "append"(arg0: $ByteBuffer$Type, arg1: byte): void
public static "append"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): integer
public static "clear"(arg0: $ByteBuffer$Type): void
public static "toHexString"(arg0: $ByteBuffer$Type): string
public static "isEmpty"(arg0: $ByteBuffer$Type): boolean
public static "toArray"(arg0: $ByteBuffer$Type): (byte)[]
public static "fill"(arg0: $ByteBuffer$Type, arg1: (byte)[], arg2: integer, arg3: integer): integer
public static "ensureCapacity"(arg0: $ByteBuffer$Type, arg1: integer): $ByteBuffer
public static "allocate"(arg0: integer): $ByteBuffer
public static "allocateDirect"(arg0: integer): $ByteBuffer
public static "compact"(arg0: $ByteBuffer$Type): boolean
public static "space"(arg0: $ByteBuffer$Type): integer
public static "writeTo"(arg0: $ByteBuffer$Type, arg1: $OutputStream$Type): void
public static "readFrom"(arg0: $InputStream$Type, arg1: integer, arg2: $ByteBuffer$Type): void
public static "readFrom"(arg0: $File$Type, arg1: $ByteBuffer$Type): void
public static "toLong"(arg0: $ByteBuffer$Type): long
public static "isFull"(arg0: $ByteBuffer$Type): boolean
public static "toInt"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): integer
public static "toInt"(arg0: $ByteBuffer$Type): integer
public static "flipPutFlip"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): integer
public static "takeInt"(arg0: $ByteBuffer$Type): integer
public static "putDecInt"(arg0: $ByteBuffer$Type, arg1: integer): void
public static "toIDString"(arg0: $ByteBuffer$Type): string
public static "toMappedBuffer"(arg0: $File$Type): $ByteBuffer
public static "toHexSummary"(arg0: $ByteBuffer$Type): string
public static "isMappedBuffer"(arg0: $ByteBuffer$Type): boolean
public static "toDirectBuffer"(arg0: string, arg1: $Charset$Type): $ByteBuffer
public static "toDirectBuffer"(arg0: string): $ByteBuffer
public static "toSummaryString"(arg0: $ByteBuffer$Type): string
public static "hasContent"(arg0: $ByteBuffer$Type): boolean
public static "toBuffer"(arg0: integer): $ByteBuffer
public static "toBuffer"(arg0: string, arg1: $Charset$Type): $ByteBuffer
public static "toBuffer"(arg0: (byte)[], arg1: integer, arg2: integer): $ByteBuffer
public static "toBuffer"(arg0: $Resource$Type, arg1: boolean): $ByteBuffer
public static "toBuffer"(arg0: long): $ByteBuffer
public static "toBuffer"(arg0: string): $ByteBuffer
public static "toBuffer"(arg0: (byte)[]): $ByteBuffer
public static "isPrefix"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): boolean
public static "toDetailString"(arg0: ($ByteBuffer$Type)[]): string
public static "toDetailString"(arg0: $ByteBuffer$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BufferUtil$Type = ($BufferUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BufferUtil_ = $BufferUtil$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$AbstractUserAuthentication" {
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"

export class $AbstractUserAuthentication implements $Authentication$User, $Serializable {

constructor(arg0: string, arg1: $UserIdentity$Type)

public "getUserIdentity"(): $UserIdentity
public "isUserInRole"(arg0: $UserIdentity$Scope$Type, arg1: string): boolean
public "getAuthMethod"(): string
public "declaredRolesContains"(arg0: string): boolean
public "logout"(): void
get "userIdentity"(): $UserIdentity
get "authMethod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractUserAuthentication$Type = ($AbstractUserAuthentication);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractUserAuthentication_ = $AbstractUserAuthentication$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpScheme" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"

export class $HttpScheme extends $Enum<($HttpScheme)> {
static readonly "HTTP": $HttpScheme
static readonly "HTTPS": $HttpScheme
static readonly "WS": $HttpScheme
static readonly "WSS": $HttpScheme
static readonly "CACHE": $Trie<($HttpScheme)>


public "toString"(): string
public static "values"(): ($HttpScheme)[]
public static "valueOf"(arg0: string): $HttpScheme
public "is"(arg0: string): boolean
public "asString"(): string
public "asByteBuffer"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpScheme$Type = (("wss") | ("http") | ("https") | ("ws")) | ($HttpScheme);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpScheme_ = $HttpScheme$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$QuotedQualityCSV" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$QuotedCSV, $QuotedCSV$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$QuotedCSV"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $QuotedQualityCSV extends $QuotedCSV implements $Iterable<(string)> {
static "MOST_SPECIFIC": $Function<(string), (integer)>

constructor(arg0: $Function$Type<(string), (integer)>)
constructor(arg0: (string)[])
constructor()

public "iterator"(): $Iterator<(string)>
public "addValue"(arg0: string): void
public "getValues"(): $List<(string)>
get "values"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuotedQualityCSV$Type = ($QuotedQualityCSV);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuotedQualityCSV_ = $QuotedQualityCSV$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$FloatIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $FloatIterator implements $Iterator<(float)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextFloat"(): float
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatIterator$Type = ($FloatIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatIterator_ = $FloatIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MimeTypes" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MimeTypes$Type, $MimeTypes$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MimeTypes$Type"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MimeTypes {
static readonly "CACHE": $Trie<($MimeTypes$Type)>

constructor()

public "setMimeMap"(arg0: $Map$Type<(string), (string)>): void
public "getMimeMap"(): $Map<(string), (string)>
public "addMimeMapping"(arg0: string, arg1: string): void
public static "getKnownMimeTypes"(): $Set<(string)>
public "getMimeByExtension"(arg0: string): string
public static "getDefaultMimeByExtension"(arg0: string): string
public static "getInferredEncodings"(): $Map<(string), (string)>
public static "getAssumedEncodings"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
public static "inferCharsetFromContentType"(arg0: string): string
public static "getCharsetFromContentType"(arg0: string): string
public static "getCharsetAssumedFromContentType"(arg0: string): string
public static "getCharsetInferredFromContentType"(arg0: string): string
public static "getContentTypeWithoutCharset"(arg0: string): string
set "mimeMap"(value: $Map$Type<(string), (string)>)
get "mimeMap"(): $Map<(string), (string)>
get "knownMimeTypes"(): $Set<(string)>
get "inferredEncodings"(): $Map<(string), (string)>
get "assumedEncodings"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MimeTypes$Type = ($MimeTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MimeTypes_ = $MimeTypes$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$NaturalOrderComparator" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export class $NaturalOrderComparator implements $Comparator<($Comparable<(any)>)> {
static readonly "INSTANCE": $NaturalOrderComparator


public "compare"(arg0: $Comparable$Type<(any)>, arg1: $Comparable$Type<(any)>): integer
public "reversed"(): $Comparator<($Comparable<(any)>)>
public "equals"(arg0: any): boolean
public static "reverseOrder"<T extends $Comparable<(any)>>(): $Comparator<($Comparable<(any)>)>
public static "comparing"<T, U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($Comparable<(any)>)>
public static "comparing"<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($Comparable<(any)>)>
public static "comparingInt"<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "comparingLong"<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "comparingDouble"<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "naturalOrder"<T extends $Comparable<(any)>>(): $Comparator<($Comparable<(any)>)>
public static "nullsFirst"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "nullsLast"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NaturalOrderComparator$Type = ($NaturalOrderComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NaturalOrderComparator_ = $NaturalOrderComparator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression" {
import {$LongProgression$Companion, $LongProgression$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression$Companion"
import {$LongIterator, $LongIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$LongIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $LongProgression implements $Iterable<(long)>, $KMappedMarker {
static readonly "Companion": $LongProgression$Companion

constructor(arg0: long, arg1: long, arg2: long)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $LongIterator
public "getFirst"(): long
public "getLast"(): long
public "getStep"(): long
public "spliterator"(): $Spliterator<(long)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
get "empty"(): boolean
get "first"(): long
get "last"(): long
get "step"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongProgression$Type = ($LongProgression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongProgression_ = $LongProgression$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$DefaultSessionIdManager" {
import {$HouseKeeper, $HouseKeeper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$HouseKeeper"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionIdManager, $SessionIdManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SessionIdManager"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $DefaultSessionIdManager extends $ContainerLifeCycle implements $SessionIdManager {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Server$Type)
constructor(arg0: $Server$Type, arg1: $Random$Type)

public "toString"(): string
public "getId"(arg0: string): string
public "setServer"(arg0: $Server$Type): void
public "getServer"(): $Server
public "setSessionHouseKeeper"(arg0: $HouseKeeper$Type): void
public "getSessionHouseKeeper"(): $HouseKeeper
public "initRandom"(): void
public "getRandom"(): $Random
public "getExtendedId"(arg0: string, arg1: $HttpServletRequest$Type): string
public "renewSessionId"(arg0: string, arg1: string, arg2: $HttpServletRequest$Type): string
public "getSessionHandlers"(): $Set<($SessionHandler)>
public "isIdInUse"(arg0: string): boolean
public "newSessionId"(arg0: long): string
public "newSessionId"(arg0: $HttpServletRequest$Type, arg1: long): string
public "expireAll"(arg0: string): void
public "getWorkerName"(): string
public "invalidateAll"(arg0: string): void
public "setRandom"(arg0: $Random$Type): void
public "setWorkerName"(arg0: string): void
public "getReseed"(): long
public "setReseed"(arg0: long): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "server"(value: $Server$Type)
get "server"(): $Server
set "sessionHouseKeeper"(value: $HouseKeeper$Type)
get "sessionHouseKeeper"(): $HouseKeeper
get "random"(): $Random
get "sessionHandlers"(): $Set<($SessionHandler)>
get "workerName"(): string
set "random"(value: $Random$Type)
set "workerName"(value: string)
get "reseed"(): long
set "reseed"(value: long)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultSessionIdManager$Type = ($DefaultSessionIdManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultSessionIdManager_ = $DefaultSessionIdManager$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Content" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HttpInput$Content implements $Callback {

constructor(arg0: $ByteBuffer$Type)

public "get"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "toString"(): string
public "isEmpty"(): boolean
public "remaining"(): integer
public "getInvocationType"(): $Invocable$InvocationType
public "skip"(arg0: integer): integer
public "getByteBuffer"(): $ByteBuffer
public "hasContent"(): boolean
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public "succeeded"(): void
public "failed"(arg0: $Throwable$Type): void
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "empty"(): boolean
get "invocationType"(): $Invocable$InvocationType
get "byteBuffer"(): $ByteBuffer
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpInput$Content$Type = ($HttpInput$Content);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpInput$Content_ = $HttpInput$Content$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapWithDefaultKt" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapsKt__MapWithDefaultKt {

constructor()

public static "getOrImplicitDefaultNullable"<K, V>(arg0: $Map$Type<(K), (any)>, arg1: K): V
public static "withDefault"<K, V>(arg0: $Map$Type<(K), (any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "withDefaultMutable"<K, V>(arg0: $Map$Type<(K), (V)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapsKt__MapWithDefaultKt$Type = ($MapsKt__MapWithDefaultKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapsKt__MapWithDefaultKt_ = $MapsKt__MapWithDefaultKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$TaglibDescriptor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $TaglibDescriptor {

 "getTaglibURI"(): string
 "getTaglibLocation"(): string
}

export namespace $TaglibDescriptor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TaglibDescriptor$Type = ($TaglibDescriptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TaglibDescriptor_ = $TaglibDescriptor$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Result" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Result$Companion, $Result$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Result$Companion"

export class $Result<T> implements $Serializable {
static readonly "Companion": $Result$Companion


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "exceptionOrNull-impl"(arg0: any): $Throwable
public static "constructor-impl"<T>(arg0: any): any
public static "equals-impl"(arg0: any, arg1: any): boolean
public static "hashCode-impl"(arg0: any): integer
public static "toString-impl"(arg0: any): string
public static "equals-impl0"(arg0: any, arg1: any): boolean
public static "isSuccess-impl"(arg0: any): boolean
public static "isFailure-impl"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Result$Type<T> = ($Result<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Result_<T> = $Result$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$EntriesItr" {
import {$KMutableIterator, $KMutableIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$MapBuilder$Itr, $MapBuilder$Itr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$Itr"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapBuilder$EntriesItr<K, V> extends $MapBuilder$Itr<(K), (V)> implements $Iterator<($Map$Entry<(K), (V)>)>, $KMutableIterator {

constructor(arg0: $MapBuilder$Type<(K), (V)>)

public "nextAppendString"(arg0: $StringBuilder$Type): void
public "nextHashCode$kotlin_stdlib"(): integer
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$EntriesItr$Type<K, V> = ($MapBuilder$EntriesItr<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder$EntriesItr_<K, V> = $MapBuilder$EntriesItr$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/intrinsics/$IntrinsicsKt__IntrinsicsJvmKt" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"

export class $IntrinsicsKt__IntrinsicsJvmKt {

constructor()

public static "intercepted"<T>(arg0: $Continuation$Type<(any)>): $Continuation<(T)>
public static "createCoroutineUnintercepted"<R, T>(arg0: $Function2$Type<(any), (any), (any)>, arg1: R, arg2: $Continuation$Type<(any)>): $Continuation<($Unit)>
public static "createCoroutineUnintercepted"<T>(arg0: $Function1$Type<(any), (any)>, arg1: $Continuation$Type<(any)>): $Continuation<($Unit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntrinsicsKt__IntrinsicsJvmKt$Type = ($IntrinsicsKt__IntrinsicsJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntrinsicsKt__IntrinsicsJvmKt_ = $IntrinsicsKt__IntrinsicsJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UNINITIALIZED_VALUE" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UNINITIALIZED_VALUE {
static readonly "INSTANCE": $UNINITIALIZED_VALUE


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UNINITIALIZED_VALUE$Type = ($UNINITIALIZED_VALUE);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UNINITIALIZED_VALUE_ = $UNINITIALIZED_VALUE$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$DefaultIdentityService" {
import {$RunAsToken, $RunAsToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RunAsToken"
import {$Subject, $Subject$Type} from "packages/javax/security/auth/$Subject"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"

export class $DefaultIdentityService implements $IdentityService {

constructor()

public "setRunAs"(arg0: $UserIdentity$Type, arg1: $RunAsToken$Type): any
public "unsetRunAs"(arg0: any): void
public "newUserIdentity"(arg0: $Subject$Type, arg1: $Principal$Type, arg2: (string)[]): $UserIdentity
public "newRunAsToken"(arg0: string): $RunAsToken
public "associate"(arg0: $UserIdentity$Type): any
public "disassociate"(arg0: any): void
public "getSystemUserIdentity"(): $UserIdentity
get "systemUserIdentity"(): $UserIdentity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultIdentityService$Type = ($DefaultIdentityService);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultIdentityService_ = $DefaultIdentityService$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$SharedBlockingCallback" {
import {$SharedBlockingCallback$Blocker, $SharedBlockingCallback$Blocker$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$SharedBlockingCallback$Blocker"

export class $SharedBlockingCallback {

constructor()

public "acquire"(): $SharedBlockingCallback$Blocker
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SharedBlockingCallback$Type = ($SharedBlockingCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SharedBlockingCallback_ = $SharedBlockingCallback$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$DefaultSessionCache" {
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$AbstractSessionCache, $AbstractSessionCache$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$AbstractSessionCache"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $DefaultSessionCache extends $AbstractSessionCache {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $SessionHandler$Type)

public "shutdown"(): void
public "doReplace"(arg0: string, arg1: $Session$Type, arg2: $Session$Type): boolean
public "doGet"(arg0: string): $Session
public "resetStats"(): void
public "newSession"(arg0: $HttpServletRequest$Type, arg1: $SessionData$Type): $Session
public "newSession"(arg0: $SessionData$Type): $Session
public "doDelete"(arg0: string): $Session
public "doPutIfAbsent"(arg0: string, arg1: $Session$Type): $Session
public "getSessionsCurrent"(): long
public "getSessionsMax"(): long
public "getSessionsTotal"(): long
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "sessionsCurrent"(): long
get "sessionsMax"(): long
get "sessionsTotal"(): long
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultSessionCache$Type = ($DefaultSessionCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultSessionCache_ = $DefaultSessionCache$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ByteIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ByteIterator implements $Iterator<(byte)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextByte"(): byte
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteIterator$Type = ($ByteIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteIterator_ = $ByteIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverFactory" {
import {$EventDriverImpl, $EventDriverImpl$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverImpl"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"

export class $EventDriverFactory {

constructor(arg0: $WebSocketContainerScope$Type)

public "toString"(): string
public "wrap"(arg0: any): $EventDriver
public "removeImplementation"(arg0: $EventDriverImpl$Type): boolean
public "clearImplementations"(): void
public "addImplementation"(arg0: $EventDriverImpl$Type): void
public "getImplementations"(): $List<($EventDriverImpl)>
get "implementations"(): $List<($EventDriverImpl)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventDriverFactory$Type = ($EventDriverFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventDriverFactory_ = $EventDriverFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$AbstractEventDriver" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$CloseInfo, $CloseInfo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $AbstractEventDriver extends $AbstractLifeCycle implements $IncomingFrames, $EventDriver {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $WebSocketPolicy$Type, arg1: any)

public "incomingFrame"(arg0: $Frame$Type): void
public "incomingError"(arg0: $Throwable$Type): void
public "getPolicy"(): $WebSocketPolicy
public "getSession"(): $WebSocketSession
public "onPing"(arg0: $ByteBuffer$Type): void
public "onPong"(arg0: $ByteBuffer$Type): void
public "getBatchMode"(): $BatchMode
public "openSession"(arg0: $WebSocketSession$Type): void
public "onContinuationFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onClose"(arg0: $CloseInfo$Type): void
public "onConnect"(): void
public "onTextFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onFrame"(arg0: $Frame$Type): void
public "onBinaryFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onInputStream"(arg0: $InputStream$Type): void
public "onReader"(arg0: $Reader$Type): void
public "onTextMessage"(arg0: string): void
public "onError"(arg0: $Throwable$Type): void
public "onBinaryMessage"(arg0: (byte)[]): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "policy"(): $WebSocketPolicy
get "session"(): $WebSocketSession
get "batchMode"(): $BatchMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractEventDriver$Type = ($AbstractEventDriver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractEventDriver_ = $AbstractEventDriver$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkPredicate" {
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export interface $ChunkPredicate {

 "match"(arg0: $PngChunk$Type): boolean

(arg0: $PngChunk$Type): boolean
}

export namespace $ChunkPredicate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkPredicate$Type = ($ChunkPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkPredicate_ = $ChunkPredicate$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$HouseKeeper" {
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionIdManager, $SessionIdManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SessionIdManager"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"

export class $HouseKeeper extends $AbstractLifeCycle {
static readonly "DEFAULT_PERIOD_MS": long
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "toString"(): string
public "setIntervalSec"(arg0: long): void
public "setSessionIdManager"(arg0: $SessionIdManager$Type): void
public "scavenge"(): void
public "getIntervalSec"(): long
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
set "intervalSec"(value: long)
set "sessionIdManager"(value: $SessionIdManager$Type)
get "intervalSec"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HouseKeeper$Type = ($HouseKeeper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HouseKeeper_ = $HouseKeeper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Frame$Type extends $Enum<($Frame$Type)> {
static readonly "CONTINUATION": $Frame$Type
static readonly "TEXT": $Frame$Type
static readonly "BINARY": $Frame$Type
static readonly "CLOSE": $Frame$Type
static readonly "PING": $Frame$Type
static readonly "PONG": $Frame$Type


public "toString"(): string
public static "values"(): ($Frame$Type)[]
public static "valueOf"(arg0: string): $Frame$Type
public static "from"(arg0: byte): $Frame$Type
public "isData"(): boolean
public "getOpCode"(): byte
public "isControl"(): boolean
public "isContinuation"(): boolean
get "data"(): boolean
get "opCode"(): byte
get "control"(): boolean
get "continuation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frame$Type$Type = (("ping") | ("binary") | ("text") | ("pong") | ("continuation") | ("close")) | ($Frame$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frame$Type_ = $Frame$Type$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FileTreeWalkKt" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$FilesKt__FileReadWriteKt, $FilesKt__FileReadWriteKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FileReadWriteKt"
import {$FileTreeWalk, $FileTreeWalk$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileTreeWalk"
import {$FileWalkDirection, $FileWalkDirection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileWalkDirection"

export class $FilesKt__FileTreeWalkKt extends $FilesKt__FileReadWriteKt {

constructor()

public static "walk"(arg0: $File$Type, arg1: $FileWalkDirection$Type): $FileTreeWalk
public static "walkBottomUp"(arg0: $File$Type): $FileTreeWalk
public static "walkTopDown"(arg0: $File$Type): $FileTreeWalk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilesKt__FileTreeWalkKt$Type = ($FilesKt__FileTreeWalkKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilesKt__FileTreeWalkKt_ = $FilesKt__FileTreeWalkKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroupCollection" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$MatchGroup, $MatchGroup$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroup"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export interface $MatchGroupCollection extends $Collection<($MatchGroup)>, $KMappedMarker {

 "get"(arg0: integer): $MatchGroup
 "add"(arg0: $MatchGroup$Type): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "iterator"(): $Iterator<($MatchGroup)>
 "stream"(): $Stream<($MatchGroup)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<($MatchGroup)>
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<($MatchGroup)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $MatchGroupCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchGroupCollection$Type = ($MatchGroupCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchGroupCollection_ = $MatchGroupCollection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$DeprecatedSinceKotlin" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $DeprecatedSinceKotlin extends $Annotation {

 "errorSince"(): string
 "hiddenSince"(): string
 "warningSince"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $DeprecatedSinceKotlin {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeprecatedSinceKotlin$Type = ($DeprecatedSinceKotlin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeprecatedSinceKotlin_ = $DeprecatedSinceKotlin$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$RandomKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$LongRange, $LongRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $RandomKt {


public static "nextInt"(arg0: $Random$Type, arg1: $IntRange$Type): integer
public static "nextLong"(arg0: $Random$Type, arg1: $LongRange$Type): long
public static "Random"(arg0: integer): $Random
public static "Random"(arg0: long): $Random
public static "takeUpperBits"(arg0: integer, arg1: integer): integer
public static "fastLog2"(arg0: integer): integer
public static "checkRangeBounds"(arg0: double, arg1: double): void
public static "checkRangeBounds"(arg0: long, arg1: long): void
public static "checkRangeBounds"(arg0: integer, arg1: integer): void
public static "boundsErrorMessage"(arg0: any, arg1: any): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomKt$Type = ($RandomKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RandomKt_ = $RandomKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $WriteCallback {

 "writeFailed"(arg0: $Throwable$Type): void
 "writeSuccess"(): void
}

export namespace $WriteCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WriteCallback$Type = ($WriteCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WriteCallback_ = $WriteCallback$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UnsafeLazyImpl" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"

export class $UnsafeLazyImpl<T> implements $Lazy<(T)>, $Serializable {

constructor(arg0: $Function0$Type<(any)>)

public "toString"(): string
public "getValue"(): T
public "isInitialized"(): boolean
get "value"(): T
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnsafeLazyImpl$Type<T> = ($UnsafeLazyImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnsafeLazyImpl_<T> = $UnsafeLazyImpl$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$JvmInline" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JvmInline extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JvmInline {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JvmInline$Type = ($JvmInline);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JvmInline_ = $JvmInline$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$UIntIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"

export class $UIntIterator implements $Iterator<($UInt)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextUInt-pVg5ArA"(): integer
public "next-pVg5ArA"(): integer
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntIterator$Type = ($UIntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntIterator_ = $UIntIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$PublishedApi" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $PublishedApi extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $PublishedApi {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PublishedApi$Type = ($PublishedApi);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PublishedApi_ = $PublishedApi$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$RestrictsSuspension" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $RestrictsSuspension extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $RestrictsSuspension {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RestrictsSuspension$Type = ($RestrictsSuspension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RestrictsSuspension_ = $RestrictsSuspension$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseStatus" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CloseStatus {
static readonly "MAX_REASON_PHRASE": integer

constructor(arg0: integer, arg1: string)

public "getCode"(): integer
/**
 * 
 * @deprecated
 */
public static "trimMaxReasonLength"(arg0: string): string
public "getPhrase"(): string
get "code"(): integer
get "phrase"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseStatus$Type = ($CloseStatus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseStatus_ = $CloseStatus$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$CloseInfo, $CloseInfo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export interface $EventDriver extends $IncomingFrames {

 "onClose"(arg0: $CloseInfo$Type): void
 "getPolicy"(): $WebSocketPolicy
 "onConnect"(): void
 "getSession"(): $WebSocketSession
 "onTextFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
 "onFrame"(arg0: $Frame$Type): void
 "onPing"(arg0: $ByteBuffer$Type): void
 "onBinaryFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
 "onPong"(arg0: $ByteBuffer$Type): void
 "onInputStream"(arg0: $InputStream$Type): void
 "getBatchMode"(): $BatchMode
 "onReader"(arg0: $Reader$Type): void
 "onTextMessage"(arg0: string): void
 "openSession"(arg0: $WebSocketSession$Type): void
 "onError"(arg0: $Throwable$Type): void
 "onContinuationFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
 "onBinaryMessage"(arg0: (byte)[]): void
 "incomingFrame"(arg0: $Frame$Type): void
 "incomingError"(arg0: $Throwable$Type): void
}

export namespace $EventDriver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventDriver$Type = ($EventDriver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventDriver_ = $EventDriver$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableMap" {
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"

export interface $KMutableMap extends $KMappedMarker {

}

export namespace $KMutableMap {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableMap$Type = ($KMutableMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableMap_ = $KMutableMap$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassReference" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$ClassReference$Companion, $ClassReference$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassReference$Companion"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KClass, $KClass$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClass"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$ClassBasedDeclarationContainer, $ClassBasedDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ClassBasedDeclarationContainer"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"

export class $ClassReference implements $KClass<(any)>, $ClassBasedDeclarationContainer {
static readonly "Companion": $ClassReference$Companion

constructor(arg0: $Class$Type<(any)>)

public "isCompanion"(): boolean
public "isFun"(): boolean
public "getNestedClasses"(): $Collection<($KClass<(any)>)>
public "getSupertypes"(): $List<($KType)>
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isInstance"(arg0: any): boolean
public "getTypeParameters"(): $List<($KTypeParameter)>
public "getSimpleName"(): string
public "isOpen"(): boolean
public "getConstructors"(): $Collection<($KFunction<(any)>)>
public "getAnnotations"(): $List<($Annotation)>
public "isSealed"(): boolean
public "isFinal"(): boolean
public "isAbstract"(): boolean
public "getMembers"(): $Collection<($KCallable<(any)>)>
public "getObjectInstance"(): any
public "getQualifiedName"(): string
public "isValue"(): boolean
public "getVisibility"(): $KVisibility
public "isInner"(): boolean
public "isData"(): boolean
public "getJClass"(): $Class<(any)>
public "getSealedSubclasses"(): $List<($KClass<(any)>)>
get "companion"(): boolean
get "fun"(): boolean
get "nestedClasses"(): $Collection<($KClass<(any)>)>
get "supertypes"(): $List<($KType)>
get "typeParameters"(): $List<($KTypeParameter)>
get "simpleName"(): string
get "open"(): boolean
get "constructors"(): $Collection<($KFunction<(any)>)>
get "annotations"(): $List<($Annotation)>
get "sealed"(): boolean
get "final"(): boolean
get "abstract"(): boolean
get "members"(): $Collection<($KCallable<(any)>)>
get "objectInstance"(): any
get "qualifiedName"(): string
get "value"(): boolean
get "visibility"(): $KVisibility
get "inner"(): boolean
get "data"(): boolean
get "jClass"(): $Class<(any)>
get "sealedSubclasses"(): $List<($KClass<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassReference$Type = ($ClassReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassReference_ = $ClassReference$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle" {
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"

export class $AbstractLifeCycle implements $LifeCycle {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "start"(): void
public "stop"(): void
public "getState"(): string
public static "getState"(arg0: $LifeCycle$Type): string
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
public "setStopTimeout"(arg0: long): void
public "getStopTimeout"(): long
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "state"(): string
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
set "stopTimeout"(value: long)
get "stopTimeout"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLifeCycle$Type = ($AbstractLifeCycle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLifeCycle_ = $AbstractLifeCycle$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * 
 * @deprecated
 */
export class $PathSpec {


public "getSpec"(): string
get "spec"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathSpec$Type = ($PathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathSpec_ = $PathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$AsyncListener" {
import {$AsyncEvent, $AsyncEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncEvent"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"

export interface $AsyncListener extends $EventListener {

 "onComplete"(arg0: $AsyncEvent$Type): void
 "onError"(arg0: $AsyncEvent$Type): void
 "onTimeout"(arg0: $AsyncEvent$Type): void
 "onStartAsync"(arg0: $AsyncEvent$Type): void
}

export namespace $AsyncListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncListener$Type = ($AsyncListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncListener_ = $AsyncListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MutableMapWithDefaultImpl" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$MutableMapWithDefault, $MutableMapWithDefault$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MutableMapWithDefault"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MutableMapWithDefaultImpl<K, V> implements $MutableMapWithDefault<(K), (V)> {

constructor(arg0: $Map$Type<(K), (V)>, arg1: $Function1$Type<(any), (any)>)

public "getOrImplicitDefault"(arg0: K): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $Collection<(V)>
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(K)>
public "containsValue"(arg0: any): boolean
public "getSize"(): integer
public "getEntries"(): $Set<($Map$Entry<(K), (V)>)>
public "getMap"(): $Map<(K), (V)>
public "getKeys"(): $Set<(K)>
public "getValues"(): $Collection<(V)>
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
get "entries"(): $Set<($Map$Entry<(K), (V)>)>
get "map"(): $Map<(K), (V)>
get "keys"(): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableMapWithDefaultImpl$Type<K, V> = ($MutableMapWithDefaultImpl<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableMapWithDefaultImpl_<K, V> = $MutableMapWithDefaultImpl$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$EmptySequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$DropTakeSequence, $DropTakeSequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropTakeSequence"

export class $EmptySequence implements $Sequence<(any)>, $DropTakeSequence<(any)> {
static readonly "INSTANCE": $EmptySequence


public "iterator"(): $Iterator<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptySequence$Type = ($EmptySequence);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptySequence_ = $EmptySequence$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeReference" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KTypeProjection, $KTypeProjection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"
import {$TypeReference$Companion, $TypeReference$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeReference$Companion"

export class $TypeReference implements $KType {
static readonly "Companion": $TypeReference$Companion
static readonly "IS_MARKED_NULLABLE": integer
static readonly "IS_MUTABLE_COLLECTION_TYPE": integer
static readonly "IS_NOTHING_TYPE": integer

constructor(arg0: $KClassifier$Type, arg1: $List$Type<($KTypeProjection$Type)>, arg2: $KType$Type, arg3: integer)
constructor(arg0: $KClassifier$Type, arg1: $List$Type<($KTypeProjection$Type)>, arg2: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getAnnotations"(): $List<($Annotation)>
public "getArguments"(): $List<($KTypeProjection)>
public "isMarkedNullable"(): boolean
public "getFlags$kotlin_stdlib"(): integer
public "getClassifier"(): $KClassifier
public "getPlatformTypeUpperBound$kotlin_stdlib"(): $KType
get "annotations"(): $List<($Annotation)>
get "arguments"(): $List<($KTypeProjection)>
get "markedNullable"(): boolean
get "flags$kotlin_stdlib"(): integer
get "classifier"(): $KClassifier
get "platformTypeUpperBound$kotlin_stdlib"(): $KType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeReference$Type = ($TypeReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeReference_ = $TypeReference$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$RangesKt" {
import {$RangesKt___RangesKt, $RangesKt___RangesKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$RangesKt___RangesKt"

export class $RangesKt extends $RangesKt___RangesKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangesKt$Type = ($RangesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangesKt_ = $RangesKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange$Companion" {
import {$LongRange, $LongRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $LongRange$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getEMPTY"(): $LongRange
get "eMPTY"(): $LongRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongRange$Companion$Type = ($LongRange$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongRange$Companion_ = $LongRange$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$GeneralError" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GeneralError {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneralError$Type = ($GeneralError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneralError_ = $GeneralError$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServers$Identifiers" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $EmbeddedServers$Identifiers extends $Enum<($EmbeddedServers$Identifiers)> {
static readonly "JETTY": $EmbeddedServers$Identifiers


public static "values"(): ($EmbeddedServers$Identifiers)[]
public static "valueOf"(arg0: string): $EmbeddedServers$Identifiers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedServers$Identifiers$Type = (("jetty")) | ($EmbeddedServers$Identifiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedServers$Identifiers_ = $EmbeddedServers$Identifiers$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UInt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$UInt$Companion, $UInt$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt$Companion"

export class $UInt implements $Comparable<($UInt)> {
static readonly "Companion": $UInt$Companion
static readonly "MIN_VALUE": integer
static readonly "MAX_VALUE": integer
static readonly "SIZE_BYTES": integer
static readonly "SIZE_BITS": integer


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "constructor-impl"(arg0: integer): integer
public static "equals-impl"(arg0: integer, arg1: any): boolean
public static "hashCode-impl"(arg0: integer): integer
public static "toString-impl"(arg0: integer): string
public static "equals-impl0"(arg0: integer, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt$Type = ($UInt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt_ = $UInt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$NativeWebSocketServletContainerInitializer" {
import {$ServletContainerInitializer, $ServletContainerInitializer$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContainerInitializer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$NativeWebSocketConfiguration, $NativeWebSocketConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$NativeWebSocketConfiguration"

export class $NativeWebSocketServletContainerInitializer implements $ServletContainerInitializer {

constructor()

public static "getDefaultFrom"(arg0: $ServletContext$Type): $NativeWebSocketConfiguration
public "onStartup"(arg0: $Set$Type<($Class$Type<(any)>)>, arg1: $ServletContext$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeWebSocketServletContainerInitializer$Type = ($NativeWebSocketServletContainerInitializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeWebSocketServletContainerInitializer_ = $NativeWebSocketServletContainerInitializer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSessionFactory" {
import {$SessionFactory, $SessionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$SessionFactory"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"

export class $WebSocketSessionFactory implements $SessionFactory {

constructor(arg0: $WebSocketContainerScope$Type)

public "supports"(arg0: $EventDriver$Type): boolean
public "createSession"(arg0: $URI$Type, arg1: $EventDriver$Type, arg2: $LogicalConnection$Type): $WebSocketSession
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketSessionFactory$Type = ($WebSocketSessionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketSessionFactory_ = $WebSocketSessionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$FormAuthenticator" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication$User, $Authentication$User$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$User"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export class $FormAuthenticator extends $LoginAuthenticator {
static readonly "__FORM_LOGIN_PAGE": string
static readonly "__FORM_ERROR_PAGE": string
static readonly "__FORM_DISPATCH": string
static readonly "__J_URI": string
static readonly "__J_POST": string
static readonly "__J_METHOD": string
static readonly "__J_SECURITY_CHECK": string
static readonly "__J_USERNAME": string
static readonly "__J_PASSWORD": string

constructor()
constructor(arg0: string, arg1: string, arg2: boolean)

public "validateRequest"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean): $Authentication
public "prepareRequest"(arg0: $ServletRequest$Type): void
public "secureResponse"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type, arg2: boolean, arg3: $Authentication$User$Type): boolean
public "isJSecurityCheck"(arg0: string): boolean
public "isLoginOrErrorPage"(arg0: string): boolean
public "setConfiguration"(arg0: $Authenticator$AuthConfiguration$Type): void
public "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $UserIdentity
public "setAlwaysSaveUri"(arg0: boolean): void
public "getAlwaysSaveUri"(): boolean
public "getAuthMethod"(): string
set "configuration"(value: $Authenticator$AuthConfiguration$Type)
set "alwaysSaveUri"(value: boolean)
get "alwaysSaveUri"(): boolean
get "authMethod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormAuthenticator$Type = ($FormAuthenticator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormAuthenticator_ = $FormAuthenticator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$WebSocket" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $WebSocket extends $Annotation {

 "batchMode"(): $BatchMode
 "maxTextMessageSize"(): integer
 "inputBufferSize"(): integer
 "maxIdleTime"(): integer
 "maxBinaryMessageSize"(): integer
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $WebSocket {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocket$Type = ($WebSocket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocket_ = $WebSocket$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"

export interface $RequestDispatcher {

 "include"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
 "forward"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
}

export namespace $RequestDispatcher {
const FORWARD_REQUEST_URI: string
const FORWARD_CONTEXT_PATH: string
const FORWARD_MAPPING: string
const FORWARD_PATH_INFO: string
const FORWARD_SERVLET_PATH: string
const FORWARD_QUERY_STRING: string
const INCLUDE_REQUEST_URI: string
const INCLUDE_CONTEXT_PATH: string
const INCLUDE_PATH_INFO: string
const INCLUDE_MAPPING: string
const INCLUDE_SERVLET_PATH: string
const INCLUDE_QUERY_STRING: string
const ERROR_EXCEPTION: string
const ERROR_EXCEPTION_TYPE: string
const ERROR_MESSAGE: string
const ERROR_REQUEST_URI: string
const ERROR_SERVLET_NAME: string
const ERROR_STATUS_CODE: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestDispatcher$Type = ($RequestDispatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequestDispatcher_ = $RequestDispatcher$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkHelper" {
import {$ChunkLoadBehaviour, $ChunkLoadBehaviour$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkLoadBehaviour"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"
import {$ChunkPredicate, $ChunkPredicate$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkPredicate"

export class $ChunkHelper {
static readonly "IHDR": string
static readonly "PLTE": string
static readonly "IDAT": string
static readonly "IEND": string
static readonly "cHRM": string
static readonly "gAMA": string
static readonly "iCCP": string
static readonly "sBIT": string
static readonly "sRGB": string
static readonly "bKGD": string
static readonly "hIST": string
static readonly "tRNS": string
static readonly "pHYs": string
static readonly "sPLT": string
static readonly "tIME": string
static readonly "iTXt": string
static readonly "tEXt": string
static readonly "zTXt": string
static readonly "b_IHDR": (byte)[]
static readonly "b_PLTE": (byte)[]
static readonly "b_IDAT": (byte)[]
static readonly "b_IEND": (byte)[]


public static "trimList"(arg0: $List$Type<($PngChunk$Type)>, arg1: $ChunkPredicate$Type): integer
public static "toBytesUTF8"(arg0: string): (byte)[]
public static "toString"(arg0: (byte)[], arg1: integer, arg2: integer): string
public static "toString"(arg0: (byte)[]): string
public static "toBytes"(arg0: string): (byte)[]
public static "isPublic"(arg0: string): boolean
public static "isText"(arg0: $PngChunk$Type): boolean
public static "toStringUTF8"(arg0: (byte)[]): string
public static "toStringUTF8"(arg0: (byte)[], arg1: integer, arg2: integer): string
public static "isUnknown"(arg0: $PngChunk$Type): boolean
public static "shouldLoad"(arg0: string, arg1: $ChunkLoadBehaviour$Type): boolean
public static "isCritical"(arg0: string): boolean
public static "equivalent"(arg0: $PngChunk$Type, arg1: $PngChunk$Type): boolean
public static "filterList"(arg0: $List$Type<($PngChunk$Type)>, arg1: $ChunkPredicate$Type): $List<($PngChunk)>
public static "compressBytes"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: boolean): (byte)[]
public static "compressBytes"(arg0: (byte)[], arg1: boolean): (byte)[]
public static "posNullByte"(arg0: (byte)[]): integer
public static "isSafeToCopy"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkHelper$Type = ($ChunkHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkHelper_ = $ChunkHelper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession" {
import {$Connection$Listener, $Connection$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$Listener"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$UpgradeRequest, $UpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeRequest"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$ConnectionState, $ConnectionState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$ConnectionState"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$SuspendToken, $SuspendToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$SuspendToken"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$UpgradeResponse, $UpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeResponse"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$WebSocketSessionScope, $WebSocketSessionScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketSessionScope"
import {$RemoteEndpoint, $RemoteEndpoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$RemoteEndpoint"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$IOState$ConnectionStateListener, $IOState$ConnectionStateListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState$ConnectionStateListener"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$CloseStatus, $CloseStatus$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseStatus"
import {$ExtensionFactory, $ExtensionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory"
import {$RemoteEndpointFactory, $RemoteEndpointFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$RemoteEndpointFactory"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"

export class $WebSocketSession extends $ContainerLifeCycle implements $Session, $RemoteEndpointFactory, $WebSocketSessionScope, $IncomingFrames, $Connection$Listener, $IOState$ConnectionStateListener {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $WebSocketContainerScope$Type, arg1: $URI$Type, arg2: $EventDriver$Type, arg3: $LogicalConnection$Type)

public "getWebSocketSession"(): $WebSocketSession
public "setExtensionFactory"(arg0: $ExtensionFactory$Type): void
public "incomingFrame"(arg0: $Frame$Type): void
public "incomingError"(arg0: $Throwable$Type): void
public "onConnectionStateChange"(arg0: $ConnectionState$Type): void
public "getExtensionFactory"(): $ExtensionFactory
public "dispatch"(arg0: $Runnable$Type): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getClassLoader"(): $ClassLoader
public "isOpen"(): boolean
public "suspend"(): $SuspendToken
public "close"(): void
public "close"(arg0: integer, arg1: string): void
public "close"(arg0: $CloseStatus$Type): void
public "open"(): void
public "getConnection"(): $LogicalConnection
public "getPolicy"(): $WebSocketPolicy
public "isSecure"(): boolean
public "disconnect"(): void
public "getProtocolVersion"(): string
public "getRequestURI"(): $URI
public "getLocalAddress"(): $InetSocketAddress
public "getBufferPool"(): $ByteBufferPool
public "onClosed"(arg0: $Connection$Type): void
public "getRemoteAddress"(): $InetSocketAddress
/**
 * 
 * @deprecated
 */
public "setPolicy"(arg0: $WebSocketPolicy$Type): void
public "setFuture"(arg0: $CompletableFuture$Type<($Session$Type)>): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "getRemote"(): $RemoteEndpoint
public "getBatchMode"(): $BatchMode
public "notifyError"(arg0: $Throwable$Type): void
public "getContainerScope"(): $WebSocketContainerScope
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "onOpened"(arg0: $Connection$Type): void
public "getUpgradeRequest"(): $UpgradeRequest
public "getUpgradeResponse"(): $UpgradeResponse
public "setOutgoingHandler"(arg0: $OutgoingFrames$Type): void
public "setUpgradeRequest"(arg0: $UpgradeRequest$Type): void
public "setUpgradeResponse"(arg0: $UpgradeResponse$Type): void
public "getOutgoingHandler"(): $OutgoingFrames
public "notifyClose"(arg0: integer, arg1: string): void
public "getIncomingHandler"(): $IncomingFrames
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "webSocketSession"(): $WebSocketSession
set "extensionFactory"(value: $ExtensionFactory$Type)
get "extensionFactory"(): $ExtensionFactory
get "classLoader"(): $ClassLoader
get "connection"(): $LogicalConnection
get "policy"(): $WebSocketPolicy
get "secure"(): boolean
get "protocolVersion"(): string
get "requestURI"(): $URI
get "localAddress"(): $InetSocketAddress
get "bufferPool"(): $ByteBufferPool
get "remoteAddress"(): $InetSocketAddress
set "policy"(value: $WebSocketPolicy$Type)
set "future"(value: $CompletableFuture$Type<($Session$Type)>)
get "remote"(): $RemoteEndpoint
get "batchMode"(): $BatchMode
get "containerScope"(): $WebSocketContainerScope
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "upgradeRequest"(): $UpgradeRequest
get "upgradeResponse"(): $UpgradeResponse
set "outgoingHandler"(value: $OutgoingFrames$Type)
set "upgradeRequest"(value: $UpgradeRequest$Type)
set "upgradeResponse"(value: $UpgradeResponse$Type)
get "outgoingHandler"(): $OutgoingFrames
get "incomingHandler"(): $IncomingFrames
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketSession$Type = ($WebSocketSession);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketSession_ = $WebSocketSession$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapsJVMKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$MapsKt__MapWithDefaultKt, $MapsKt__MapWithDefaultKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapsKt__MapWithDefaultKt"
import {$ConcurrentMap, $ConcurrentMap$Type} from "packages/java/util/concurrent/$ConcurrentMap"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapsKt__MapsJVMKt extends $MapsKt__MapWithDefaultKt {

constructor()

public static "toSortedMap"<K extends $Comparable<(any)>, V>(arg0: $Map$Type<(any), (any)>): $SortedMap<(K), (V)>
public static "toSortedMap"<K, V>(arg0: $Map$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $SortedMap<(K), (V)>
public static "sortedMapOf"<K, V>(arg0: $Comparator$Type<(any)>, ...arg1: ($Pair$Type<(any), (any)>)[]): $SortedMap<(K), (V)>
public static "sortedMapOf"<K extends $Comparable<(any)>, V>(...arg0: ($Pair$Type<(any), (any)>)[]): $SortedMap<(K), (V)>
public static "toSingletonMap"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "createMapBuilder"<K, V>(): $Map<(K), (V)>
public static "createMapBuilder"<K, V>(arg0: integer): $Map<(K), (V)>
public static "build"<K, V>(arg0: $Map$Type<(K), (V)>): $Map<(K), (V)>
public static "mapCapacity"(arg0: integer): integer
public static "mapOf"<K, V>(arg0: $Pair$Type<(any), (any)>): $Map<(K), (V)>
public static "getOrPut"<K, V>(arg0: $ConcurrentMap$Type<(K), (V)>, arg1: K, arg2: $Function0$Type<(any)>): V
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapsKt__MapsJVMKt$Type = ($MapsKt__MapsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapsKt__MapsJVMKt_ = $MapsKt__MapsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Utf8HttpWriter" {
import {$HttpWriter, $HttpWriter$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpWriter"
import {$HttpOutput, $HttpOutput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput"

export class $Utf8HttpWriter extends $HttpWriter {
static readonly "MAX_OUTPUT_CHARS": integer

constructor(arg0: $HttpOutput$Type)

public "write"(arg0: (character)[], arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8HttpWriter$Type = ($Utf8HttpWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8HttpWriter_ = $Utf8HttpWriter$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTRNS" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkTRNS extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setGray"(arg0: integer): void
public "getGray"(): integer
public "getPalletteAlpha"(): (integer)[]
public "setPalletteAlpha"(arg0: (integer)[]): void
public "getRGB888"(): integer
public "setRGB"(arg0: integer, arg1: integer, arg2: integer): void
public "getRGB"(): (integer)[]
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
public "setIndexEntryAsTransparent"(arg0: integer): void
set "gray"(value: integer)
get "gray"(): integer
get "palletteAlpha"(): (integer)[]
set "palletteAlpha"(value: (integer)[])
get "rGB888"(): integer
get "rGB"(): (integer)[]
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "indexEntryAsTransparent"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkTRNS$Type = ($PngChunkTRNS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkTRNS_ = $PngChunkTRNS$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInputOverHTTP" {
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$HttpInput, $HttpInput$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput"

export class $HttpInputOverHTTP extends $HttpInput {

constructor(arg0: $HttpChannelState$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpInputOverHTTP$Type = ($HttpInputOverHTTP);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpInputOverHTTP_ = $HttpInputOverHTTP$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ServerConnector" {
import {$AbstractNetworkConnector, $AbstractNetworkConnector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractNetworkConnector"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SslContextFactory, $SslContextFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$SelectorManager, $SelectorManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$SelectorManager"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $ServerConnector extends $AbstractNetworkConnector {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Server$Type, arg1: $SslContextFactory$Type)
constructor(arg0: $Server$Type, arg1: integer, arg2: integer, arg3: $SslContextFactory$Type)
constructor(arg0: $Server$Type, arg1: $SslContextFactory$Type, ...arg2: ($ConnectionFactory$Type)[])
constructor(arg0: $Server$Type, arg1: $Executor$Type, arg2: $Scheduler$Type, arg3: $ByteBufferPool$Type, arg4: integer, arg5: integer, ...arg6: ($ConnectionFactory$Type)[])
constructor(arg0: $Server$Type)
constructor(arg0: $Server$Type, arg1: integer, arg2: integer)
constructor(arg0: $Server$Type, arg1: integer, arg2: integer, ...arg3: ($ConnectionFactory$Type)[])
constructor(arg0: $Server$Type, ...arg1: ($ConnectionFactory$Type)[])

public "shutdown"(): $Future<(void)>
public "isOpen"(): boolean
public "accept"(arg0: integer): void
public "close"(): void
public "open"(): void
public "getLocalPort"(): integer
public "getReuseAddress"(): boolean
public "setReuseAddress"(arg0: boolean): void
public "getSelectorManager"(): $SelectorManager
public "getTransport"(): any
public "isInheritChannel"(): boolean
public "setInheritChannel"(arg0: boolean): void
public "setAcceptQueueSize"(arg0: integer): void
public "getSoLingerTime"(): integer
public "setSoLingerTime"(arg0: integer): void
public "getAcceptQueueSize"(): integer
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "localPort"(): integer
get "reuseAddress"(): boolean
set "reuseAddress"(value: boolean)
get "selectorManager"(): $SelectorManager
get "transport"(): any
get "inheritChannel"(): boolean
set "inheritChannel"(value: boolean)
set "acceptQueueSize"(value: integer)
get "soLingerTime"(): integer
set "soLingerTime"(value: integer)
get "acceptQueueSize"(): integer
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerConnector$Type = ($ServerConnector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerConnector_ = $ServerConnector$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable" {
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"

export interface $Dumpable {

 "dump"(): string
 "dump"(arg0: $Appendable$Type, arg1: string): void
}

export namespace $Dumpable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Dumpable$Type = ($Dumpable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Dumpable_ = $Dumpable$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedImpl" {
import {$EventDriverImpl, $EventDriverImpl$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverImpl"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"

export class $JettyAnnotatedImpl implements $EventDriverImpl {

constructor()

public "toString"(): string
public "create"(arg0: any, arg1: $WebSocketPolicy$Type): $EventDriver
public "describeRule"(): string
public "supports"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyAnnotatedImpl$Type = ($JettyAnnotatedImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyAnnotatedImpl_ = $JettyAnnotatedImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$DebugProbesKt" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"

export class $DebugProbesKt {


public static "probeCoroutineSuspended"(arg0: $Continuation$Type<(any)>): void
public static "probeCoroutineCreated"<T>(arg0: $Continuation$Type<(any)>): $Continuation<(T)>
public static "probeCoroutineResumed"(arg0: $Continuation$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugProbesKt$Type = ($DebugProbesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DebugProbesKt_ = $DebugProbesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$SimpleTextMessage" {
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageAppender, $MessageAppender$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageAppender"

export class $SimpleTextMessage implements $MessageAppender {

constructor(arg0: $EventDriver$Type)

public "messageComplete"(): void
public "appendFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleTextMessage$Type = ($SimpleTextMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleTextMessage_ = $SimpleTextMessage$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$RuntimeIOException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $RuntimeIOException extends $RuntimeException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuntimeIOException$Type = ($RuntimeIOException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RuntimeIOException_ = $RuntimeIOException$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjInputException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$PngjException, $PngjException$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjException"

export class $PngjInputException extends $PngjException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngjInputException$Type = ($PngjInputException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngjInputException_ = $PngjInputException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$LoggerLog" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$AbstractLogger, $AbstractLogger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$AbstractLogger"

export class $LoggerLog extends $AbstractLogger {
static readonly "LEVEL_DEFAULT": integer
static readonly "LEVEL_ALL": integer
static readonly "LEVEL_DEBUG": integer
static readonly "LEVEL_INFO": integer
static readonly "LEVEL_WARN": integer
static readonly "LEVEL_OFF": integer

constructor(arg0: any)

public "getName"(): string
public "info"(arg0: $Throwable$Type): void
public "info"(arg0: string, ...arg1: (any)[]): void
public "info"(arg0: string, arg1: $Throwable$Type): void
public "debug"(arg0: $Throwable$Type): void
public "debug"(arg0: string, ...arg1: (any)[]): void
public "debug"(arg0: string, arg1: $Throwable$Type): void
public "debug"(arg0: string, arg1: long): void
public "ignore"(arg0: $Throwable$Type): void
public "warn"(arg0: string, arg1: $Throwable$Type): void
public "warn"(arg0: $Throwable$Type): void
public "warn"(arg0: string, ...arg1: (any)[]): void
public "isDebugEnabled"(): boolean
public "setDebugEnabled"(arg0: boolean): void
get "name"(): string
get "debugEnabled"(): boolean
set "debugEnabled"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoggerLog$Type = ($LoggerLog);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoggerLog_ = $LoggerLog$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineSetDefault" {
import {$ImageLineByte, $ImageLineByte$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineByte"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLineSetFactory, $IImageLineSetFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSetFactory"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$ImageLineInt, $ImageLineInt$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineInt"
import {$IImageLineSet, $IImageLineSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSet"

export class $ImageLineSetDefault<T extends $IImageLine> implements $IImageLineSet<(T)> {

constructor(arg0: $ImageInfo$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: integer)

public "size"(): integer
public static "getFactoryInt"(): $IImageLineSetFactory<($ImageLineInt)>
public "getImageLine"(arg0: integer): T
public static "getFactoryByte"(): $IImageLineSetFactory<($ImageLineByte)>
public "hasImageLine"(arg0: integer): boolean
public "imageRowToMatrixRowStrict"(arg0: integer): integer
public "matrixRowToImageRow"(arg0: integer): integer
public "imageRowToMatrixRow"(arg0: integer): integer
get "factoryInt"(): $IImageLineSetFactory<($ImageLineInt)>
get "factoryByte"(): $IImageLineSetFactory<($ImageLineByte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageLineSetDefault$Type<T> = ($ImageLineSetDefault<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageLineSetDefault_<T> = $ImageLineSetDefault$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletContextHandler" {
import {$DecoratedObjectFactory, $DecoratedObjectFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DecoratedObjectFactory"
import {$ServletHandler, $ServletHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHandler"
import {$HandlerWrapper, $HandlerWrapper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$GzipHandler, $GzipHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipHandler"
import {$ServletRegistration$Dynamic, $ServletRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$ErrorHandler, $ErrorHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ErrorHandler"
import {$ServletHolder, $ServletHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHolder"
import {$ServletSecurityElement, $ServletSecurityElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletSecurityElement"
import {$HandlerContainer, $HandlerContainer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HandlerContainer"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$FilterHolder, $FilterHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$FilterHolder"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServletContextListener, $ServletContextListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextListener"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"
import {$SecurityHandler, $SecurityHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$SecurityHandler"
import {$ServletContextHandler$Decorator, $ServletContextHandler$Decorator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletContextHandler$Decorator"
import {$ServletContextEvent, $ServletContextEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextEvent"

export class $ServletContextHandler extends $ContextHandler {
static readonly "SESSIONS": integer
static readonly "SECURITY": integer
static readonly "GZIP": integer
static readonly "NO_SESSIONS": integer
static readonly "NO_SECURITY": integer
static readonly "SERVLET_MAJOR_VERSION": integer
static readonly "SERVLET_MINOR_VERSION": integer
static readonly "SERVLET_LISTENER_TYPES": ($Class<(any)>)[]
static readonly "DEFAULT_LISTENER_TYPE_INDEX": integer
static readonly "EXTENDED_LISTENER_TYPE_INDEX": integer
static readonly "MANAGED_ATTRIBUTES": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $HandlerContainer$Type, arg1: string, arg2: $SessionHandler$Type, arg3: $SecurityHandler$Type, arg4: $ServletHandler$Type, arg5: $ErrorHandler$Type)
constructor(arg0: $HandlerContainer$Type, arg1: string, arg2: $SessionHandler$Type, arg3: $SecurityHandler$Type, arg4: $ServletHandler$Type, arg5: $ErrorHandler$Type, arg6: integer)
constructor()
constructor(arg0: $HandlerContainer$Type, arg1: string, arg2: integer)
constructor(arg0: $HandlerContainer$Type, arg1: string)
constructor(arg0: integer)
constructor(arg0: $HandlerContainer$Type, arg1: string, arg2: boolean, arg3: boolean)
constructor(arg0: $HandlerContainer$Type, arg1: $SessionHandler$Type, arg2: $SecurityHandler$Type, arg3: $ServletHandler$Type, arg4: $ErrorHandler$Type)

public "addServlet"(arg0: $Class$Type<(any)>, arg1: string): $ServletHolder
public "addServlet"(arg0: $ServletHolder$Type, arg1: string): void
public "addServlet"(arg0: string, arg1: string): $ServletHolder
public "setHandler"(arg0: $Handler$Type): void
public "getSessionHandler"(): $SessionHandler
public "setSessionHandler"(arg0: $SessionHandler$Type): void
/**
 * 
 * @deprecated
 */
public "addDecorator"(arg0: $ServletContextHandler$Decorator$Type): void
/**
 * 
 * @deprecated
 */
public "getDecorators"(): $List<($ServletContextHandler$Decorator)>
/**
 * 
 * @deprecated
 */
public "setDecorators"(arg0: $List$Type<($ServletContextHandler$Decorator$Type)>): void
public "getServletHandler"(): $ServletHandler
public "setServletHandler"(arg0: $ServletHandler$Type): void
public "addFilter"(arg0: $FilterHolder$Type, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): void
public "addFilter"(arg0: $Class$Type<(any)>, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): $FilterHolder
public "addFilter"(arg0: string, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): $FilterHolder
public "getObjectFactory"(): $DecoratedObjectFactory
public "insertHandler"(arg0: $HandlerWrapper$Type): void
public "getSecurityHandler"(): $SecurityHandler
public "setSecurityHandler"(arg0: $SecurityHandler$Type): void
public "setGzipHandler"(arg0: $GzipHandler$Type): void
public "getGzipHandler"(): $GzipHandler
public "callContextDestroyed"(arg0: $ServletContextListener$Type, arg1: $ServletContextEvent$Type): void
public "callContextInitialized"(arg0: $ServletContextListener$Type, arg1: $ServletContextEvent$Type): void
public "getDefaultSecurityHandlerClass"(): $Class<(any)>
public "setDefaultSecurityHandlerClass"(arg0: $Class$Type<(any)>): void
public "setServletSecurity"(arg0: $ServletRegistration$Dynamic$Type, arg1: $ServletSecurityElement$Type): $Set<(string)>
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "handler"(value: $Handler$Type)
get "sessionHandler"(): $SessionHandler
set "sessionHandler"(value: $SessionHandler$Type)
get "decorators"(): $List<($ServletContextHandler$Decorator)>
set "decorators"(value: $List$Type<($ServletContextHandler$Decorator$Type)>)
get "servletHandler"(): $ServletHandler
set "servletHandler"(value: $ServletHandler$Type)
get "objectFactory"(): $DecoratedObjectFactory
get "securityHandler"(): $SecurityHandler
set "securityHandler"(value: $SecurityHandler$Type)
set "gzipHandler"(value: $GzipHandler$Type)
get "gzipHandler"(): $GzipHandler
get "defaultSecurityHandlerClass"(): $Class<(any)>
set "defaultSecurityHandlerClass"(value: $Class$Type<(any)>)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextHandler$Type = ($ServletContextHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextHandler_ = $ServletContextHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$CertificateUtils" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$KeyStore, $KeyStore$Type} from "packages/java/security/$KeyStore"

export class $CertificateUtils {

constructor()

public static "getKeyStore"(arg0: $Resource$Type, arg1: string, arg2: string, arg3: string): $KeyStore
public static "loadCRL"(arg0: string): $Collection<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CertificateUtils$Type = ($CertificateUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CertificateUtils_ = $CertificateUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RoleInfo" {
import {$UserDataConstraint, $UserDataConstraint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$UserDataConstraint"
import {$Set, $Set$Type} from "packages/java/util/$Set"

export class $RoleInfo {

constructor()

public "getRoles"(): $Set<(string)>
public "addRole"(arg0: string): void
public "isForbidden"(): boolean
public "setAnyAuth"(arg0: boolean): void
public "setForbidden"(arg0: boolean): void
public "isAnyRole"(): boolean
public "setAnyRole"(arg0: boolean): void
public "isAnyAuth"(): boolean
public "setChecked"(arg0: boolean): void
public "toString"(): string
public "combine"(arg0: $RoleInfo$Type): void
public "isChecked"(): boolean
public "getUserDataConstraint"(): $UserDataConstraint
public "setUserDataConstraint"(arg0: $UserDataConstraint$Type): void
get "roles"(): $Set<(string)>
get "forbidden"(): boolean
set "anyAuth"(value: boolean)
set "forbidden"(value: boolean)
get "anyRole"(): boolean
set "anyRole"(value: boolean)
get "anyAuth"(): boolean
set "checked"(value: boolean)
get "checked"(): boolean
get "userDataConstraint"(): $UserDataConstraint
set "userDataConstraint"(value: $UserDataConstraint$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RoleInfo$Type = ($RoleInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RoleInfo_ = $RoleInfo$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/annotation/$Name" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Name extends $Annotation {

 "value"(): string
 "description"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Name {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Name$Type = ($Name);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Name_ = $Name$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ArrayByteBufferPool" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $ArrayByteBufferPool implements $ByteBufferPool {

constructor()
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: integer)

public "clear"(): void
public "release"(arg0: $ByteBuffer$Type): void
public "acquire"(arg0: integer, arg1: boolean): $ByteBuffer
public "newByteBuffer"(arg0: integer, arg1: boolean): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayByteBufferPool$Type = ($ArrayByteBufferPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayByteBufferPool_ = $ArrayByteBufferPool$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$BlockingWriteCallback" {
import {$BlockingWriteCallback$WriteBlocker, $BlockingWriteCallback$WriteBlocker$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$BlockingWriteCallback$WriteBlocker"
import {$SharedBlockingCallback, $SharedBlockingCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$SharedBlockingCallback"

export class $BlockingWriteCallback extends $SharedBlockingCallback {

constructor()

public "acquireWriteBlocker"(): $BlockingWriteCallback$WriteBlocker
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockingWriteCallback$Type = ($BlockingWriteCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockingWriteCallback_ = $BlockingWriteCallback$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ShortIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ShortIterator implements $Iterator<(short)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextShort"(): short
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterator$Type = ($ShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterator_ = $ShortIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$JarResource" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URLResource, $URLResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$URLResource"

export class $JarResource extends $URLResource {
static "__defaultUseCaches": boolean


public "close"(): void
public "getInputStream"(): $InputStream
public "getFile"(): $File
public "exists"(): boolean
public static "newJarResource"(arg0: $Resource$Type): $Resource
public "copyTo"(arg0: $File$Type): void
get "inputStream"(): $InputStream
get "file"(): $File
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JarResource$Type = ($JarResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JarResource_ = $JarResource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$JettyServer" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"

export class $JettyServer {


public static "create"(arg0: integer, arg1: integer, arg2: integer): $Server
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyServer$Type = ($JettyServer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyServer_ = $JettyServer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IncludeExcludeSet" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $IncludeExcludeSet<T, P> implements $Predicate<(P)> {

constructor<SET extends $Set<(T)>>(arg0: $Set$Type<(T)>, arg1: $Predicate$Type<(P)>, arg2: $Set$Type<(T)>, arg3: $Predicate$Type<(P)>)
constructor<SET extends $Set<(T)>>(arg0: $Class$Type<(SET)>)
constructor()

public "toString"(): string
public "test"(arg0: P): boolean
public "clear"(): void
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "matches"(arg0: P): boolean
public "size"(): integer
public "include"(...arg0: (T)[]): void
public "include"(arg0: T): void
public "exclude"(...arg0: (T)[]): void
public "exclude"(arg0: T): void
public "hasIncludes"(): boolean
public "getExcluded"(): $Set<(T)>
public "getIncluded"(): $Set<(T)>
public "isIncludedAndNotExcluded"(arg0: P): boolean
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(P)>
public "negate"(): $Predicate<(P)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(P)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(P)>
public static "isEqual"<T>(arg0: any): $Predicate<(P)>
get "empty"(): boolean
get "excluded"(): $Set<(T)>
get "included"(): $Set<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IncludeExcludeSet$Type<T, P> = ($IncludeExcludeSet<(T), (P)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IncludeExcludeSet_<T, P> = $IncludeExcludeSet$Type<(T), (P)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextAttributeEvent" {
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$ServletContextEvent, $ServletContextEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextEvent"

export class $ServletContextAttributeEvent extends $ServletContextEvent {

constructor(arg0: $ServletContext$Type, arg1: string, arg2: any)

public "getName"(): string
public "getValue"(): any
get "name"(): string
get "value"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextAttributeEvent$Type = ($ServletContextAttributeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextAttributeEvent_ = $ServletContextAttributeEvent$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$DefaultAuthenticatorFactory" {
import {$Authenticator, $Authenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator"
import {$Authenticator$Factory, $Authenticator$Factory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$Factory"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$LoginService, $LoginService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Authenticator$AuthConfiguration, $Authenticator$AuthConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$Authenticator$AuthConfiguration"

export class $DefaultAuthenticatorFactory implements $Authenticator$Factory {

constructor()

public "getAuthenticator"(arg0: $Server$Type, arg1: $ServletContext$Type, arg2: $Authenticator$AuthConfiguration$Type, arg3: $IdentityService$Type, arg4: $LoginService$Type): $Authenticator
public "getLoginService"(): $LoginService
public "setLoginService"(arg0: $LoginService$Type): void
get "loginService"(): $LoginService
set "loginService"(value: $LoginService$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultAuthenticatorFactory$Type = ($DefaultAuthenticatorFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultAuthenticatorFactory_ = $DefaultAuthenticatorFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser" {
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger"
import {$HttpCompliance, $HttpCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance"
import {$HttpParser$State, $HttpParser$State$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$State"
import {$HttpParser$RequestHandler, $HttpParser$RequestHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$RequestHandler"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$HttpParser$HttpHandler, $HttpParser$HttpHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$HttpHandler"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"
import {$HttpParser$ResponseHandler, $HttpParser$ResponseHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$ResponseHandler"

export class $HttpParser {
static readonly "LOG": $Logger
/**
 * 
 * @deprecated
 */
static readonly "__STRICT": string
static readonly "INITIAL_URI_LENGTH": integer
static readonly "CACHE": $Trie<($HttpField)>

constructor(arg0: $HttpParser$RequestHandler$Type, arg1: $HttpCompliance$Type)
/**
 * 
 * @deprecated
 */
constructor(arg0: $HttpParser$ResponseHandler$Type, arg1: integer, arg2: boolean)
/**
 * 
 * @deprecated
 */
constructor(arg0: $HttpParser$RequestHandler$Type, arg1: integer, arg2: boolean)
constructor(arg0: $HttpParser$RequestHandler$Type, arg1: integer, arg2: $HttpCompliance$Type)
constructor(arg0: $HttpParser$ResponseHandler$Type, arg1: integer, arg2: $HttpCompliance$Type)
constructor(arg0: $HttpParser$RequestHandler$Type)
constructor(arg0: $HttpParser$ResponseHandler$Type)
constructor(arg0: $HttpParser$RequestHandler$Type, arg1: integer)
constructor(arg0: $HttpParser$ResponseHandler$Type, arg1: integer)

public "isChunking"(): boolean
public "toString"(): string
public "getState"(): $HttpParser$State
public "close"(): void
public "reset"(): void
public "getHandler"(): $HttpParser$HttpHandler
public "getContentLength"(): long
public "isClosed"(): boolean
public "isComplete"(): boolean
public "isIdle"(): boolean
public "inHeaderState"(): boolean
public "getFieldCache"(): $Trie<($HttpField)>
public "isState"(arg0: $HttpParser$State$Type): boolean
public "isClose"(): boolean
public "parseNext"(arg0: $ByteBuffer$Type): boolean
public "inContentState"(): boolean
public "isStart"(): boolean
public "atEOF"(): void
public "getContentRead"(): long
public "isAtEOF"(): boolean
public "setHeadResponse"(arg0: boolean): void
get "chunking"(): boolean
get "state"(): $HttpParser$State
get "handler"(): $HttpParser$HttpHandler
get "contentLength"(): long
get "closed"(): boolean
get "complete"(): boolean
get "idle"(): boolean
get "fieldCache"(): $Trie<($HttpField)>
get "start"(): boolean
get "contentRead"(): long
set "headResponse"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$Type = ($HttpParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser_ = $HttpParser$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$SynchronizedLazyImpl" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"

export class $SynchronizedLazyImpl<T> implements $Lazy<(T)>, $Serializable {

constructor(arg0: $Function0$Type<(any)>, arg1: any)
constructor(arg0: $Function0$Type<(any)>, arg1: any, arg2: integer, arg3: $DefaultConstructorMarker$Type)

public "toString"(): string
public "getValue"(): T
public "isInitialized"(): boolean
get "value"(): T
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SynchronizedLazyImpl$Type<T> = ($SynchronizedLazyImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SynchronizedLazyImpl_<T> = $SynchronizedLazyImpl$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngReader" {
import {$ChunksList, $ChunksList$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksList"
import {$PngMetadata, $PngMetadata$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngMetadata"
import {$ChunkLoadBehaviour, $ChunkLoadBehaviour$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkLoadBehaviour"
import {$File, $File$Type} from "packages/java/io/$File"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLineSetFactory, $IImageLineSetFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSetFactory"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$ChunkSeqReaderPng, $ChunkSeqReaderPng$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkSeqReaderPng"
import {$IImageLineSet, $IImageLineSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineSet"

export class $PngReader {
static readonly "MAX_TOTAL_BYTES_READ_DEFAULT": long
static readonly "MAX_BYTES_METADATA_DEFAULT": long
static readonly "MAX_CHUNK_SIZE_SKIP": long
readonly "imgInfo": $ImageInfo
readonly "interlaced": boolean

constructor(arg0: $File$Type)
constructor(arg0: $InputStream$Type, arg1: boolean)
constructor(arg0: $InputStream$Type)

public "toString"(): string
public "end"(): void
public "close"(): void
public "getMetadata"(): $PngMetadata
public "setLineSetFactory"(arg0: $IImageLineSetFactory$Type<(any)>): void
public "getChunksList"(): $ChunksList
public "readRow"(arg0: integer): $IImageLine
public "readRow"(): $IImageLine
public "hasMoreRows"(): boolean
public "readRows"(arg0: integer, arg1: integer, arg2: integer): $IImageLineSet<(any)>
public "readRows"(): $IImageLineSet<(any)>
public "getSimpleDigestHex"(): string
public "toStringCompact"(): string
public "setChunksToSkip"(...arg0: (string)[]): void
public "isInterlaced"(): boolean
public "getChunkseq"(): $ChunkSeqReaderPng
public "addChunkToSkip"(arg0: string): void
public "setMaxTotalBytesRead"(arg0: long): void
public "setMaxBytesMetadata"(arg0: long): void
public "prepareSimpleDigestComputation"(): void
public "readSkippingAllRows"(): void
public "setSkipChunkMaxSize"(arg0: long): void
public "setChunkLoadBehaviour"(arg0: $ChunkLoadBehaviour$Type): void
public "setCrcCheckDisabled"(): void
public "setShouldCloseStream"(arg0: boolean): void
get "metadata"(): $PngMetadata
set "lineSetFactory"(value: $IImageLineSetFactory$Type<(any)>)
get "chunksList"(): $ChunksList
get "simpleDigestHex"(): string
set "chunksToSkip"(value: (string)[])
get "interlaced"(): boolean
get "chunkseq"(): $ChunkSeqReaderPng
set "maxTotalBytesRead"(value: long)
set "maxBytesMetadata"(value: long)
set "skipChunkMaxSize"(value: long)
set "chunkLoadBehaviour"(value: $ChunkLoadBehaviour$Type)
set "shouldCloseStream"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngReader$Type = ($PngReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngReader_ = $PngReader$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatcherMatchResult" {
import {$Matcher, $Matcher$Type} from "packages/java/util/regex/$Matcher"
import {$MatchResult$Destructured, $MatchResult$Destructured$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult$Destructured"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MatchGroupCollection, $MatchGroupCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroupCollection"
import {$MatchResult, $MatchResult$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $MatcherMatchResult implements $MatchResult {

constructor(arg0: $Matcher$Type, arg1: charseq)

public "getValue"(): string
public "next"(): $MatchResult
public "getRange"(): $IntRange
public "getGroups"(): $MatchGroupCollection
public "getGroupValues"(): $List<(string)>
public "getDestructured"(): $MatchResult$Destructured
get "value"(): string
get "range"(): $IntRange
get "groups"(): $MatchGroupCollection
get "groupValues"(): $List<(string)>
get "destructured"(): $MatchResult$Destructured
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatcherMatchResult$Type = ($MatcherMatchResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatcherMatchResult_ = $MatcherMatchResult$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ReadOnlyDelegatedFrame" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $ReadOnlyDelegatedFrame implements $Frame {

constructor(arg0: $Frame$Type)

public "getType"(): $Frame$Type
public "getPayload"(): $ByteBuffer
public "getMask"(): (byte)[]
/**
 * 
 * @deprecated
 */
public "isLast"(): boolean
public "hasPayload"(): boolean
public "getOpCode"(): byte
public "getPayloadLength"(): integer
public "isMasked"(): boolean
public "isRsv1"(): boolean
public "isRsv2"(): boolean
public "isRsv3"(): boolean
public "isFin"(): boolean
get "type"(): $Frame$Type
get "payload"(): $ByteBuffer
get "mask"(): (byte)[]
get "last"(): boolean
get "opCode"(): byte
get "payloadLength"(): integer
get "masked"(): boolean
get "rsv1"(): boolean
get "rsv2"(): boolean
get "rsv3"(): boolean
get "fin"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReadOnlyDelegatedFrame$Type = ($ReadOnlyDelegatedFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReadOnlyDelegatedFrame_ = $ReadOnlyDelegatedFrame$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$RequestHandler" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpParser$HttpHandler, $HttpParser$HttpHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$HttpHandler"

export interface $HttpParser$RequestHandler extends $HttpParser$HttpHandler {

 "startRequest"(arg0: string, arg1: string, arg2: $HttpVersion$Type): boolean
 "content"(arg0: $ByteBuffer$Type): boolean
 "earlyEOF"(): void
 "messageComplete"(): boolean
 "parsedTrailer"(arg0: $HttpField$Type): void
 "contentComplete"(): boolean
 "parsedHeader"(arg0: $HttpField$Type): void
 "headerComplete"(): boolean
 "badMessage"(arg0: integer, arg1: string): void
 "getHeaderCacheSize"(): integer
}

export namespace $HttpParser$RequestHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$RequestHandler$Type = ($HttpParser$RequestHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser$RequestHandler_ = $HttpParser$RequestHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$ServletContextEvent, $ServletContextEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextEvent"

export interface $ServletContextListener extends $EventListener {

 "contextInitialized"(arg0: $ServletContextEvent$Type): void
 "contextDestroyed"(arg0: $ServletContextEvent$Type): void
}

export namespace $ServletContextListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletContextListener$Type = ($ServletContextListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletContextListener_ = $ServletContextListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter$Kind" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $KParameter$Kind extends $Enum<($KParameter$Kind)> {
static readonly "INSTANCE": $KParameter$Kind
static readonly "EXTENSION_RECEIVER": $KParameter$Kind
static readonly "VALUE": $KParameter$Kind


public static "values"(): ($KParameter$Kind)[]
public static "valueOf"(arg0: string): $KParameter$Kind
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KParameter$Kind$Type = (("instance") | ("extension_receiver") | ("value")) | ($KParameter$Kind);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KParameter$Kind_ = $KParameter$Kind$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$SessionFactory" {
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"

export interface $SessionFactory {

 "supports"(arg0: $EventDriver$Type): boolean
 "createSession"(arg0: $URI$Type, arg1: $EventDriver$Type, arg2: $LogicalConnection$Type): $WebSocketSession
}

export namespace $SessionFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionFactory$Type = ($SessionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionFactory_ = $SessionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedScanner" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$AbstractMethodAnnotationScanner, $AbstractMethodAnnotationScanner$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$AbstractMethodAnnotationScanner"
import {$JettyAnnotatedMetadata, $JettyAnnotatedMetadata$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedMetadata"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $JettyAnnotatedScanner extends $AbstractMethodAnnotationScanner<($JettyAnnotatedMetadata)> {

constructor()

public "scan"(arg0: $Class$Type<(any)>): $JettyAnnotatedMetadata
public "onMethodAnnotation"(arg0: $JettyAnnotatedMetadata$Type, arg1: $Class$Type<(any)>, arg2: $Method$Type, arg3: $Annotation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyAnnotatedScanner$Type = ($JettyAnnotatedScanner);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyAnnotatedScanner_ = $JettyAnnotatedScanner$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ULongIterator" {
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ULongIterator implements $Iterator<($ULong)>, $KMappedMarker {

constructor()

public "remove"(): void
public "next-s-VKNKU"(): long
public "nextULong-s-VKNKU"(): long
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongIterator$Type = ($ULongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongIterator_ = $ULongIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KTypeProjection, $KTypeProjection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"
import {$KAnnotatedElement, $KAnnotatedElement$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KAnnotatedElement"

export interface $KType extends $KAnnotatedElement {

 "getArguments"(): $List<($KTypeProjection)>
 "isMarkedNullable"(): boolean
 "getClassifier"(): $KClassifier
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KType$Type = ($KType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KType_ = $KType$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintSecurityHandler" {
import {$ConstraintAware, $ConstraintAware$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintAware"
import {$ServletSecurity$TransportGuarantee, $ServletSecurity$TransportGuarantee$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$TransportGuarantee"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$ServletSecurity$EmptyRoleSemantic, $ServletSecurity$EmptyRoleSemantic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$EmptyRoleSemantic"
import {$Constraint, $Constraint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/security/$Constraint"
import {$ConstraintMapping, $ConstraintMapping$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ConstraintMapping"
import {$HttpConstraintElement, $HttpConstraintElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$HttpConstraintElement"
import {$ServletSecurityElement, $ServletSecurityElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletSecurityElement"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$SecurityHandler, $SecurityHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$SecurityHandler"

export class $ConstraintSecurityHandler extends $SecurityHandler implements $ConstraintAware {
static readonly "__NO_USER": $Principal
static readonly "__NOBODY": $Principal
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public static "createConstraint"(arg0: string, arg1: boolean, arg2: (string)[], arg3: integer): $Constraint
public static "createConstraint"(arg0: string, arg1: $HttpConstraintElement$Type): $Constraint
public static "createConstraint"(arg0: string, arg1: (string)[], arg2: $ServletSecurity$EmptyRoleSemantic$Type, arg3: $ServletSecurity$TransportGuarantee$Type): $Constraint
public static "createConstraint"(arg0: $Constraint$Type): $Constraint
public static "createConstraint"(): $Constraint
public "setRoles"(arg0: $Set$Type<(string)>): void
public "getRoles"(): $Set<(string)>
public "addRole"(arg0: string): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public static "createConstraintsWithMappingsForPath"(arg0: string, arg1: string, arg2: $ServletSecurityElement$Type): $List<($ConstraintMapping)>
public static "removeConstraintMappingsForPath"(arg0: string, arg1: $List$Type<($ConstraintMapping$Type)>): $List<($ConstraintMapping)>
public "getConstraintMappings"(): $List<($ConstraintMapping)>
public "getPathsWithUncoveredHttpMethods"(): $Set<(string)>
public "addConstraintMapping"(arg0: $ConstraintMapping$Type): void
public "setDenyUncoveredHttpMethods"(arg0: boolean): void
public "setConstraintMappings"(arg0: $List$Type<($ConstraintMapping$Type)>, arg1: $Set$Type<(string)>): void
public "setConstraintMappings"(arg0: ($ConstraintMapping$Type)[]): void
public "setConstraintMappings"(arg0: $List$Type<($ConstraintMapping$Type)>): void
public static "getConstraintMappingsForPath"(arg0: string, arg1: $List$Type<($ConstraintMapping$Type)>): $List<($ConstraintMapping)>
public "checkPathsWithUncoveredHttpMethods"(): boolean
public "isDenyUncoveredHttpMethods"(): boolean
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "roles"(value: $Set$Type<(string)>)
get "roles"(): $Set<(string)>
get "constraintMappings"(): $List<($ConstraintMapping)>
get "pathsWithUncoveredHttpMethods"(): $Set<(string)>
set "denyUncoveredHttpMethods"(value: boolean)
set "constraintMappings"(value: ($ConstraintMapping$Type)[])
set "constraintMappings"(value: $List$Type<($ConstraintMapping$Type)>)
get "denyUncoveredHttpMethods"(): boolean
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstraintSecurityHandler$Type = ($ConstraintSecurityHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstraintSecurityHandler_ = $ConstraintSecurityHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt__ArraysJVMKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ArraysKt__ArraysJVMKt {

constructor()

public static "copyOfRangeToIndexCheck"(arg0: integer, arg1: integer): void
public static "contentDeepHashCode"<T>(arg0: (T)[]): integer
public static "arrayOfNulls"<T>(arg0: (T)[], arg1: integer): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysKt__ArraysJVMKt$Type = ($ArraysKt__ArraysJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysKt__ArraysJVMKt_ = $ArraysKt__ArraysJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$TypeUtil" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TypeUtil {
static readonly "NO_ARGS": ($Class<(any)>)[]
static readonly "CR": integer
static readonly "LF": integer

constructor()

public static "convertHexDigit"(arg0: integer): integer
public static "convertHexDigit"(arg0: character): integer
public static "convertHexDigit"(arg0: byte): byte
public static "toHex"(arg0: integer, arg1: $Appendable$Type): void
public static "toHex"(arg0: byte, arg1: $Appendable$Type): void
public static "toHex"(arg0: long, arg1: $Appendable$Type): void
public static "toString"(arg0: (byte)[], arg1: integer): string
public static "valueOf"(arg0: $Class$Type<(any)>, arg1: string): any
public static "valueOf"(arg0: string, arg1: string): any
public static "toHexString"(arg0: byte): string
public static "toHexString"(arg0: (byte)[]): string
public static "toHexString"(arg0: (byte)[], arg1: integer, arg2: integer): string
public static "asList"<T>(arg0: (T)[]): $List<(T)>
public static "parseInt"(arg0: string, arg1: integer, arg2: integer, arg3: integer): integer
public static "parseInt"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): integer
public static "call"(arg0: $Class$Type<(any)>, arg1: string, arg2: any, arg3: (any)[]): any
public static "construct"(arg0: $Class$Type<(any)>, arg1: (any)[], arg2: $Map$Type<(string), (any)>): any
public static "construct"(arg0: $Class$Type<(any)>, arg1: (any)[]): any
public static "fromHexString"(arg0: string): (byte)[]
public static "isTrue"(arg0: any): boolean
public static "parseBytes"(arg0: string, arg1: integer): (byte)[]
public static "fromName"(arg0: string): $Class<(any)>
public static "dump"(arg0: $ClassLoader$Type): void
public static "dump"(arg0: $Class$Type<(any)>): void
public static "toName"(arg0: $Class$Type<(any)>): string
public static "isFalse"(arg0: any): boolean
public static "getLoadedFrom"(arg0: $Class$Type<(any)>): $Resource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeUtil$Type = ($TypeUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeUtil_ = $TypeUtil$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Interceptor" {
import {$HttpInput$Content, $HttpInput$Content$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Content"

export interface $HttpInput$Interceptor {

 "readFrom"(arg0: $HttpInput$Content$Type): $HttpInput$Content

(arg0: $HttpInput$Content$Type): $HttpInput$Content
}

export namespace $HttpInput$Interceptor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpInput$Interceptor$Type = ($HttpInput$Interceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpInput$Interceptor_ = $HttpInput$Interceptor$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$MultipartConfigElement" {
import {$MultipartConfig, $MultipartConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$MultipartConfig"

export class $MultipartConfigElement {

constructor(arg0: $MultipartConfig$Type)
constructor(arg0: string, arg1: long, arg2: long, arg3: integer)
constructor(arg0: string)

public "getLocation"(): string
public "getFileSizeThreshold"(): integer
public "getMaxFileSize"(): long
public "getMaxRequestSize"(): long
get "location"(): string
get "fileSizeThreshold"(): integer
get "maxFileSize"(): long
get "maxRequestSize"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartConfigElement$Type = ($MultipartConfigElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartConfigElement_ = $MultipartConfigElement$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SlidingWindowKt" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SlidingWindowKt {


public static "windowedSequence"<T>(arg0: $Sequence$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean): $Sequence<($List<(T)>)>
public static "windowedIterator"<T>(arg0: $Iterator$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean): $Iterator<($List<(T)>)>
public static "checkWindowSizeStep"(arg0: integer, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlidingWindowKt$Type = ($SlidingWindowKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlidingWindowKt_ = $SlidingWindowKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ExceptionMapper" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExceptionHandlerImpl, $ExceptionHandlerImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandlerImpl"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $ExceptionMapper {

constructor()

public "clear"(): void
public "map"(arg0: $Class$Type<(any)>, arg1: $ExceptionHandlerImpl$Type<(any)>): void
public static "getInstance"(): $ExceptionMapper
public "getHandler"(arg0: $Exception$Type): $ExceptionHandlerImpl<(any)>
public "getHandler"(arg0: $Class$Type<(any)>): $ExceptionHandlerImpl<(any)>
get "instance"(): $ExceptionMapper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionMapper$Type = ($ExceptionMapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionMapper_ = $ExceptionMapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringBuilderKt" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$StringsKt__StringBuilderJVMKt, $StringsKt__StringBuilderJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringBuilderJVMKt"

export class $StringsKt__StringBuilderKt extends $StringsKt__StringBuilderJVMKt {

constructor()

public static "append"(arg0: $StringBuilder$Type, ...arg1: (string)[]): $StringBuilder
public static "append"(arg0: $StringBuilder$Type, ...arg1: (any)[]): $StringBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringBuilderKt$Type = ($StringsKt__StringBuilderKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringBuilderKt_ = $StringsKt__StringBuilderKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $PngjException extends $RuntimeException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngjException$Type = ($PngjException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngjException_ = $PngjException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$AbstractCoroutineContextKey" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export class $AbstractCoroutineContextKey<B extends $CoroutineContext$Element, E extends B> implements $CoroutineContext$Key<(E)> {

constructor(arg0: $CoroutineContext$Key$Type<(B)>, arg1: $Function1$Type<(any), (any)>)

public "isSubKey$kotlin_stdlib"(arg0: $CoroutineContext$Key$Type<(any)>): boolean
public "tryCast$kotlin_stdlib"(arg0: $CoroutineContext$Element$Type): E
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCoroutineContextKey$Type<B, E> = ($AbstractCoroutineContextKey<(B), (E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractCoroutineContextKey_<B, E> = $AbstractCoroutineContextKey$Type<(B), (E)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$BuilderInference" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $BuilderInference extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $BuilderInference {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderInference$Type = ($BuilderInference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderInference_ = $BuilderInference$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler" {
import {$WebConnection, $WebConnection$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$WebConnection"

export interface $HttpUpgradeHandler {

 "init"(arg0: $WebConnection$Type): void
 "destroy"(): void
}

export namespace $HttpUpgradeHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpUpgradeHandler$Type = ($HttpUpgradeHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpUpgradeHandler_ = $HttpUpgradeHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/statistic/$SampleStatistic" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SampleStatistic {

constructor()

public "toString"(): string
public "set"(arg0: long): void
public "reset"(): void
public "getCount"(): long
public "getMax"(): long
public "getTotal"(): long
public "getVariance"(): double
public "getStdDev"(): double
public "getMean"(): double
get "count"(): long
get "max"(): long
get "total"(): long
get "variance"(): double
get "stdDev"(): double
get "mean"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SampleStatistic$Type = ($SampleStatistic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SampleStatistic_ = $SampleStatistic$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__AppendableKt" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"

export class $StringsKt__AppendableKt {

constructor()

public static "append"<T extends $Appendable>(arg0: T, ...arg1: (charseq)[]): T
public static "appendRange"<T extends $Appendable>(arg0: T, arg1: charseq, arg2: integer, arg3: integer): T
public static "appendElement"<T>(arg0: $Appendable$Type, arg1: T, arg2: $Function1$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__AppendableKt$Type = ($StringsKt__AppendableKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__AppendableKt_ = $StringsKt__AppendableKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ManagedAttributeListener" {
import {$ServletContextListener, $ServletContextListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextListener"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$ServletContextAttributeListener, $ServletContextAttributeListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextAttributeListener"
import {$ServletContextAttributeEvent, $ServletContextAttributeEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextAttributeEvent"
import {$ServletContextEvent, $ServletContextEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContextEvent"

export class $ManagedAttributeListener implements $ServletContextListener, $ServletContextAttributeListener {

constructor(arg0: $ContextHandler$Type, ...arg1: (string)[])

public "attributeAdded"(arg0: $ServletContextAttributeEvent$Type): void
public "attributeReplaced"(arg0: $ServletContextAttributeEvent$Type): void
public "attributeRemoved"(arg0: $ServletContextAttributeEvent$Type): void
public "contextInitialized"(arg0: $ServletContextEvent$Type): void
public "contextDestroyed"(arg0: $ServletContextEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedAttributeListener$Type = ($ManagedAttributeListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedAttributeListener_ = $ManagedAttributeListener$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkITXT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkTextVar, $PngChunkTextVar$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTextVar"

export class $PngChunkITXT extends $PngChunkTextVar {
static readonly "ID": string
static readonly "KEY_Title": string
static readonly "KEY_Author": string
static readonly "KEY_Description": string
static readonly "KEY_Copyright": string
static readonly "KEY_Creation_Time": string
static readonly "KEY_Software": string
static readonly "KEY_Disclaimer": string
static readonly "KEY_Warning": string
static readonly "KEY_Source": string
static readonly "KEY_Comment": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setLangtag"(arg0: string): void
public "getTranslatedTag"(): string
public "setTranslatedTag"(arg0: string): void
public "getLangtag"(): string
public "setCompressed"(arg0: boolean): void
public "isCompressed"(): boolean
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
set "langtag"(value: string)
get "translatedTag"(): string
set "translatedTag"(value: string)
get "langtag"(): string
set "compressed"(value: boolean)
get "compressed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkITXT$Type = ($PngChunkITXT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkITXT_ = $PngChunkITXT$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AsyncContextState" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$AsyncListener, $AsyncListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncListener"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"

export class $AsyncContextState implements $AsyncContext {

constructor(arg0: $HttpChannelState$Type)

public "getTimeout"(): long
public "dispatch"(arg0: string): void
public "dispatch"(): void
public "dispatch"(arg0: $ServletContext$Type, arg1: string): void
public "start"(arg0: $Runnable$Type): void
public "reset"(): void
public "complete"(): void
public "setTimeout"(arg0: long): void
public "getResponse"(): $ServletResponse
public "getHttpChannelState"(): $HttpChannelState
public "createListener"<T extends $AsyncListener>(arg0: $Class$Type<(T)>): T
public "addListener"(arg0: $AsyncListener$Type, arg1: $ServletRequest$Type, arg2: $ServletResponse$Type): void
public "addListener"(arg0: $AsyncListener$Type): void
public "getHttpChannel"(): $HttpChannel
public "getRequest"(): $ServletRequest
public "hasOriginalRequestAndResponse"(): boolean
get "timeout"(): long
set "timeout"(value: long)
get "response"(): $ServletResponse
get "httpChannelState"(): $HttpChannelState
get "httpChannel"(): $HttpChannel
get "request"(): $ServletRequest
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncContextState$Type = ($AsyncContextState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncContextState_ = $AsyncContextState$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$ContinuationImpl" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$BaseContinuationImpl, $BaseContinuationImpl$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$BaseContinuationImpl"

export class $ContinuationImpl extends $BaseContinuationImpl {

constructor(arg0: $Continuation$Type<(any)>, arg1: $CoroutineContext$Type)
constructor(arg0: $Continuation$Type<(any)>)

public "getContext"(): $CoroutineContext
public "intercepted"(): $Continuation<(any)>
get "context"(): $CoroutineContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinuationImpl$Type = ($ContinuationImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinuationImpl_ = $ContinuationImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringNumberConversionsKt" {
import {$StringsKt__StringNumberConversionsJVMKt, $StringsKt__StringNumberConversionsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringNumberConversionsJVMKt"

export class $StringsKt__StringNumberConversionsKt extends $StringsKt__StringNumberConversionsJVMKt {

constructor()

public static "numberFormatError"(arg0: string): void
public static "toByteOrNull"(arg0: string): byte
public static "toByteOrNull"(arg0: string, arg1: integer): byte
public static "toIntOrNull"(arg0: string, arg1: integer): integer
public static "toIntOrNull"(arg0: string): integer
public static "toLongOrNull"(arg0: string, arg1: integer): long
public static "toLongOrNull"(arg0: string): long
public static "toShortOrNull"(arg0: string): short
public static "toShortOrNull"(arg0: string, arg1: integer): short
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringNumberConversionsKt$Type = ($StringsKt__StringNumberConversionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringNumberConversionsKt_ = $StringsKt__StringNumberConversionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$Target" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$AnnotationTarget, $AnnotationTarget$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$AnnotationTarget"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Target extends $Annotation {

 "allowedTargets"(): ($AnnotationTarget)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Target {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Target$Type = ($Target);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Target_ = $Target$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$QuotedStringTokenizer" {
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$StringTokenizer, $StringTokenizer$Type} from "packages/java/util/$StringTokenizer"

export class $QuotedStringTokenizer extends $StringTokenizer {

constructor(arg0: string, arg1: string, arg2: boolean, arg3: boolean)
constructor(arg0: string, arg1: string, arg2: boolean)
constructor(arg0: string, arg1: string)
constructor(arg0: string)

public "setSingle"(arg0: boolean): void
public static "unquoteOnly"(arg0: string, arg1: boolean): string
public static "unquoteOnly"(arg0: string): string
public "getDouble"(): boolean
public "countTokens"(): integer
public "hasMoreElements"(): boolean
public "nextToken"(arg0: string): string
public "nextToken"(): string
public "nextElement"(): any
public "setDouble"(arg0: boolean): void
public "hasMoreTokens"(): boolean
public static "quote"(arg0: $Appendable$Type, arg1: string): void
public static "quote"(arg0: string): string
public static "isQuoted"(arg0: string): boolean
public static "quoteOnly"(arg0: $Appendable$Type, arg1: string): void
public static "unquote"(arg0: string, arg1: boolean): string
public static "unquote"(arg0: string): string
public static "quoteIfNeeded"(arg0: string, arg1: string): string
public "getSingle"(): boolean
set "single"(value: boolean)
get "double"(): boolean
set "double"(value: boolean)
get "single"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuotedStringTokenizer$Type = ($QuotedStringTokenizer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuotedStringTokenizer_ = $QuotedStringTokenizer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableSet" {
import {$KMutableCollection, $KMutableCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableCollection"

export interface $KMutableSet extends $KMutableCollection {

}

export namespace $KMutableSet {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableSet$Type = ($KMutableSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableSet_ = $KMutableSet$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ConstantThrowable" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export class $ConstantThrowable extends $Throwable {

constructor()
constructor(arg0: string)

public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantThrowable$Type = ($ConstantThrowable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstantThrowable_ = $ConstantThrowable$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__FilePathComponentsKt" {
import {$FilePathComponents, $FilePathComponents$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilePathComponents"
import {$File, $File$Type} from "packages/java/io/$File"

export class $FilesKt__FilePathComponentsKt {

constructor()

public static "getRoot"(arg0: $File$Type): $File
public static "getRootName"(arg0: $File$Type): string
public static "subPath"(arg0: $File$Type, arg1: integer, arg2: integer): $File
public static "toComponents"(arg0: $File$Type): $FilePathComponents
public static "isRooted"(arg0: $File$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilesKt__FilePathComponentsKt$Type = ($FilesKt__FilePathComponentsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilesKt__FilePathComponentsKt_ = $FilesKt__FilePathComponentsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ClassLoaderDump" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"

export class $ClassLoaderDump implements $Dumpable {

constructor(arg0: $ClassLoader$Type)

public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassLoaderDump$Type = ($ClassLoaderDump);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassLoaderDump_ = $ClassLoaderDump$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionIdListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$HttpSessionEvent, $HttpSessionEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent"

export interface $HttpSessionIdListener extends $EventListener {

 "sessionIdChanged"(arg0: $HttpSessionEvent$Type, arg1: string): void

(arg0: $HttpSessionEvent$Type, arg1: string): void
}

export namespace $HttpSessionIdListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionIdListener$Type = ($HttpSessionIdListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionIdListener_ = $HttpSessionIdListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadPool" {
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $ThreadPool extends $Executor {

 "join"(): void
 "getThreads"(): integer
 "isLowOnThreads"(): boolean
 "getIdleThreads"(): integer
 "execute"(arg0: $Runnable$Type): void
}

export namespace $ThreadPool {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadPool$Type = ($ThreadPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadPool_ = $ThreadPool$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkPHYS" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkPHYS extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getAsDpi2"(): (double)[]
public "setAsDpi2"(arg0: double, arg1: double): void
public "getPixelsxUnitX"(): long
public "setPixelsxUnitX"(arg0: long): void
public "getAsDpi"(): double
public "getPixelsxUnitY"(): long
public "setUnits"(arg0: integer): void
public "setPixelsxUnitY"(arg0: long): void
public "setAsDpi"(arg0: double): void
public "getUnits"(): integer
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "asDpi2"(): (double)[]
get "pixelsxUnitX"(): long
set "pixelsxUnitX"(value: long)
get "asDpi"(): double
get "pixelsxUnitY"(): long
set "units"(value: integer)
set "pixelsxUnitY"(value: long)
set "asDpi"(value: double)
get "units"(): integer
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkPHYS$Type = ($PngChunkPHYS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkPHYS_ = $PngChunkPHYS$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference" {
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$CallableReference, $CallableReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$CallableReference"

export class $PropertyReference extends $CallableReference implements $KProperty<(any)> {
static readonly "NO_RECEIVER": any

constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: any)
constructor()

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isLateinit"(): boolean
public "isConst"(): boolean
public "getGetter"(): $KProperty$Getter<(any)>
get "lateinit"(): boolean
get "const"(): boolean
get "getter"(): $KProperty$Getter<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyReference$Type = ($PropertyReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyReference_ = $PropertyReference$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpCompliance extends $Enum<($HttpCompliance)> {
static readonly "LEGACY": $HttpCompliance
static readonly "RFC2616": $HttpCompliance
static readonly "RFC7230": $HttpCompliance


public static "values"(): ($HttpCompliance)[]
public static "valueOf"(arg0: string): $HttpCompliance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpCompliance$Type = (("legacy") | ("rfc7230") | ("rfc2616")) | ($HttpCompliance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpCompliance_ = $HttpCompliance$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ReversedList" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$AbstractMutableList, $AbstractMutableList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableList"

export class $ReversedList<T> extends $AbstractMutableList<(T)> {

constructor(arg0: $List$Type<(T)>)

public "add"(arg0: integer, arg1: T): void
public "get"(arg0: integer): T
public "clear"(): void
public "set"(arg0: integer, arg1: T): T
public "getSize"(): integer
public "removeAt"(arg0: integer): T
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "indexOf"(arg0: any): integer
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "subList"(arg0: integer, arg1: integer): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "listIterator"(): $ListIterator<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "size"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReversedList$Type<T> = ($ReversedList<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReversedList_<T> = $ReversedList$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$Halt" {
import {$HaltException, $HaltException$Type} from "packages/info/journeymap/shaded/kotlin/spark/$HaltException"
import {$Body, $Body$Type} from "packages/info/journeymap/shaded/kotlin/spark/http/matching/$Body"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"

export class $Halt {

constructor()

public static "modify"(arg0: $HttpServletResponse$Type, arg1: $Body$Type, arg2: $HaltException$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Halt$Type = ($Halt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Halt_ = $Halt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt" {
import {$SetsKt___SetsKt, $SetsKt___SetsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt___SetsKt"

export class $SetsKt extends $SetsKt___SetsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetsKt$Type = ($SetsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetsKt_ = $SetsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$OpCode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $OpCode {
static readonly "CONTINUATION": byte
static readonly "TEXT": byte
static readonly "BINARY": byte
static readonly "CLOSE": byte
static readonly "PING": byte
static readonly "PONG": byte
static readonly "UNDEFINED": byte

constructor()

public static "name"(arg0: byte): string
public static "isKnown"(arg0: byte): boolean
public static "isControlFrame"(arg0: byte): boolean
public static "isDataFrame"(arg0: byte): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpCode$Type = ($OpCode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpCode_ = $OpCode$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/annotations/$OnWebSocketConnect" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OnWebSocketConnect extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OnWebSocketConnect {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnWebSocketConnect$Type = ($OnWebSocketConnect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnWebSocketConnect_ = $OnWebSocketConnect$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$InputStreamResource" {
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export interface $InputStreamResource {

 "getInputStream"(): $InputStream

(): $InputStream
}

export namespace $InputStreamResource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputStreamResource$Type = ($InputStreamResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputStreamResource_ = $InputStreamResource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export interface $CoroutineContext {

 "get"<E extends $CoroutineContext$Element>(arg0: $CoroutineContext$Key$Type<(E)>): E
 "plus"(arg0: $CoroutineContext$Type): $CoroutineContext
 "minusKey"(arg0: $CoroutineContext$Key$Type<(any)>): $CoroutineContext
 "fold"<R>(arg0: R, arg1: $Function2$Type<(any), (any), (any)>): R
}

export namespace $CoroutineContext {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoroutineContext$Type = ($CoroutineContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoroutineContext_ = $CoroutineContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$HttpMethodConstraint, $HttpMethodConstraint$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$HttpMethodConstraint"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$HttpConstraint, $HttpConstraint$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$HttpConstraint"

export interface $ServletSecurity extends $Annotation {

 "value"(): $HttpConstraint
 "httpMethodConstraints"(): ($HttpMethodConstraint)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ServletSecurity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletSecurity$Type = ($ServletSecurity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletSecurity_ = $ServletSecurity$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$KMutableProperty$Setter, $KMutableProperty$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty<V> extends $KProperty<(V)> {

 "getSetter"(): $KMutableProperty$Setter<(V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "getGetter"(): $KProperty$Getter<(V)>
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty$Type<V> = ($KMutableProperty<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty_<V> = $KMutableProperty$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCookie" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $HttpCookie {

constructor(arg0: string, arg1: string, arg2: string, arg3: string, arg4: long, arg5: boolean, arg6: boolean)
constructor(arg0: string, arg1: string, arg2: string, arg3: string, arg4: long, arg5: boolean, arg6: boolean, arg7: string, arg8: integer)
constructor(arg0: string, arg1: string)
constructor(arg0: string, arg1: string, arg2: long)
constructor(arg0: string, arg1: string, arg2: string, arg3: string)

public "getName"(): string
public "getValue"(): string
public "getPath"(): string
public "getComment"(): string
public "getVersion"(): integer
public "getDomain"(): string
public "isSecure"(): boolean
public "isHttpOnly"(): boolean
public "asString"(): string
public "getMaxAge"(): long
public "isExpired"(arg0: long): boolean
get "name"(): string
get "value"(): string
get "path"(): string
get "comment"(): string
get "version"(): integer
get "domain"(): string
get "secure"(): boolean
get "httpOnly"(): boolean
get "maxAge"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpCookie$Type = ($HttpCookie);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpCookie_ = $HttpCookie$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2$Setter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Function3, $Function3$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3"
import {$KMutableProperty$Setter, $KMutableProperty$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty2$Setter<D, E, V> extends $KMutableProperty$Setter<(V)>, $Function3<(D), (E), (V), ($Unit)> {

 "invoke"(arg0: D, arg1: E, arg2: V): $Unit
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): $Unit
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): $Unit
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty2$Setter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty2$Setter$Type<D, E, V> = ($KMutableProperty2$Setter<(D), (E), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty2$Setter_<D, E, V> = $KMutableProperty2$Setter$Type<(D), (E), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KFunction<R> extends $KCallable<(R)>, $Function<(R)> {

 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): R
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): R
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KFunction$Type<R> = ($KFunction<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KFunction_<R> = $KFunction$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$_Assertions" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $_Assertions {
static readonly "INSTANCE": $_Assertions
static readonly "ENABLED": boolean


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $_Assertions$Type = ($_Assertions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $_Assertions_ = $_Assertions$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IncludeExclude" {
import {$IncludeExcludeSet, $IncludeExcludeSet$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IncludeExcludeSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $IncludeExclude<ITEM> extends $IncludeExcludeSet<(ITEM), (ITEM)> {

constructor()
constructor<SET extends $Set<(ITEM)>>(arg0: $Class$Type<(SET)>)
constructor<SET extends $Set<(ITEM)>>(arg0: $Set$Type<(ITEM)>, arg1: $Predicate$Type<(ITEM)>, arg2: $Set$Type<(ITEM)>, arg3: $Predicate$Type<(ITEM)>)

public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IncludeExclude$Type<ITEM> = ($IncludeExclude<(ITEM)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IncludeExclude_<ITEM> = $IncludeExclude$Type<(ITEM)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Pair" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"

export class $Pair<A, B> implements $Serializable {

constructor(arg0: A, arg1: B)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "copy"(arg0: A, arg1: B): $Pair<(A), (B)>
public "getFirst"(): A
public "getSecond"(): B
public "component2"(): B
public "component1"(): A
get "first"(): A
get "second"(): B
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pair$Type<A, B> = ($Pair<(A), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pair_<A, B> = $Pair$Type<(A), (B)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference" {
import {$KMutableProperty, $KMutableProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty"
import {$KMutableProperty$Setter, $KMutableProperty$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$PropertyReference, $PropertyReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference"

export class $MutablePropertyReference extends $PropertyReference implements $KMutableProperty<(any)> {
static readonly "NO_RECEIVER": any

constructor()
constructor(arg0: any)
constructor(arg0: any, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)

public "getSetter"(): $KMutableProperty$Setter<(any)>
get "setter"(): $KMutableProperty$Setter<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutablePropertyReference$Type = ($MutablePropertyReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutablePropertyReference_ = $MutablePropertyReference$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedCollection" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$SerializedCollection$Companion, $SerializedCollection$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedCollection$Companion"
import {$Externalizable, $Externalizable$Type} from "packages/java/io/$Externalizable"
import {$ObjectOutput, $ObjectOutput$Type} from "packages/java/io/$ObjectOutput"
import {$ObjectInput, $ObjectInput$Type} from "packages/java/io/$ObjectInput"

export class $SerializedCollection implements $Externalizable {
static readonly "Companion": $SerializedCollection$Companion
static readonly "tagList": integer
static readonly "tagSet": integer

constructor(arg0: $Collection$Type<(any)>, arg1: integer)
constructor()

public "writeExternal"(arg0: $ObjectOutput$Type): void
public "readExternal"(arg0: $ObjectInput$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializedCollection$Type = ($SerializedCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializedCollection_ = $SerializedCollection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt__SetsJVMKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TreeSet, $TreeSet$Type} from "packages/java/util/$TreeSet"

export class $SetsKt__SetsJVMKt {

constructor()

public static "build"<E>(arg0: $Set$Type<(E)>): $Set<(E)>
public static "setOf"<T>(arg0: T): $Set<(T)>
public static "sortedSetOf"<T>(arg0: $Comparator$Type<(any)>, ...arg1: (T)[]): $TreeSet<(T)>
public static "sortedSetOf"<T>(...arg0: (T)[]): $TreeSet<(T)>
public static "createSetBuilder"<E>(arg0: integer): $Set<(E)>
public static "createSetBuilder"<E>(): $Set<(E)>
set "of"(value: T)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetsKt__SetsJVMKt$Type = ($SetsKt__SetsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetsKt__SetsJVMKt_ = $SetsKt__SetsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$TemplateViewRouteImpl" {
import {$RouteImpl, $RouteImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteImpl"
import {$TemplateEngine, $TemplateEngine$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine"
import {$TemplateViewRoute, $TemplateViewRoute$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateViewRoute"
import {$ModelAndView, $ModelAndView$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ModelAndView"

export class $TemplateViewRouteImpl extends $RouteImpl {


public static "create"(arg0: string, arg1: $TemplateViewRoute$Type, arg2: $TemplateEngine$Type): $TemplateViewRouteImpl
public static "create"(arg0: string, arg1: string, arg2: $TemplateViewRoute$Type, arg3: $TemplateEngine$Type): $TemplateViewRouteImpl
public "render"(arg0: $ModelAndView$Type): any
public "render"(arg0: any): any
public "modelAndView"(arg0: any, arg1: string): $ModelAndView
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemplateViewRouteImpl$Type = ($TemplateViewRouteImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemplateViewRouteImpl_ = $TemplateViewRouteImpl$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkTextVar" {
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$PngChunkMultiple, $PngChunkMultiple$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkMultiple"

export class $PngChunkTextVar extends $PngChunkMultiple {
static readonly "KEY_Title": string
static readonly "KEY_Author": string
static readonly "KEY_Description": string
static readonly "KEY_Copyright": string
static readonly "KEY_Creation_Time": string
static readonly "KEY_Software": string
static readonly "KEY_Disclaimer": string
static readonly "KEY_Warning": string
static readonly "KEY_Source": string
static readonly "KEY_Comment": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean


public "getVal"(): string
public "setKeyVal"(arg0: string, arg1: string): void
public "getKey"(): string
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "val"(): string
get "key"(): string
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkTextVar$Type = ($PngChunkTextVar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkTextVar_ = $PngChunkTextVar$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipFactory" {
import {$Deflater, $Deflater$Type} from "packages/java/util/zip/$Deflater"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"

export interface $GzipFactory {

 "getDeflater"(arg0: $Request$Type, arg1: long): $Deflater
 "recycle"(arg0: $Deflater$Type): void
 "isMimeTypeGzipable"(arg0: string): boolean
}

export namespace $GzipFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GzipFactory$Type = ($GzipFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GzipFactory_ = $GzipFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$HostPort" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $HostPort {

constructor(arg0: string)

public "getHost"(): string
public "getPort"(arg0: integer): integer
public "getPort"(): integer
public static "normalizeHost"(arg0: string): string
get "host"(): string
get "port"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HostPort$Type = ($HostPort);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HostPort_ = $HostPort$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DefaultConstructorMarker {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultConstructorMarker$Type = ($DefaultConstructorMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultConstructorMarker_ = $DefaultConstructorMarker$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$AbstractMapBuilderEntrySet" {
import {$AbstractMutableSet, $AbstractMutableSet$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractMapBuilderEntrySet<E extends $Map$Entry<(any), (any)>, K, V> extends $AbstractMutableSet<(E)> {

constructor()

public "remove"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "remove"(arg0: any): boolean
public "contains"(arg0: E): boolean
public "contains"(arg0: any): boolean
public "containsEntry"(arg0: $Map$Entry$Type<(any), (any)>): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMapBuilderEntrySet$Type<E, K, V> = ($AbstractMapBuilderEntrySet<(E), (K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMapBuilderEntrySet_<E, K, V> = $AbstractMapBuilderEntrySet$Type<(E), (K), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession$Listener" {
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"

export interface $WebSocketSession$Listener {

 "onClosed"(arg0: $WebSocketSession$Type): void
 "onOpened"(arg0: $WebSocketSession$Type): void
}

export namespace $WebSocketSession$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketSession$Listener$Type = ($WebSocketSession$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketSession$Listener_ = $WebSocketSession$Listener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$Assert" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Assert {

constructor()

public static "state"(arg0: boolean, arg1: string): void
public static "isTrue"(arg0: boolean, arg1: string): void
public static "notNull"(arg0: any): void
public static "notNull"(arg0: any, arg1: string): void
public static "notEmpty"(arg0: (any)[], arg1: string): void
public static "hasLength"(arg0: string, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Assert$Type = ($Assert);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Assert_ = $Assert$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt___SequencesJvmKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$SequencesKt__SequencesKt, $SequencesKt__SequencesKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequencesKt"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SequencesKt___SequencesJvmKt extends $SequencesKt__SequencesKt {

constructor()

public static "toSortedSet"<T>(arg0: $Sequence$Type<(any)>, arg1: $Comparator$Type<(any)>): $SortedSet<(T)>
public static "toSortedSet"<T extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>): $SortedSet<(T)>
public static "filterIsInstanceTo"<C extends $Collection<(any)>, R>(arg0: $Sequence$Type<(any)>, arg1: C, arg2: $Class$Type<(R)>): C
public static "filterIsInstance"<R>(arg0: $Sequence$Type<(any)>, arg1: $Class$Type<(R)>): $Sequence<(R)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt___SequencesJvmKt$Type = ($SequencesKt___SequencesJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt___SequencesJvmKt_ = $SequencesKt___SequencesJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableListIterator" {
import {$KMutableIterator, $KMutableIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterator"

export interface $KMutableListIterator extends $KMutableIterator {

}

export namespace $KMutableListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableListIterator$Type = ($KMutableListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableListIterator_ = $KMutableListIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$WasExperimental" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $WasExperimental extends $Annotation {

 "markerClass"(): ($Class<(any)>)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $WasExperimental {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WasExperimental$Type = ($WasExperimental);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WasExperimental_ = $WasExperimental$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Redirect$Status" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Redirect$Status extends $Enum<($Redirect$Status)> {
static readonly "MULTIPLE_CHOICES": $Redirect$Status
static readonly "MOVED_PERMANENTLY": $Redirect$Status
static readonly "FOUND": $Redirect$Status
static readonly "SEE_OTHER": $Redirect$Status
static readonly "NOT_MODIFIED": $Redirect$Status
static readonly "USE_PROXY": $Redirect$Status
static readonly "SWITCH_PROXY": $Redirect$Status
static readonly "TEMPORARY_REDIRECT": $Redirect$Status
static readonly "PERMANENT_REDIRECT": $Redirect$Status


public static "values"(): ($Redirect$Status)[]
public "intValue"(): integer
public static "valueOf"(arg0: string): $Redirect$Status
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Redirect$Status$Type = (("found") | ("multiple_choices") | ("switch_proxy") | ("temporary_redirect") | ("moved_permanently") | ("use_proxy") | ("see_other") | ("not_modified") | ("permanent_redirect")) | ($Redirect$Status);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Redirect$Status_ = $Redirect$Status$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$SelectorManager" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$SelectableChannel, $SelectableChannel$Type} from "packages/java/nio/channels/$SelectableChannel"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $SelectorManager extends $ContainerLifeCycle implements $Dumpable {
static readonly "DEFAULT_CONNECT_TIMEOUT": integer
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener


public "connectionOpened"(arg0: $Connection$Type): void
public "connectionClosed"(arg0: $Connection$Type): void
public "connect"(arg0: $SelectableChannel$Type, arg1: any): void
public "accept"(arg0: $SelectableChannel$Type): void
public "accept"(arg0: $SelectableChannel$Type, arg1: any): void
public "getExecutor"(): $Executor
public "setConnectTimeout"(arg0: long): void
public "getConnectTimeout"(): long
public "newConnection"(arg0: $SelectableChannel$Type, arg1: $EndPoint$Type, arg2: any): $Connection
public "getScheduler"(): $Scheduler
public "getSelectorCount"(): integer
public "acceptor"(arg0: $SelectableChannel$Type): void
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "executor"(): $Executor
set "connectTimeout"(value: long)
get "connectTimeout"(): long
get "scheduler"(): $Scheduler
get "selectorCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectorManager$Type = ($SelectorManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectorManager_ = $SelectorManager$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$GZIPContentDecoder" {
import {$Destroyable, $Destroyable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Destroyable"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $GZIPContentDecoder implements $Destroyable {

constructor(arg0: $ByteBufferPool$Type, arg1: integer)
constructor(arg0: integer)
constructor()

public "decode"(arg0: $ByteBuffer$Type): $ByteBuffer
public "destroy"(): void
public "release"(arg0: $ByteBuffer$Type): void
public "acquire"(arg0: integer): $ByteBuffer
public "isFinished"(): boolean
get "finished"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GZIPContentDecoder$Type = ($GZIPContentDecoder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GZIPContentDecoder_ = $GZIPContentDecoder$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketServerFactory" {
import {$DecoratedObjectFactory, $DecoratedObjectFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$DecoratedObjectFactory"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$ServletUpgradeResponse, $ServletUpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeResponse"
import {$SslContextFactory, $SslContextFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$ServletUpgradeRequest, $ServletUpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeRequest"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"
import {$WebSocketServletFactory, $WebSocketServletFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketServletFactory"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$EventDriverFactory, $EventDriverFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriverFactory"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$WebSocketSession$Listener, $WebSocketSession$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession$Listener"
import {$SessionFactory, $SessionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$SessionFactory"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$ExtensionFactory, $ExtensionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"

export class $WebSocketServerFactory extends $ContainerLifeCycle implements $WebSocketCreator, $WebSocketContainerScope, $WebSocketServletFactory {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $ServletContext$Type)
constructor(arg0: $ServletContext$Type, arg1: $ByteBufferPool$Type)
constructor(arg0: $ServletContext$Type, arg1: $WebSocketPolicy$Type)
constructor(arg0: $ServletContext$Type, arg1: $WebSocketPolicy$Type, arg2: $ByteBufferPool$Type)

public "removeSessionListener"(arg0: $WebSocketSession$Listener$Type): void
public "getEventDriverFactory"(): $EventDriverFactory
public "getExtensionFactory"(): $ExtensionFactory
public "register"(arg0: $Class$Type<(any)>): void
public "getExecutor"(): $Executor
public "getPolicy"(): $WebSocketPolicy
public "setCreator"(arg0: $WebSocketCreator$Type): void
public "isUpgradeRequest"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type): boolean
public "acceptWebSocket"(arg0: $WebSocketCreator$Type, arg1: $HttpServletRequest$Type, arg2: $HttpServletResponse$Type): boolean
public "acceptWebSocket"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type): boolean
public "getBufferPool"(): $ByteBufferPool
public "onSessionOpened"(arg0: $WebSocketSession$Type): void
public "onSessionClosed"(arg0: $WebSocketSession$Type): void
public "createWebSocket"(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): any
public "getCreator"(): $WebSocketCreator
public "getObjectFactory"(): $DecoratedObjectFactory
public "getSslContextFactory"(): $SslContextFactory
public "addSessionListener"(arg0: $WebSocketSession$Listener$Type): void
public "addSessionFactory"(arg0: $SessionFactory$Type): void
public "getOpenSessions"(): $Collection<($WebSocketSession)>
public "isRunning"(): boolean
public "start"(): void
public "stop"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "eventDriverFactory"(): $EventDriverFactory
get "extensionFactory"(): $ExtensionFactory
get "executor"(): $Executor
get "policy"(): $WebSocketPolicy
set "creator"(value: $WebSocketCreator$Type)
get "bufferPool"(): $ByteBufferPool
get "creator"(): $WebSocketCreator
get "objectFactory"(): $DecoratedObjectFactory
get "sslContextFactory"(): $SslContextFactory
get "openSessions"(): $Collection<($WebSocketSession)>
get "running"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServerFactory$Type = ($WebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServerFactory_ = $WebSocketServerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ContinuationFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$DataFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $ContinuationFrame extends $DataFrame {

constructor()

public "getType"(): $Frame$Type
public "setPayload"(arg0: string): $ContinuationFrame
public "setPayload"(arg0: (byte)[]): $ContinuationFrame
get "type"(): $Frame$Type
set "payload"(value: string)
set "payload"(value: (byte)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinuationFrame$Type = ($ContinuationFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinuationFrame_ = $ContinuationFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharDirectionality" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$CharDirectionality$Companion, $CharDirectionality$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharDirectionality$Companion"

export class $CharDirectionality extends $Enum<($CharDirectionality)> {
static readonly "Companion": $CharDirectionality$Companion
static readonly "UNDEFINED": $CharDirectionality
static readonly "LEFT_TO_RIGHT": $CharDirectionality
static readonly "RIGHT_TO_LEFT": $CharDirectionality
static readonly "RIGHT_TO_LEFT_ARABIC": $CharDirectionality
static readonly "EUROPEAN_NUMBER": $CharDirectionality
static readonly "EUROPEAN_NUMBER_SEPARATOR": $CharDirectionality
static readonly "EUROPEAN_NUMBER_TERMINATOR": $CharDirectionality
static readonly "ARABIC_NUMBER": $CharDirectionality
static readonly "COMMON_NUMBER_SEPARATOR": $CharDirectionality
static readonly "NONSPACING_MARK": $CharDirectionality
static readonly "BOUNDARY_NEUTRAL": $CharDirectionality
static readonly "PARAGRAPH_SEPARATOR": $CharDirectionality
static readonly "SEGMENT_SEPARATOR": $CharDirectionality
static readonly "WHITESPACE": $CharDirectionality
static readonly "OTHER_NEUTRALS": $CharDirectionality
static readonly "LEFT_TO_RIGHT_EMBEDDING": $CharDirectionality
static readonly "LEFT_TO_RIGHT_OVERRIDE": $CharDirectionality
static readonly "RIGHT_TO_LEFT_EMBEDDING": $CharDirectionality
static readonly "RIGHT_TO_LEFT_OVERRIDE": $CharDirectionality
static readonly "POP_DIRECTIONAL_FORMAT": $CharDirectionality


public static "values"(): ($CharDirectionality)[]
public static "valueOf"(arg0: string): $CharDirectionality
public "getValue"(): integer
get "value"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharDirectionality$Type = (("european_number_terminator") | ("right_to_left") | ("paragraph_separator") | ("other_neutrals") | ("left_to_right") | ("arabic_number") | ("nonspacing_mark") | ("boundary_neutral") | ("right_to_left_override") | ("common_number_separator") | ("right_to_left_embedding") | ("undefined") | ("right_to_left_arabic") | ("european_number") | ("european_number_separator") | ("left_to_right_embedding") | ("segment_separator") | ("left_to_right_override") | ("pop_directional_format") | ("whitespace")) | ($CharDirectionality);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharDirectionality_ = $CharDirectionality$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ByteArrayOutputStream2" {
import {$ByteArrayOutputStream, $ByteArrayOutputStream$Type} from "packages/java/io/$ByteArrayOutputStream"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $ByteArrayOutputStream2 extends $ByteArrayOutputStream {

constructor()
constructor(arg0: integer)

public "toString"(arg0: $Charset$Type): string
public "reset"(arg0: integer): void
public "getCount"(): integer
public "getBuf"(): (byte)[]
public "writeUnchecked"(arg0: integer): void
public "setCount"(arg0: integer): void
get "count"(): integer
get "buf"(): (byte)[]
set "count"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteArrayOutputStream2$Type = ($ByteArrayOutputStream2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteArrayOutputStream2_ = $ByteArrayOutputStream2$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadPool$SizedThreadPool" {
import {$ThreadPool, $ThreadPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadPool"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $ThreadPool$SizedThreadPool extends $ThreadPool {

 "getMaxThreads"(): integer
 "setMinThreads"(arg0: integer): void
 "getMinThreads"(): integer
 "setMaxThreads"(arg0: integer): void
 "join"(): void
 "getThreads"(): integer
 "isLowOnThreads"(): boolean
 "getIdleThreads"(): integer
 "execute"(arg0: $Runnable$Type): void
}

export namespace $ThreadPool$SizedThreadPool {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadPool$SizedThreadPool$Type = ($ThreadPool$SizedThreadPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadPool$SizedThreadPool_ = $ThreadPool$SizedThreadPool$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ChannelEndPoint" {
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$ManagedSelector$Selectable, $ManagedSelector$Selectable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ManagedSelector$Selectable"
import {$AbstractEndPoint, $AbstractEndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractEndPoint"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ManagedSelector, $ManagedSelector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ManagedSelector"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $ChannelEndPoint extends $AbstractEndPoint implements $ManagedSelector$Selectable {

constructor(arg0: $ByteChannel$Type, arg1: $ManagedSelector$Type, arg2: $SelectionKey$Type, arg3: $Scheduler$Type)

public "flush"(...arg0: ($ByteBuffer$Type)[]): boolean
public "fill"(arg0: $ByteBuffer$Type): integer
public "isOpen"(): boolean
public "getChannel"(): $ByteChannel
public "onClose"(): void
public "onSelected"(): $Runnable
public "updateKey"(): void
public "toEndPointString"(): string
public "isOptimizedForDirectBuffers"(): boolean
public "getTransport"(): any
public "doClose"(): void
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
get "open"(): boolean
get "channel"(): $ByteChannel
get "optimizedForDirectBuffers"(): boolean
get "transport"(): any
set "idleTimeout"(value: long)
get "idleTimeout"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChannelEndPoint$Type = ($ChannelEndPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChannelEndPoint_ = $ChannelEndPoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$PlatformImplementations" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MatchResult, $MatchResult$Type} from "packages/java/util/regex/$MatchResult"
import {$MatchGroup, $MatchGroup$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchGroup"

export class $PlatformImplementations {

constructor()

public "getSuppressed"(arg0: $Throwable$Type): $List<($Throwable)>
public "addSuppressed"(arg0: $Throwable$Type, arg1: $Throwable$Type): void
public "getMatchResultNamedGroup"(arg0: $MatchResult$Type, arg1: string): $MatchGroup
public "defaultPlatformRandom"(): $Random
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformImplementations$Type = ($PlatformImplementations);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformImplementations_ = $PlatformImplementations$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$AbstractWebSocketConnection$Stats" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AbstractWebSocketConnection$Stats {

constructor()

public "getFillableErrorCount"(): long
public "getFillInterestedCount"(): long
public "getOnFillableCount"(): long
get "fillableErrorCount"(): long
get "fillInterestedCount"(): long
get "onFillableCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractWebSocketConnection$Stats$Type = ($AbstractWebSocketConnection$Stats);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractWebSocketConnection$Stats_ = $AbstractWebSocketConnection$Stats$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspConfigDescriptor" {
import {$TaglibDescriptor, $TaglibDescriptor$Type} from "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$TaglibDescriptor"
import {$JspPropertyGroupDescriptor, $JspPropertyGroupDescriptor$Type} from "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspPropertyGroupDescriptor"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $JspConfigDescriptor {

 "getTaglibs"(): $Collection<($TaglibDescriptor)>
 "getJspPropertyGroups"(): $Collection<($JspPropertyGroupDescriptor)>
}

export namespace $JspConfigDescriptor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JspConfigDescriptor$Type = ($JspConfigDescriptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JspConfigDescriptor_ = $JspConfigDescriptor$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$MultipartConfig" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $MultipartConfig extends $Annotation {

 "location"(): string
 "maxFileSize"(): long
 "maxRequestSize"(): long
 "fileSizeThreshold"(): integer
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $MultipartConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartConfig$Type = ($MultipartConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartConfig_ = $MultipartConfig$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$ChunkReader$ChunkReaderMode, $ChunkReader$ChunkReaderMode$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader$ChunkReaderMode"

export class $ChunkReader {
readonly "mode": $ChunkReader$ChunkReaderMode

constructor(arg0: integer, arg1: string, arg2: long, arg3: $ChunkReader$ChunkReaderMode$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isDone"(): boolean
public "setCrcCheck"(arg0: boolean): void
public "feedBytes"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "getChunkRaw"(): $ChunkRaw
get "done"(): boolean
set "crcCheck"(value: boolean)
get "chunkRaw"(): $ChunkRaw
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkReader$Type = ($ChunkReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkReader_ = $ChunkReader$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/unsigned/$UArraysKt___UArraysJvmKt" {
import {$UByte, $UByte$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UByte"
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$UShort, $UShort$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UShort"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"

export class $UArraysKt___UArraysJvmKt {

constructor()

public static "asList-GBYM_sE"(arg0: (byte)[]): $List<($UByte)>
public static "asList--ajY-9A"(arg0: (integer)[]): $List<($UInt)>
public static "asList-QwZRm1k"(arg0: (long)[]): $List<($ULong)>
public static "asList-rL5Bavg"(arg0: (short)[]): $List<($UShort)>
public static "binarySearch-EtDCXyQ"(arg0: (short)[], arg1: short, arg2: integer, arg3: integer): integer
public static "binarySearch-K6DWlUc"(arg0: (long)[], arg1: long, arg2: integer, arg3: integer): integer
public static "binarySearch-2fe2U9s"(arg0: (integer)[], arg1: integer, arg2: integer, arg3: integer): integer
public static "binarySearch-WpHrYlw"(arg0: (byte)[], arg1: byte, arg2: integer, arg3: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UArraysKt___UArraysJvmKt$Type = ($UArraysKt___UArraysJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UArraysKt___UArraysJvmKt_ = $UArraysKt___UArraysJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$FallbackThreadLocalRandom" {
import {$Random$Default, $Random$Default$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$AbstractPlatformRandom, $AbstractPlatformRandom$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$AbstractPlatformRandom"

export class $FallbackThreadLocalRandom extends $AbstractPlatformRandom {
static readonly "Default": $Random$Default

constructor()

public "getImpl"(): $Random
get "impl"(): $Random
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallbackThreadLocalRandom$Type = ($FallbackThreadLocalRandom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FallbackThreadLocalRandom_ = $FallbackThreadLocalRandom$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$TerminateException" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$FileSystemException, $FileSystemException$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileSystemException"

export class $TerminateException extends $FileSystemException {

constructor(arg0: $File$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerminateException$Type = ($TerminateException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TerminateException_ = $TerminateException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$UnreadableSessionDataException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $UnreadableSessionDataException extends $Exception {

constructor(arg0: string, arg1: $SessionContext$Type, arg2: $Throwable$Type)

public "getId"(): string
public "getSessionContext"(): $SessionContext
get "id"(): string
get "sessionContext"(): $SessionContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnreadableSessionDataException$Type = ($UnreadableSessionDataException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnreadableSessionDataException_ = $UnreadableSessionDataException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipHandler" {
import {$Deflater, $Deflater$Type} from "packages/java/util/zip/$Deflater"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HandlerWrapper, $HandlerWrapper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper"
import {$GzipFactory, $GzipFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipFactory"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $GzipHandler extends $HandlerWrapper implements $GzipFactory {
static readonly "GZIP": string
static readonly "DEFLATE": string
static readonly "DEFAULT_MIN_GZIP_SIZE": integer
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

/**
 * 
 * @deprecated
 */
public "getMethods"(): (string)[]
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "getDeflater"(arg0: $Request$Type, arg1: long): $Deflater
public "recycle"(arg0: $Deflater$Type): void
public "getCompressionLevel"(): integer
public "getExcludedMethods"(): (string)[]
public "getInflateBufferSize"(): integer
public "setExcludedAgentPatterns"(...arg0: (string)[]): void
public "setIncludedMimeTypes"(...arg0: (string)[]): void
public "getIncludedMethodList"(): string
public "addExcludedAgentPatterns"(...arg0: (string)[]): void
public "setInflateBufferSize"(arg0: integer): void
public "addExcludedMimeTypes"(...arg0: (string)[]): void
public "setExcludedMimeTypes"(...arg0: (string)[]): void
public "setIncludedAgentPatterns"(...arg0: (string)[]): void
public "setIncludedMethodList"(arg0: string): void
public "setExcludedMethodList"(arg0: string): void
public "getExcludedMethodList"(): string
public "getIncludedAgentPatterns"(): (string)[]
public "addIncludedMimeTypes"(...arg0: (string)[]): void
public "addIncludedAgentPatterns"(...arg0: (string)[]): void
public "getExcludedAgentPatterns"(): (string)[]
public "getExcludedMimeTypes"(): (string)[]
public "getIncludedMimeTypes"(): (string)[]
public "setDispatcherTypes"(arg0: $EnumSet$Type<($DispatcherType$Type)>): void
public "setDispatcherTypes"(...arg0: ($DispatcherType$Type)[]): void
public "setCompressionLevel"(arg0: integer): void
public "addExcludedMethods"(...arg0: (string)[]): void
public "getDispatcherTypes"(): $EnumSet<($DispatcherType)>
public "addExcludedPaths"(...arg0: (string)[]): void
public "getCheckGzExists"(): boolean
public "setSyncFlush"(arg0: boolean): void
public "isSyncFlush"(): boolean
public "getExcludedPaths"(): (string)[]
public "isMimeTypeGzipable"(arg0: string): boolean
public "addIncludedPaths"(...arg0: (string)[]): void
public "getIncludedPaths"(): (string)[]
public "addIncludedMethods"(...arg0: (string)[]): void
public "getMinGzipSize"(): integer
public "getIncludedMethods"(): (string)[]
public "setCheckGzExists"(arg0: boolean): void
public "setExcludedMethods"(...arg0: (string)[]): void
public "setExcludedPaths"(...arg0: (string)[]): void
public "setMinGzipSize"(arg0: integer): void
public "setIncludedMethods"(...arg0: (string)[]): void
public "setIncludedPaths"(...arg0: (string)[]): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "methods"(): (string)[]
get "compressionLevel"(): integer
get "excludedMethods"(): (string)[]
get "inflateBufferSize"(): integer
set "excludedAgentPatterns"(value: (string)[])
set "includedMimeTypes"(value: (string)[])
get "includedMethodList"(): string
set "inflateBufferSize"(value: integer)
set "excludedMimeTypes"(value: (string)[])
set "includedAgentPatterns"(value: (string)[])
set "includedMethodList"(value: string)
set "excludedMethodList"(value: string)
get "excludedMethodList"(): string
get "includedAgentPatterns"(): (string)[]
get "excludedAgentPatterns"(): (string)[]
get "excludedMimeTypes"(): (string)[]
get "includedMimeTypes"(): (string)[]
set "dispatcherTypes"(value: $EnumSet$Type<($DispatcherType$Type)>)
set "dispatcherTypes"(value: ($DispatcherType$Type)[])
set "compressionLevel"(value: integer)
get "dispatcherTypes"(): $EnumSet<($DispatcherType)>
get "checkGzExists"(): boolean
set "syncFlush"(value: boolean)
get "syncFlush"(): boolean
get "excludedPaths"(): (string)[]
get "includedPaths"(): (string)[]
get "minGzipSize"(): integer
get "includedMethods"(): (string)[]
set "checkGzExists"(value: boolean)
set "excludedMethods"(value: (string)[])
set "excludedPaths"(value: (string)[])
set "minGzipSize"(value: integer)
set "includedMethods"(value: (string)[])
set "includedPaths"(value: (string)[])
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GzipHandler$Type = ($GzipHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GzipHandler_ = $GzipHandler$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkPLTE" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkPLTE extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "getEntryRgb"(arg0: integer, arg1: (integer)[]): void
public "getEntryRgb"(arg0: integer, arg1: (integer)[], arg2: integer): void
public "setNentries"(arg0: integer): void
public "getNentries"(): integer
public "minBitDepth"(): integer
public "getEntry"(arg0: integer): integer
public "setEntry"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "nentries"(value: integer)
get "nentries"(): integer
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkPLTE$Type = ($PngChunkPLTE);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkPLTE_ = $PngChunkPLTE$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/route/$ServletRoutes" {
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"

export class $ServletRoutes {


public static "get"(): $Routes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRoutes$Type = ($ServletRoutes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRoutes_ = $ServletRoutes$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslHandshakeListener" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$SslHandshakeListener$Event, $SslHandshakeListener$Event$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslHandshakeListener$Event"

export interface $SslHandshakeListener extends $EventListener {

 "handshakeFailed"(arg0: $SslHandshakeListener$Event$Type, arg1: $Throwable$Type): void
 "handshakeSucceeded"(arg0: $SslHandshakeListener$Event$Type): void
}

export namespace $SslHandshakeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslHandshakeListener$Type = ($SslHandshakeListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslHandshakeListener_ = $SslHandshakeListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AllowSymLinkAliasChecker" {
import {$ContextHandler$AliasCheck, $ContextHandler$AliasCheck$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$AliasCheck"
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"

export class $AllowSymLinkAliasChecker implements $ContextHandler$AliasCheck {

constructor()

public "check"(arg0: string, arg1: $Resource$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllowSymLinkAliasChecker$Type = ($AllowSymLinkAliasChecker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AllowSymLinkAliasChecker_ = $AllowSymLinkAliasChecker$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ReverseOrderComparator" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export class $ReverseOrderComparator implements $Comparator<($Comparable<(any)>)> {
static readonly "INSTANCE": $ReverseOrderComparator


public "compare"(arg0: $Comparable$Type<(any)>, arg1: $Comparable$Type<(any)>): integer
public "reversed"(): $Comparator<($Comparable<(any)>)>
public "equals"(arg0: any): boolean
public static "reverseOrder"<T extends $Comparable<(any)>>(): $Comparator<($Comparable<(any)>)>
public static "comparing"<T, U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($Comparable<(any)>)>
public static "comparing"<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($Comparable<(any)>)>
public static "comparingInt"<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "comparingLong"<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "comparingDouble"<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "naturalOrder"<T extends $Comparable<(any)>>(): $Comparator<($Comparable<(any)>)>
public static "nullsFirst"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
public static "nullsLast"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($Comparable<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReverseOrderComparator$Type = ($ReverseOrderComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReverseOrderComparator_ = $ReverseOrderComparator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ModelAndView" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ModelAndView {

constructor(arg0: any, arg1: string)

public "getModel"(): any
public "getViewName"(): string
get "model"(): any
get "viewName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelAndView$Type = ($ModelAndView);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelAndView_ = $ModelAndView$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PngChunk$ChunkOrderingConstraint extends $Enum<($PngChunk$ChunkOrderingConstraint)> {
static readonly "NONE": $PngChunk$ChunkOrderingConstraint
static readonly "BEFORE_PLTE_AND_IDAT": $PngChunk$ChunkOrderingConstraint
static readonly "AFTER_PLTE_BEFORE_IDAT": $PngChunk$ChunkOrderingConstraint
static readonly "AFTER_PLTE_BEFORE_IDAT_PLTE_REQUIRED": $PngChunk$ChunkOrderingConstraint
static readonly "BEFORE_IDAT": $PngChunk$ChunkOrderingConstraint
static readonly "NA": $PngChunk$ChunkOrderingConstraint


public static "values"(): ($PngChunk$ChunkOrderingConstraint)[]
public static "valueOf"(arg0: string): $PngChunk$ChunkOrderingConstraint
public "mustGoBeforePLTE"(): boolean
public "mustGoBeforeIDAT"(): boolean
public "mustGoAfterPLTE"(): boolean
public "isOk"(arg0: integer, arg1: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunk$ChunkOrderingConstraint$Type = (("na") | ("before_plte_and_idat") | ("before_idat") | ("after_plte_before_idat_plte_required") | ("none") | ("after_plte_before_idat")) | ($PngChunk$ChunkOrderingConstraint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunk$ChunkOrderingConstraint_ = $PngChunk$ChunkOrderingConstraint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $KVariance extends $Enum<($KVariance)> {
static readonly "INVARIANT": $KVariance
static readonly "IN": $KVariance
static readonly "OUT": $KVariance


public static "values"(): ($KVariance)[]
public static "valueOf"(arg0: string): $KVariance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KVariance$Type = (("in") | ("invariant") | ("out")) | ($KVariance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KVariance_ = $KVariance$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$CustomErrorPages" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"

export class $CustomErrorPages {
static readonly "NOT_FOUND": string
static readonly "INTERNAL_ERROR": string


public "getDefaultFor"(arg0: integer): string
public static "getFor"(arg0: integer, arg1: $Request$Type, arg2: $Response$Type): any
public static "existsFor"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomErrorPages$Type = ($CustomErrorPages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomErrorPages_ = $CustomErrorPages$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$CookieCutter" {
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"

export class $CookieCutter {

constructor()

public "reset"(): void
public "addCookieField"(arg0: string): void
public "setCookies"(arg0: ($Cookie$Type)[]): void
public "getCookies"(): ($Cookie)[]
set "cookies"(value: ($Cookie$Type)[])
get "cookies"(): ($Cookie)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CookieCutter$Type = ($CookieCutter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CookieCutter_ = $CookieCutter$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export interface $HttpServletResponse extends $ServletResponse {

 "getHeader"(arg0: string): string
 "getHeaders"(arg0: string): $Collection<(string)>
 "sendError"(arg0: integer, arg1: string): void
 "sendError"(arg0: integer): void
 "setStatus"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "setStatus"(arg0: integer, arg1: string): void
 "getStatus"(): integer
 "addHeader"(arg0: string, arg1: string): void
 "setHeader"(arg0: string, arg1: string): void
 "sendRedirect"(arg0: string): void
 "setIntHeader"(arg0: string, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "encodeUrl"(arg0: string): string
 "encodeRedirectURL"(arg0: string): string
 "getHeaderNames"(): $Collection<(string)>
/**
 * 
 * @deprecated
 */
 "encodeRedirectUrl"(arg0: string): string
 "addCookie"(arg0: $Cookie$Type): void
 "containsHeader"(arg0: string): boolean
 "setTrailerFields"(arg0: $Supplier$Type<($Map$Type<(string), (string)>)>): void
 "getTrailerFields"(): $Supplier<($Map<(string), (string)>)>
 "setDateHeader"(arg0: string, arg1: long): void
 "addIntHeader"(arg0: string, arg1: integer): void
 "addDateHeader"(arg0: string, arg1: long): void
 "encodeURL"(arg0: string): string
 "reset"(): void
 "flushBuffer"(): void
 "getLocale"(): $Locale
 "setLocale"(arg0: $Locale$Type): void
 "getContentType"(): string
 "getOutputStream"(): $ServletOutputStream
 "setContentType"(arg0: string): void
 "setContentLength"(arg0: integer): void
 "getCharacterEncoding"(): string
 "setContentLengthLong"(arg0: long): void
 "setCharacterEncoding"(arg0: string): void
 "setBufferSize"(arg0: integer): void
 "getBufferSize"(): integer
 "getWriter"(): $PrintWriter
 "isCommitted"(): boolean
 "resetBuffer"(): void
}

export namespace $HttpServletResponse {
const SC_CONTINUE: integer
const SC_SWITCHING_PROTOCOLS: integer
const SC_OK: integer
const SC_CREATED: integer
const SC_ACCEPTED: integer
const SC_NON_AUTHORITATIVE_INFORMATION: integer
const SC_NO_CONTENT: integer
const SC_RESET_CONTENT: integer
const SC_PARTIAL_CONTENT: integer
const SC_MULTIPLE_CHOICES: integer
const SC_MOVED_PERMANENTLY: integer
const SC_MOVED_TEMPORARILY: integer
const SC_FOUND: integer
const SC_SEE_OTHER: integer
const SC_NOT_MODIFIED: integer
const SC_USE_PROXY: integer
const SC_TEMPORARY_REDIRECT: integer
const SC_BAD_REQUEST: integer
const SC_UNAUTHORIZED: integer
const SC_PAYMENT_REQUIRED: integer
const SC_FORBIDDEN: integer
const SC_NOT_FOUND: integer
const SC_METHOD_NOT_ALLOWED: integer
const SC_NOT_ACCEPTABLE: integer
const SC_PROXY_AUTHENTICATION_REQUIRED: integer
const SC_REQUEST_TIMEOUT: integer
const SC_CONFLICT: integer
const SC_GONE: integer
const SC_LENGTH_REQUIRED: integer
const SC_PRECONDITION_FAILED: integer
const SC_REQUEST_ENTITY_TOO_LARGE: integer
const SC_REQUEST_URI_TOO_LONG: integer
const SC_UNSUPPORTED_MEDIA_TYPE: integer
const SC_REQUESTED_RANGE_NOT_SATISFIABLE: integer
const SC_EXPECTATION_FAILED: integer
const SC_INTERNAL_SERVER_ERROR: integer
const SC_NOT_IMPLEMENTED: integer
const SC_BAD_GATEWAY: integer
const SC_SERVICE_UNAVAILABLE: integer
const SC_GATEWAY_TIMEOUT: integer
const SC_HTTP_VERSION_NOT_SUPPORTED: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpServletResponse$Type = ($HttpServletResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpServletResponse_ = $HttpServletResponse$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapWithDefault" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $MapWithDefault<K, V> extends $Map<(K), (V)>, $KMappedMarker {

 "getOrImplicitDefault"(arg0: K): V
 "getMap"(): $Map<(K), (V)>
 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "equals"(arg0: any): boolean
 "values"(): $Collection<(V)>
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "keySet"(): $Set<(K)>
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
}

export namespace $MapWithDefault {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapWithDefault$Type<K, V> = ($MapWithDefault<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapWithDefault_<K, V> = $MapWithDefault$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Uptime" {
import {$Uptime$Impl, $Uptime$Impl$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Uptime$Impl"

export class $Uptime {
static readonly "NOIMPL": integer


public static "getInstance"(): $Uptime
public "getImpl"(): $Uptime$Impl
public "setImpl"(arg0: $Uptime$Impl$Type): void
public static "getUptime"(): long
get "instance"(): $Uptime
get "impl"(): $Uptime$Impl
set "impl"(value: $Uptime$Impl$Type)
get "uptime"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Uptime$Type = ($Uptime);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Uptime_ = $Uptime$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnectionFactory" {
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SslContextFactory, $SslContextFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $AbstractConnectionFactory extends $ContainerLifeCycle implements $ConnectionFactory {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener


public "toString"(): string
public "getProtocol"(): string
public "setInputBufferSize"(arg0: integer): void
public "getProtocols"(): $List<(string)>
public static "getFactories"(arg0: $SslContextFactory$Type, ...arg1: ($ConnectionFactory$Type)[]): ($ConnectionFactory)[]
public "getInputBufferSize"(): integer
public "newConnection"(arg0: $Connector$Type, arg1: $EndPoint$Type): $Connection
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "protocol"(): string
set "inputBufferSize"(value: integer)
get "protocols"(): $List<(string)>
get "inputBufferSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractConnectionFactory$Type = ($AbstractConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractConnectionFactory_ = $AbstractConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeReference$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $TypeReference$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeReference$Companion$Type = ($TypeReference$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeReference$Companion_ = $TypeReference$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$NOPLoggerFactory" {
import {$ILoggerFactory, $ILoggerFactory$Type} from "packages/info/journeymap/shaded/org/slf4j/$ILoggerFactory"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export class $NOPLoggerFactory implements $ILoggerFactory {

constructor()

public "getLogger"(arg0: string): $Logger
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NOPLoggerFactory$Type = ($NOPLoggerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NOPLoggerFactory_ = $NOPLoggerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$SessionTrackingMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SessionTrackingMode extends $Enum<($SessionTrackingMode)> {
static readonly "COOKIE": $SessionTrackingMode
static readonly "URL": $SessionTrackingMode
static readonly "SSL": $SessionTrackingMode


public static "values"(): ($SessionTrackingMode)[]
public static "valueOf"(arg0: string): $SessionTrackingMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionTrackingMode$Type = (("cookie") | ("ssl") | ("url")) | ($SessionTrackingMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionTrackingMode_ = $SessionTrackingMode$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeParameterReference" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$KVariance, $KVariance$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance"
import {$TypeParameterReference$Companion, $TypeParameterReference$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeParameterReference$Companion"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"

export class $TypeParameterReference implements $KTypeParameter {
static readonly "Companion": $TypeParameterReference$Companion

constructor(arg0: any, arg1: string, arg2: $KVariance$Type, arg3: boolean)

public "getName"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isReified"(): boolean
public "setUpperBounds"(arg0: $List$Type<(any)>): void
public "getVariance"(): $KVariance
public "getUpperBounds"(): $List<($KType)>
get "name"(): string
get "reified"(): boolean
set "upperBounds"(value: $List$Type<(any)>)
get "variance"(): $KVariance
get "upperBounds"(): $List<($KType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeParameterReference$Type = ($TypeParameterReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeParameterReference_ = $TypeParameterReference$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$SimpleBinaryMessage" {
import {$EventDriver, $EventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$EventDriver"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageAppender, $MessageAppender$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageAppender"

export class $SimpleBinaryMessage implements $MessageAppender {

constructor(arg0: $EventDriver$Type)

public "messageComplete"(): void
public "appendFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleBinaryMessage$Type = ($SimpleBinaryMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleBinaryMessage_ = $SimpleBinaryMessage$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DistinctIterator" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$AbstractIterator, $AbstractIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $DistinctIterator<T, K> extends $AbstractIterator<(T)> {

constructor(arg0: $Iterator$Type<(any)>, arg1: $Function1$Type<(any), (any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DistinctIterator$Type<T, K> = ($DistinctIterator<(T), (K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DistinctIterator_<T, K> = $DistinctIterator$Type<(T), (K)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkCHRM" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkCHRM extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setChromaticities"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): void
public "getChromaticities"(): (double)[]
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "chromaticities"(): (double)[]
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkCHRM$Type = ($PngChunkCHRM);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkCHRM_ = $PngChunkCHRM$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"

export interface $ClosedRange<T extends $Comparable<(any)>> {

 "isEmpty"(): boolean
 "contains"(arg0: T): boolean
 "getEndInclusive"(): T
 "getStart"(): T
}

export namespace $ClosedRange {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClosedRange$Type<T> = ($ClosedRange<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClosedRange_<T> = $ClosedRange$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty<V> extends $KCallable<(V)> {

 "isLateinit"(): boolean
 "isConst"(): boolean
 "getGetter"(): $KProperty$Getter<(V)>
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty$Type<V> = ($KProperty<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty_<V> = $KProperty$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayIntIterator" {
import {$IntIterator, $IntIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IntIterator"

export class $ArrayIntIterator extends $IntIterator {

constructor(arg0: (integer)[])

public "hasNext"(): boolean
public "nextInt"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayIntIterator$Type = ($ArrayIntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayIntIterator_ = $ArrayIntIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"

export interface $OutgoingFrames {

 "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void

(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
}

export namespace $OutgoingFrames {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutgoingFrames$Type = ($OutgoingFrames);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutgoingFrames_ = $OutgoingFrames$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IteratorsKt" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$CollectionsKt__IteratorsJVMKt, $CollectionsKt__IteratorsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IteratorsJVMKt"

export class $CollectionsKt__IteratorsKt extends $CollectionsKt__IteratorsJVMKt {

constructor()

public static "forEach"<T>(arg0: $Iterator$Type<(any)>, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "withIndex"<T>(arg0: $Iterator$Type<(any)>): $Iterator<($IndexedValue<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__IteratorsKt$Type = ($CollectionsKt__IteratorsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__IteratorsKt_ = $CollectionsKt__IteratorsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$PathMap" {
import {$PathMap$MappedEntry, $PathMap$MappedEntry$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$PathMap$MappedEntry"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

/**
 * 
 * @deprecated
 */
export class $PathMap<O> extends $HashMap<(string), (O)> {

constructor(arg0: $Map$Type<(string), (any)>)
constructor(arg0: integer)
constructor(arg0: boolean)
constructor()

public "remove"(arg0: any): O
public "put"(arg0: string, arg1: O): O
public "clear"(): void
public static "match"(arg0: string, arg1: string, arg2: boolean): boolean
public "match"(arg0: string): O
public static "match"(arg0: string, arg1: string): boolean
public static "pathInfo"(arg0: string, arg1: string): string
public static "relativePath"(arg0: string, arg1: string, arg2: string): string
public "getMatches"(arg0: string): $List<(any)>
public "getMatch"(arg0: string): $PathMap$MappedEntry<(O)>
public "containsMatch"(arg0: string): boolean
public static "pathMatch"(arg0: string, arg1: string): string
public static "setPathSpecSeparators"(arg0: string): void
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
set "pathSpecSeparators"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathMap$Type<O> = ($PathMap<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathMap_<O> = $PathMap$Type<(O)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UInt$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $UInt$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt$Companion$Type = ($UInt$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt$Companion_ = $UInt$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$MappedWebSocketCreator" {
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"
import {$PathSpec as $PathSpec$0, $PathSpec$Type as $PathSpec$0$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"

export interface $MappedWebSocketCreator {

 "removeMapping"(arg0: string): boolean
 "addMapping"(arg0: string, arg1: $WebSocketCreator$Type): void
 "addMapping"(arg0: $PathSpec$Type, arg1: $WebSocketCreator$Type): void
/**
 * 
 * @deprecated
 */
 "addMapping"(arg0: $PathSpec$0$Type, arg1: $WebSocketCreator$Type): void
 "getMapping"(arg0: string): $WebSocketCreator
}

export namespace $MappedWebSocketCreator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MappedWebSocketCreator$Type = ($MappedWebSocketCreator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MappedWebSocketCreator_ = $MappedWebSocketCreator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgression" {
import {$UIntProgression$Companion, $UIntProgression$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgression$Companion"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $UIntProgression implements $Iterable<($UInt)>, $KMappedMarker {
static readonly "Companion": $UIntProgression$Companion

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $DefaultConstructorMarker$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($UInt)>
public "getStep"(): integer
public "getLast-pVg5ArA"(): integer
public "getFirst-pVg5ArA"(): integer
public "spliterator"(): $Spliterator<($UInt)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$UInt>;
get "empty"(): boolean
get "step"(): integer
get "last-pVg5ArA"(): integer
get "first-pVg5ArA"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntProgression$Type = ($UIntProgression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntProgression_ = $UIntProgression$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestAttributeEvent" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletRequestEvent, $ServletRequestEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequestEvent"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export class $ServletRequestAttributeEvent extends $ServletRequestEvent {

constructor(arg0: $ServletContext$Type, arg1: $ServletRequest$Type, arg2: string, arg3: any)

public "getName"(): string
public "getValue"(): any
get "name"(): string
get "value"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletRequestAttributeEvent$Type = ($ServletRequestAttributeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletRequestAttributeEvent_ = $ServletRequestAttributeEvent$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$RequiresOptIn" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$RequiresOptIn$Level, $RequiresOptIn$Level$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$RequiresOptIn$Level"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $RequiresOptIn extends $Annotation {

 "message"(): string
 "level"(): $RequiresOptIn$Level
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $RequiresOptIn {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequiresOptIn$Type = ($RequiresOptIn);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequiresOptIn_ = $RequiresOptIn$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractNetworkConnector" {
import {$AbstractConnector, $AbstractConnector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnector"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$NetworkConnector, $NetworkConnector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$NetworkConnector"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $AbstractNetworkConnector extends $AbstractConnector implements $NetworkConnector {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Server$Type, arg1: $Executor$Type, arg2: $Scheduler$Type, arg3: $ByteBufferPool$Type, arg4: integer, ...arg5: ($ConnectionFactory$Type)[])

public "shutdown"(): $Future<(void)>
public "toString"(): string
public "close"(): void
public "open"(): void
public "getHost"(): string
public "getPort"(): integer
public "getLocalPort"(): integer
public "setPort"(arg0: integer): void
public "setHost"(arg0: string): void
public "isOpen"(): boolean
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "host"(): string
get "port"(): integer
get "localPort"(): integer
set "port"(value: integer)
set "host"(value: string)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractNetworkConnector$Type = ($AbstractNetworkConnector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractNetworkConnector_ = $AbstractNetworkConnector$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$UriTemplatePathSpec" {
import {$RegexPathSpec, $RegexPathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$RegexPathSpec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UriTemplatePathSpec extends $RegexPathSpec {

constructor(arg0: string)

public "getPathParams"(arg0: string): $Map<(string), (string)>
public "getVariableCount"(): integer
public "getVariables"(): (string)[]
get "variableCount"(): integer
get "variables"(): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UriTemplatePathSpec$Type = ($UriTemplatePathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UriTemplatePathSpec_ = $UriTemplatePathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$ConnectionFactory" {
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"

export interface $HttpConfiguration$ConnectionFactory {

 "getHttpConfiguration"(): $HttpConfiguration

(): $HttpConfiguration
}

export namespace $HttpConfiguration$ConnectionFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConfiguration$ConnectionFactory$Type = ($HttpConfiguration$ConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConfiguration$ConnectionFactory_ = $HttpConfiguration$ConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$Http1FieldPreEncoder" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpFieldPreEncoder, $HttpFieldPreEncoder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFieldPreEncoder"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"

export class $Http1FieldPreEncoder implements $HttpFieldPreEncoder {

constructor()

public "getEncodedField"(arg0: $HttpHeader$Type, arg1: string, arg2: string): (byte)[]
public "getHttpVersion"(): $HttpVersion
get "httpVersion"(): $HttpVersion
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Http1FieldPreEncoder$Type = ($Http1FieldPreEncoder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Http1FieldPreEncoder_ = $Http1FieldPreEncoder$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatRange" {
import {$ClosedFloatingPointRange, $ClosedFloatingPointRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatingPointRange"

export class $ClosedFloatRange implements $ClosedFloatingPointRange<(float)> {

constructor(arg0: float, arg1: float)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: float): boolean
public "lessThanOrEquals"(arg0: float, arg1: float): boolean
public "getStart"(): float
get "empty"(): boolean
get "start"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClosedFloatRange$Type = ($ClosedFloatRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClosedFloatRange_ = $ClosedFloatRange$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletSecurityElement" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$HttpMethodConstraintElement, $HttpMethodConstraintElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$HttpMethodConstraintElement"
import {$ServletSecurity, $ServletSecurity$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity"
import {$HttpConstraintElement, $HttpConstraintElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$HttpConstraintElement"

export class $ServletSecurityElement extends $HttpConstraintElement {

constructor(arg0: $HttpConstraintElement$Type, arg1: $Collection$Type<($HttpMethodConstraintElement$Type)>)
constructor(arg0: $ServletSecurity$Type)
constructor()
constructor(arg0: $HttpConstraintElement$Type)
constructor(arg0: $Collection$Type<($HttpMethodConstraintElement$Type)>)

public "getMethodNames"(): $Collection<(string)>
public "getHttpMethodConstraints"(): $Collection<($HttpMethodConstraintElement)>
get "methodNames"(): $Collection<(string)>
get "httpMethodConstraints"(): $Collection<($HttpMethodConstraintElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletSecurityElement$Type = ($ServletSecurityElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletSecurityElement_ = $ServletSecurityElement$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $Random$Default extends $Random implements $Serializable {
static readonly "Default": $Random$Default

constructor(arg0: $DefaultConstructorMarker$Type)

public "nextDouble"(arg0: double): double
public "nextDouble"(arg0: double, arg1: double): double
public "nextDouble"(): double
public "nextInt"(): integer
public "nextInt"(arg0: integer): integer
public "nextInt"(arg0: integer, arg1: integer): integer
public "nextBytes"(arg0: (byte)[]): (byte)[]
public "nextBytes"(arg0: integer): (byte)[]
public "nextBytes"(arg0: (byte)[], arg1: integer, arg2: integer): (byte)[]
public "nextLong"(arg0: long): long
public "nextLong"(): long
public "nextLong"(arg0: long, arg1: long): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public "nextBits"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Random$Default$Type = ($Random$Default);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Random$Default_ = $Random$Default$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapWithDefaultImpl" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapWithDefault, $MapWithDefault$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapWithDefault"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapWithDefaultImpl<K, V> implements $MapWithDefault<(K), (V)> {

constructor(arg0: $Map$Type<(K), (any)>, arg1: $Function1$Type<(any), (any)>)

public "getOrImplicitDefault"(arg0: K): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $Collection<(V)>
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(K)>
public "containsValue"(arg0: any): boolean
public "getSize"(): integer
public "getEntries"(): $Set<($Map$Entry<(K), (V)>)>
public "getMap"(): $Map<(K), (V)>
public "getKeys"(): $Set<(K)>
public "getValues"(): $Collection<(V)>
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
get "entries"(): $Set<($Map$Entry<(K), (V)>)>
get "map"(): $Map<(K), (V)>
get "keys"(): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapWithDefaultImpl$Type<K, V> = ($MapWithDefaultImpl<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapWithDefaultImpl_<K, V> = $MapWithDefaultImpl$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$ContinuationInterceptor" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$ContinuationInterceptor$Key, $ContinuationInterceptor$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$ContinuationInterceptor$Key"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export interface $ContinuationInterceptor extends $CoroutineContext$Element {

 "get"<E extends $CoroutineContext$Element>(arg0: $CoroutineContext$Key$Type<(E)>): E
 "minusKey"(arg0: $CoroutineContext$Key$Type<(any)>): $CoroutineContext
 "interceptContinuation"<T>(arg0: $Continuation$Type<(any)>): $Continuation<(T)>
 "releaseInterceptedContinuation"(arg0: $Continuation$Type<(any)>): void
 "getKey"(): $CoroutineContext$Key<(any)>
 "fold"<R>(arg0: R, arg1: $Function2$Type<(any), (any), (any)>): R
 "plus"(arg0: $CoroutineContext$Type): $CoroutineContext
}

export namespace $ContinuationInterceptor {
const Key: $ContinuationInterceptor$Key
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinuationInterceptor$Type = ($ContinuationInterceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinuationInterceptor_ = $ContinuationInterceptor$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslSelectionDump" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"

export class $SslSelectionDump extends $ContainerLifeCycle implements $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: string, arg1: (string)[], arg2: (string)[], arg3: (string)[], arg4: (string)[])

public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslSelectionDump$Type = ($SslSelectionDump);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslSelectionDump_ = $SslSelectionDump$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$IOState$ConnectionStateListener, $IOState$ConnectionStateListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState$ConnectionStateListener"
import {$ConnectionState, $ConnectionState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$ConnectionState"
import {$CloseInfo, $CloseInfo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo"

export class $IOState {

constructor()

public "wasLocalCloseInitiated"(): boolean
public "wasRemoteCloseInitiated"(): boolean
public "toString"(): string
public "isOpen"(): boolean
public "isClosed"(): boolean
public "addListener"(arg0: $IOState$ConnectionStateListener$Type): void
public "getConnectionState"(): $ConnectionState
public "onCloseRemote"(arg0: $CloseInfo$Type): void
public "getCloseInfo"(): $CloseInfo
public "assertInputOpen"(): void
public "isInputAvailable"(): boolean
public "assertOutputOpen"(): void
public "isOutputAvailable"(): boolean
public "onCloseLocal"(arg0: $CloseInfo$Type): void
public "onReadFailure"(arg0: $Throwable$Type): void
public "onOpened"(): void
public "onAbnormalClose"(arg0: $CloseInfo$Type): void
public "onFailedUpgrade"(): void
public "onDisconnected"(): void
public "wasCleanClose"(): boolean
public "onWriteFailure"(arg0: $Throwable$Type): void
public "wasAbnormalClose"(): boolean
public "onConnected"(): void
get "open"(): boolean
get "closed"(): boolean
get "connectionState"(): $ConnectionState
get "closeInfo"(): $CloseInfo
get "inputAvailable"(): boolean
get "outputAvailable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOState$Type = ($IOState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOState_ = $IOState$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServerFactory" {
import {$EmbeddedServer, $EmbeddedServer$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServer"
import {$StaticFilesConfiguration, $StaticFilesConfiguration$Type} from "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesConfiguration"
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"

export interface $EmbeddedServerFactory {

 "create"(arg0: $Routes$Type, arg1: $StaticFilesConfiguration$Type, arg2: boolean): $EmbeddedServer

(arg0: $Routes$Type, arg1: $StaticFilesConfiguration$Type, arg2: boolean): $EmbeddedServer
}

export namespace $EmbeddedServerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedServerFactory$Type = ($EmbeddedServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedServerFactory_ = $EmbeddedServerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$TuplesKt" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Triple, $Triple$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Triple"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"

export class $TuplesKt {


public static "toList"<T>(arg0: $Pair$Type<(any), (any)>): $List<(T)>
public static "toList"<T>(arg0: $Triple$Type<(any), (any), (any)>): $List<(T)>
public static "to"<A, B>(arg0: A, arg1: B): $Pair<(A), (B)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TuplesKt$Type = ($TuplesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TuplesKt_ = $TuplesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionCache" {
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$Session"
import {$SessionDataStore, $SessionDataStore$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStore"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export interface $SessionCache extends $LifeCycle {

 "shutdown"(): void
 "get"(arg0: string): $Session
 "put"(arg0: string, arg1: $Session$Type): void
 "contains"(arg0: string): boolean
 "initialize"(arg0: $SessionContext$Type): void
 "delete"(arg0: string): $Session
 "exists"(arg0: string): boolean
 "getSessionHandler"(): $SessionHandler
 "renewSessionId"(arg0: string, arg1: string): $Session
 "newSession"(arg0: $HttpServletRequest$Type, arg1: string, arg2: long, arg3: long): $Session
 "newSession"(arg0: $SessionData$Type): $Session
 "setSaveOnCreate"(arg0: boolean): void
 "getEvictionPolicy"(): integer
 "isSaveOnCreate"(): boolean
 "setEvictionPolicy"(arg0: integer): void
 "checkExpiration"(arg0: $Set$Type<(string)>): $Set<(string)>
 "setRemoveUnloadableSessions"(arg0: boolean): void
 "checkInactiveSession"(arg0: $Session$Type): void
 "isRemoveUnloadableSessions"(): boolean
 "isSaveOnInactiveEviction"(): boolean
 "getSessionDataStore"(): $SessionDataStore
 "setSessionDataStore"(arg0: $SessionDataStore$Type): void
 "setSaveOnInactiveEviction"(arg0: boolean): void
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $SessionCache {
const NEVER_EVICT: integer
const EVICT_ON_SESSION_EXIT: integer
const EVICT_ON_INACTIVITY: integer
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionCache$Type = ($SessionCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionCache_ = $SessionCache$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation" {
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"

export interface $Continuation<T> {

 "getContext"(): $CoroutineContext
 "resumeWith"(arg0: any): void
}

export namespace $Continuation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Continuation$Type<T> = ($Continuation<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Continuation_<T> = $Continuation$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$MessageTooLargeException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CloseException, $CloseException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseException"

export class $MessageTooLargeException extends $CloseException {

constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageTooLargeException$Type = ($MessageTooLargeException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageTooLargeException_ = $MessageTooLargeException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$RegexSet" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractSet, $AbstractSet$Type} from "packages/java/util/$AbstractSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $RegexSet extends $AbstractSet<(string)> implements $Predicate<(string)> {

constructor()

public "add"(arg0: string): boolean
public "remove"(arg0: any): boolean
public "test"(arg0: string): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "matches"(arg0: string): boolean
public "size"(): integer
public "iterator"(): $Iterator<(string)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public "negate"(): $Predicate<(string)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
public static "isEqual"<T>(arg0: any): $Predicate<(string)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexSet$Type = ($RegexSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexSet_ = $RegexSet$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgression" {
import {$ULong, $ULong$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ULong"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ULongProgression$Companion, $ULongProgression$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgression$Companion"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $ULongProgression implements $Iterable<($ULong)>, $KMappedMarker {
static readonly "Companion": $ULongProgression$Companion

constructor(arg0: long, arg1: long, arg2: long, arg3: $DefaultConstructorMarker$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($ULong)>
public "getFirst-s-VKNKU"(): long
public "getLast-s-VKNKU"(): long
public "getStep"(): long
public "spliterator"(): $Spliterator<($ULong)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ULong>;
get "empty"(): boolean
get "first-s-VKNKU"(): long
get "last-s-VKNKU"(): long
get "step"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongProgression$Type = ($ULongProgression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongProgression_ = $ULongProgression$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$Registration" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Registration {

 "getInitParameter"(arg0: string): string
 "setInitParameter"(arg0: string, arg1: string): boolean
 "getInitParameters"(): $Map<(string), (string)>
 "setInitParameters"(arg0: $Map$Type<(string), (string)>): $Set<(string)>
 "getName"(): string
 "getClassName"(): string
}

export namespace $Registration {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Registration$Type = ($Registration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Registration_ = $Registration$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$CompressedContentFormat" {
import {$PreEncodedHttpField, $PreEncodedHttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$PreEncodedHttpField"

export class $CompressedContentFormat {
static readonly "GZIP": $CompressedContentFormat
static readonly "BR": $CompressedContentFormat
static readonly "NONE": ($CompressedContentFormat)[]
readonly "_encoding": string
readonly "_extension": string
readonly "_etag": string
readonly "_etagQuote": string
readonly "_contentEncoding": $PreEncodedHttpField

constructor(arg0: string, arg1: string)

public "equals"(arg0: any): boolean
public static "tagEquals"(arg0: string, arg1: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompressedContentFormat$Type = ($CompressedContentFormat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompressedContentFormat_ = $CompressedContentFormat$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$SharedBlockingCallback$Blocker" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $SharedBlockingCallback$Blocker implements $Callback, $Closeable {


public "toString"(): string
public "close"(): void
public "getInvocationType"(): $Invocable$InvocationType
public "block"(): void
public "succeeded"(): void
public "failed"(arg0: $Throwable$Type): void
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "invocationType"(): $Invocable$InvocationType
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SharedBlockingCallback$Blocker$Type = ($SharedBlockingCallback$Blocker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SharedBlockingCallback$Blocker_ = $SharedBlockingCallback$Blocker$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/serialization/$InputStreamSerializer" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Serializer, $Serializer$Type} from "packages/info/journeymap/shaded/kotlin/spark/serialization/$Serializer"

export class $InputStreamSerializer extends $Serializer {


public "process"(arg0: $OutputStream$Type, arg1: any): void
public "canProcess"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputStreamSerializer$Type = ($InputStreamSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputStreamSerializer_ = $InputStreamSerializer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$FlagEnum" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FlagEnum {

 "getValue"(): integer
 "getMask"(): integer
}

export namespace $FlagEnum {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlagEnum$Type = ($FlagEnum);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlagEnum_ = $FlagEnum$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$X509" {
import {$X509Certificate, $X509Certificate$Type} from "packages/java/security/cert/$X509Certificate"
import {$Set, $Set$Type} from "packages/java/util/$Set"

export class $X509 {

constructor(arg0: string, arg1: $X509Certificate$Type)

public "toString"(): string
public "matches"(arg0: string): boolean
public "getCertificate"(): $X509Certificate
public "getAlias"(): string
public "getWilds"(): $Set<(string)>
public "getHosts"(): $Set<(string)>
public static "isCertSign"(arg0: $X509Certificate$Type): boolean
get "certificate"(): $X509Certificate
get "alias"(): string
get "wilds"(): $Set<(string)>
get "hosts"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $X509$Type = ($X509);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $X509_ = $X509$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayLongIterator" {
import {$LongIterator, $LongIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$LongIterator"

export class $ArrayLongIterator extends $LongIterator {

constructor(arg0: (long)[])

public "hasNext"(): boolean
public "nextLong"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayLongIterator$Type = ($ArrayLongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayLongIterator_ = $ArrayLongIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedMap" {
import {$SerializedMap$Companion, $SerializedMap$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$SerializedMap$Companion"
import {$Externalizable, $Externalizable$Type} from "packages/java/io/$Externalizable"
import {$ObjectOutput, $ObjectOutput$Type} from "packages/java/io/$ObjectOutput"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ObjectInput, $ObjectInput$Type} from "packages/java/io/$ObjectInput"

export class $SerializedMap implements $Externalizable {
static readonly "Companion": $SerializedMap$Companion

constructor(arg0: $Map$Type<(any), (any)>)
constructor()

public "writeExternal"(arg0: $ObjectOutput$Type): void
public "readExternal"(arg0: $ObjectInput$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializedMap$Type = ($SerializedMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializedMap_ = $SerializedMap$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Dispatcher" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$HttpURI, $HttpURI$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpURI"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"

export class $Dispatcher implements $RequestDispatcher {
static readonly "__ERROR_DISPATCH": string
static readonly "__INCLUDE_PREFIX": string
static readonly "__FORWARD_PREFIX": string

constructor(arg0: $ContextHandler$Type, arg1: $HttpURI$Type, arg2: string)
constructor(arg0: $ContextHandler$Type, arg1: string)

public "toString"(): string
public "error"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
public "include"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
public "forward"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Dispatcher$Type = ($Dispatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Dispatcher_ = $Dispatcher$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ImageInfo {
static readonly "MAX_COLS_ROW": integer
readonly "cols": integer
readonly "rows": integer
readonly "bitDepth": integer
readonly "channels": integer
readonly "alpha": boolean
readonly "greyscale": boolean
readonly "indexed": boolean
readonly "packed": boolean
readonly "bitspPixel": integer
readonly "bytesPixel": integer
readonly "bytesPerRow": integer
readonly "samplesPerRow": integer
readonly "samplesPerRowPacked": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: boolean)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean, arg5: boolean)

public "toStringDetail"(): string
public "getTotalPixels"(): long
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "toStringBrief"(): string
public "getTotalRawBytes"(): long
get "totalPixels"(): long
get "totalRawBytes"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageInfo$Type = ($ImageInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageInfo_ = $ImageInfo$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/$ILoggerFactory" {
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"

export interface $ILoggerFactory {

 "getLogger"(arg0: string): $Logger

(arg0: string): $Logger
}

export namespace $ILoggerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILoggerFactory$Type = ($ILoggerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILoggerFactory_ = $ILoggerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$SparkUtils" {
import {$List, $List$Type} from "packages/java/util/$List"

export class $SparkUtils {
static readonly "ALL_PATHS": string


public static "isParam"(arg0: string): boolean
public static "convertRouteToList"(arg0: string): $List<(string)>
public static "isSplat"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkUtils$Type = ($SparkUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkUtils_ = $SparkUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$CloseFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ControlFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $CloseFrame extends $ControlFrame {
static readonly "MAX_CONTROL_PAYLOAD": integer

constructor()

public "getType"(): $Frame$Type
public static "truncate"(arg0: string): string
get "type"(): $Frame$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseFrame$Type = ($CloseFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseFrame_ = $CloseFrame$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/util/$ReflectUtils" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $ReflectUtils {

constructor()

public static "toString"(arg0: $Class$Type<(any)>, arg1: $Method$Type): string
public static "toShortName"(arg0: $Type$Type): string
public static "trimClassName"(arg0: string): string
public static "isDefaultConstructable"(arg0: $Class$Type<(any)>): boolean
public static "findGenericClassFor"(arg0: $Class$Type<(any)>, arg1: $Class$Type<(any)>): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReflectUtils$Type = ($ReflectUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReflectUtils_ = $ReflectUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataStore" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$SessionContext, $SessionContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionContext"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SessionDataMap, $SessionDataMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionDataMap"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"

export interface $SessionDataStore extends $SessionDataMap {

 "exists"(arg0: string): boolean
 "isPassivating"(): boolean
 "getExpired"(arg0: $Set$Type<(string)>): $Set<(string)>
 "newSessionData"(arg0: string, arg1: long, arg2: long, arg3: long, arg4: long): $SessionData
 "load"(arg0: string): $SessionData
 "store"(arg0: string, arg1: $SessionData$Type): void
 "initialize"(arg0: $SessionContext$Type): void
 "delete"(arg0: string): boolean
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $SessionDataStore {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionDataStore$Type = ($SessionDataStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionDataStore_ = $SessionDataStore$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/extensions/$ExtensionStack" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$Extension, $Extension$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Extension"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$OutgoingFrames, $OutgoingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$OutgoingFrames"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ExtensionFactory, $ExtensionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$Generator, $Generator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Generator"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$Parser, $Parser$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Parser"

export class $ExtensionStack extends $ContainerLifeCycle implements $IncomingFrames, $OutgoingFrames {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $ExtensionFactory$Type)

public "incomingFrame"(arg0: $Frame$Type): void
public "getNextOutgoing"(): $OutgoingFrames
public "getNextIncoming"(): $IncomingFrames
public "incomingError"(arg0: $Throwable$Type): void
public "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
public "setNextIncoming"(arg0: $IncomingFrames$Type): void
public "setNextOutgoing"(arg0: $OutgoingFrames$Type): void
public "negotiate"(arg0: $List$Type<($ExtensionConfig$Type)>): void
public "toString"(): string
public "getExtensions"(): $List<($Extension)>
public "configure"(arg0: $Generator$Type): void
public "configure"(arg0: $Parser$Type): void
public "setPolicy"(arg0: $WebSocketPolicy$Type): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "hasNegotiatedExtensions"(): boolean
public "getNegotiatedExtensions"(): $List<($ExtensionConfig)>
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "nextOutgoing"(): $OutgoingFrames
get "nextIncoming"(): $IncomingFrames
set "nextIncoming"(value: $IncomingFrames$Type)
set "nextOutgoing"(value: $OutgoingFrames$Type)
get "extensions"(): $List<($Extension)>
set "policy"(value: $WebSocketPolicy$Type)
get "negotiatedExtensions"(): $List<($ExtensionConfig)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionStack$Type = ($ExtensionStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionStack_ = $ExtensionStack$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$Regex" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Regex$Companion, $Regex$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$Regex$Companion"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$RegexOption, $RegexOption$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$RegexOption"
import {$MatchResult, $MatchResult$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult"

export class $Regex implements $Serializable {
static readonly "Companion": $Regex$Companion

constructor(arg0: string, arg1: $Set$Type<(any)>)
constructor(arg0: string, arg1: $RegexOption$Type)
constructor(arg0: string)
constructor(arg0: $Pattern$Type)

public "toString"(): string
public "replace"(arg0: charseq, arg1: string): string
public "replace"(arg0: charseq, arg1: $Function1$Type<(any), (any)>): string
public "matches"(arg0: charseq): boolean
public "replaceFirst"(arg0: charseq, arg1: string): string
public "split"(arg0: charseq, arg1: integer): $List<(string)>
public "find"(arg0: charseq, arg1: integer): $MatchResult
public "findAll"(arg0: charseq, arg1: integer): $Sequence<($MatchResult)>
public "toPattern"(): $Pattern
public "getPattern"(): string
public "getOptions"(): $Set<($RegexOption)>
public "matchesAt"(arg0: charseq, arg1: integer): boolean
public "splitToSequence"(arg0: charseq, arg1: integer): $Sequence<(string)>
public "containsMatchIn"(arg0: charseq): boolean
public "matchAt"(arg0: charseq, arg1: integer): $MatchResult
public "matchEntire"(arg0: charseq): $MatchResult
get "pattern"(): string
get "options"(): $Set<($RegexOption)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Regex$Type = ($Regex);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Regex_ = $Regex$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageLineByte" {
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$IImageLineFactory, $IImageLineFactory$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineFactory"
import {$IImageLine, $IImageLine$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLine"
import {$IImageLineArray, $IImageLineArray$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IImageLineArray"

export class $ImageLineByte implements $IImageLine, $IImageLineArray {
readonly "imgInfo": $ImageInfo

constructor(arg0: $ImageInfo$Type)
constructor(arg0: $ImageInfo$Type, arg1: (byte)[])

public "toString"(): string
public static "getFactory"(arg0: $ImageInfo$Type): $IImageLineFactory<($ImageLineByte)>
public "getSize"(): integer
public "getElem"(arg0: integer): integer
public "getImageInfo"(): $ImageInfo
public "endReadFromPngRaw"(): void
public "readFromPngRaw"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): void
public "getFilterUsed"(): $FilterType
public "getScanlineByte"(): (byte)[]
public "writeToPngRaw"(arg0: (byte)[]): void
public "getScanlineByte2"(): (byte)[]
public "getScanline"(): (byte)[]
public "getFilterType"(): $FilterType
get "size"(): integer
get "imageInfo"(): $ImageInfo
get "filterUsed"(): $FilterType
get "scanlineByte"(): (byte)[]
get "scanlineByte2"(): (byte)[]
get "scanline"(): (byte)[]
get "filterType"(): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageLineByte$Type = ($ImageLineByte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageLineByte_ = $ImageLineByte$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/$Marker" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Marker extends $Serializable {

 "getName"(): string
 "add"(arg0: $Marker$Type): void
 "remove"(arg0: $Marker$Type): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "iterator"(): $Iterator<($Marker)>
 "contains"(arg0: string): boolean
 "contains"(arg0: $Marker$Type): boolean
 "hasChildren"(): boolean
 "hasReferences"(): boolean
}

export namespace $Marker {
const ANY_MARKER: string
const ANY_NON_NULL_MARKER: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Marker$Type = ($Marker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Marker_ = $Marker$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle" {
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"

export interface $LifeCycle {

 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $LifeCycle {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LifeCycle$Type = ($LifeCycle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LifeCycle_ = $LifeCycle$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$UpgradeTo" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $Connection$UpgradeTo {

 "onUpgradeTo"(arg0: $ByteBuffer$Type): void

(arg0: $ByteBuffer$Type): void
}

export namespace $Connection$UpgradeTo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Connection$UpgradeTo$Type = ($Connection$UpgradeTo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Connection$UpgradeTo_ = $Connection$UpgradeTo$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$JettyHandler" {
import {$SessionTrackingMode, $SessionTrackingMode$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionTrackingMode"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$SessionHandler, $SessionHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BigDecimal, $BigDecimal$Type} from "packages/java/math/$BigDecimal"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $JettyHandler extends $SessionHandler {
static readonly "DEFAULT_TRACKING": $EnumSet<($SessionTrackingMode)>
static readonly "__SessionCookieProperty": string
static readonly "__DefaultSessionCookie": string
static readonly "__SessionIdPathParameterNameProperty": string
static readonly "__DefaultSessionIdPathParameterName": string
static readonly "__CheckRemoteSessionEncoding": string
static readonly "__SessionDomainProperty": string
static readonly "__DefaultSessionDomain": string
static readonly "__SessionPathProperty": string
static readonly "__MaxAgeProperty": string
 "__defaultSessionTrackingModes": $Set<($SessionTrackingMode)>
static readonly "SESSION_LISTENER_TYPES": ($Class<(any)>)[]
static readonly "MAX_INACTIVE_MINUTES": $BigDecimal
 "_sessionTrackingModes": $Set<($SessionTrackingMode)>
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $Filter$Type)

public "doHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyHandler$Type = ($JettyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyHandler_ = $JettyHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/strategy/$EatWhatYouKill" {
import {$ExecutionStrategy$Producer, $ExecutionStrategy$Producer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ExecutionStrategy$Producer"
import {$ExecutionStrategy, $ExecutionStrategy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ExecutionStrategy"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $EatWhatYouKill extends $AbstractLifeCycle implements $ExecutionStrategy, $Runnable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $ExecutionStrategy$Producer$Type, arg1: $Executor$Type, arg2: $Invocable$InvocationType$Type, arg3: $Invocable$InvocationType$Type, arg4: integer)
constructor(arg0: $ExecutionStrategy$Producer$Type, arg1: $Executor$Type, arg2: $Invocable$InvocationType$Type, arg3: $Invocable$InvocationType$Type)
constructor(arg0: $ExecutionStrategy$Producer$Type, arg1: $Executor$Type, arg2: integer)
constructor(arg0: $ExecutionStrategy$Producer$Type, arg1: $Executor$Type)

public "run"(): void
public "dispatch"(): void
public "toString"(): string
public "produce"(): void
public "isIdle"(): boolean
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "idle"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EatWhatYouKill$Type = ($EatWhatYouKill);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EatWhatYouKill_ = $EatWhatYouKill$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt___CollectionsKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$Function3, $Function3$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Grouping, $Grouping$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$Grouping"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$CollectionsKt___CollectionsJvmKt, $CollectionsKt___CollectionsJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt___CollectionsJvmKt"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CollectionsKt___CollectionsKt extends $CollectionsKt___CollectionsJvmKt {

constructor()

public static "firstOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "firstOrNull"<T>(arg0: $Iterable$Type<(any)>): T
public static "firstOrNull"<T>(arg0: $List$Type<(any)>): T
public static "mapTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "reduceIndexedOrNull"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "runningReduceIndexed"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): $List<(S)>
public static "mapIndexedNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "indexOf"<T>(arg0: $Iterable$Type<(any)>, arg1: T): integer
public static "indexOf"<T>(arg0: $List$Type<(any)>, arg1: T): integer
public static "lastIndexOf"<T>(arg0: $List$Type<(any)>, arg1: T): integer
public static "lastIndexOf"<T>(arg0: $Iterable$Type<(any)>, arg1: T): integer
public static "map"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "toList"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "toCharArray"(arg0: $Collection$Type<(character)>): (character)[]
public static "count"<T>(arg0: $Iterable$Type<(any)>): integer
public static "count"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "contains"<T>(arg0: $Iterable$Type<(any)>, arg1: T): boolean
public static "last"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "last"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "last"<T>(arg0: $List$Type<(any)>): T
public static "last"<T>(arg0: $Iterable$Type<(any)>): T
public static "single"<T>(arg0: $List$Type<(any)>): T
public static "single"<T>(arg0: $Iterable$Type<(any)>): T
public static "single"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "filter"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "first"<T>(arg0: $List$Type<(any)>): T
public static "first"<T>(arg0: $Iterable$Type<(any)>): T
public static "first"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "flatMap"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "forEach"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "toSet"<T>(arg0: $Iterable$Type<(any)>): $Set<(T)>
public static "toByteArray"(arg0: $Collection$Type<(byte)>): (byte)[]
public static "reduce"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "elementAt"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): T
public static "slice"<T>(arg0: $List$Type<(any)>, arg1: $IntRange$Type): $List<(T)>
public static "slice"<T>(arg0: $List$Type<(any)>, arg1: $Iterable$Type<(integer)>): $List<(T)>
public static "reversed"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "distinct"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "random"<T>(arg0: $Collection$Type<(any)>, arg1: $Random$Type): T
public static "shuffle"<T>(arg0: $List$Type<(T)>, arg1: $Random$Type): void
public static "sorted"<T extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "scan"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "groupingBy"<T, K>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Grouping<(T), (K)>
public static "subtract"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "plus"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $List<(T)>
public static "plus"<T>(arg0: $Iterable$Type<(any)>, arg1: (T)[]): $List<(T)>
public static "plus"<T>(arg0: $Collection$Type<(any)>, arg1: (T)[]): $List<(T)>
public static "plus"<T>(arg0: $Collection$Type<(any)>, arg1: $Sequence$Type<(any)>): $List<(T)>
public static "plus"<T>(arg0: $Iterable$Type<(any)>, arg1: $Sequence$Type<(any)>): $List<(T)>
public static "plus"<T>(arg0: $Collection$Type<(any)>, arg1: $Iterable$Type<(any)>): $List<(T)>
public static "plus"<T>(arg0: $Iterable$Type<(any)>, arg1: T): $List<(T)>
public static "plus"<T>(arg0: $Collection$Type<(any)>, arg1: T): $List<(T)>
public static "drop"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): $List<(T)>
public static "toIntArray"(arg0: $Collection$Type<(integer)>): (integer)[]
public static "all"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "minus"<T>(arg0: $Iterable$Type<(any)>, arg1: T): $List<(T)>
public static "minus"<T>(arg0: $Iterable$Type<(any)>, arg1: (T)[]): $List<(T)>
public static "minus"<T>(arg0: $Iterable$Type<(any)>, arg1: $Sequence$Type<(any)>): $List<(T)>
public static "minus"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $List<(T)>
public static "take"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): $List<(T)>
public static "toCollection"<T, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C): C
public static "union"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "takeWhile"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "dropWhile"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "zip"<T, R, V>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<T, R, V>(arg0: $Iterable$Type<(any)>, arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<T, R>(arg0: $Iterable$Type<(any)>, arg1: (R)[]): $List<($Pair<(T), (R)>)>
public static "zip"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $List<($Pair<(T), (R)>)>
public static "any"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"<T>(arg0: $Iterable$Type<(any)>): boolean
public static "toLongArray"(arg0: $Collection$Type<(long)>): (long)[]
public static "toBooleanArray"(arg0: $Collection$Type<(boolean)>): (boolean)[]
public static "associate"<T, K, V>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "chunked"<T, R>(arg0: $Iterable$Type<(any)>, arg1: integer, arg2: $Function1$Type<(any), (any)>): $List<(R)>
public static "chunked"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): $List<($List<(T)>)>
public static "none"<T>(arg0: $Iterable$Type<(any)>): boolean
public static "none"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "partition"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(T)>), ($List<(T)>)>
public static "intersect"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "reduceRight"<S, T extends S>(arg0: $List$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "sortBy"<T, R extends $Comparable<(any)>>(arg0: $List$Type<(T)>, arg1: $Function1$Type<(any), (any)>): void
public static "getOrNull"<T>(arg0: $List$Type<(any)>, arg1: integer): T
public static "indexOfFirst"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "takeLast"<T>(arg0: $List$Type<(any)>, arg1: integer): $List<(T)>
public static "joinTo"<T, A extends $Appendable>(arg0: $Iterable$Type<(any)>, arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "toFloatArray"(arg0: $Collection$Type<(float)>): (float)[]
public static "toDoubleArray"(arg0: $Collection$Type<(double)>): (double)[]
public static "foldRightIndexed"<T, R>(arg0: $List$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "dropLast"<T>(arg0: $List$Type<(any)>, arg1: integer): $List<(T)>
public static "dropLastWhile"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "foldRight"<T, R>(arg0: $List$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "reduceRightIndexed"<S, T extends S>(arg0: $List$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceRightOrNull"<S, T extends S>(arg0: $List$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "takeLastWhile"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "randomOrNull"<T>(arg0: $Collection$Type<(any)>, arg1: $Random$Type): T
public static "asSequence"<T>(arg0: $Iterable$Type<(any)>): $Sequence<(T)>
public static "associateByTo"<T, K, M extends $Map<(any), (any)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "averageOfByte"(arg0: $Iterable$Type<(byte)>): double
public static "averageOfFloat"(arg0: $Iterable$Type<(float)>): double
public static "averageOfInt"(arg0: $Iterable$Type<(integer)>): double
public static "associateBy"<T, K>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (T)>
public static "associateBy"<T, K, V>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateWithTo"<K, V, M extends $Map<(any), (any)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "averageOfShort"(arg0: $Iterable$Type<(short)>): double
public static "averageOfLong"(arg0: $Iterable$Type<(long)>): double
public static "associateWith"<K, V>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "averageOfDouble"(arg0: $Iterable$Type<(double)>): double
public static "forEachIndexed"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "mapIndexed"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexedNotNull"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "elementAtOrElse"<T>(arg0: $Iterable$Type<(any)>, arg1: integer, arg2: $Function1$Type<(any), (any)>): T
public static "filterIndexed"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (boolean)>): $List<(T)>
public static "filterNot"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "distinctBy"<T, K>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "elementAtOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: integer): T
public static "filterNotNullTo"<C extends $Collection<(any)>, T>(arg0: $Iterable$Type<(any)>, arg1: C): C
public static "filterTo"<T, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "flatMapTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "filterIndexedTo"<T, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "groupBy"<T, K, V>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<T, K>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(T)>)>
public static "foldIndexed"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "groupByTo"<T, K, M extends $Map<(any), ($List<(T)>)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<T, K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: $Iterable$Type<(any)>, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "filterNotTo"<T, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "indexOfLast"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): integer
public static "joinToString"<T>(arg0: $Iterable$Type<(any)>, arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "minOrNull"(arg0: $Iterable$Type<(float)>): float
public static "mapNotNull"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "onEach"<T, C extends $Iterable<(any)>>(arg0: C, arg1: $Function1$Type<(any), ($Unit$Type)>): C
public static "onEachIndexed"<T, C extends $Iterable<(any)>>(arg0: C, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): C
public static "minByOrNull"<T, R extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): T
public static "reduceIndexed"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceOrNull"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): S
public static "maxWithOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: $Comparator$Type<(any)>): T
public static "minWithOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: $Comparator$Type<(any)>): T
public static "mapNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "maxOrNull"(arg0: $Iterable$Type<(float)>): float
public static "mapIndexedTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "maxByOrNull"<T, R extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): T
public static "sumOfLong"(arg0: $Iterable$Type<(long)>): long
public static "sortedBy"<T, R extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "sumOfDouble"(arg0: $Iterable$Type<(double)>): double
public static "runningFoldIndexed"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "requireNoNulls"<T>(arg0: $List$Type<(any)>): $List<(T)>
public static "requireNoNulls"<T>(arg0: $Iterable$Type<(any)>): $Iterable<(T)>
public static "singleOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "singleOrNull"<T>(arg0: $Iterable$Type<(any)>): T
public static "singleOrNull"<T>(arg0: $List$Type<(any)>): T
public static "sumBy"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (integer)>): integer
public static "sortedWith"<T>(arg0: $Iterable$Type<(any)>, arg1: $Comparator$Type<(any)>): $List<(T)>
public static "sumOfByte"(arg0: $Iterable$Type<(byte)>): integer
public static "sumOfShort"(arg0: $Iterable$Type<(short)>): integer
public static "scanIndexed"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "sumOfInt"(arg0: $Iterable$Type<(integer)>): integer
public static "toMutableSet"<T>(arg0: $Iterable$Type<(any)>): $Set<(T)>
public static "runningFold"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "sumByDouble"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (double)>): double
public static "zipWithNext"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "zipWithNext"<T>(arg0: $Iterable$Type<(any)>): $List<($Pair<(T), (T)>)>
public static "sortedByDescending"<T, R extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "runningReduce"<S, T extends S>(arg0: $Iterable$Type<(any)>, arg1: $Function2$Type<(any), (any), (any)>): $List<(S)>
public static "sortedDescending"<T extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "sumOfFloat"(arg0: $Iterable$Type<(float)>): float
public static "toHashSet"<T>(arg0: $Iterable$Type<(any)>): $HashSet<(T)>
public static "fold"<T, R>(arg0: $Iterable$Type<(any)>, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "sortDescending"<T extends $Comparable<(any)>>(arg0: $List$Type<(T)>): void
public static "windowed"<T>(arg0: $Iterable$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean): $List<($List<(T)>)>
public static "windowed"<T, R>(arg0: $Iterable$Type<(any)>, arg1: integer, arg2: integer, arg3: boolean, arg4: $Function1$Type<(any), (any)>): $List<(R)>
public static "toShortArray"(arg0: $Collection$Type<(short)>): (short)[]
public static "toMutableList"<T>(arg0: $Collection$Type<(any)>): $List<(T)>
public static "toMutableList"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "filterNotNull"<T>(arg0: $Iterable$Type<(any)>): $List<(T)>
public static "withIndex"<T>(arg0: $Iterable$Type<(any)>): $Iterable<($IndexedValue<(T)>)>
public static "flatMapSequenceTo"<T, R, C extends $Collection<(any)>>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapSequence"<T, R>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "sortByDescending"<T, R extends $Comparable<(any)>>(arg0: $List$Type<(T)>, arg1: $Function1$Type<(any), (any)>): void
public static "lastOrNull"<T>(arg0: $List$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "lastOrNull"<T>(arg0: $Iterable$Type<(any)>, arg1: $Function1$Type<(any), (boolean)>): T
public static "lastOrNull"<T>(arg0: $List$Type<(any)>): T
public static "lastOrNull"<T>(arg0: $Iterable$Type<(any)>): T
public static "reduceRightIndexedOrNull"<S, T extends S>(arg0: $List$Type<(any)>, arg1: $Function3$Type<(any), (any), (any), (any)>): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt___CollectionsKt$Type = ($CollectionsKt___CollectionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt___CollectionsKt_ = $CollectionsKt___CollectionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConnection" {
import {$HttpCompliance, $HttpCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$MetaData$Request, $MetaData$Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$HttpTransport, $HttpTransport$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpTransport"
import {$Connection$UpgradeFrom, $Connection$UpgradeFrom$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$UpgradeFrom"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$HttpGenerator, $HttpGenerator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$MetaData$Response, $MetaData$Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$HttpParser, $HttpParser$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser"
import {$AbstractConnection, $AbstractConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractConnection"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $HttpConnection extends $AbstractConnection implements $Runnable, $HttpTransport, $Connection$UpgradeFrom {
static readonly "CONNECTION_CLOSE": $HttpField
static readonly "UPGRADE_CONNECTION_ATTRIBUTE": string

constructor(arg0: $HttpConfiguration$Type, arg1: $Connector$Type, arg2: $EndPoint$Type, arg3: $HttpCompliance$Type, arg4: boolean)

public "run"(): void
public "push"(arg0: $MetaData$Request$Type): void
public "onClose"(): void
public "abort"(arg0: $Throwable$Type): void
public "toConnectionString"(): string
public "onUpgradeFrom"(): $ByteBuffer
public "getParser"(): $HttpParser
public "getGenerator"(): $HttpGenerator
public "onOpen"(): void
public "getServer"(): $Server
public "getHttpConfiguration"(): $HttpConfiguration
public "isOptimizedForDirectBuffers"(): boolean
public "asyncReadFillInterested"(): void
public "send"(arg0: $MetaData$Response$Type, arg1: boolean, arg2: $ByteBuffer$Type, arg3: boolean, arg4: $Callback$Type): void
public "onCompleted"(): void
public "isRecordHttpComplianceViolations"(): boolean
public "isRequestBufferEmpty"(): boolean
public static "getCurrentConnection"(): $HttpConnection
public "blockingReadFillInterested"(): void
public "blockingReadException"(arg0: $Throwable$Type): void
public "getConnector"(): $Connector
public "getHttpChannel"(): $HttpChannel
public "isPushSupported"(): boolean
public "getMessagesIn"(): long
public "getMessagesOut"(): long
public "getRequestBuffer"(): $ByteBuffer
public "onFillable"(): void
get "parser"(): $HttpParser
get "generator"(): $HttpGenerator
get "server"(): $Server
get "httpConfiguration"(): $HttpConfiguration
get "optimizedForDirectBuffers"(): boolean
get "recordHttpComplianceViolations"(): boolean
get "requestBufferEmpty"(): boolean
get "currentConnection"(): $HttpConnection
get "connector"(): $Connector
get "httpChannel"(): $HttpChannel
get "pushSupported"(): boolean
get "messagesIn"(): long
get "messagesOut"(): long
get "requestBuffer"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConnection$Type = ($HttpConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConnection_ = $HttpConnection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$WriteFlusher" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"

export class $WriteFlusher {


public "getCallbackInvocationType"(): $Invocable$InvocationType
public "toString"(): string
public "write"(arg0: $Callback$Type, ...arg1: ($ByteBuffer$Type)[]): void
public "onClose"(): void
public "onFail"(arg0: $Throwable$Type): boolean
public "toStateString"(): string
public "isInProgress"(): boolean
public "completeWrite"(): void
get "callbackInvocationType"(): $Invocable$InvocationType
get "inProgress"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WriteFlusher$Type = ($WriteFlusher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WriteFlusher_ = $WriteFlusher$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle$Managed" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ContainerLifeCycle$Managed extends $Enum<($ContainerLifeCycle$Managed)> {
static readonly "POJO": $ContainerLifeCycle$Managed
static readonly "MANAGED": $ContainerLifeCycle$Managed
static readonly "UNMANAGED": $ContainerLifeCycle$Managed
static readonly "AUTO": $ContainerLifeCycle$Managed


public static "values"(): ($ContainerLifeCycle$Managed)[]
public static "valueOf"(arg0: string): $ContainerLifeCycle$Managed
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerLifeCycle$Managed$Type = (("pojo") | ("auto") | ("managed") | ("unmanaged")) | ($ContainerLifeCycle$Managed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerLifeCycle$Managed_ = $ContainerLifeCycle$Managed$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/message/$MessageAppender" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $MessageAppender {

 "messageComplete"(): void
 "appendFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
}

export namespace $MessageAppender {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageAppender$Type = ($MessageAppender);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageAppender_ = $MessageAppender$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$WriteListener, $WriteListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$WriteListener"

export class $ServletOutputStream extends $OutputStream {


public "println"(arg0: integer): void
public "println"(arg0: character): void
public "println"(arg0: string): void
public "println"(): void
public "println"(arg0: long): void
public "println"(arg0: float): void
public "println"(arg0: double): void
public "println"(arg0: boolean): void
public "print"(arg0: integer): void
public "print"(arg0: character): void
public "print"(arg0: boolean): void
public "print"(arg0: string): void
public "print"(arg0: double): void
public "print"(arg0: float): void
public "print"(arg0: long): void
public "isReady"(): boolean
public "setWriteListener"(arg0: $WriteListener$Type): void
get "ready"(): boolean
set "writeListener"(value: $WriteListener$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletOutputStream$Type = ($ServletOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletOutputStream_ = $ServletOutputStream$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EofException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$QuietException, $QuietException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$QuietException"
import {$EOFException, $EOFException$Type} from "packages/java/io/$EOFException"

export class $EofException extends $EOFException implements $QuietException {

constructor()
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EofException$Type = ($EofException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EofException_ = $EofException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$EmptyMap" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmptyMap implements $Map<(any), (any)>, $Serializable, $KMappedMarker {
static readonly "INSTANCE": $EmptyMap


public "get"(arg0: any): void
public "put"(arg0: any, arg1: void): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $Collection<(any)>
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry)>
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(any)>
public "containsValue"(arg0: void): boolean
public "containsValue"(arg0: any): boolean
public "getSize"(): integer
public "getEntries"(): $Set<($Map$Entry)>
public "getKeys"(): $Set<(any)>
public "getValues"(): $Collection<(any)>
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(any), (any)>
public "replace"(arg0: any, arg1: any): any
public "replace"(arg0: any, arg1: any, arg2: any): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $Map<(any), (any)>
public static "of"<K, V>(): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any, arg16: any, arg17: any, arg18: any, arg19: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any, arg16: any, arg17: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any): $Map<(any), (any)>
public "merge"(arg0: any, arg1: any, arg2: $BiFunction$Type<(any), (any), (any)>): any
public "putIfAbsent"(arg0: any, arg1: any): any
public "compute"(arg0: any, arg1: $BiFunction$Type<(any), (any), (any)>): any
public static "entry"<K, V>(arg0: any, arg1: any): $Map$Entry<(any), (any)>
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: any, arg1: $Function$Type<(any), (any)>): any
public "getOrDefault"(arg0: any, arg1: any): any
public "computeIfPresent"(arg0: any, arg1: $BiFunction$Type<(any), (any), (any)>): any
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(any), (any)>
[index: string | number]: void
get "empty"(): boolean
get "entries"(): $Set<($Map$Entry)>
get "keys"(): $Set<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyMap$Type = ($EmptyMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyMap_ = $EmptyMap$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$AbstractPlatformRandom" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Random$Default, $Random$Default$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default"
import {$Random as $Random$0, $Random$Type as $Random$0$Type} from "packages/java/util/$Random"

export class $AbstractPlatformRandom extends $Random {
static readonly "Default": $Random$Default

constructor()

public "nextDouble"(): double
public "nextInt"(): integer
public "nextInt"(arg0: integer): integer
public "nextBytes"(arg0: (byte)[]): (byte)[]
public "getImpl"(): $Random$0
public "nextLong"(): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public "nextBits"(arg0: integer): integer
get "impl"(): $Random$0
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractPlatformRandom$Type = ($AbstractPlatformRandom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractPlatformRandom_ = $AbstractPlatformRandom$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$TemplateViewRoute" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$ModelAndView, $ModelAndView$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ModelAndView"

export interface $TemplateViewRoute {

 "handle"(arg0: $Request$Type, arg1: $Response$Type): $ModelAndView

(arg0: $Request$Type, arg1: $Response$Type): $ModelAndView
}

export namespace $TemplateViewRoute {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemplateViewRoute$Type = ($TemplateViewRoute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemplateViewRoute_ = $TemplateViewRoute$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$CollectionToArray" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $CollectionToArray {


public static "toArray"(arg0: $Collection$Type<(any)>): (any)[]
public static "toArray"(arg0: $Collection$Type<(any)>, arg1: (any)[]): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionToArray$Type = ($CollectionToArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionToArray_ = $CollectionToArray$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$TextFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$DataFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $TextFrame extends $DataFrame {

constructor()

public "getType"(): $Frame$Type
public "setPayload"(arg0: string): $TextFrame
public "getPayloadAsUTF8"(): string
get "type"(): $Frame$Type
set "payload"(value: string)
get "payloadAsUTF8"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextFrame$Type = ($TextFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextFrame_ = $TextFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$LongIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $LongIterator implements $Iterator<(long)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextLong"(): long
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterator$Type = ($LongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterator_ = $LongIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Response" {
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"

export class $Response {


public "type"(arg0: string): void
public "type"(): string
public "status"(arg0: integer): void
public "status"(): integer
public "body"(): string
public "body"(arg0: string): void
public "raw"(): $HttpServletResponse
public "header"(arg0: string, arg1: string): void
public "redirect"(arg0: string, arg1: integer): void
public "redirect"(arg0: string): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: integer, arg4: boolean, arg5: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: integer, arg4: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: integer, arg5: boolean, arg6: boolean): void
public "cookie"(arg0: string, arg1: string): void
public "cookie"(arg0: string, arg1: string, arg2: integer): void
public "cookie"(arg0: string, arg1: string, arg2: integer, arg3: boolean): void
public "cookie"(arg0: string, arg1: string, arg2: integer, arg3: boolean, arg4: boolean): void
public "removeCookie"(arg0: string, arg1: string): void
public "removeCookie"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Response$Type = ($Response);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Response_ = $Response$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle" {
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export class $PngChunkSingle extends $PngChunk {
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "allowsMultiple"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkSingle$Type = ($PngChunkSingle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkSingle_ = $PngChunkSingle$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$AccessDeniedException" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$File, $File$Type} from "packages/java/io/$File"
import {$FileSystemException, $FileSystemException$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileSystemException"

export class $AccessDeniedException extends $FileSystemException {

constructor(arg0: $File$Type, arg1: $File$Type, arg2: string)
constructor(arg0: $File$Type, arg1: $File$Type, arg2: string, arg3: integer, arg4: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccessDeniedException$Type = ($AccessDeniedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AccessDeniedException_ = $AccessDeniedException$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$EmptyRoleSemantic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ServletSecurity$EmptyRoleSemantic extends $Enum<($ServletSecurity$EmptyRoleSemantic)> {
static readonly "PERMIT": $ServletSecurity$EmptyRoleSemantic
static readonly "DENY": $ServletSecurity$EmptyRoleSemantic


public static "values"(): ($ServletSecurity$EmptyRoleSemantic)[]
public static "valueOf"(arg0: string): $ServletSecurity$EmptyRoleSemantic
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletSecurity$EmptyRoleSemantic$Type = (("deny") | ("permit")) | ($ServletSecurity$EmptyRoleSemantic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletSecurity$EmptyRoleSemantic_ = $ServletSecurity$EmptyRoleSemantic$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/route/$Routes" {
import {$RouteImpl, $RouteImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteImpl"
import {$RouteMatch, $RouteMatch$Type} from "packages/info/journeymap/shaded/kotlin/spark/routematch/$RouteMatch"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FilterImpl, $FilterImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$FilterImpl"
import {$HttpMethod, $HttpMethod$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$HttpMethod"

export class $Routes {


/**
 * 
 * @deprecated
 */
public "add"(arg0: string, arg1: string, arg2: any): void
public "add"(arg0: $HttpMethod$Type, arg1: $FilterImpl$Type): void
public "add"(arg0: $HttpMethod$Type, arg1: $RouteImpl$Type): void
public "remove"(arg0: string, arg1: string): boolean
public "remove"(arg0: string): boolean
public "clear"(): void
public "find"(arg0: $HttpMethod$Type, arg1: string, arg2: string): $RouteMatch
public static "create"(): $Routes
public "findMultiple"(arg0: $HttpMethod$Type, arg1: string, arg2: string): $List<($RouteMatch)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Routes$Type = ($Routes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Routes_ = $Routes$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$EmbeddedJettyFactory" {
import {$EmbeddedServer, $EmbeddedServer$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServer"
import {$EmbeddedServerFactory, $EmbeddedServerFactory$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/$EmbeddedServerFactory"
import {$JettyServerFactory, $JettyServerFactory$Type} from "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$JettyServerFactory"
import {$StaticFilesConfiguration, $StaticFilesConfiguration$Type} from "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesConfiguration"
import {$Routes, $Routes$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$Routes"

export class $EmbeddedJettyFactory implements $EmbeddedServerFactory {

constructor()
constructor(arg0: $JettyServerFactory$Type)

public "create"(arg0: $Routes$Type, arg1: $StaticFilesConfiguration$Type, arg2: boolean): $EmbeddedServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedJettyFactory$Type = ($EmbeddedJettyFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedJettyFactory_ = $EmbeddedJettyFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Function" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Function<R> {

}

export namespace $Function {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$Type<R> = ($Function<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_<R> = $Function$Type<(R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$InlineMarker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $InlineMarker {

constructor()

public static "mark"(arg0: string): void
public static "mark"(arg0: integer): void
public static "finallyStart"(arg0: integer): void
public static "beforeInlineCall"(): void
public static "afterInlineCall"(): void
public static "finallyEnd"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InlineMarker$Type = ($InlineMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InlineMarker_ = $InlineMarker$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$ValuesItr" {
import {$KMutableIterator, $KMutableIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MapBuilder$Itr, $MapBuilder$Itr$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder$Itr"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $MapBuilder$ValuesItr<K, V> extends $MapBuilder$Itr<(K), (V)> implements $Iterator<(V)>, $KMutableIterator {

constructor(arg0: $MapBuilder$Type<(K), (V)>)

public "next"(): V
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilder$ValuesItr$Type<K, V> = ($MapBuilder$ValuesItr<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilder$ValuesItr_<K, V> = $MapBuilder$ValuesItr$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileSystemException" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$File, $File$Type} from "packages/java/io/$File"
import {$IOException, $IOException$Type} from "packages/java/io/$IOException"

export class $FileSystemException extends $IOException {

constructor(arg0: $File$Type, arg1: $File$Type, arg2: string)
constructor(arg0: $File$Type, arg1: $File$Type, arg2: string, arg3: integer, arg4: $DefaultConstructorMarker$Type)

public "getFile"(): $File
public "getReason"(): string
public "getOther"(): $File
get "file"(): $File
get "reason"(): string
get "other"(): $File
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FileSystemException$Type = ($FileSystemException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FileSystemException_ = $FileSystemException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$Context" {
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ContextHandler$StaticContext, $ContextHandler$StaticContext$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$StaticContext"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$JspConfigDescriptor, $JspConfigDescriptor$Type} from "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspConfigDescriptor"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $ContextHandler$Context extends $ContextHandler$StaticContext {


public "getInitParameter"(arg0: string): string
public "setInitParameter"(arg0: string, arg1: string): boolean
public "getResourcePaths"(arg0: string): $Set<(string)>
public "declareRoles"(...arg0: (string)[]): void
public "toString"(): string
public "log"(arg0: string, arg1: $Throwable$Type): void
public "log"(arg0: $Exception$Type, arg1: string): void
public "log"(arg0: string): void
public "getClassLoader"(): $ClassLoader
public "getResourceAsStream"(arg0: string): $InputStream
public "getResource"(arg0: string): $URL
public "getContext"(arg0: string): $ServletContext
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "isEnabled"(): boolean
public "getRealPath"(arg0: string): string
public "createInstance"<T>(arg0: $Class$Type<(T)>): T
public "setEnabled"(arg0: boolean): void
public "getMimeType"(arg0: string): string
public "removeAttribute"(arg0: string): void
public "getRequestDispatcher"(arg0: string): $RequestDispatcher
public "createListener"<T extends $EventListener>(arg0: $Class$Type<(T)>): T
public "getContextPath"(): string
public "addListener"(arg0: $Class$Type<(any)>): void
public "addListener"<T extends $EventListener>(arg0: T): void
public "addListener"(arg0: string): void
public "getContextHandler"(): $ContextHandler
public "getAttributeNames"(): $Enumeration<(string)>
public "checkListener"(arg0: $Class$Type<(any)>): void
public "setJspConfigDescriptor"(arg0: $JspConfigDescriptor$Type): void
public "setExtendedListenerTypes"(arg0: boolean): void
public "isExtendedListenerTypes"(): boolean
public "getInitParameterNames"(): $Enumeration<(string)>
public "getVirtualServerName"(): string
public "getJspConfigDescriptor"(): $JspConfigDescriptor
public "getServletContextName"(): string
get "classLoader"(): $ClassLoader
get "enabled"(): boolean
set "enabled"(value: boolean)
get "contextPath"(): string
get "contextHandler"(): $ContextHandler
get "attributeNames"(): $Enumeration<(string)>
set "jspConfigDescriptor"(value: $JspConfigDescriptor$Type)
set "extendedListenerTypes"(value: boolean)
get "extendedListenerTypes"(): boolean
get "initParameterNames"(): $Enumeration<(string)>
get "virtualServerName"(): string
get "jspConfigDescriptor"(): $JspConfigDescriptor
get "servletContextName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextHandler$Context$Type = ($ContextHandler$Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextHandler$Context_ = $ContextHandler$Context$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export interface $Frame {

 "getType"(): $Frame$Type
 "getPayload"(): $ByteBuffer
 "getMask"(): (byte)[]
/**
 * 
 * @deprecated
 */
 "isLast"(): boolean
 "hasPayload"(): boolean
 "getOpCode"(): byte
 "getPayloadLength"(): integer
 "isMasked"(): boolean
 "isRsv1"(): boolean
 "isRsv2"(): boolean
 "isRsv3"(): boolean
 "isFin"(): boolean
}

export namespace $Frame {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frame$Type = ($Frame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frame_ = $Frame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/staticfiles/$StaticFilesConfiguration" {
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StaticFilesConfiguration {
static "servletInstance": $StaticFilesConfiguration

constructor()

public "putCustomHeaders"(arg0: $Map$Type<(string), (string)>): void
public "putCustomHeader"(arg0: string, arg1: string): void
public "clear"(): void
public static "create"(): $StaticFilesConfiguration
public "consume"(arg0: $HttpServletRequest$Type, arg1: $HttpServletResponse$Type): boolean
public "configure"(arg0: string): void
public "configureExternal"(arg0: string): void
public "setExpireTimeSeconds"(arg0: long): void
set "expireTimeSeconds"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StaticFilesConfiguration$Type = ($StaticFilesConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StaticFilesConfiguration_ = $StaticFilesConfiguration$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/ssl/$SslStores" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SslStores {


public static "create"(arg0: string, arg1: string, arg2: string, arg3: string): $SslStores
public static "create"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: boolean): $SslStores
public "trustStoreFile"(): string
public "trustStorePassword"(): string
public "needsClientCert"(): boolean
public "keystorePassword"(): string
public "keystoreFile"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslStores$Type = ($SslStores);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslStores_ = $SslStores$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ControlFrame" {
import {$WebSocketFrame, $WebSocketFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketFrame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $ControlFrame extends $WebSocketFrame {
static readonly "MAX_CONTROL_PAYLOAD": integer

constructor(arg0: byte)

public "equals"(arg0: any): boolean
public "getPayload"(): $ByteBuffer
public "setPayload"(arg0: $ByteBuffer$Type): $WebSocketFrame
public "assertValid"(): void
public "isControlFrame"(): boolean
public "isDataFrame"(): boolean
get "payload"(): $ByteBuffer
set "payload"(value: $ByteBuffer$Type)
get "controlFrame"(): boolean
get "dataFrame"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ControlFrame$Type = ($ControlFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ControlFrame_ = $ControlFrame$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionActivationListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$HttpSessionEvent, $HttpSessionEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent"

export interface $HttpSessionActivationListener extends $EventListener {

 "sessionDidActivate"(arg0: $HttpSessionEvent$Type): void
 "sessionWillPassivate"(arg0: $HttpSessionEvent$Type): void
}

export namespace $HttpSessionActivationListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionActivationListener$Type = ($HttpSessionActivationListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionActivationListener_ = $HttpSessionActivationListener$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt" {
import {$CollectionsKt___CollectionsKt, $CollectionsKt___CollectionsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt___CollectionsKt"

export class $CollectionsKt extends $CollectionsKt___CollectionsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt$Type = ($CollectionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt_ = $CollectionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $UserIdentity$Scope {

 "getName"(): string
 "getContextPath"(): string
 "getRoleRefMap"(): $Map<(string), (string)>
}

export namespace $UserIdentity$Scope {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UserIdentity$Scope$Type = ($UserIdentity$Scope);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UserIdentity$Scope_ = $UserIdentity$Scope$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source" {
import {$Source$Origin, $Source$Origin$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source$Origin"

export class $Source {
static readonly "EMBEDDED": $Source
static readonly "JAVAX_API": $Source
 "_origin": $Source$Origin
 "_resource": string

constructor(arg0: $Source$Origin$Type, arg1: string)

public "toString"(): string
public "getResource"(): string
public "getOrigin"(): $Source$Origin
get "resource"(): string
get "origin"(): $Source$Origin
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Source$Type = ($Source);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Source_ = $Source$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$ExperimentalUnsignedTypes" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ExperimentalUnsignedTypes extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ExperimentalUnsignedTypes {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperimentalUnsignedTypes$Type = ($ExperimentalUnsignedTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperimentalUnsignedTypes_ = $ExperimentalUnsignedTypes$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$ServerAuthException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$GeneralSecurityException, $GeneralSecurityException$Type} from "packages/java/security/$GeneralSecurityException"

export class $ServerAuthException extends $GeneralSecurityException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerAuthException$Type = ($ServerAuthException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerAuthException_ = $ServerAuthException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange" {
import {$LongProgression, $LongProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression"
import {$LongRange$Companion, $LongRange$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange$Companion"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export class $LongRange extends $LongProgression implements $ClosedRange<(long)> {
static readonly "Companion": $LongRange$Companion

constructor(arg0: long, arg1: long)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: long): boolean
public "getEndInclusive"(): long
get "empty"(): boolean
get "endInclusive"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongRange$Type = ($LongRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongRange_ = $LongRange$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$InitializedLazyImpl" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Lazy, $Lazy$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy"

export class $InitializedLazyImpl<T> implements $Lazy<(T)>, $Serializable {

constructor(arg0: T)

public "toString"(): string
public "getValue"(): T
public "isInitialized"(): boolean
get "value"(): T
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InitializedLazyImpl$Type<T> = ($InitializedLazyImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InitializedLazyImpl_<T> = $InitializedLazyImpl$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$StringUtils" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $StringUtils {

constructor()

public static "delimitedListToStringArray"(arg0: string, arg1: string, arg2: string): (string)[]
public static "delimitedListToStringArray"(arg0: string, arg1: string): (string)[]
public static "collectionToDelimitedString"(arg0: $Collection$Type<(any)>, arg1: string): string
public static "collectionToDelimitedString"(arg0: $Collection$Type<(any)>, arg1: string, arg2: string, arg3: string): string
public static "toString"(arg0: (byte)[], arg1: string): string
public static "isEmpty"(arg0: any): boolean
public static "replace"(arg0: string, arg1: string, arg2: string): string
public static "isBlank"(arg0: charseq): boolean
public static "cleanPath"(arg0: string): string
public static "toStringArray"(arg0: $Collection$Type<(string)>): (string)[]
public static "getFilename"(arg0: string): string
public static "isNotBlank"(arg0: charseq): boolean
public static "isNotEmpty"(arg0: string): boolean
public static "hasLength"(arg0: charseq): boolean
public static "hasLength"(arg0: string): boolean
public static "deleteAny"(arg0: string, arg1: string): string
public static "applyRelativePath"(arg0: string, arg1: string): string
public static "removeLeadingAndTrailingSlashesFrom"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUtils$Type = ($StringUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringUtils_ = $StringUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$Customizer" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"

export interface $HttpConfiguration$Customizer {

 "customize"(arg0: $Connector$Type, arg1: $HttpConfiguration$Type, arg2: $Request$Type): void

(arg0: $Connector$Type, arg1: $HttpConfiguration$Type, arg2: $Request$Type): void
}

export namespace $HttpConfiguration$Customizer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConfiguration$Customizer$Type = ($HttpConfiguration$Customizer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConfiguration$Customizer_ = $HttpConfiguration$Customizer$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionBindingEvent" {
import {$HttpSessionEvent, $HttpSessionEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"

export class $HttpSessionBindingEvent extends $HttpSessionEvent {

constructor(arg0: $HttpSession$Type, arg1: string, arg2: any)
constructor(arg0: $HttpSession$Type, arg1: string)

public "getName"(): string
public "getValue"(): any
public "getSession"(): $HttpSession
get "name"(): string
get "value"(): any
get "session"(): $HttpSession
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionBindingEvent$Type = ($HttpSessionBindingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionBindingEvent_ = $HttpSessionBindingEvent$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$BrittleContainsOptimizationKt" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $BrittleContainsOptimizationKt {


public static "convertToSetForSetOperation"<T>(arg0: (T)[]): $Collection<(T)>
public static "convertToSetForSetOperation"<T>(arg0: $Sequence$Type<(any)>): $Collection<(T)>
public static "convertToSetForSetOperation"<T>(arg0: $Iterable$Type<(any)>): $Collection<(T)>
public static "convertToSetForSetOperationWith"<T>(arg0: $Iterable$Type<(any)>, arg1: $Iterable$Type<(any)>): $Collection<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrittleContainsOptimizationKt$Type = ($BrittleContainsOptimizationKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BrittleContainsOptimizationKt_ = $BrittleContainsOptimizationKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$Deferred" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"

export interface $Authentication$Deferred extends $Authentication {

 "authenticate"(arg0: $ServletRequest$Type): $Authentication
 "authenticate"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $Authentication
 "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $Authentication
}

export namespace $Authentication$Deferred {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Authentication$Deferred$Type = ($Authentication$Deferred);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Authentication$Deferred_ = $Authentication$Deferred$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Invocable$InvocationType extends $Enum<($Invocable$InvocationType)> {
static readonly "BLOCKING": $Invocable$InvocationType
static readonly "NON_BLOCKING": $Invocable$InvocationType
static readonly "EITHER": $Invocable$InvocationType


public static "values"(): ($Invocable$InvocationType)[]
public static "valueOf"(arg0: string): $Invocable$InvocationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Invocable$InvocationType$Type = (("non_blocking") | ("either") | ("blocking")) | ($Invocable$InvocationType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Invocable$InvocationType_ = $Invocable$InvocationType$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$IOUtils" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Writer, $Writer$Type} from "packages/java/io/$Writer"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $IOUtils {
static readonly "LINE_SEPARATOR": string


public static "toString"(arg0: $InputStream$Type): string
public static "toByteArray"(arg0: $InputStream$Type): (byte)[]
public static "copy"(arg0: $Reader$Type, arg1: $Writer$Type): integer
public static "copy"(arg0: $InputStream$Type, arg1: $Writer$Type): void
public static "copy"(arg0: $InputStream$Type, arg1: $OutputStream$Type): integer
public static "copyLarge"(arg0: $Reader$Type, arg1: $Writer$Type): long
public static "copyLarge"(arg0: $InputStream$Type, arg1: $OutputStream$Type): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOUtils$Type = ($IOUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOUtils_ = $IOUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeRequest" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$HttpCookie, $HttpCookie$Type} from "packages/java/net/$HttpCookie"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $UpgradeRequest {

 "getMethod"(): string
 "getHost"(): string
 "setExtensions"(arg0: $List$Type<($ExtensionConfig$Type)>): void
 "getExtensions"(): $List<($ExtensionConfig)>
 "setMethod"(arg0: string): void
 "getHeader"(arg0: string): string
 "getHeaders"(): $Map<(string), ($List<(string)>)>
 "getHeaders"(arg0: string): $List<(string)>
 "isSecure"(): boolean
 "getProtocolVersion"(): string
 "getRequestURI"(): $URI
 "setHeaders"(arg0: $Map$Type<(string), ($List$Type<(string)>)>): void
 "getQueryString"(): string
 "setCookies"(arg0: $List$Type<($HttpCookie$Type)>): void
 "setSession"(arg0: any): void
 "setHttpVersion"(arg0: string): void
 "getSession"(): any
 "getOrigin"(): string
 "setHeader"(arg0: string, arg1: string): void
 "setHeader"(arg0: string, arg1: $List$Type<(string)>): void
 "getUserPrincipal"(): $Principal
 "getCookies"(): $List<($HttpCookie)>
 "getParameterMap"(): $Map<(string), ($List<(string)>)>
 "getHttpVersion"(): string
/**
 * 
 * @deprecated
 */
 "clearHeaders"(): void
 "getHeaderInt"(arg0: string): integer
 "addExtensions"(...arg0: (string)[]): void
 "addExtensions"(...arg0: ($ExtensionConfig$Type)[]): void
 "setRequestURI"(arg0: $URI$Type): void
 "setSubProtocols"(arg0: $List$Type<(string)>): void
 "setSubProtocols"(...arg0: (string)[]): void
 "isOrigin"(arg0: string): boolean
 "getSubProtocols"(): $List<(string)>
 "hasSubProtocol"(arg0: string): boolean
}

export namespace $UpgradeRequest {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeRequest$Type = ($UpgradeRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeRequest_ = $UpgradeRequest$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinVersion" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$KotlinVersion$Companion, $KotlinVersion$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$KotlinVersion$Companion"

export class $KotlinVersion implements $Comparable<($KotlinVersion)> {
static readonly "Companion": $KotlinVersion$Companion
static readonly "MAX_COMPONENT_VALUE": integer
static readonly "CURRENT": $KotlinVersion

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $KotlinVersion$Type): integer
public "isAtLeast"(arg0: integer, arg1: integer, arg2: integer): boolean
public "isAtLeast"(arg0: integer, arg1: integer): boolean
public "getMinor"(): integer
public "getMajor"(): integer
public "getPatch"(): integer
get "minor"(): integer
get "major"(): integer
get "patch"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinVersion$Type = ($KotlinVersion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinVersion_ = $KotlinVersion$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjExceptionInternal" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $PngjExceptionInternal extends $RuntimeException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngjExceptionInternal$Type = ($PngjExceptionInternal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngjExceptionInternal_ = $PngjExceptionInternal$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharCategory$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$CharCategory, $CharCategory$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharCategory"

export class $CharCategory$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "valueOf"(arg0: integer): $CharCategory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharCategory$Companion$Type = ($CharCategory$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharCategory$Companion_ = $CharCategory$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$DebugMetadata" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $DebugMetadata extends $Annotation {

 "i"(): (integer)[]
 "s"(): (string)[]
 "c"(): string
 "n"(): (string)[]
 "f"(): string
 "l"(): (integer)[]
 "m"(): string
 "v"(): integer
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $DebugMetadata {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugMetadata$Type = ($DebugMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DebugMetadata_ = $DebugMetadata$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt___ArraysKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$ArraysKt___ArraysJvmKt, $ArraysKt___ArraysJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArraysKt___ArraysJvmKt"
import {$Function3, $Function3$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Grouping, $Grouping$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$Grouping"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArraysKt___ArraysKt extends $ArraysKt___ArraysJvmKt {

constructor()

public static "sortedArrayWith"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): (T)[]
public static "firstOrNull"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "firstOrNull"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "firstOrNull"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "firstOrNull"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "firstOrNull"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "firstOrNull"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "firstOrNull"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "firstOrNull"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "firstOrNull"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "firstOrNull"(arg0: (integer)[]): integer
public static "firstOrNull"(arg0: (short)[]): short
public static "firstOrNull"(arg0: (byte)[]): byte
public static "firstOrNull"<T>(arg0: (T)[]): T
public static "firstOrNull"(arg0: (character)[]): character
public static "firstOrNull"(arg0: (boolean)[]): boolean
public static "firstOrNull"(arg0: (double)[]): double
public static "firstOrNull"(arg0: (float)[]): float
public static "firstOrNull"(arg0: (long)[]): long
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "reduceIndexedOrNull"(arg0: (byte)[], arg1: $Function3$Type<(any), (any), (any), (byte)>): byte
public static "reduceIndexedOrNull"<S, T extends S>(arg0: (T)[], arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceIndexedOrNull"(arg0: (character)[], arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceIndexedOrNull"(arg0: (float)[], arg1: $Function3$Type<(any), (any), (any), (float)>): float
public static "reduceIndexedOrNull"(arg0: (long)[], arg1: $Function3$Type<(any), (any), (any), (long)>): long
public static "reduceIndexedOrNull"(arg0: (boolean)[], arg1: $Function3$Type<(any), (any), (any), (boolean)>): boolean
public static "reduceIndexedOrNull"(arg0: (double)[], arg1: $Function3$Type<(any), (any), (any), (double)>): double
public static "reduceIndexedOrNull"(arg0: (integer)[], arg1: $Function3$Type<(any), (any), (any), (integer)>): integer
public static "reduceIndexedOrNull"(arg0: (short)[], arg1: $Function3$Type<(any), (any), (any), (short)>): short
public static "runningReduceIndexed"<S, T extends S>(arg0: (T)[], arg1: $Function3$Type<(any), (any), (any), (any)>): $List<(S)>
public static "mapIndexedNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "indexOf"(arg0: (float)[], arg1: float): integer
public static "indexOf"(arg0: (byte)[], arg1: byte): integer
public static "indexOf"(arg0: (short)[], arg1: short): integer
public static "indexOf"(arg0: (character)[], arg1: character): integer
public static "indexOf"(arg0: (long)[], arg1: long): integer
public static "indexOf"(arg0: (double)[], arg1: double): integer
public static "indexOf"(arg0: (boolean)[], arg1: boolean): integer
public static "indexOf"(arg0: (integer)[], arg1: integer): integer
public static "indexOf"<T>(arg0: (T)[], arg1: T): integer
public static "lastIndexOf"(arg0: (short)[], arg1: short): integer
public static "lastIndexOf"(arg0: (float)[], arg1: float): integer
public static "lastIndexOf"(arg0: (byte)[], arg1: byte): integer
public static "lastIndexOf"<T>(arg0: (T)[], arg1: T): integer
public static "lastIndexOf"(arg0: (integer)[], arg1: integer): integer
public static "lastIndexOf"(arg0: (double)[], arg1: double): integer
public static "lastIndexOf"(arg0: (boolean)[], arg1: boolean): integer
public static "lastIndexOf"(arg0: (character)[], arg1: character): integer
public static "lastIndexOf"(arg0: (long)[], arg1: long): integer
public static "map"<R>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<T, R>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "map"<R>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "toList"(arg0: (short)[]): $List<(short)>
public static "toList"(arg0: (long)[]): $List<(long)>
public static "toList"(arg0: (float)[]): $List<(float)>
public static "toList"(arg0: (double)[]): $List<(double)>
public static "toList"(arg0: (boolean)[]): $List<(boolean)>
public static "toList"(arg0: (integer)[]): $List<(integer)>
public static "toList"(arg0: (character)[]): $List<(character)>
public static "toList"(arg0: (byte)[]): $List<(byte)>
public static "toList"<T>(arg0: (T)[]): $List<(T)>
public static "toCharArray"(arg0: (character)[]): (character)[]
public static "count"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "count"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "contains"(arg0: (integer)[], arg1: integer): boolean
public static "contains"(arg0: (long)[], arg1: long): boolean
public static "contains"(arg0: (byte)[], arg1: byte): boolean
public static "contains"<T>(arg0: (T)[], arg1: T): boolean
public static "contains"(arg0: (double)[], arg1: double): boolean
public static "contains"(arg0: (boolean)[], arg1: boolean): boolean
public static "contains"(arg0: (character)[], arg1: character): boolean
public static "contains"(arg0: (float)[], arg1: float): boolean
public static "contains"(arg0: (short)[], arg1: short): boolean
public static "last"(arg0: (short)[]): short
public static "last"(arg0: (integer)[]): integer
public static "last"(arg0: (long)[]): long
public static "last"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "last"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "last"(arg0: (byte)[]): byte
public static "last"(arg0: (double)[]): double
public static "last"(arg0: (boolean)[]): boolean
public static "last"(arg0: (character)[]): character
public static "last"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "last"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "last"(arg0: (float)[]): float
public static "last"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "last"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "last"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "last"<T>(arg0: (T)[]): T
public static "last"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "last"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "single"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "single"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "single"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "single"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "single"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "single"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "single"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "single"(arg0: (long)[]): long
public static "single"(arg0: (character)[]): character
public static "single"(arg0: (double)[]): double
public static "single"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "single"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "single"(arg0: (boolean)[]): boolean
public static "single"(arg0: (float)[]): float
public static "single"<T>(arg0: (T)[]): T
public static "single"(arg0: (short)[]): short
public static "single"(arg0: (byte)[]): byte
public static "single"(arg0: (integer)[]): integer
public static "filter"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "filter"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "filter"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "filter"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "filter"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "filter"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "filter"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "filter"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "filter"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "first"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "first"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "first"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "first"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "first"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "first"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "first"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "first"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "first"(arg0: (long)[]): long
public static "first"(arg0: (integer)[]): integer
public static "first"(arg0: (short)[]): short
public static "first"<T>(arg0: (T)[]): T
public static "first"(arg0: (byte)[]): byte
public static "first"(arg0: (boolean)[]): boolean
public static "first"(arg0: (double)[]): double
public static "first"(arg0: (float)[]): float
public static "first"(arg0: (character)[]): character
public static "first"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "flatMap"<R>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<R>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "flatMap"<T, R>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "forEach"(arg0: (byte)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"<T>(arg0: (T)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (short)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (character)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (long)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (float)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (double)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (boolean)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "forEach"(arg0: (integer)[], arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "toSet"(arg0: (double)[]): $Set<(double)>
public static "toSet"(arg0: (float)[]): $Set<(float)>
public static "toSet"(arg0: (long)[]): $Set<(long)>
public static "toSet"(arg0: (boolean)[]): $Set<(boolean)>
public static "toSet"(arg0: (character)[]): $Set<(character)>
public static "toSet"(arg0: (integer)[]): $Set<(integer)>
public static "toSet"<T>(arg0: (T)[]): $Set<(T)>
public static "toSet"(arg0: (byte)[]): $Set<(byte)>
public static "toSet"(arg0: (short)[]): $Set<(short)>
public static "toByteArray"(arg0: (byte)[]): (byte)[]
public static "reverse"(arg0: (float)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (double)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (boolean)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (character)[], arg1: integer, arg2: integer): void
public static "reverse"<T>(arg0: (T)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "reverse"(arg0: (float)[]): void
public static "reverse"<T>(arg0: (T)[]): void
public static "reverse"(arg0: (integer)[]): void
public static "reverse"(arg0: (short)[]): void
public static "reverse"(arg0: (byte)[]): void
public static "reverse"(arg0: (long)[]): void
public static "reverse"(arg0: (character)[]): void
public static "reverse"(arg0: (boolean)[]): void
public static "reverse"(arg0: (double)[]): void
public static "sum"(arg0: (double)[]): double
public static "sum"(arg0: (byte)[]): integer
public static "sum"(arg0: (short)[]): integer
public static "sum"(arg0: (integer)[]): integer
public static "sum"(arg0: (long)[]): long
public static "sum"(arg0: (float)[]): float
public static "reduce"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (integer)>): integer
public static "reduce"(arg0: (short)[], arg1: $Function2$Type<(any), (any), (short)>): short
public static "reduce"(arg0: (long)[], arg1: $Function2$Type<(any), (any), (long)>): long
public static "reduce"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (byte)>): byte
public static "reduce"<S, T extends S>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): S
public static "reduce"(arg0: (character)[], arg1: $Function2$Type<(any), (any), (character)>): character
public static "reduce"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (boolean)>): boolean
public static "reduce"(arg0: (double)[], arg1: $Function2$Type<(any), (any), (double)>): double
public static "reduce"(arg0: (float)[], arg1: $Function2$Type<(any), (any), (float)>): float
public static "slice"(arg0: (double)[], arg1: $Iterable$Type<(integer)>): $List<(double)>
public static "slice"(arg0: (boolean)[], arg1: $Iterable$Type<(integer)>): $List<(boolean)>
public static "slice"(arg0: (float)[], arg1: $Iterable$Type<(integer)>): $List<(float)>
public static "slice"(arg0: (character)[], arg1: $Iterable$Type<(integer)>): $List<(character)>
public static "slice"<T>(arg0: (T)[], arg1: $IntRange$Type): $List<(T)>
public static "slice"(arg0: (long)[], arg1: $IntRange$Type): $List<(long)>
public static "slice"(arg0: (float)[], arg1: $IntRange$Type): $List<(float)>
public static "slice"(arg0: (double)[], arg1: $IntRange$Type): $List<(double)>
public static "slice"(arg0: (boolean)[], arg1: $IntRange$Type): $List<(boolean)>
public static "slice"(arg0: (integer)[], arg1: $IntRange$Type): $List<(integer)>
public static "slice"(arg0: (short)[], arg1: $IntRange$Type): $List<(short)>
public static "slice"(arg0: (byte)[], arg1: $IntRange$Type): $List<(byte)>
public static "slice"(arg0: (long)[], arg1: $Iterable$Type<(integer)>): $List<(long)>
public static "slice"(arg0: (integer)[], arg1: $Iterable$Type<(integer)>): $List<(integer)>
public static "slice"(arg0: (short)[], arg1: $Iterable$Type<(integer)>): $List<(short)>
public static "slice"(arg0: (byte)[], arg1: $Iterable$Type<(integer)>): $List<(byte)>
public static "slice"<T>(arg0: (T)[], arg1: $Iterable$Type<(integer)>): $List<(T)>
public static "slice"(arg0: (character)[], arg1: $IntRange$Type): $List<(character)>
public static "reversed"(arg0: (integer)[]): $List<(integer)>
public static "reversed"(arg0: (short)[]): $List<(short)>
public static "reversed"(arg0: (byte)[]): $List<(byte)>
public static "reversed"<T>(arg0: (T)[]): $List<(T)>
public static "reversed"(arg0: (boolean)[]): $List<(boolean)>
public static "reversed"(arg0: (double)[]): $List<(double)>
public static "reversed"(arg0: (float)[]): $List<(float)>
public static "reversed"(arg0: (long)[]): $List<(long)>
public static "reversed"(arg0: (character)[]): $List<(character)>
public static "distinct"(arg0: (float)[]): $List<(float)>
public static "distinct"(arg0: (double)[]): $List<(double)>
public static "distinct"(arg0: (boolean)[]): $List<(boolean)>
public static "distinct"(arg0: (character)[]): $List<(character)>
public static "distinct"<T>(arg0: (T)[]): $List<(T)>
public static "distinct"(arg0: (byte)[]): $List<(byte)>
public static "distinct"(arg0: (short)[]): $List<(short)>
public static "distinct"(arg0: (integer)[]): $List<(integer)>
public static "distinct"(arg0: (long)[]): $List<(long)>
public static "random"(arg0: (integer)[], arg1: $Random$Type): integer
public static "random"(arg0: (long)[], arg1: $Random$Type): long
public static "random"(arg0: (float)[], arg1: $Random$Type): float
public static "random"<T>(arg0: (T)[], arg1: $Random$Type): T
public static "random"(arg0: (byte)[], arg1: $Random$Type): byte
public static "random"(arg0: (short)[], arg1: $Random$Type): short
public static "random"(arg0: (double)[], arg1: $Random$Type): double
public static "random"(arg0: (boolean)[], arg1: $Random$Type): boolean
public static "random"(arg0: (character)[], arg1: $Random$Type): character
public static "shuffle"(arg0: (integer)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (short)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (byte)[], arg1: $Random$Type): void
public static "shuffle"<T>(arg0: (T)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (character)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (boolean)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (double)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (float)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (long)[], arg1: $Random$Type): void
public static "shuffle"(arg0: (integer)[]): void
public static "shuffle"(arg0: (short)[]): void
public static "shuffle"(arg0: (byte)[]): void
public static "shuffle"<T>(arg0: (T)[]): void
public static "shuffle"(arg0: (character)[]): void
public static "shuffle"(arg0: (boolean)[]): void
public static "shuffle"(arg0: (float)[]): void
public static "shuffle"(arg0: (double)[]): void
public static "shuffle"(arg0: (long)[]): void
public static "sorted"(arg0: (long)[]): $List<(long)>
public static "sorted"(arg0: (integer)[]): $List<(integer)>
public static "sorted"(arg0: (short)[]): $List<(short)>
public static "sorted"(arg0: (byte)[]): $List<(byte)>
public static "sorted"<T extends $Comparable<(any)>>(arg0: (T)[]): $List<(T)>
public static "sorted"(arg0: (character)[]): $List<(character)>
public static "sorted"(arg0: (double)[]): $List<(double)>
public static "sorted"(arg0: (float)[]): $List<(float)>
public static "scan"<T, R>(arg0: (T)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "groupingBy"<T, K>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $Grouping<(T), (K)>
public static "subtract"(arg0: (integer)[], arg1: $Iterable$Type<(integer)>): $Set<(integer)>
public static "subtract"(arg0: (long)[], arg1: $Iterable$Type<(long)>): $Set<(long)>
public static "subtract"(arg0: (float)[], arg1: $Iterable$Type<(float)>): $Set<(float)>
public static "subtract"(arg0: (double)[], arg1: $Iterable$Type<(double)>): $Set<(double)>
public static "subtract"<T>(arg0: (T)[], arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "subtract"(arg0: (short)[], arg1: $Iterable$Type<(short)>): $Set<(short)>
public static "subtract"(arg0: (byte)[], arg1: $Iterable$Type<(byte)>): $Set<(byte)>
public static "subtract"(arg0: (boolean)[], arg1: $Iterable$Type<(boolean)>): $Set<(boolean)>
public static "subtract"(arg0: (character)[], arg1: $Iterable$Type<(character)>): $Set<(character)>
public static "drop"(arg0: (character)[], arg1: integer): $List<(character)>
public static "drop"(arg0: (double)[], arg1: integer): $List<(double)>
public static "drop"(arg0: (boolean)[], arg1: integer): $List<(boolean)>
public static "drop"(arg0: (integer)[], arg1: integer): $List<(integer)>
public static "drop"(arg0: (long)[], arg1: integer): $List<(long)>
public static "drop"(arg0: (float)[], arg1: integer): $List<(float)>
public static "drop"(arg0: (byte)[], arg1: integer): $List<(byte)>
public static "drop"<T>(arg0: (T)[], arg1: integer): $List<(T)>
public static "drop"(arg0: (short)[], arg1: integer): $List<(short)>
public static "toIntArray"(arg0: (integer)[]): (integer)[]
public static "all"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "all"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "take"(arg0: (long)[], arg1: integer): $List<(long)>
public static "take"(arg0: (float)[], arg1: integer): $List<(float)>
public static "take"(arg0: (integer)[], arg1: integer): $List<(integer)>
public static "take"(arg0: (short)[], arg1: integer): $List<(short)>
public static "take"(arg0: (byte)[], arg1: integer): $List<(byte)>
public static "take"(arg0: (character)[], arg1: integer): $List<(character)>
public static "take"(arg0: (boolean)[], arg1: integer): $List<(boolean)>
public static "take"(arg0: (double)[], arg1: integer): $List<(double)>
public static "take"<T>(arg0: (T)[], arg1: integer): $List<(T)>
public static "toCollection"<C extends $Collection<(any)>>(arg0: (double)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (float)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (character)[], arg1: C): C
public static "toCollection"<T, C extends $Collection<(any)>>(arg0: (T)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (byte)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (short)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (integer)[], arg1: C): C
public static "toCollection"<C extends $Collection<(any)>>(arg0: (long)[], arg1: C): C
public static "union"(arg0: (long)[], arg1: $Iterable$Type<(long)>): $Set<(long)>
public static "union"(arg0: (integer)[], arg1: $Iterable$Type<(integer)>): $Set<(integer)>
public static "union"(arg0: (short)[], arg1: $Iterable$Type<(short)>): $Set<(short)>
public static "union"(arg0: (byte)[], arg1: $Iterable$Type<(byte)>): $Set<(byte)>
public static "union"<T>(arg0: (T)[], arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "union"(arg0: (boolean)[], arg1: $Iterable$Type<(boolean)>): $Set<(boolean)>
public static "union"(arg0: (character)[], arg1: $Iterable$Type<(character)>): $Set<(character)>
public static "union"(arg0: (double)[], arg1: $Iterable$Type<(double)>): $Set<(double)>
public static "union"(arg0: (float)[], arg1: $Iterable$Type<(float)>): $Set<(float)>
public static "takeWhile"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "takeWhile"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "takeWhile"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "takeWhile"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "takeWhile"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "takeWhile"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "takeWhile"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "takeWhile"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "takeWhile"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "dropWhile"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "dropWhile"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "dropWhile"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "dropWhile"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "dropWhile"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "dropWhile"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "dropWhile"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "dropWhile"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "dropWhile"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "average"(arg0: (double)[]): double
public static "average"(arg0: (short)[]): double
public static "average"(arg0: (integer)[]): double
public static "average"(arg0: (byte)[]): double
public static "average"(arg0: (float)[]): double
public static "average"(arg0: (long)[]): double
public static "zip"<R, V>(arg0: (long)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (boolean)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(boolean), (R)>)>
public static "zip"<R, V>(arg0: (integer)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (short)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (character)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(character), (R)>)>
public static "zip"<R>(arg0: (byte)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(byte), (R)>)>
public static "zip"<T, R>(arg0: (T)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(T), (R)>)>
public static "zip"<R, V>(arg0: (character)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (boolean)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (double)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (float)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (double)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(double), (R)>)>
public static "zip"<R>(arg0: (float)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(float), (R)>)>
public static "zip"<R>(arg0: (long)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(long), (R)>)>
public static "zip"<R>(arg0: (integer)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(integer), (R)>)>
public static "zip"<R>(arg0: (short)[], arg1: $Iterable$Type<(any)>): $List<($Pair<(short), (R)>)>
public static "zip"(arg0: (boolean)[], arg1: (boolean)[]): $List<($Pair<(boolean), (boolean)>)>
public static "zip"(arg0: (character)[], arg1: (character)[]): $List<($Pair<(character), (character)>)>
public static "zip"<V>(arg0: (byte)[], arg1: (byte)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (short)[], arg1: (short)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"(arg0: (double)[], arg1: (double)[]): $List<($Pair<(double), (double)>)>
public static "zip"(arg0: (float)[], arg1: (float)[]): $List<($Pair<(float), (float)>)>
public static "zip"(arg0: (long)[], arg1: (long)[]): $List<($Pair<(long), (long)>)>
public static "zip"<V>(arg0: (character)[], arg1: (character)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (boolean)[], arg1: (boolean)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (double)[], arg1: (double)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (float)[], arg1: (float)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (long)[], arg1: (long)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<V>(arg0: (integer)[], arg1: (integer)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (float)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (long)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (integer)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (short)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (byte)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<T, R, V>(arg0: (T)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"(arg0: (integer)[], arg1: (integer)[]): $List<($Pair<(integer), (integer)>)>
public static "zip"(arg0: (short)[], arg1: (short)[]): $List<($Pair<(short), (short)>)>
public static "zip"(arg0: (byte)[], arg1: (byte)[]): $List<($Pair<(byte), (byte)>)>
public static "zip"<R, V>(arg0: (character)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (boolean)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R, V>(arg0: (double)[], arg1: $Iterable$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (long)[], arg1: (R)[]): $List<($Pair<(long), (R)>)>
public static "zip"<R>(arg0: (integer)[], arg1: (R)[]): $List<($Pair<(integer), (R)>)>
public static "zip"<R>(arg0: (short)[], arg1: (R)[]): $List<($Pair<(short), (R)>)>
public static "zip"<R, V>(arg0: (byte)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (byte)[], arg1: (R)[]): $List<($Pair<(byte), (R)>)>
public static "zip"<T, R>(arg0: (T)[], arg1: (R)[]): $List<($Pair<(T), (R)>)>
public static "zip"<R>(arg0: (character)[], arg1: (R)[]): $List<($Pair<(character), (R)>)>
public static "zip"<T, R, V>(arg0: (T)[], arg1: (R)[], arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "zip"<R>(arg0: (double)[], arg1: (R)[]): $List<($Pair<(double), (R)>)>
public static "zip"<R>(arg0: (float)[], arg1: (R)[]): $List<($Pair<(float), (R)>)>
public static "zip"<R>(arg0: (boolean)[], arg1: (R)[]): $List<($Pair<(boolean), (R)>)>
public static "any"(arg0: (character)[]): boolean
public static "any"(arg0: (integer)[]): boolean
public static "any"(arg0: (long)[]): boolean
public static "any"(arg0: (float)[]): boolean
public static "any"(arg0: (double)[]): boolean
public static "any"(arg0: (boolean)[]): boolean
public static "any"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "any"<T>(arg0: (T)[]): boolean
public static "any"(arg0: (byte)[]): boolean
public static "any"(arg0: (short)[]): boolean
public static "toLongArray"(arg0: (long)[]): (long)[]
public static "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
public static "associate"<K, V>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<T, K, V>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associate"<K, V>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "none"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (float)[]): boolean
public static "none"(arg0: (double)[]): boolean
public static "none"(arg0: (boolean)[]): boolean
public static "none"(arg0: (character)[]): boolean
public static "none"(arg0: (short)[]): boolean
public static "none"<T>(arg0: (T)[]): boolean
public static "none"(arg0: (byte)[]): boolean
public static "none"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: (long)[]): boolean
public static "none"(arg0: (integer)[]): boolean
public static "partition"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(short)>), ($List<(short)>)>
public static "partition"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(byte)>), ($List<(byte)>)>
public static "partition"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(T)>), ($List<(T)>)>
public static "partition"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(double)>), ($List<(double)>)>
public static "partition"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(character)>), ($List<(character)>)>
public static "partition"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(boolean)>), ($List<(boolean)>)>
public static "partition"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(float)>), ($List<(float)>)>
public static "partition"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(long)>), ($List<(long)>)>
public static "partition"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $Pair<($List<(integer)>), ($List<(integer)>)>
public static "intersect"(arg0: (integer)[], arg1: $Iterable$Type<(integer)>): $Set<(integer)>
public static "intersect"<T>(arg0: (T)[], arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "intersect"(arg0: (byte)[], arg1: $Iterable$Type<(byte)>): $Set<(byte)>
public static "intersect"(arg0: (short)[], arg1: $Iterable$Type<(short)>): $Set<(short)>
public static "intersect"(arg0: (character)[], arg1: $Iterable$Type<(character)>): $Set<(character)>
public static "intersect"(arg0: (boolean)[], arg1: $Iterable$Type<(boolean)>): $Set<(boolean)>
public static "intersect"(arg0: (double)[], arg1: $Iterable$Type<(double)>): $Set<(double)>
public static "intersect"(arg0: (float)[], arg1: $Iterable$Type<(float)>): $Set<(float)>
public static "intersect"(arg0: (long)[], arg1: $Iterable$Type<(long)>): $Set<(long)>
public static "reduceRight"(arg0: (long)[], arg1: $Function2$Type<(any), (any), (long)>): long
public static "reduceRight"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (integer)>): integer
public static "reduceRight"(arg0: (float)[], arg1: $Function2$Type<(any), (any), (float)>): float
public static "reduceRight"(arg0: (double)[], arg1: $Function2$Type<(any), (any), (double)>): double
public static "reduceRight"(arg0: (short)[], arg1: $Function2$Type<(any), (any), (short)>): short
public static "reduceRight"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (byte)>): byte
public static "reduceRight"<S, T extends S>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): S
public static "reduceRight"(arg0: (character)[], arg1: $Function2$Type<(any), (any), (character)>): character
public static "reduceRight"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (boolean)>): boolean
public static "sortBy"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): void
public static "getOrNull"(arg0: (integer)[], arg1: integer): integer
public static "getOrNull"(arg0: (long)[], arg1: integer): long
public static "getOrNull"(arg0: (short)[], arg1: integer): short
public static "getOrNull"(arg0: (float)[], arg1: integer): float
public static "getOrNull"(arg0: (boolean)[], arg1: integer): boolean
public static "getOrNull"(arg0: (double)[], arg1: integer): double
public static "getOrNull"<T>(arg0: (T)[], arg1: integer): T
public static "getOrNull"(arg0: (byte)[], arg1: integer): byte
public static "getOrNull"(arg0: (character)[], arg1: integer): character
public static "indexOfFirst"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfFirst"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "sortedArrayDescending"(arg0: (long)[]): (long)[]
public static "sortedArrayDescending"(arg0: (float)[]): (float)[]
public static "sortedArrayDescending"(arg0: (character)[]): (character)[]
public static "sortedArrayDescending"(arg0: (double)[]): (double)[]
public static "sortedArrayDescending"<T extends $Comparable<(any)>>(arg0: (T)[]): (T)[]
public static "sortedArrayDescending"(arg0: (byte)[]): (byte)[]
public static "sortedArrayDescending"(arg0: (integer)[]): (integer)[]
public static "sortedArrayDescending"(arg0: (short)[]): (short)[]
public static "takeLast"(arg0: (character)[], arg1: integer): $List<(character)>
public static "takeLast"(arg0: (boolean)[], arg1: integer): $List<(boolean)>
public static "takeLast"(arg0: (integer)[], arg1: integer): $List<(integer)>
public static "takeLast"(arg0: (double)[], arg1: integer): $List<(double)>
public static "takeLast"(arg0: (float)[], arg1: integer): $List<(float)>
public static "takeLast"(arg0: (long)[], arg1: integer): $List<(long)>
public static "takeLast"<T>(arg0: (T)[], arg1: integer): $List<(T)>
public static "takeLast"(arg0: (byte)[], arg1: integer): $List<(byte)>
public static "takeLast"(arg0: (short)[], arg1: integer): $List<(short)>
public static "joinTo"<T, A extends $Appendable>(arg0: (T)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (double)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (integer)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (character)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (long)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (float)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (boolean)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (short)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "joinTo"<A extends $Appendable>(arg0: (byte)[], arg1: A, arg2: charseq, arg3: charseq, arg4: charseq, arg5: integer, arg6: charseq, arg7: $Function1$Type<(any), (any)>): A
public static "toFloatArray"(arg0: (float)[]): (float)[]
public static "getLastIndex"(arg0: (boolean)[]): integer
public static "getLastIndex"(arg0: (character)[]): integer
public static "getLastIndex"(arg0: (double)[]): integer
public static "getLastIndex"<T>(arg0: (T)[]): integer
public static "getLastIndex"(arg0: (byte)[]): integer
public static "getLastIndex"(arg0: (short)[]): integer
public static "getLastIndex"(arg0: (float)[]): integer
public static "getLastIndex"(arg0: (long)[]): integer
public static "getLastIndex"(arg0: (integer)[]): integer
public static "toDoubleArray"(arg0: (double)[]): (double)[]
public static "foldRightIndexed"<R>(arg0: (long)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (integer)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (short)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (byte)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<T, R>(arg0: (T)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (character)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (boolean)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (double)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldRightIndexed"<R>(arg0: (float)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "dropLast"(arg0: (short)[], arg1: integer): $List<(short)>
public static "dropLast"(arg0: (character)[], arg1: integer): $List<(character)>
public static "dropLast"(arg0: (float)[], arg1: integer): $List<(float)>
public static "dropLast"(arg0: (double)[], arg1: integer): $List<(double)>
public static "dropLast"(arg0: (boolean)[], arg1: integer): $List<(boolean)>
public static "dropLast"(arg0: (byte)[], arg1: integer): $List<(byte)>
public static "dropLast"<T>(arg0: (T)[], arg1: integer): $List<(T)>
public static "dropLast"(arg0: (integer)[], arg1: integer): $List<(integer)>
public static "dropLast"(arg0: (long)[], arg1: integer): $List<(long)>
public static "dropLastWhile"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "dropLastWhile"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "dropLastWhile"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "dropLastWhile"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "dropLastWhile"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "dropLastWhile"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "dropLastWhile"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "dropLastWhile"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "dropLastWhile"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "foldRight"<R>(arg0: (long)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (integer)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (byte)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<T, R>(arg0: (T)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (short)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (character)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (boolean)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (float)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "foldRight"<R>(arg0: (double)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "reduceRightIndexed"(arg0: (byte)[], arg1: $Function3$Type<(any), (any), (any), (byte)>): byte
public static "reduceRightIndexed"(arg0: (character)[], arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceRightIndexed"(arg0: (short)[], arg1: $Function3$Type<(any), (any), (any), (short)>): short
public static "reduceRightIndexed"(arg0: (float)[], arg1: $Function3$Type<(any), (any), (any), (float)>): float
public static "reduceRightIndexed"(arg0: (long)[], arg1: $Function3$Type<(any), (any), (any), (long)>): long
public static "reduceRightIndexed"<S, T extends S>(arg0: (T)[], arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceRightIndexed"(arg0: (integer)[], arg1: $Function3$Type<(any), (any), (any), (integer)>): integer
public static "reduceRightIndexed"(arg0: (double)[], arg1: $Function3$Type<(any), (any), (any), (double)>): double
public static "reduceRightIndexed"(arg0: (boolean)[], arg1: $Function3$Type<(any), (any), (any), (boolean)>): boolean
public static "reduceRightOrNull"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (byte)>): byte
public static "reduceRightOrNull"(arg0: (character)[], arg1: $Function2$Type<(any), (any), (character)>): character
public static "reduceRightOrNull"(arg0: (double)[], arg1: $Function2$Type<(any), (any), (double)>): double
public static "reduceRightOrNull"<S, T extends S>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): S
public static "reduceRightOrNull"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (integer)>): integer
public static "reduceRightOrNull"(arg0: (long)[], arg1: $Function2$Type<(any), (any), (long)>): long
public static "reduceRightOrNull"(arg0: (float)[], arg1: $Function2$Type<(any), (any), (float)>): float
public static "reduceRightOrNull"(arg0: (short)[], arg1: $Function2$Type<(any), (any), (short)>): short
public static "reduceRightOrNull"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (boolean)>): boolean
public static "takeLastWhile"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "takeLastWhile"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "takeLastWhile"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "takeLastWhile"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "takeLastWhile"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "takeLastWhile"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "takeLastWhile"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "takeLastWhile"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "takeLastWhile"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "randomOrNull"(arg0: (integer)[], arg1: $Random$Type): integer
public static "randomOrNull"<T>(arg0: (T)[], arg1: $Random$Type): T
public static "randomOrNull"(arg0: (short)[], arg1: $Random$Type): short
public static "randomOrNull"(arg0: (byte)[], arg1: $Random$Type): byte
public static "randomOrNull"(arg0: (boolean)[], arg1: $Random$Type): boolean
public static "randomOrNull"(arg0: (double)[], arg1: $Random$Type): double
public static "randomOrNull"(arg0: (float)[], arg1: $Random$Type): float
public static "randomOrNull"(arg0: (character)[], arg1: $Random$Type): character
public static "randomOrNull"(arg0: (long)[], arg1: $Random$Type): long
public static "asSequence"(arg0: (character)[]): $Sequence<(character)>
public static "asSequence"(arg0: (short)[]): $Sequence<(short)>
public static "asSequence"(arg0: (integer)[]): $Sequence<(integer)>
public static "asSequence"(arg0: (boolean)[]): $Sequence<(boolean)>
public static "asSequence"<T>(arg0: (T)[]): $Sequence<(T)>
public static "asSequence"(arg0: (double)[]): $Sequence<(double)>
public static "asSequence"(arg0: (byte)[]): $Sequence<(byte)>
public static "asSequence"(arg0: (float)[]): $Sequence<(float)>
public static "asSequence"(arg0: (long)[]): $Sequence<(long)>
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (double)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (boolean)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (long)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<T, K, M extends $Map<(any), (any)>>(arg0: (T)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (byte)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (short)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (integer)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (character)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: (T)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (character)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (boolean)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (double)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: (float)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (float)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (long)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (integer)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (short)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: (byte)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "averageOfByte"(arg0: (byte)[]): double
public static "averageOfFloat"(arg0: (float)[]): double
public static "averageOfInt"(arg0: (integer)[]): double
public static "associateBy"<K, V>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<T, K, V>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (double)>
public static "associateBy"<K>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (character)>
public static "associateBy"<K>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (boolean)>
public static "associateBy"<K, V>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K, V>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K, V>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K, V>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K, V>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (byte)>
public static "associateBy"<T, K>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (T)>
public static "associateBy"<K, V>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K, V>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (integer)>
public static "associateBy"<K>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (short)>
public static "associateBy"<K>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (float)>
public static "associateBy"<K>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (long)>
public static "associateWithTo"<K, V, M extends $Map<(any), (any)>>(arg0: (K)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (float)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (integer)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<T, K, V, M extends $Map<(any), (any)>>(arg0: (T)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (byte)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (long)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (character)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (short)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (double)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: (boolean)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "averageOfShort"(arg0: (short)[]): double
public static "averageOfLong"(arg0: (long)[]): double
public static "asIterable"(arg0: (character)[]): $Iterable<(character)>
public static "asIterable"(arg0: (long)[]): $Iterable<(long)>
public static "asIterable"(arg0: (double)[]): $Iterable<(double)>
public static "asIterable"(arg0: (float)[]): $Iterable<(float)>
public static "asIterable"(arg0: (short)[]): $Iterable<(short)>
public static "asIterable"(arg0: (byte)[]): $Iterable<(byte)>
public static "asIterable"<T>(arg0: (T)[]): $Iterable<(T)>
public static "asIterable"(arg0: (integer)[]): $Iterable<(integer)>
public static "asIterable"(arg0: (boolean)[]): $Iterable<(boolean)>
public static "associateWith"<K, V>(arg0: (K)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "averageOfDouble"(arg0: (double)[]): double
public static "forEachIndexed"(arg0: (long)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"<T>(arg0: (T)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (short)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (character)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (double)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (float)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "forEachIndexed"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "mapIndexed"<T, R>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (character)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (double)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (float)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (long)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexed"<R>(arg0: (short)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexedNotNull"<T, R>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "filterIndexed"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(byte)>
public static "filterIndexed"(arg0: (short)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(short)>
public static "filterIndexed"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(integer)>
public static "filterIndexed"(arg0: (long)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(long)>
public static "filterIndexed"(arg0: (character)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(character)>
public static "filterIndexed"(arg0: (float)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(float)>
public static "filterIndexed"(arg0: (double)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(double)>
public static "filterIndexed"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(boolean)>
public static "filterIndexed"<T>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (boolean)>): $List<(T)>
public static "filterNot"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): $List<(integer)>
public static "filterNot"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): $List<(character)>
public static "filterNot"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): $List<(boolean)>
public static "filterNot"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): $List<(long)>
public static "filterNot"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): $List<(float)>
public static "filterNot"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): $List<(double)>
public static "filterNot"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): $List<(T)>
public static "filterNot"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): $List<(byte)>
public static "filterNot"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): $List<(short)>
public static "distinctBy"<K>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $List<(integer)>
public static "distinctBy"<K>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $List<(short)>
public static "distinctBy"<K>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $List<(byte)>
public static "distinctBy"<T, K>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "distinctBy"<K>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $List<(character)>
public static "distinctBy"<K>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $List<(boolean)>
public static "distinctBy"<K>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $List<(double)>
public static "distinctBy"<K>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $List<(float)>
public static "distinctBy"<K>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $List<(long)>
public static "filterNotNullTo"<C extends $Collection<(any)>, T>(arg0: (T)[], arg1: C): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<T, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterTo"<C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<T, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "filterIndexedTo"<C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "groupBy"<K>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(long)>)>
public static "groupBy"<K>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(float)>)>
public static "groupBy"<K>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(double)>)>
public static "groupBy"<K>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(integer)>)>
public static "groupBy"<K>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(byte)>)>
public static "groupBy"<K>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(short)>)>
public static "groupBy"<K, V>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(boolean)>)>
public static "groupBy"<K>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(character)>)>
public static "groupBy"<T, K, V>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K, V>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<T, K>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(T)>)>
public static "foldIndexed"<R>(arg0: (double)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (float)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (long)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (boolean)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (character)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<T, R>(arg0: (T)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (byte)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (short)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "foldIndexed"<R>(arg0: (integer)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (short)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (integer)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (long)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (float)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (double)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<T, K, M extends $Map<(any), ($List<(T)>)>>(arg0: (T)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(byte)>)>>(arg0: (byte)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<T, K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (T)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (byte)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(long)>)>>(arg0: (long)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(integer)>)>>(arg0: (integer)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(short)>)>>(arg0: (short)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (character)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: (boolean)[], arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(character)>)>>(arg0: (character)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(boolean)>)>>(arg0: (boolean)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(double)>)>>(arg0: (double)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, M extends $Map<(any), ($List<(float)>)>>(arg0: (float)[], arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<T, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "filterNotTo"<C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "indexOfLast"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "indexOfLast"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "joinToString"(arg0: (integer)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"<T>(arg0: (T)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (boolean)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (byte)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (character)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (short)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (long)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (float)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "joinToString"(arg0: (double)[], arg1: charseq, arg2: charseq, arg3: charseq, arg4: integer, arg5: charseq, arg6: $Function1$Type<(any), (any)>): string
public static "minOrNull"(arg0: (character)[]): character
public static "minOrNull"<T extends $Comparable<(any)>>(arg0: (T)[]): T
public static "minOrNull"(arg0: (double)[]): double
public static "minOrNull"(arg0: (byte)[]): byte
public static "minOrNull"(arg0: (float)[]): float
public static "minOrNull"(arg0: (double)[]): double
public static "minOrNull"(arg0: (float)[]): float
public static "minOrNull"(arg0: (long)[]): long
public static "minOrNull"(arg0: (integer)[]): integer
public static "minOrNull"(arg0: (short)[]): short
public static "mapNotNull"<T, R>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): short
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): byte
public static "minByOrNull"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): T
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): float
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): double
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): boolean
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): character
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): integer
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): long
public static "reduceIndexed"(arg0: (short)[], arg1: $Function3$Type<(any), (any), (any), (short)>): short
public static "reduceIndexed"(arg0: (byte)[], arg1: $Function3$Type<(any), (any), (any), (byte)>): byte
public static "reduceIndexed"<S, T extends S>(arg0: (T)[], arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceIndexed"(arg0: (character)[], arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceIndexed"(arg0: (boolean)[], arg1: $Function3$Type<(any), (any), (any), (boolean)>): boolean
public static "reduceIndexed"(arg0: (double)[], arg1: $Function3$Type<(any), (any), (any), (double)>): double
public static "reduceIndexed"(arg0: (float)[], arg1: $Function3$Type<(any), (any), (any), (float)>): float
public static "reduceIndexed"(arg0: (long)[], arg1: $Function3$Type<(any), (any), (any), (long)>): long
public static "reduceIndexed"(arg0: (integer)[], arg1: $Function3$Type<(any), (any), (any), (integer)>): integer
public static "reduceOrNull"(arg0: (character)[], arg1: $Function2$Type<(any), (any), (character)>): character
public static "reduceOrNull"(arg0: (integer)[], arg1: $Function2$Type<(any), (any), (integer)>): integer
public static "reduceOrNull"(arg0: (boolean)[], arg1: $Function2$Type<(any), (any), (boolean)>): boolean
public static "reduceOrNull"(arg0: (double)[], arg1: $Function2$Type<(any), (any), (double)>): double
public static "reduceOrNull"(arg0: (float)[], arg1: $Function2$Type<(any), (any), (float)>): float
public static "reduceOrNull"(arg0: (long)[], arg1: $Function2$Type<(any), (any), (long)>): long
public static "reduceOrNull"<S, T extends S>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): S
public static "reduceOrNull"(arg0: (byte)[], arg1: $Function2$Type<(any), (any), (byte)>): byte
public static "reduceOrNull"(arg0: (short)[], arg1: $Function2$Type<(any), (any), (short)>): short
public static "maxWithOrNull"(arg0: (character)[], arg1: $Comparator$Type<(any)>): character
public static "maxWithOrNull"(arg0: (integer)[], arg1: $Comparator$Type<(any)>): integer
public static "maxWithOrNull"(arg0: (long)[], arg1: $Comparator$Type<(any)>): long
public static "maxWithOrNull"(arg0: (float)[], arg1: $Comparator$Type<(any)>): float
public static "maxWithOrNull"(arg0: (double)[], arg1: $Comparator$Type<(any)>): double
public static "maxWithOrNull"(arg0: (short)[], arg1: $Comparator$Type<(any)>): short
public static "maxWithOrNull"(arg0: (byte)[], arg1: $Comparator$Type<(any)>): byte
public static "maxWithOrNull"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): T
public static "maxWithOrNull"(arg0: (boolean)[], arg1: $Comparator$Type<(any)>): boolean
public static "minWithOrNull"(arg0: (integer)[], arg1: $Comparator$Type<(any)>): integer
public static "minWithOrNull"(arg0: (long)[], arg1: $Comparator$Type<(any)>): long
public static "minWithOrNull"(arg0: (boolean)[], arg1: $Comparator$Type<(any)>): boolean
public static "minWithOrNull"(arg0: (character)[], arg1: $Comparator$Type<(any)>): character
public static "minWithOrNull"(arg0: (short)[], arg1: $Comparator$Type<(any)>): short
public static "minWithOrNull"(arg0: (byte)[], arg1: $Comparator$Type<(any)>): byte
public static "minWithOrNull"(arg0: (double)[], arg1: $Comparator$Type<(any)>): double
public static "minWithOrNull"(arg0: (float)[], arg1: $Comparator$Type<(any)>): float
public static "minWithOrNull"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): T
public static "mapNotNullTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "maxOrNull"(arg0: (double)[]): double
public static "maxOrNull"(arg0: (character)[]): character
public static "maxOrNull"(arg0: (float)[]): float
public static "maxOrNull"(arg0: (long)[]): long
public static "maxOrNull"(arg0: (integer)[]): integer
public static "maxOrNull"<T extends $Comparable<(any)>>(arg0: (T)[]): T
public static "maxOrNull"(arg0: (short)[]): short
public static "maxOrNull"(arg0: (byte)[]): byte
public static "maxOrNull"(arg0: (float)[]): float
public static "maxOrNull"(arg0: (double)[]): double
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (boolean)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (double)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (long)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (byte)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (character)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (short)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (integer)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: (float)[], arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): double
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): boolean
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): float
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): integer
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): short
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): byte
public static "maxByOrNull"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): T
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): character
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): long
public static "sumOfLong"(arg0: (long)[]): long
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $List<(long)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $List<(integer)>
public static "sortedBy"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $List<(short)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $List<(byte)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $List<(double)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $List<(float)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $List<(character)>
public static "sortedBy"<R extends $Comparable<(any)>>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $List<(boolean)>
public static "sumOfDouble"(arg0: (double)[]): double
public static "runningFoldIndexed"<T, R>(arg0: (T)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "requireNoNulls"<T>(arg0: (T)[]): (T)[]
public static "singleOrNull"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "singleOrNull"(arg0: (short)[]): short
public static "singleOrNull"(arg0: (character)[]): character
public static "singleOrNull"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "singleOrNull"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "singleOrNull"(arg0: (integer)[]): integer
public static "singleOrNull"(arg0: (long)[]): long
public static "singleOrNull"(arg0: (float)[]): float
public static "singleOrNull"(arg0: (double)[]): double
public static "singleOrNull"<T>(arg0: (T)[]): T
public static "singleOrNull"(arg0: (byte)[]): byte
public static "singleOrNull"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "singleOrNull"(arg0: (boolean)[]): boolean
public static "singleOrNull"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "singleOrNull"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "singleOrNull"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "singleOrNull"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "singleOrNull"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "sumBy"(arg0: (short)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (byte)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (boolean)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (integer)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (character)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (float)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (double)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sumBy"(arg0: (long)[], arg1: $Function1$Type<(any), (integer)>): integer
public static "sortedWith"(arg0: (long)[], arg1: $Comparator$Type<(any)>): $List<(long)>
public static "sortedWith"(arg0: (short)[], arg1: $Comparator$Type<(any)>): $List<(short)>
public static "sortedWith"(arg0: (integer)[], arg1: $Comparator$Type<(any)>): $List<(integer)>
public static "sortedWith"(arg0: (character)[], arg1: $Comparator$Type<(any)>): $List<(character)>
public static "sortedWith"(arg0: (double)[], arg1: $Comparator$Type<(any)>): $List<(double)>
public static "sortedWith"(arg0: (float)[], arg1: $Comparator$Type<(any)>): $List<(float)>
public static "sortedWith"(arg0: (boolean)[], arg1: $Comparator$Type<(any)>): $List<(boolean)>
public static "sortedWith"(arg0: (byte)[], arg1: $Comparator$Type<(any)>): $List<(byte)>
public static "sortedWith"<T>(arg0: (T)[], arg1: $Comparator$Type<(any)>): $List<(T)>
public static "sumOfByte"(arg0: (byte)[]): integer
public static "sumOfShort"(arg0: (short)[]): integer
public static "scanIndexed"<T, R>(arg0: (T)[], arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "sumOfInt"(arg0: (integer)[]): integer
public static "toMutableSet"(arg0: (long)[]): $Set<(long)>
public static "toMutableSet"(arg0: (character)[]): $Set<(character)>
public static "toMutableSet"(arg0: (float)[]): $Set<(float)>
public static "toMutableSet"(arg0: (boolean)[]): $Set<(boolean)>
public static "toMutableSet"(arg0: (double)[]): $Set<(double)>
public static "toMutableSet"<T>(arg0: (T)[]): $Set<(T)>
public static "toMutableSet"(arg0: (byte)[]): $Set<(byte)>
public static "toMutableSet"(arg0: (short)[]): $Set<(short)>
public static "toMutableSet"(arg0: (integer)[]): $Set<(integer)>
public static "runningFold"<T, R>(arg0: (T)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "sumByDouble"(arg0: (short)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (boolean)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (long)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (byte)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (integer)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (double)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (float)[], arg1: $Function1$Type<(any), (double)>): double
public static "sumByDouble"(arg0: (character)[], arg1: $Function1$Type<(any), (double)>): double
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (character)[], arg1: $Function1$Type<(any), (any)>): $List<(character)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (boolean)[], arg1: $Function1$Type<(any), (any)>): $List<(boolean)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (double)[], arg1: $Function1$Type<(any), (any)>): $List<(double)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (short)[], arg1: $Function1$Type<(any), (any)>): $List<(short)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (byte)[], arg1: $Function1$Type<(any), (any)>): $List<(byte)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (integer)[], arg1: $Function1$Type<(any), (any)>): $List<(integer)>
public static "sortedByDescending"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(T)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (long)[], arg1: $Function1$Type<(any), (any)>): $List<(long)>
public static "sortedByDescending"<R extends $Comparable<(any)>>(arg0: (float)[], arg1: $Function1$Type<(any), (any)>): $List<(float)>
public static "runningReduce"<S, T extends S>(arg0: (T)[], arg1: $Function2$Type<(any), (any), (any)>): $List<(S)>
public static "sortedDescending"(arg0: (double)[]): $List<(double)>
public static "sortedDescending"(arg0: (long)[]): $List<(long)>
public static "sortedDescending"(arg0: (float)[]): $List<(float)>
public static "sortedDescending"<T extends $Comparable<(any)>>(arg0: (T)[]): $List<(T)>
public static "sortedDescending"(arg0: (byte)[]): $List<(byte)>
public static "sortedDescending"(arg0: (short)[]): $List<(short)>
public static "sortedDescending"(arg0: (integer)[]): $List<(integer)>
public static "sortedDescending"(arg0: (character)[]): $List<(character)>
public static "sumOfFloat"(arg0: (float)[]): float
public static "toHashSet"(arg0: (short)[]): $HashSet<(short)>
public static "toHashSet"(arg0: (integer)[]): $HashSet<(integer)>
public static "toHashSet"(arg0: (long)[]): $HashSet<(long)>
public static "toHashSet"(arg0: (byte)[]): $HashSet<(byte)>
public static "toHashSet"<T>(arg0: (T)[]): $HashSet<(T)>
public static "toHashSet"(arg0: (boolean)[]): $HashSet<(boolean)>
public static "toHashSet"(arg0: (character)[]): $HashSet<(character)>
public static "toHashSet"(arg0: (float)[]): $HashSet<(float)>
public static "toHashSet"(arg0: (double)[]): $HashSet<(double)>
public static "fold"<T, R>(arg0: (T)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (byte)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (short)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (integer)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (double)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (float)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (character)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (long)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "fold"<R>(arg0: (boolean)[], arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "sortDescending"<T extends $Comparable<(any)>>(arg0: (T)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (character)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (double)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (float)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (double)[]): void
public static "sortDescending"(arg0: (float)[]): void
public static "sortDescending"(arg0: (long)[]): void
public static "sortDescending"(arg0: (character)[]): void
public static "sortDescending"(arg0: (short)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "sortDescending"(arg0: (integer)[]): void
public static "sortDescending"<T extends $Comparable<(any)>>(arg0: (T)[]): void
public static "sortDescending"(arg0: (byte)[]): void
public static "sortDescending"(arg0: (short)[]): void
public static "sortDescending"(arg0: (long)[], arg1: integer, arg2: integer): void
public static "toShortArray"(arg0: (short)[]): (short)[]
public static "toMutableList"(arg0: (short)[]): $List<(short)>
public static "toMutableList"(arg0: (byte)[]): $List<(byte)>
public static "toMutableList"(arg0: (character)[]): $List<(character)>
public static "toMutableList"<T>(arg0: (T)[]): $List<(T)>
public static "toMutableList"(arg0: (integer)[]): $List<(integer)>
public static "toMutableList"(arg0: (float)[]): $List<(float)>
public static "toMutableList"(arg0: (double)[]): $List<(double)>
public static "toMutableList"(arg0: (long)[]): $List<(long)>
public static "toMutableList"(arg0: (boolean)[]): $List<(boolean)>
public static "getIndices"(arg0: (double)[]): $IntRange
public static "getIndices"(arg0: (float)[]): $IntRange
public static "getIndices"(arg0: (long)[]): $IntRange
public static "getIndices"(arg0: (integer)[]): $IntRange
public static "getIndices"(arg0: (character)[]): $IntRange
public static "getIndices"(arg0: (boolean)[]): $IntRange
public static "getIndices"(arg0: (short)[]): $IntRange
public static "getIndices"(arg0: (byte)[]): $IntRange
public static "getIndices"<T>(arg0: (T)[]): $IntRange
public static "filterNotNull"<T>(arg0: (T)[]): $List<(T)>
public static "withIndex"(arg0: (character)[]): $Iterable<($IndexedValue<(character)>)>
public static "withIndex"(arg0: (boolean)[]): $Iterable<($IndexedValue<(boolean)>)>
public static "withIndex"<T>(arg0: (T)[]): $Iterable<($IndexedValue<(T)>)>
public static "withIndex"(arg0: (float)[]): $Iterable<($IndexedValue<(float)>)>
public static "withIndex"(arg0: (double)[]): $Iterable<($IndexedValue<(double)>)>
public static "withIndex"(arg0: (byte)[]): $Iterable<($IndexedValue<(byte)>)>
public static "withIndex"(arg0: (short)[]): $Iterable<($IndexedValue<(short)>)>
public static "withIndex"(arg0: (long)[]): $Iterable<($IndexedValue<(long)>)>
public static "withIndex"(arg0: (integer)[]): $Iterable<($IndexedValue<(integer)>)>
public static "flatMapSequenceTo"<T, R, C extends $Collection<(any)>>(arg0: (T)[], arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "flatMapSequence"<T, R>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "sortByDescending"<T, R extends $Comparable<(any)>>(arg0: (T)[], arg1: $Function1$Type<(any), (any)>): void
public static "lastOrNull"(arg0: (double)[], arg1: $Function1$Type<(any), (boolean)>): double
public static "lastOrNull"(arg0: (float)[], arg1: $Function1$Type<(any), (boolean)>): float
public static "lastOrNull"(arg0: (long)[], arg1: $Function1$Type<(any), (boolean)>): long
public static "lastOrNull"(arg0: (boolean)[], arg1: $Function1$Type<(any), (boolean)>): boolean
public static "lastOrNull"(arg0: (character)[], arg1: $Function1$Type<(any), (boolean)>): character
public static "lastOrNull"(arg0: (byte)[]): byte
public static "lastOrNull"<T>(arg0: (T)[], arg1: $Function1$Type<(any), (boolean)>): T
public static "lastOrNull"(arg0: (byte)[], arg1: $Function1$Type<(any), (boolean)>): byte
public static "lastOrNull"(arg0: (short)[], arg1: $Function1$Type<(any), (boolean)>): short
public static "lastOrNull"(arg0: (integer)[], arg1: $Function1$Type<(any), (boolean)>): integer
public static "lastOrNull"(arg0: (double)[]): double
public static "lastOrNull"(arg0: (float)[]): float
public static "lastOrNull"(arg0: (long)[]): long
public static "lastOrNull"(arg0: (integer)[]): integer
public static "lastOrNull"<T>(arg0: (T)[]): T
public static "lastOrNull"(arg0: (character)[]): character
public static "lastOrNull"(arg0: (short)[]): short
public static "lastOrNull"(arg0: (boolean)[]): boolean
public static "reversedArray"(arg0: (character)[]): (character)[]
public static "reversedArray"(arg0: (short)[]): (short)[]
public static "reversedArray"(arg0: (integer)[]): (integer)[]
public static "reversedArray"(arg0: (long)[]): (long)[]
public static "reversedArray"(arg0: (double)[]): (double)[]
public static "reversedArray"(arg0: (boolean)[]): (boolean)[]
public static "reversedArray"(arg0: (float)[]): (float)[]
public static "reversedArray"<T>(arg0: (T)[]): (T)[]
public static "reversedArray"(arg0: (byte)[]): (byte)[]
public static "sliceArray"<T>(arg0: (T)[], arg1: $IntRange$Type): (T)[]
public static "sliceArray"(arg0: (byte)[], arg1: $IntRange$Type): (byte)[]
public static "sliceArray"(arg0: (boolean)[], arg1: $Collection$Type<(integer)>): (boolean)[]
public static "sliceArray"(arg0: (character)[], arg1: $Collection$Type<(integer)>): (character)[]
public static "sliceArray"(arg0: (integer)[], arg1: $IntRange$Type): (integer)[]
public static "sliceArray"(arg0: (short)[], arg1: $IntRange$Type): (short)[]
public static "sliceArray"(arg0: (long)[], arg1: $IntRange$Type): (long)[]
public static "sliceArray"(arg0: (float)[], arg1: $IntRange$Type): (float)[]
public static "sliceArray"(arg0: (byte)[], arg1: $Collection$Type<(integer)>): (byte)[]
public static "sliceArray"(arg0: (short)[], arg1: $Collection$Type<(integer)>): (short)[]
public static "sliceArray"(arg0: (integer)[], arg1: $Collection$Type<(integer)>): (integer)[]
public static "sliceArray"(arg0: (long)[], arg1: $Collection$Type<(integer)>): (long)[]
public static "sliceArray"<T>(arg0: (T)[], arg1: $Collection$Type<(integer)>): (T)[]
public static "sliceArray"(arg0: (boolean)[], arg1: $IntRange$Type): (boolean)[]
public static "sliceArray"(arg0: (character)[], arg1: $IntRange$Type): (character)[]
public static "sliceArray"(arg0: (double)[], arg1: $IntRange$Type): (double)[]
public static "sliceArray"(arg0: (double)[], arg1: $Collection$Type<(integer)>): (double)[]
public static "sliceArray"(arg0: (float)[], arg1: $Collection$Type<(integer)>): (float)[]
public static "sortedArray"<T extends $Comparable<(any)>>(arg0: (T)[]): (T)[]
public static "sortedArray"(arg0: (byte)[]): (byte)[]
public static "sortedArray"(arg0: (character)[]): (character)[]
public static "sortedArray"(arg0: (float)[]): (float)[]
public static "sortedArray"(arg0: (long)[]): (long)[]
public static "sortedArray"(arg0: (integer)[]): (integer)[]
public static "sortedArray"(arg0: (short)[]): (short)[]
public static "sortedArray"(arg0: (double)[]): (double)[]
public static "reduceRightIndexedOrNull"(arg0: (character)[], arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceRightIndexedOrNull"<S, T extends S>(arg0: (T)[], arg1: $Function3$Type<(any), (any), (any), (any)>): S
public static "reduceRightIndexedOrNull"(arg0: (long)[], arg1: $Function3$Type<(any), (any), (any), (long)>): long
public static "reduceRightIndexedOrNull"(arg0: (integer)[], arg1: $Function3$Type<(any), (any), (any), (integer)>): integer
public static "reduceRightIndexedOrNull"(arg0: (short)[], arg1: $Function3$Type<(any), (any), (any), (short)>): short
public static "reduceRightIndexedOrNull"(arg0: (byte)[], arg1: $Function3$Type<(any), (any), (any), (byte)>): byte
public static "reduceRightIndexedOrNull"(arg0: (float)[], arg1: $Function3$Type<(any), (any), (any), (float)>): float
public static "reduceRightIndexedOrNull"(arg0: (double)[], arg1: $Function3$Type<(any), (any), (any), (double)>): double
public static "reduceRightIndexedOrNull"(arg0: (boolean)[], arg1: $Function3$Type<(any), (any), (any), (boolean)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArraysKt___ArraysKt$Type = ($ArraysKt___ArraysKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArraysKt___ArraysKt_ = $ArraysKt___ArraysKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$FilterMapping" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"

export class $FilterMapping implements $Dumpable {
static readonly "DEFAULT": integer
static readonly "REQUEST": integer
static readonly "FORWARD": integer
static readonly "INCLUDE": integer
static readonly "ERROR": integer
static readonly "ASYNC": integer
static readonly "ALL": integer

constructor()

public "setPathSpec"(arg0: string): void
public "getServletNames"(): (string)[]
public static "dispatch"(arg0: string): $DispatcherType
public static "dispatch"(arg0: $DispatcherType$Type): integer
public "toString"(): string
public "appliesTo"(arg0: $DispatcherType$Type): boolean
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "setServletNames"(arg0: (string)[]): void
public "getFilterName"(): string
public "getPathSpecs"(): (string)[]
public "setFilterName"(arg0: string): void
public "setDispatcherTypes"(arg0: $EnumSet$Type<($DispatcherType$Type)>): void
public "setServletName"(arg0: string): void
public "setDispatches"(arg0: integer): void
public "isDefaultDispatches"(): boolean
public "setPathSpecs"(arg0: (string)[]): void
public "getDispatcherTypes"(): $EnumSet<($DispatcherType)>
set "pathSpec"(value: string)
get "servletNames"(): (string)[]
set "servletNames"(value: (string)[])
get "filterName"(): string
get "pathSpecs"(): (string)[]
set "filterName"(value: string)
set "dispatcherTypes"(value: $EnumSet$Type<($DispatcherType$Type)>)
set "servletName"(value: string)
set "dispatches"(value: integer)
get "defaultDispatches"(): boolean
set "pathSpecs"(value: (string)[])
get "dispatcherTypes"(): $EnumSet<($DispatcherType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterMapping$Type = ($FilterMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterMapping_ = $FilterMapping$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringNumberConversionsJVMKt" {
import {$BigInteger, $BigInteger$Type} from "packages/java/math/$BigInteger"
import {$BigDecimal, $BigDecimal$Type} from "packages/java/math/$BigDecimal"
import {$StringsKt__StringBuilderKt, $StringsKt__StringBuilderKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringBuilderKt"
import {$MathContext, $MathContext$Type} from "packages/java/math/$MathContext"

export class $StringsKt__StringNumberConversionsJVMKt extends $StringsKt__StringBuilderKt {

constructor()

public static "toBigIntegerOrNull"(arg0: string): $BigInteger
public static "toBigIntegerOrNull"(arg0: string, arg1: integer): $BigInteger
public static "toBigDecimalOrNull"(arg0: string, arg1: $MathContext$Type): $BigDecimal
public static "toBigDecimalOrNull"(arg0: string): $BigDecimal
public static "toDoubleOrNull"(arg0: string): double
public static "toFloatOrNull"(arg0: string): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringNumberConversionsJVMKt$Type = ($StringsKt__StringNumberConversionsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringNumberConversionsJVMKt_ = $StringsKt__StringNumberConversionsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$NullSessionDataStore" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$AbstractSessionDataStore, $AbstractSessionDataStore$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$AbstractSessionDataStore"
import {$SessionData, $SessionData$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/session/$SessionData"

export class $NullSessionDataStore extends $AbstractSessionDataStore {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "load"(arg0: string): $SessionData
public "delete"(arg0: string): boolean
public "exists"(arg0: string): boolean
public "doStore"(arg0: string, arg1: $SessionData$Type, arg2: long): void
public "doGetExpired"(arg0: $Set$Type<(string)>): $Set<(string)>
public "isPassivating"(): boolean
public "newSessionData"(arg0: string, arg1: long, arg2: long, arg3: long, arg4: long): $SessionData
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "passivating"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NullSessionDataStore$Type = ($NullSessionDataStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NullSessionDataStore_ = $NullSessionDataStore$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Destroyable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Destroyable {

 "destroy"(): void

(): void
}

export namespace $Destroyable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Destroyable$Type = ($Destroyable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Destroyable_ = $Destroyable$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$OverloadResolutionByLambdaReturnType" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $OverloadResolutionByLambdaReturnType extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $OverloadResolutionByLambdaReturnType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverloadResolutionByLambdaReturnType$Type = ($OverloadResolutionByLambdaReturnType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverloadResolutionByLambdaReturnType_ = $OverloadResolutionByLambdaReturnType$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$PongFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/frames/$ControlFrame"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $PongFrame extends $ControlFrame {
static readonly "MAX_CONTROL_PAYLOAD": integer

constructor()

public "getType"(): $Frame$Type
public "setPayload"(arg0: (byte)[]): $PongFrame
public "setPayload"(arg0: string): $PongFrame
get "type"(): $Frame$Type
set "payload"(value: (byte)[])
set "payload"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PongFrame$Type = ($PongFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PongFrame_ = $PongFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$CharProgression, $CharProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression"

export class $CharProgression$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "fromClosedRange"(arg0: character, arg1: character, arg2: integer): $CharProgression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharProgression$Companion$Type = ($CharProgression$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharProgression$Companion_ = $CharProgression$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequencesJVMKt" {
import {$SequencesKt__SequenceBuilderKt, $SequencesKt__SequenceBuilderKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt__SequenceBuilderKt"

export class $SequencesKt__SequencesJVMKt extends $SequencesKt__SequenceBuilderKt {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt__SequencesJVMKt$Type = ($SequencesKt__SequencesJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt__SequencesJVMKt_ = $SequencesKt__SequencesJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$ContinuationInterceptor$Key" {
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$ContinuationInterceptor, $ContinuationInterceptor$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$ContinuationInterceptor"

export class $ContinuationInterceptor$Key implements $CoroutineContext$Key<($ContinuationInterceptor)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinuationInterceptor$Key$Type = ($ContinuationInterceptor$Key);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinuationInterceptor$Key_ = $ContinuationInterceptor$Key$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$MappedByteBufferPool" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ByteBufferPool$Bucket, $ByteBufferPool$Bucket$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool$Bucket"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $MappedByteBufferPool implements $ByteBufferPool {

constructor()
constructor(arg0: integer, arg1: integer, arg2: $Function$Type<(integer), ($ByteBufferPool$Bucket$Type)>)
constructor(arg0: integer, arg1: integer)
constructor(arg0: integer)

public "clear"(): void
public "release"(arg0: $ByteBuffer$Type): void
public "acquire"(arg0: integer, arg1: boolean): $ByteBuffer
public "newByteBuffer"(arg0: integer, arg1: boolean): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MappedByteBufferPool$Type = ($MappedByteBufferPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MappedByteBufferPool_ = $MappedByteBufferPool$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$CloseableKt" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export class $CloseableKt {


public static "closeFinally"(arg0: $Closeable$Type, arg1: $Throwable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseableKt$Type = ($CloseableKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseableKt_ = $CloseableKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1$Setter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$KMutableProperty$Setter, $KMutableProperty$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty$Setter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty1$Setter<T, V> extends $KMutableProperty$Setter<(V)>, $Function2<(T), (V), ($Unit)> {

 "invoke"(arg0: T, arg1: V): $Unit
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): $Unit
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): $Unit
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty1$Setter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty1$Setter$Type<T, V> = ($KMutableProperty1$Setter<(T), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty1$Setter_<T, V> = $KMutableProperty1$Setter$Type<(T), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/serialization/$Serializer" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"

export class $Serializer {

constructor()

public "process"(arg0: $OutputStream$Type, arg1: any): void
public "setNext"(arg0: $Serializer$Type): void
public "canProcess"(arg0: any): boolean
public "processElement"(arg0: $OutputStream$Type, arg1: any): void
set "next"(value: $Serializer$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Serializer$Type = ($Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Serializer_ = $Serializer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RunAsToken" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RunAsToken {

}

export namespace $RunAsToken {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RunAsToken$Type = ($RunAsToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RunAsToken_ = $RunAsToken$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$GeneratorSequence" {
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $GeneratorSequence<T> implements $Sequence<(T)> {

constructor(arg0: $Function0$Type<(any)>, arg1: $Function1$Type<(any), (any)>)

public "iterator"(): $Iterator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratorSequence$Type<T> = ($GeneratorSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratorSequence_<T> = $GeneratorSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$WebConnection" {
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"

export interface $WebConnection extends $AutoCloseable {

 "getInputStream"(): $ServletInputStream
 "getOutputStream"(): $ServletOutputStream
 "close"(): void
}

export namespace $WebConnection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebConnection$Type = ($WebConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebConnection_ = $WebConnection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$ProtocolException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CloseException, $CloseException$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseException"

export class $ProtocolException extends $CloseException {

constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtocolException$Type = ($ProtocolException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtocolException_ = $ProtocolException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$UpgradeFrom" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $Connection$UpgradeFrom {

 "onUpgradeFrom"(): $ByteBuffer

(): $ByteBuffer
}

export namespace $Connection$UpgradeFrom {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Connection$UpgradeFrom$Type = ($Connection$UpgradeFrom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Connection$UpgradeFrom_ = $Connection$UpgradeFrom$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$LoginService" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$IdentityService, $IdentityService$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$IdentityService"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"

export interface $LoginService {

 "setIdentityService"(arg0: $IdentityService$Type): void
 "getIdentityService"(): $IdentityService
 "getName"(): string
 "validate"(arg0: $UserIdentity$Type): boolean
 "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $UserIdentity
 "logout"(arg0: $UserIdentity$Type): void
}

export namespace $LoginService {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoginService$Type = ($LoginService);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoginService_ = $LoginService$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ReadableByteChannel, $ReadableByteChannel$Type} from "packages/java/nio/channels/$ReadableByteChannel"
import {$File, $File$Type} from "packages/java/io/$File"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$ResourceFactory, $ResourceFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$ResourceFactory"

export class $Resource implements $ResourceFactory, $Closeable {
static "__defaultUseCaches": boolean

constructor()

public static "newClassPathResource"(arg0: string, arg1: boolean, arg2: boolean): $Resource
public static "newClassPathResource"(arg0: string): $Resource
public "getReadableByteChannel"(): $ReadableByteChannel
public "getName"(): string
public "length"(): long
/**
 * 
 * @deprecated
 */
public "encode"(arg0: string): string
public "list"(): (string)[]
public "getResource"(arg0: string): $Resource
public "delete"(): boolean
public "close"(): void
public "getInputStream"(): $InputStream
public "getFile"(): $File
public static "toURL"(arg0: $File$Type): $URL
public "release"(): void
public "exists"(): boolean
public "renameTo"(arg0: $Resource$Type): boolean
public "isDirectory"(): boolean
public "lastModified"(): long
public "writeTo"(arg0: $OutputStream$Type, arg1: long, arg2: long): void
public static "newResource"(arg0: $URI$Type): $Resource
public static "newResource"(arg0: string): $Resource
public static "newResource"(arg0: $URL$Type): $Resource
public static "newResource"(arg0: string, arg1: boolean): $Resource
public static "newResource"(arg0: $File$Type): $Resource
/**
 * 
 * @deprecated
 */
public "getURL"(): $URL
public static "setDefaultUseCaches"(arg0: boolean): void
public static "getDefaultUseCaches"(): boolean
public "getURI"(): $URI
public "isAlias"(): boolean
public "getListHTML"(arg0: string, arg1: boolean): string
public "addPath"(arg0: string): $Resource
public "getAssociate"(): any
public static "newSystemResource"(arg0: string): $Resource
public "setAssociate"(arg0: any): void
public "isContainedIn"(arg0: $Resource$Type): boolean
public static "isContainedIn"(arg0: $Resource$Type, arg1: $Resource$Type): boolean
public "getWeakETag"(arg0: string): string
public "getWeakETag"(): string
public "copyTo"(arg0: $File$Type): void
public "getAlias"(): $URI
public "getAllResources"(): $Collection<($Resource)>
get "readableByteChannel"(): $ReadableByteChannel
get "name"(): string
get "inputStream"(): $InputStream
get "file"(): $File
get "directory"(): boolean
get "uRL"(): $URL
set "defaultUseCaches"(value: boolean)
get "defaultUseCaches"(): boolean
get "uRI"(): $URI
get "alias"(): boolean
get "associate"(): any
set "associate"(value: any)
get "weakETag"(): string
get "alias"(): $URI
get "allResources"(): $Collection<($Resource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Resource$Type = ($Resource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Resource_ = $Resource$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/math/$MathKt" {
import {$MathKt__MathJVMKt, $MathKt__MathJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/math/$MathKt__MathJVMKt"

export class $MathKt extends $MathKt__MathJVMKt {
static readonly "PI": double
static readonly "E": double


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MathKt$Type = ($MathKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MathKt_ = $MathKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AsyncContextEvent" {
import {$AsyncContextState, $AsyncContextState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AsyncContextState"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$AsyncEvent, $AsyncEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncEvent"
import {$ContextHandler$Context, $ContextHandler$Context$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$Context"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$Scheduler$Task, $Scheduler$Task$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler$Task"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"

export class $AsyncContextEvent extends $AsyncEvent implements $Runnable {

constructor(arg0: $ContextHandler$Context$Type, arg1: $AsyncContextState$Type, arg2: $HttpChannelState$Type, arg3: $Request$Type, arg4: $ServletRequest$Type, arg5: $ServletResponse$Type)

public "addThrowable"(arg0: $Throwable$Type): void
public "cancelTimeoutTask"(): void
public "getDispatchContext"(): $ServletContext
public "hasTimeoutTask"(): boolean
public "run"(): void
public "getContext"(): $ContextHandler$Context
public "getPath"(): string
public "completed"(): void
public "setTimeoutTask"(arg0: $Scheduler$Task$Type): void
public "setDispatchPath"(arg0: string): void
public "setDispatchContext"(arg0: $ServletContext$Type): void
public "getThrowable"(): $Throwable
public "getHttpChannelState"(): $HttpChannelState
public "getServletContext"(): $ServletContext
public "getAsyncContext"(): $AsyncContext
public "getSuspendedContext"(): $ServletContext
get "dispatchContext"(): $ServletContext
get "context"(): $ContextHandler$Context
get "path"(): string
set "timeoutTask"(value: $Scheduler$Task$Type)
set "dispatchPath"(value: string)
set "dispatchContext"(value: $ServletContext$Type)
get "throwable"(): $Throwable
get "httpChannelState"(): $HttpChannelState
get "servletContext"(): $ServletContext
get "asyncContext"(): $AsyncContext
get "suspendedContext"(): $ServletContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncContextEvent$Type = ($AsyncContextEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncContextEvent_ = $AsyncContextEvent$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Triple" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"

export class $Triple<A, B, C> implements $Serializable {

constructor(arg0: A, arg1: B, arg2: C)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "copy"(arg0: A, arg1: B, arg2: C): $Triple<(A), (B), (C)>
public "getFirst"(): A
public "getSecond"(): B
public "component2"(): B
public "component3"(): C
public "component1"(): A
public "getThird"(): C
get "first"(): A
get "second"(): B
get "third"(): C
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Triple$Type<A, B, C> = ($Triple<(A), (B), (C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Triple_<A, B, C> = $Triple$Type<(A), (B), (C)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$ProgressionUtilKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ProgressionUtilKt {


public static "getProgressionLastElement"(arg0: integer, arg1: integer, arg2: integer): integer
public static "getProgressionLastElement"(arg0: long, arg1: long, arg2: long): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressionUtilKt$Type = ($ProgressionUtilKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressionUtilKt_ = $ProgressionUtilKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Generator" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $Generator {
static readonly "MAX_HEADER_LENGTH": integer

constructor(arg0: $WebSocketPolicy$Type, arg1: $ByteBufferPool$Type, arg2: boolean, arg3: boolean)
constructor(arg0: $WebSocketPolicy$Type, arg1: $ByteBufferPool$Type, arg2: boolean)
constructor(arg0: $WebSocketPolicy$Type, arg1: $ByteBufferPool$Type)

public "toString"(): string
public "getBufferPool"(): $ByteBufferPool
public "assertFrameValid"(arg0: $Frame$Type): void
public "isRsv2InUse"(): boolean
public "setRsv2InUse"(arg0: boolean): void
public "setRsv3InUse"(arg0: boolean): void
public "isRsv3InUse"(): boolean
public "generateWholeFrame"(arg0: $Frame$Type, arg1: $ByteBuffer$Type): void
public "setRsv1InUse"(arg0: boolean): void
public "isRsv1InUse"(): boolean
public "generateHeaderBytes"(arg0: $Frame$Type): $ByteBuffer
public "generateHeaderBytes"(arg0: $Frame$Type, arg1: $ByteBuffer$Type): void
public "configureFromExtensions"(arg0: $List$Type<(any)>): void
get "bufferPool"(): $ByteBufferPool
get "rsv2InUse"(): boolean
set "rsv2InUse"(value: boolean)
set "rsv3InUse"(value: boolean)
get "rsv3InUse"(): boolean
set "rsv1InUse"(value: boolean)
get "rsv1InUse"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Generator$Type = ($Generator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Generator_ = $Generator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayBooleanIterator" {
import {$BooleanIterator, $BooleanIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$BooleanIterator"

export class $ArrayBooleanIterator extends $BooleanIterator {

constructor(arg0: (boolean)[])

public "hasNext"(): boolean
public "nextBoolean"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayBooleanIterator$Type = ($ArrayBooleanIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayBooleanIterator_ = $ArrayBooleanIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHandler$CachedChain" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$FilterChain, $FilterChain$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterChain"

export class $ServletHandler$CachedChain implements $FilterChain {


public "doFilter"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletHandler$CachedChain$Type = ($ServletHandler$CachedChain);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletHandler$CachedChain_ = $ServletHandler$CachedChain$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$ExceptionsKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ExceptionsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionsKt$Type = ($ExceptionsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionsKt_ = $ExceptionsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Destroyable, $Destroyable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Destroyable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export interface $Handler extends $LifeCycle, $Destroyable {

 "destroy"(): void
 "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
 "setServer"(arg0: $Server$Type): void
 "getServer"(): $Server
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $Handler {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Handler$Type = ($Handler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Handler_ = $Handler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel" {
import {$HttpInput$Content, $HttpInput$Content$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Content"
import {$RequestLog, $RequestLog$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$RequestLog"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$MetaData$Request, $MetaData$Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$HttpOutput$Interceptor, $HttpOutput$Interceptor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput$Interceptor"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$HttpTransport, $HttpTransport$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpTransport"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$MetaData$Response, $MetaData$Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Response"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $HttpChannel implements $Runnable, $HttpOutput$Interceptor {

constructor(arg0: $Connector$Type, arg1: $HttpConfiguration$Type, arg2: $EndPoint$Type, arg3: $HttpTransport$Type)

public "run"(): void
public "toString"(): string
public "write"(arg0: $ByteBuffer$Type, arg1: boolean, arg2: $Callback$Type): void
public "getState"(): $HttpChannelState
public "handle"(): boolean
public "getBytesWritten"(): long
public "abort"(arg0: $Throwable$Type): void
public "getResponse"(): $Response
public "getLocalAddress"(): $InetSocketAddress
public "recycle"(): void
public "getServer"(): $Server
public "getCommittedMetaData"(): $MetaData$Response
public "getHttpConfiguration"(): $HttpConfiguration
public "isOptimizedForDirectBuffers"(): boolean
public "asyncReadFillInterested"(): void
public "getRemoteAddress"(): $InetSocketAddress
public "isExpecting100Continue"(): boolean
public "isExpecting102Processing"(): boolean
public "getScheduler"(): $Scheduler
public "onCompleted"(): void
public "getRequestLog"(): $RequestLog
public "setRequestLog"(arg0: $RequestLog$Type): void
public "isCommitted"(): boolean
public "resetBuffer"(): void
public "getEndPoint"(): $EndPoint
public "addRequestLog"(arg0: $RequestLog$Type): void
public "getByteBufferPool"(): $ByteBufferPool
public "continue100"(arg0: integer): void
public "setIdleTimeout"(arg0: long): void
public "getConnector"(): $Connector
public "getHttpTransport"(): $HttpTransport
public "getRequests"(): long
public "getIdleTimeout"(): long
public "onRequest"(arg0: $MetaData$Request$Type): void
public "onEarlyEOF"(): boolean
public "onTrailers"(arg0: $HttpFields$Type): void
public "onContentComplete"(): boolean
public "onBadMessage"(arg0: integer, arg1: string): void
public "onContent"(arg0: $HttpInput$Content$Type): boolean
public "onRequestComplete"(): boolean
public "useDirectBuffers"(): boolean
public "getNextInterceptor"(): $HttpOutput$Interceptor
public "getRequest"(): $Request
get "state"(): $HttpChannelState
get "bytesWritten"(): long
get "response"(): $Response
get "localAddress"(): $InetSocketAddress
get "server"(): $Server
get "committedMetaData"(): $MetaData$Response
get "httpConfiguration"(): $HttpConfiguration
get "optimizedForDirectBuffers"(): boolean
get "remoteAddress"(): $InetSocketAddress
get "expecting100Continue"(): boolean
get "expecting102Processing"(): boolean
get "scheduler"(): $Scheduler
get "requestLog"(): $RequestLog
set "requestLog"(value: $RequestLog$Type)
get "committed"(): boolean
get "endPoint"(): $EndPoint
get "byteBufferPool"(): $ByteBufferPool
set "idleTimeout"(value: long)
get "connector"(): $Connector
get "httpTransport"(): $HttpTransport
get "requests"(): long
get "idleTimeout"(): long
get "nextInterceptor"(): $HttpOutput$Interceptor
get "request"(): $Request
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpChannel$Type = ($HttpChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpChannel_ = $HttpChannel$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$DeferredAuthentication" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Authentication, $Authentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$Authentication$Deferred, $Authentication$Deferred$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Authentication$Deferred"
import {$LoginAuthenticator, $LoginAuthenticator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/authentication/$LoginAuthenticator"

export class $DeferredAuthentication implements $Authentication$Deferred {

constructor(arg0: $LoginAuthenticator$Type)

public "authenticate"(arg0: $ServletRequest$Type): $Authentication
public "authenticate"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $Authentication
public static "isDeferred"(arg0: $HttpServletResponse$Type): boolean
public "login"(arg0: string, arg1: any, arg2: $ServletRequest$Type): $Authentication
public "getPreviousAssociation"(): any
get "previousAssociation"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeferredAuthentication$Type = ($DeferredAuthentication);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeferredAuthentication_ = $DeferredAuthentication$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$ServletPathSpec" {
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec"

/**
 * 
 * @deprecated
 */
export class $ServletPathSpec extends $PathSpec {

constructor(arg0: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletPathSpec$Type = ($ServletPathSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletPathSpec_ = $ServletPathSpec$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer" {
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $KDeclarationContainer {

 "getMembers"(): $Collection<($KCallable<(any)>)>

(): $Collection<($KCallable<(any)>)>
}

export namespace $KDeclarationContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KDeclarationContainer$Type = ($KDeclarationContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KDeclarationContainer_ = $KDeclarationContainer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerCollection" {
import {$AbstractHandlerContainer, $AbstractHandlerContainer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandlerContainer"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $HandlerCollection extends $AbstractHandlerContainer {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()
constructor(arg0: boolean, ...arg1: ($Handler$Type)[])
constructor(...arg0: ($Handler$Type)[])

public "setHandlers"(arg0: ($Handler$Type)[]): void
public "toString"(): string
public "destroy"(): void
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "addHandler"(arg0: $Handler$Type): void
public "getHandlers"(): ($Handler)[]
public "removeHandler"(arg0: $Handler$Type): void
public "prependHandler"(arg0: $Handler$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "handlers"(value: ($Handler$Type)[])
get "handlers"(): ($Handler)[]
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandlerCollection$Type = ($HandlerCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandlerCollection_ = $HandlerCollection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslConnection" {
import {$SslConnection$DecryptedEndPoint, $SslConnection$DecryptedEndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslConnection$DecryptedEndPoint"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$SslHandshakeListener, $SslHandshakeListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslHandshakeListener"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$AbstractConnection, $AbstractConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractConnection"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $SslConnection extends $AbstractConnection {

constructor(arg0: $ByteBufferPool$Type, arg1: $Executor$Type, arg2: $EndPoint$Type, arg3: $SSLEngine$Type)

public "close"(): void
public "onClose"(): void
public "onIdleExpired"(): boolean
public "toConnectionString"(): string
public "getSSLEngine"(): $SSLEngine
public "onOpen"(): void
public "onFillable"(): void
public "addHandshakeListener"(arg0: $SslHandshakeListener$Type): void
public "removeHandshakeListener"(arg0: $SslHandshakeListener$Type): boolean
public "isRenegotiationAllowed"(): boolean
public "setRenegotiationLimit"(arg0: integer): void
public "getDecryptedEndPoint"(): $SslConnection$DecryptedEndPoint
public "setRenegotiationAllowed"(arg0: boolean): void
public "getRenegotiationLimit"(): integer
public "onFillInterestedFailed"(arg0: $Throwable$Type): void
get "sSLEngine"(): $SSLEngine
get "renegotiationAllowed"(): boolean
set "renegotiationLimit"(value: integer)
get "decryptedEndPoint"(): $SslConnection$DecryptedEndPoint
set "renegotiationAllowed"(value: boolean)
get "renegotiationLimit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslConnection$Type = ($SslConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslConnection_ = $SslConnection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ExecutionStrategy$Producer" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $ExecutionStrategy$Producer {

 "produce"(): $Runnable

(): $Runnable
}

export namespace $ExecutionStrategy$Producer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExecutionStrategy$Producer$Type = ($ExecutionStrategy$Producer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExecutionStrategy$Producer_ = $ExecutionStrategy$Producer$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$RouteGroup" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RouteGroup {

 "addRoutes"(): void

(): void
}

export namespace $RouteGroup {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteGroup$Type = ($RouteGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteGroup_ = $RouteGroup$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HandlerContainer" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"

export interface $HandlerContainer extends $LifeCycle {

 "getHandlers"(): ($Handler)[]
 "getChildHandlerByClass"<T extends $Handler>(arg0: $Class$Type<(T)>): T
 "getChildHandlersByClass"(arg0: $Class$Type<(any)>): ($Handler)[]
 "getChildHandlers"(): ($Handler)[]
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $HandlerContainer {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandlerContainer$Type = ($HandlerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandlerContainer_ = $HandlerContainer$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$HttpHandler" {
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $HttpParser$HttpHandler {

 "content"(arg0: $ByteBuffer$Type): boolean
 "earlyEOF"(): void
 "messageComplete"(): boolean
 "parsedTrailer"(arg0: $HttpField$Type): void
 "contentComplete"(): boolean
 "parsedHeader"(arg0: $HttpField$Type): void
 "headerComplete"(): boolean
 "badMessage"(arg0: integer, arg1: string): void
 "getHeaderCacheSize"(): integer
}

export namespace $HttpParser$HttpHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$HttpHandler$Type = ($HttpParser$HttpHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser$HttpHandler_ = $HttpParser$HttpHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $IntRange$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getEMPTY"(): $IntRange
get "eMPTY"(): $IntRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntRange$Companion$Type = ($IntRange$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntRange$Companion_ = $IntRange$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketSessionScope" {
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$WebSocketSession, $WebSocketSession$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketSession"

export interface $WebSocketSessionScope {

 "getWebSocketSession"(): $WebSocketSession
 "getContainerScope"(): $WebSocketContainerScope
}

export namespace $WebSocketSessionScope {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketSessionScope$Type = ($WebSocketSessionScope);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketSessionScope_ = $WebSocketSessionScope$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RoleRunAsToken" {
import {$RunAsToken, $RunAsToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$RunAsToken"

export class $RoleRunAsToken implements $RunAsToken {

constructor(arg0: string)

public "getRunAsRole"(): string
public "toString"(): string
get "runAsRole"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RoleRunAsToken$Type = ($RoleRunAsToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RoleRunAsToken_ = $RoleRunAsToken$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KClassifier {

}

export namespace $KClassifier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KClassifier$Type = ($KClassifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KClassifier_ = $KClassifier$Type;
}}
declare module "packages/info/journeymap/shaded/org/jetbrains/annotations/$Nullable" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Nullable extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Nullable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Nullable$Type = ($Nullable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Nullable_ = $Nullable$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler$StaticContext" {
import {$SessionTrackingMode, $SessionTrackingMode$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionTrackingMode"
import {$Servlet, $Servlet$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Servlet"
import {$FilterRegistration, $FilterRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletRegistration$Dynamic, $ServletRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$Filter"
import {$FilterRegistration$Dynamic, $FilterRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$FilterRegistration$Dynamic"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$AttributesMap, $AttributesMap$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AttributesMap"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ServletRegistration, $ServletRegistration$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration"
import {$JspConfigDescriptor, $JspConfigDescriptor$Type} from "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspConfigDescriptor"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$SessionCookieConfig, $SessionCookieConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$SessionCookieConfig"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ContextHandler$StaticContext extends $AttributesMap implements $ServletContext {

constructor()

public "getInitParameter"(arg0: string): string
public "setInitParameter"(arg0: string, arg1: string): boolean
public "createServlet"<T extends $Servlet>(arg0: $Class$Type<(T)>): T
public "addServlet"(arg0: string, arg1: string): $ServletRegistration$Dynamic
public "addServlet"(arg0: string, arg1: $Class$Type<(any)>): $ServletRegistration$Dynamic
public "addServlet"(arg0: string, arg1: $Servlet$Type): $ServletRegistration$Dynamic
public "getNamedDispatcher"(arg0: string): $RequestDispatcher
/**
 * 
 * @deprecated
 */
public "getServlet"(arg0: string): $Servlet
/**
 * 
 * @deprecated
 */
public "getServletNames"(): $Enumeration<(string)>
/**
 * 
 * @deprecated
 */
public "getServlets"(): $Enumeration<($Servlet)>
public "getResourcePaths"(arg0: string): $Set<(string)>
public "declareRoles"(...arg0: (string)[]): void
public "log"(arg0: $Exception$Type, arg1: string): void
public "log"(arg0: string): void
public "log"(arg0: string, arg1: $Throwable$Type): void
public "getClassLoader"(): $ClassLoader
public "getResourceAsStream"(arg0: string): $InputStream
public "getResource"(arg0: string): $URL
public "getContext"(arg0: string): $ServletContext
public "getMajorVersion"(): integer
public "getMinorVersion"(): integer
public "getRealPath"(arg0: string): string
public "getMimeType"(arg0: string): string
public "createFilter"<T extends $Filter>(arg0: $Class$Type<(T)>): T
public "getRequestDispatcher"(arg0: string): $RequestDispatcher
public "createListener"<T extends $EventListener>(arg0: $Class$Type<(T)>): T
public "getContextPath"(): string
public "getServerInfo"(): string
public "addListener"(arg0: string): void
public "addListener"<T extends $EventListener>(arg0: T): void
public "addListener"(arg0: $Class$Type<(any)>): void
public "addFilter"(arg0: string, arg1: string): $FilterRegistration$Dynamic
public "addFilter"(arg0: string, arg1: $Class$Type<(any)>): $FilterRegistration$Dynamic
public "addFilter"(arg0: string, arg1: $Filter$Type): $FilterRegistration$Dynamic
public "setEffectiveMajorVersion"(arg0: integer): void
public "setEffectiveMinorVersion"(arg0: integer): void
public "getInitParameterNames"(): $Enumeration<(string)>
public "getEffectiveMinorVersion"(): integer
public "setSessionTrackingModes"(arg0: $Set$Type<($SessionTrackingMode$Type)>): void
public "getFilterRegistration"(arg0: string): $FilterRegistration
public "getServletRegistration"(arg0: string): $ServletRegistration
public "getVirtualServerName"(): string
public "getFilterRegistrations"(): $Map<(string), (any)>
public "getSessionCookieConfig"(): $SessionCookieConfig
public "getEffectiveSessionTrackingModes"(): $Set<($SessionTrackingMode)>
public "getJspConfigDescriptor"(): $JspConfigDescriptor
public "getServletContextName"(): string
public "getServletRegistrations"(): $Map<(string), (any)>
public "getDefaultSessionTrackingModes"(): $Set<($SessionTrackingMode)>
public "getEffectiveMajorVersion"(): integer
public "addJspFile"(arg0: string, arg1: string): $ServletRegistration$Dynamic
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "removeAttribute"(arg0: string): void
public "setSessionTimeout"(arg0: integer): void
public "getSessionTimeout"(): integer
public "getAttributeNames"(): $Enumeration<(string)>
public "getResponseCharacterEncoding"(): string
public "setResponseCharacterEncoding"(arg0: string): void
public "setRequestCharacterEncoding"(arg0: string): void
public "getRequestCharacterEncoding"(): string
get "servletNames"(): $Enumeration<(string)>
get "servlets"(): $Enumeration<($Servlet)>
get "classLoader"(): $ClassLoader
get "majorVersion"(): integer
get "minorVersion"(): integer
get "contextPath"(): string
get "serverInfo"(): string
set "effectiveMajorVersion"(value: integer)
set "effectiveMinorVersion"(value: integer)
get "initParameterNames"(): $Enumeration<(string)>
get "effectiveMinorVersion"(): integer
set "sessionTrackingModes"(value: $Set$Type<($SessionTrackingMode$Type)>)
get "virtualServerName"(): string
get "filterRegistrations"(): $Map<(string), (any)>
get "sessionCookieConfig"(): $SessionCookieConfig
get "effectiveSessionTrackingModes"(): $Set<($SessionTrackingMode)>
get "jspConfigDescriptor"(): $JspConfigDescriptor
get "servletContextName"(): string
get "servletRegistrations"(): $Map<(string), (any)>
get "defaultSessionTrackingModes"(): $Set<($SessionTrackingMode)>
get "effectiveMajorVersion"(): integer
set "sessionTimeout"(value: integer)
get "sessionTimeout"(): integer
get "attributeNames"(): $Enumeration<(string)>
get "responseCharacterEncoding"(): string
set "responseCharacterEncoding"(value: string)
set "requestCharacterEncoding"(value: string)
get "requestCharacterEncoding"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextHandler$StaticContext$Type = ($ContextHandler$StaticContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextHandler$StaticContext_ = $ContextHandler$StaticContext$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UShort$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $UShort$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UShort$Companion$Type = ($UShort$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UShort$Companion_ = $UShort$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$RequestLog" {
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Response"

export interface $RequestLog {

 "log"(arg0: $Request$Type, arg1: $Response$Type): void

(arg0: $Request$Type, arg1: $Response$Type): void
}

export namespace $RequestLog {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestLog$Type = ($RequestLog);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequestLog_ = $RequestLog$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$PreEncodedHttpField" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"

export class $PreEncodedHttpField extends $HttpField {

constructor(arg0: string, arg1: string)
constructor(arg0: $HttpHeader$Type, arg1: string)
constructor(arg0: $HttpHeader$Type, arg1: string, arg2: string)

public "putTo"(arg0: $ByteBuffer$Type, arg1: $HttpVersion$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreEncodedHttpField$Type = ($PreEncodedHttpField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PreEncodedHttpField_ = $PreEncodedHttpField$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange" {
import {$IntRange$Companion, $IntRange$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange$Companion"
import {$IntProgression, $IntProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"

export class $IntRange extends $IntProgression implements $ClosedRange<(integer)> {
static readonly "Companion": $IntRange$Companion

constructor(arg0: integer, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "contains"(arg0: integer): boolean
public "getEndInclusive"(): integer
get "empty"(): boolean
get "endInclusive"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntRange$Type = ($IntRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntRange_ = $IntRange$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $ServletException extends $Exception {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

public "getRootCause"(): $Throwable
get "rootCause"(): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletException$Type = ($ServletException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletException_ = $ServletException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Metadata" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Metadata extends $Annotation {

 "pn"(): string
 "k"(): integer
 "mv"(): (integer)[]
 "d1"(): (string)[]
 "d2"(): (string)[]
 "bv"(): (integer)[]
 "xi"(): integer
 "xs"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Metadata {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Metadata$Type = ($Metadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Metadata_ = $Metadata$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $DispatcherType extends $Enum<($DispatcherType)> {
static readonly "FORWARD": $DispatcherType
static readonly "INCLUDE": $DispatcherType
static readonly "REQUEST": $DispatcherType
static readonly "ASYNC": $DispatcherType
static readonly "ERROR": $DispatcherType


public static "values"(): ($DispatcherType)[]
public static "valueOf"(arg0: string): $DispatcherType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispatcherType$Type = (("include") | ("request") | ("async") | ("forward") | ("error")) | ($DispatcherType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DispatcherType_ = $DispatcherType$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$StringCompanionObject" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $StringCompanionObject {
static readonly "INSTANCE": $StringCompanionObject


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringCompanionObject$Type = ($StringCompanionObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringCompanionObject_ = $StringCompanionObject$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$SafePublicationLazyImpl$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"

export class $SafePublicationLazyImpl$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SafePublicationLazyImpl$Companion$Type = ($SafePublicationLazyImpl$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SafePublicationLazyImpl$Companion_ = $SafePublicationLazyImpl$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipHttpInputInterceptor" {
import {$HttpInput$Content, $HttpInput$Content$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Content"
import {$Destroyable, $Destroyable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Destroyable"
import {$HttpInput$Interceptor, $HttpInput$Interceptor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Interceptor"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $GzipHttpInputInterceptor implements $HttpInput$Interceptor, $Destroyable {

constructor(arg0: $ByteBufferPool$Type, arg1: integer)

public "destroy"(): void
public "readFrom"(arg0: $HttpInput$Content$Type): $HttpInput$Content
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GzipHttpInputInterceptor$Type = ($GzipHttpInputInterceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GzipHttpInputInterceptor_ = $GzipHttpInputInterceptor$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionContext" {
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"

/**
 * 
 * @deprecated
 */
export interface $HttpSessionContext {

/**
 * 
 * @deprecated
 */
 "getSession"(arg0: string): $HttpSession
/**
 * 
 * @deprecated
 */
 "getIds"(): $Enumeration<(string)>
}

export namespace $HttpSessionContext {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionContext$Type = ($HttpSessionContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionContext_ = $HttpSessionContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Holder" {
import {$BaseHolder, $BaseHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$BaseHolder"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Holder<T> extends $BaseHolder<(T)> {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener


public "getInitParameter"(arg0: string): string
public "setInitParameter"(arg0: string, arg1: string): void
public "destroyInstance"(arg0: any): void
public "getInitParameters"(): $Map<(string), (string)>
public "setInitParameters"(arg0: $Map$Type<(string), (string)>): void
public "getName"(): string
public "toString"(): string
public "setName"(arg0: string): void
public "getDisplayName"(): string
public "setDisplayName"(arg0: string): void
public "setClassName"(arg0: string): void
public "setAsyncSupported"(arg0: boolean): void
public "setHeldClass"(arg0: $Class$Type<(any)>): void
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "isAsyncSupported"(): boolean
public "getInitParameterNames"(): $Enumeration<(string)>
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "initParameters"(): $Map<(string), (string)>
set "initParameters"(value: $Map$Type<(string), (string)>)
get "name"(): string
set "name"(value: string)
get "displayName"(): string
set "displayName"(value: string)
set "className"(value: string)
set "asyncSupported"(value: boolean)
set "heldClass"(value: $Class$Type<(any)>)
get "asyncSupported"(): boolean
get "initParameterNames"(): $Enumeration<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Holder$Type<T> = ($Holder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Holder_<T> = $Holder$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__MutableCollectionsJVMKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CollectionsKt__IteratorsKt, $CollectionsKt__IteratorsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__IteratorsKt"

export class $CollectionsKt__MutableCollectionsJVMKt extends $CollectionsKt__IteratorsKt {

constructor()

public static "sort"<T extends $Comparable<(any)>>(arg0: $List$Type<(T)>): void
public static "sortWith"<T>(arg0: $List$Type<(T)>, arg1: $Comparator$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt__MutableCollectionsJVMKt$Type = ($CollectionsKt__MutableCollectionsJVMKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt__MutableCollectionsJVMKt_ = $CollectionsKt__MutableCollectionsJVMKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$AliasedX509ExtendedKeyManager" {
import {$X509ExtendedKeyManager, $X509ExtendedKeyManager$Type} from "packages/javax/net/ssl/$X509ExtendedKeyManager"
import {$X509Certificate, $X509Certificate$Type} from "packages/java/security/cert/$X509Certificate"
import {$PrivateKey, $PrivateKey$Type} from "packages/java/security/$PrivateKey"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Socket, $Socket$Type} from "packages/java/net/$Socket"

export class $AliasedX509ExtendedKeyManager extends $X509ExtendedKeyManager {

constructor(arg0: $X509ExtendedKeyManager$Type, arg1: string)

public "getCertificateChain"(arg0: string): ($X509Certificate)[]
public "getDelegate"(): $X509ExtendedKeyManager
public "getPrivateKey"(arg0: string): $PrivateKey
public "getClientAliases"(arg0: string, arg1: ($Principal$Type)[]): (string)[]
public "chooseClientAlias"(arg0: (string)[], arg1: ($Principal$Type)[], arg2: $Socket$Type): string
public "getServerAliases"(arg0: string, arg1: ($Principal$Type)[]): (string)[]
public "chooseServerAlias"(arg0: string, arg1: ($Principal$Type)[], arg2: $Socket$Type): string
public "chooseEngineClientAlias"(arg0: (string)[], arg1: ($Principal$Type)[], arg2: $SSLEngine$Type): string
public "chooseEngineServerAlias"(arg0: string, arg1: ($Principal$Type)[], arg2: $SSLEngine$Type): string
get "delegate"(): $X509ExtendedKeyManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AliasedX509ExtendedKeyManager$Type = ($AliasedX509ExtendedKeyManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AliasedX509ExtendedKeyManager_ = $AliasedX509ExtendedKeyManager$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$DateGenerator" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export class $DateGenerator {
static readonly "__01Jan1970": string

constructor()

public static "formatCookieDate"(arg0: long): string
public static "formatCookieDate"(arg0: $StringBuilder$Type, arg1: long): void
public static "formatDate"(arg0: long): string
public "doFormatDate"(arg0: long): string
public "doFormatCookieDate"(arg0: $StringBuilder$Type, arg1: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DateGenerator$Type = ($DateGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DateGenerator_ = $DateGenerator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KMutableProperty, $KMutableProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty"
import {$KMutableProperty2$Setter, $KMutableProperty2$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2$Setter"
import {$KProperty2, $KProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty2$Getter, $KProperty2$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty2<D, E, V> extends $KProperty2<(D), (E), (V)>, $KMutableProperty<(V)> {

 "set"(arg0: D, arg1: E, arg2: V): void
 "getSetter"(): $KMutableProperty2$Setter<(D), (E), (V)>
 "get"(arg0: D, arg1: E): V
 "getDelegate"(arg0: D, arg1: E): any
 "getGetter"(): $KProperty2$Getter<(D), (E), (V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(arg0: D, arg1: E): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty2$Type<D, E, V> = ($KMutableProperty2<(D), (E), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty2_<D, E, V> = $KMutableProperty2$Type<(D), (E), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KMutableProperty, $KMutableProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty"
import {$KMutableProperty1$Setter, $KMutableProperty1$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1$Setter"
import {$KProperty1, $KProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty1$Getter, $KProperty1$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty1<T, V> extends $KProperty1<(T), (V)>, $KMutableProperty<(V)> {

 "set"(arg0: T, arg1: V): void
 "getSetter"(): $KMutableProperty1$Setter<(T), (V)>
 "get"(arg0: T): V
 "getDelegate"(arg0: T): any
 "getGetter"(): $KProperty1$Getter<(T), (V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(arg0: T): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty1 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty1$Type<T, V> = ($KMutableProperty1<(T), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty1_<T, V> = $KMutableProperty1$Type<(T), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KMutableProperty, $KMutableProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KMutableProperty0$Setter, $KMutableProperty0$Setter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0$Setter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KProperty0, $KProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$KProperty0$Getter, $KProperty0$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0$Getter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KMutableProperty0<V> extends $KProperty0<(V)>, $KMutableProperty<(V)> {

 "set"(arg0: V): void
 "getSetter"(): $KMutableProperty0$Setter<(V)>
 "get"(): V
 "getDelegate"(): any
 "getGetter"(): $KProperty0$Getter<(V)>
 "isLateinit"(): boolean
 "isConst"(): boolean
 "invoke"(): V
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "isSuspend"(): boolean
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KMutableProperty0 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableProperty0$Type<V> = ($KMutableProperty0<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableProperty0_<V> = $KMutableProperty0$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionListener" {
import {$EventListener, $EventListener$Type} from "packages/java/util/$EventListener"
import {$HttpSessionEvent, $HttpSessionEvent$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionEvent"

export interface $HttpSessionListener extends $EventListener {

 "sessionCreated"(arg0: $HttpSessionEvent$Type): void
 "sessionDestroyed"(arg0: $HttpSessionEvent$Type): void
}

export namespace $HttpSessionListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSessionListener$Type = ($HttpSessionListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSessionListener_ = $HttpSessionListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/annotation/$ManagedAttribute" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ManagedAttribute extends $Annotation {

 "name"(): string
 "value"(): string
 "readonly"(): boolean
 "proxied"(): boolean
 "setter"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ManagedAttribute {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedAttribute$Type = ($ManagedAttribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedAttribute_ = $ManagedAttribute$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkLoadBehaviour" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ChunkLoadBehaviour extends $Enum<($ChunkLoadBehaviour)> {
static readonly "LOAD_CHUNK_NEVER": $ChunkLoadBehaviour
static readonly "LOAD_CHUNK_IF_SAFE": $ChunkLoadBehaviour
static readonly "LOAD_CHUNK_MOST_IMPORTANT": $ChunkLoadBehaviour
static readonly "LOAD_CHUNK_ALWAYS": $ChunkLoadBehaviour


public static "values"(): ($ChunkLoadBehaviour)[]
public static "valueOf"(arg0: string): $ChunkLoadBehaviour
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkLoadBehaviour$Type = (("load_chunk_never") | ("load_chunk_most_important") | ("load_chunk_always") | ("load_chunk_if_safe")) | ($ChunkLoadBehaviour);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkLoadBehaviour_ = $ChunkLoadBehaviour$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$CloseStatus, $CloseStatus$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$CloseStatus"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$SuspendToken, $SuspendToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$SuspendToken"
import {$UpgradeRequest, $UpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeRequest"
import {$RemoteEndpoint, $RemoteEndpoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$RemoteEndpoint"
import {$UpgradeResponse, $UpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$UpgradeResponse"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export interface $Session extends $Closeable {

 "isOpen"(): boolean
 "suspend"(): $SuspendToken
 "close"(): void
 "close"(arg0: $CloseStatus$Type): void
 "close"(arg0: integer, arg1: string): void
 "getPolicy"(): $WebSocketPolicy
 "isSecure"(): boolean
 "disconnect"(): void
 "getProtocolVersion"(): string
 "getLocalAddress"(): $InetSocketAddress
 "getRemoteAddress"(): $InetSocketAddress
 "getRemote"(): $RemoteEndpoint
 "setIdleTimeout"(arg0: long): void
 "getIdleTimeout"(): long
 "getUpgradeRequest"(): $UpgradeRequest
 "getUpgradeResponse"(): $UpgradeResponse
}

export namespace $Session {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Session$Type = ($Session);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Session_ = $Session$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$ReadListener, $ReadListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ReadListener"
import {$HttpInput$Content, $HttpInput$Content$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Content"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$HttpInput$Interceptor, $HttpInput$Interceptor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpInput$Interceptor"
import {$HttpChannelState, $HttpChannelState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HttpInput extends $ServletInputStream implements $Runnable {

constructor(arg0: $HttpChannelState$Type)

public "run"(): void
public "toString"(): string
public "read"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "read"(): integer
public "available"(): integer
public "isError"(): boolean
public "eof"(): boolean
public "isReady"(): boolean
public "setReadListener"(arg0: $ReadListener$Type): void
public "recycle"(): void
public "isAsync"(): boolean
public "hasContent"(): boolean
public "setInterceptor"(arg0: $HttpInput$Interceptor$Type): void
public "getInterceptor"(): $HttpInput$Interceptor
public "isFinished"(): boolean
public "prependContent"(arg0: $HttpInput$Content$Type): boolean
public "unblock"(): void
public "isAsyncEOF"(): boolean
public "earlyEOF"(): boolean
public "addContent"(arg0: $HttpInput$Content$Type): boolean
public "consumeAll"(): boolean
public "failed"(arg0: $Throwable$Type): boolean
public "getContentConsumed"(): long
public "addInterceptor"(arg0: $HttpInput$Interceptor$Type): void
get "error"(): boolean
get "ready"(): boolean
set "readListener"(value: $ReadListener$Type)
get "async"(): boolean
set "interceptor"(value: $HttpInput$Interceptor$Type)
get "interceptor"(): $HttpInput$Interceptor
get "finished"(): boolean
get "asyncEOF"(): boolean
get "contentConsumed"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpInput$Type = ($HttpInput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpInput_ = $HttpInput$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$FiltersPerformance" {
import {$FilterType, $FilterType$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$FilterType"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $FiltersPerformance {
static readonly "FILTER_WEIGHTS_DEFAULT": (double)[]

constructor(arg0: $ImageInfo$Type)

public "updateFromFiltered"(arg0: $FilterType$Type, arg1: (byte)[], arg2: integer): void
public "updateFromRaw"(arg0: $FilterType$Type, arg1: (byte)[], arg2: (byte)[], arg3: integer): void
public "setFilterWeights"(arg0: (double)[]): void
public "computeHistogram"(arg0: (byte)[]): void
public "tuneMemory"(arg0: double): void
public "getPreferred"(): $FilterType
public "computeAbsFromHistogram"(): double
public "computeEntropyFromHistogram"(): double
public "computeHistogramForFilter"(arg0: $FilterType$Type, arg1: (byte)[], arg2: (byte)[]): void
public "setPreferenceForNone"(arg0: double): void
set "filterWeights"(value: (double)[])
get "preferred"(): $FilterType
set "preferenceForNone"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FiltersPerformance$Type = ($FiltersPerformance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FiltersPerformance_ = $FiltersPerformance$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkSeqReader" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$IBytesConsumer, $IBytesConsumer$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IBytesConsumer"
import {$ChunkReader, $ChunkReader$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader"
import {$DeflatedChunksSet, $DeflatedChunksSet$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$DeflatedChunksSet"

export class $ChunkSeqReader implements $IBytesConsumer {

constructor()
constructor(arg0: boolean)

public "close"(): void
public "isDone"(): boolean
public "consume"(arg0: (byte)[], arg1: integer, arg2: integer): integer
public "feedAll"(arg0: (byte)[], arg1: integer, arg2: integer): boolean
public "feedFromFile"(arg0: $File$Type): void
public "isAtChunkBoundary"(): boolean
public "getChunkCount"(): integer
public "getBytesCount"(): long
public "getCurChunkReader"(): $ChunkReader
public "isSignatureDone"(): boolean
public "getIdatBytes"(): long
public "feedFromInputStream"(arg0: $InputStream$Type): void
public "feedFromInputStream"(arg0: $InputStream$Type, arg1: boolean): void
public "getCurReaderDeflatedSet"(): $DeflatedChunksSet
get "done"(): boolean
get "atChunkBoundary"(): boolean
get "chunkCount"(): integer
get "bytesCount"(): long
get "curChunkReader"(): $ChunkReader
get "signatureDone"(): boolean
get "idatBytes"(): long
get "curReaderDeflatedSet"(): $DeflatedChunksSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSeqReader$Type = ($ChunkSeqReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkSeqReader_ = $ChunkSeqReader$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$WebSocketFrame" {
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Frame$Type, $Frame$Type$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame$Type"

export class $WebSocketFrame implements $Frame {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getType"(): $Frame$Type
public static "copy"(arg0: $Frame$Type): $WebSocketFrame
public "reset"(): void
public "getPayload"(): $ByteBuffer
public "getMask"(): (byte)[]
public "setFin"(arg0: boolean): $WebSocketFrame
public "setPayload"(arg0: $ByteBuffer$Type): $WebSocketFrame
public "assertValid"(): void
public "getPayloadAsUTF8"(): string
public "isControlFrame"(): boolean
public "setRsv2"(arg0: boolean): $WebSocketFrame
public "setMasked"(arg0: boolean): $Frame
public "setRsv3"(arg0: boolean): $WebSocketFrame
public "setRsv1"(arg0: boolean): $WebSocketFrame
public "isDataFrame"(): boolean
public "setMask"(arg0: (byte)[]): $Frame
public "isLast"(): boolean
public "hasPayload"(): boolean
public "getOpCode"(): byte
public "getPayloadLength"(): integer
public "isMasked"(): boolean
public "isRsv1"(): boolean
public "isRsv2"(): boolean
public "isRsv3"(): boolean
public "isFin"(): boolean
get "type"(): $Frame$Type
get "payload"(): $ByteBuffer
get "mask"(): (byte)[]
set "fin"(value: boolean)
set "payload"(value: $ByteBuffer$Type)
get "payloadAsUTF8"(): string
get "controlFrame"(): boolean
set "rsv2"(value: boolean)
set "masked"(value: boolean)
set "rsv3"(value: boolean)
set "rsv1"(value: boolean)
get "dataFrame"(): boolean
set "mask"(value: (byte)[])
get "last"(): boolean
get "opCode"(): byte
get "payloadLength"(): integer
get "masked"(): boolean
get "rsv1"(): boolean
get "rsv2"(): boolean
get "rsv3"(): boolean
get "fin"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketFrame$Type = ($WebSocketFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketFrame_ = $WebSocketFrame$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$KotlinReflectionNotSupportedError" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Error, $Error$Type} from "packages/java/lang/$Error"

export class $KotlinReflectionNotSupportedError extends $Error {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KotlinReflectionNotSupportedError$Type = ($KotlinReflectionNotSupportedError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KotlinReflectionNotSupportedError_ = $KotlinReflectionNotSupportedError$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractEndPoint" {
import {$FillInterest, $FillInterest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$FillInterest"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$IdleTimeout, $IdleTimeout$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$IdleTimeout"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $AbstractEndPoint extends $IdleTimeout implements $EndPoint {


public "getCreatedTimeStamp"(): long
public "toString"(): string
public "isOpen"(): boolean
public "write"(arg0: $Callback$Type, ...arg1: ($ByteBuffer$Type)[]): void
public "close"(): void
public "onClose"(): void
public "getConnection"(): $Connection
public "tryFillInterested"(arg0: $Callback$Type): boolean
public "getFillInterest"(): $FillInterest
public "checkFill"(): void
public "checkFlush"(): void
public "fillInterested"(arg0: $Callback$Type): void
public "isFillInterested"(): boolean
public "toConnectionString"(): string
public "toEndPointString"(): string
public "setConnection"(arg0: $Connection$Type): void
public "isInputShutdown"(): boolean
public "isOutputShutdown"(): boolean
public "shutdownOutput"(): void
public "onOpen"(): void
public "isOptimizedForDirectBuffers"(): boolean
public "upgrade"(arg0: $Connection$Type): void
public "flush"(...arg0: ($ByteBuffer$Type)[]): boolean
public "fill"(arg0: $ByteBuffer$Type): integer
public "getLocalAddress"(): $InetSocketAddress
public "getRemoteAddress"(): $InetSocketAddress
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "getTransport"(): any
get "createdTimeStamp"(): long
get "open"(): boolean
get "connection"(): $Connection
get "fillInterest"(): $FillInterest
set "connection"(value: $Connection$Type)
get "inputShutdown"(): boolean
get "outputShutdown"(): boolean
get "optimizedForDirectBuffers"(): boolean
get "localAddress"(): $InetSocketAddress
get "remoteAddress"(): $InetSocketAddress
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "transport"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractEndPoint$Type = ($AbstractEndPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractEndPoint_ = $AbstractEndPoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$CompletedContinuation" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"

export class $CompletedContinuation implements $Continuation<(any)> {
static readonly "INSTANCE": $CompletedContinuation


public "toString"(): string
public "getContext"(): $CoroutineContext
public "resumeWith"(arg0: any): void
get "context"(): $CoroutineContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompletedContinuation$Type = ($CompletedContinuation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompletedContinuation_ = $CompletedContinuation$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SslConnectionFactory" {
import {$AbstractConnectionFactory, $AbstractConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AbstractConnectionFactory"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$SslContextFactory, $SslContextFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SslContextFactory"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $SslConnectionFactory extends $AbstractConnectionFactory {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $SslContextFactory$Type, arg1: string)
constructor(arg0: string)
constructor()

public "toString"(): string
public "getNextProtocol"(): string
public "newConnection"(arg0: $Connector$Type, arg1: $EndPoint$Type): $Connection
public "getSslContextFactory"(): $SslContextFactory
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "nextProtocol"(): string
get "sslContextFactory"(): $SslContextFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslConnectionFactory$Type = ($SslConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslConnectionFactory_ = $SslConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Experimental$Level" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Experimental$Level extends $Enum<($Experimental$Level)> {
static readonly "WARNING": $Experimental$Level
static readonly "ERROR": $Experimental$Level


public static "values"(): ($Experimental$Level)[]
public static "valueOf"(arg0: string): $Experimental$Level
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Experimental$Level$Type = (("warning") | ("error")) | ($Experimental$Level);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Experimental$Level_ = $Experimental$Level$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileAlreadyExistsException" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$File, $File$Type} from "packages/java/io/$File"
import {$FileSystemException, $FileSystemException$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FileSystemException"

export class $FileAlreadyExistsException extends $FileSystemException {

constructor(arg0: $File$Type, arg1: $File$Type, arg2: string)
constructor(arg0: $File$Type, arg1: $File$Type, arg2: string, arg3: integer, arg4: $DefaultConstructorMarker$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FileAlreadyExistsException$Type = ($FileAlreadyExistsException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FileAlreadyExistsException_ = $FileAlreadyExistsException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedEventDriver" {
import {$AbstractEventDriver, $AbstractEventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$AbstractEventDriver"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$JettyAnnotatedMetadata, $JettyAnnotatedMetadata$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyAnnotatedMetadata"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$CloseInfo, $CloseInfo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $JettyAnnotatedEventDriver extends $AbstractEventDriver {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $WebSocketPolicy$Type, arg1: any, arg2: $JettyAnnotatedMetadata$Type)

public "toString"(): string
public "onClose"(arg0: $CloseInfo$Type): void
public "onConnect"(): void
public "onTextFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onFrame"(arg0: $Frame$Type): void
public "onBinaryFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onInputStream"(arg0: $InputStream$Type): void
public "getBatchMode"(): $BatchMode
public "onReader"(arg0: $Reader$Type): void
public "onTextMessage"(arg0: string): void
public "onError"(arg0: $Throwable$Type): void
public "onBinaryMessage"(arg0: (byte)[]): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "batchMode"(): $BatchMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyAnnotatedEventDriver$Type = ($JettyAnnotatedEventDriver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyAnnotatedEventDriver_ = $JettyAnnotatedEventDriver$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayDoubleIterator" {
import {$DoubleIterator, $DoubleIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$DoubleIterator"

export class $ArrayDoubleIterator extends $DoubleIterator {

constructor(arg0: (double)[])

public "hasNext"(): boolean
public "nextDouble"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDoubleIterator$Type = ($ArrayDoubleIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDoubleIterator_ = $ArrayDoubleIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$LazyList" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $LazyList implements $Cloneable, $Serializable {


public static "add"(arg0: any, arg1: any): any
public static "add"(arg0: any, arg1: integer, arg2: any): any
public static "remove"(arg0: any, arg1: integer): any
public static "remove"(arg0: any, arg1: any): any
public static "get"<E>(arg0: any, arg1: integer): E
public static "toString"(arg0: any): string
public static "clone"(arg0: any): any
public static "isEmpty"(arg0: any): boolean
public static "size"(arg0: any): integer
public static "toArray"(arg0: any, arg1: $Class$Type<(any)>): any
public static "iterator"<E>(arg0: any): $Iterator<(E)>
public static "contains"(arg0: any, arg1: any): boolean
public static "listIterator"<E>(arg0: any): $ListIterator<(E)>
public static "getList"<E>(arg0: any, arg1: boolean): $List<(E)>
public static "getList"<E>(arg0: any): $List<(E)>
public static "addArray"(arg0: any, arg1: (any)[]): any
public static "hasEntry"(arg0: any): boolean
public static "toStringArray"(arg0: any): (string)[]
public static "ensureSize"(arg0: any, arg1: integer): any
public static "addCollection"(arg0: any, arg1: $Collection$Type<(any)>): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyList$Type = ($LazyList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyList_ = $LazyList$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/random/$XorWowRandom" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Random$Default, $Random$Default$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random$Default"

export class $XorWowRandom extends $Random implements $Serializable {
static readonly "Default": $Random$Default

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer)
constructor(arg0: integer, arg1: integer)

public "nextInt"(): integer
public "nextBits"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XorWowRandom$Type = ($XorWowRandom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $XorWowRandom_ = $XorWowRandom$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketServerConnection" {
import {$Connection$UpgradeTo, $Connection$UpgradeTo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$UpgradeTo"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$AbstractWebSocketConnection, $AbstractWebSocketConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$AbstractWebSocketConnection"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketServerConnection extends $AbstractWebSocketConnection implements $Connection$UpgradeTo {

constructor(arg0: $EndPoint$Type, arg1: $Executor$Type, arg2: $Scheduler$Type, arg3: $WebSocketPolicy$Type, arg4: $ByteBufferPool$Type)

public "getLocalAddress"(): $InetSocketAddress
public "getRemoteAddress"(): $InetSocketAddress
public "setNextIncomingFrames"(arg0: $IncomingFrames$Type): void
public "onUpgradeTo"(arg0: $ByteBuffer$Type): void
get "localAddress"(): $InetSocketAddress
get "remoteAddress"(): $InetSocketAddress
set "nextIncomingFrames"(value: $IncomingFrames$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServerConnection$Type = ($WebSocketServerConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServerConnection_ = $WebSocketServerConnection$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ChunkReader$ChunkReaderMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ChunkReader$ChunkReaderMode extends $Enum<($ChunkReader$ChunkReaderMode)> {
static readonly "BUFFER": $ChunkReader$ChunkReaderMode
static readonly "PROCESS": $ChunkReader$ChunkReaderMode
static readonly "SKIP": $ChunkReader$ChunkReaderMode


public static "values"(): ($ChunkReader$ChunkReaderMode)[]
public static "valueOf"(arg0: string): $ChunkReader$ChunkReaderMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkReader$ChunkReaderMode$Type = (("process") | ("skip") | ("buffer")) | ($ChunkReader$ChunkReaderMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkReader$ChunkReaderMode_ = $ChunkReader$ChunkReaderMode$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$IntProgression, $IntProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression"

export class $IntProgression$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "fromClosedRange"(arg0: integer, arg1: integer, arg2: integer): $IntProgression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntProgression$Companion$Type = ($IntProgression$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntProgression$Companion_ = $IntProgression$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2$Getter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty2$Getter<D, E, V> extends $KProperty$Getter<(V)>, $Function2<(D), (E), (V)> {

 "invoke"(arg0: D, arg1: E): V
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty2$Getter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty2$Getter$Type<D, E, V> = ($KProperty2$Getter<(D), (E), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty2$Getter_<D, E, V> = $KProperty2$Getter$Type<(D), (E), (V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractConnection" {
import {$Connection$Listener, $Connection$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$Listener"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $AbstractConnection implements $Connection {


public "getCreatedTimeStamp"(): long
public "toString"(): string
public "close"(): void
public "onClose"(): void
public "onIdleExpired"(): boolean
public "tryFillInterested"(arg0: $Callback$Type): void
public "tryFillInterested"(): void
public "fillInterested"(): void
public "isFillInterested"(): boolean
public "toConnectionString"(): string
public "setInputBufferSize"(arg0: integer): void
public "removeListener"(arg0: $Connection$Listener$Type): void
public "onOpen"(): void
public "addListener"(arg0: $Connection$Listener$Type): void
public "getEndPoint"(): $EndPoint
public "getInputBufferSize"(): integer
public "getBytesIn"(): long
public "getMessagesIn"(): long
public "getMessagesOut"(): long
public "getBytesOut"(): long
public "onFillable"(): void
get "createdTimeStamp"(): long
set "inputBufferSize"(value: integer)
get "endPoint"(): $EndPoint
get "inputBufferSize"(): integer
get "bytesIn"(): long
get "messagesIn"(): long
get "messagesOut"(): long
get "bytesOut"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractConnection$Type = ($AbstractConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractConnection_ = $AbstractConnection$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$AbstractWebSocketConnection" {
import {$BatchMode, $BatchMode$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LogicalConnection, $LogicalConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$LogicalConnection"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$IOState, $IOState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState"
import {$Connection$UpgradeTo, $Connection$UpgradeTo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$UpgradeTo"
import {$ConnectionState, $ConnectionState$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$ConnectionState"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractConnection, $AbstractConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractConnection"
import {$SuspendToken, $SuspendToken$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$SuspendToken"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"
import {$Parser, $Parser$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Parser"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$IOState$ConnectionStateListener, $IOState$ConnectionStateListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$IOState$ConnectionStateListener"
import {$AbstractWebSocketConnection$Stats, $AbstractWebSocketConnection$Stats$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$AbstractWebSocketConnection$Stats"
import {$Generator, $Generator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Generator"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"

export class $AbstractWebSocketConnection extends $AbstractConnection implements $LogicalConnection, $Connection$UpgradeTo, $IOState$ConnectionStateListener, $Dumpable {

constructor(arg0: $EndPoint$Type, arg1: $Executor$Type, arg2: $Scheduler$Type, arg3: $WebSocketPolicy$Type, arg4: $ByteBufferPool$Type)

public "outgoingFrame"(arg0: $Frame$Type, arg1: $WriteCallback$Type, arg2: $BatchMode$Type): void
public "onConnectionStateChange"(arg0: $ConnectionState$Type): void
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "isOpen"(): boolean
public "resume"(): void
public "suspend"(): $SuspendToken
public "getId"(): string
public "close"(): void
public "close"(arg0: integer, arg1: string): void
public "onClose"(): void
public "setExtensions"(arg0: $List$Type<($ExtensionConfig$Type)>): void
public "getExtensions"(): $List<($ExtensionConfig)>
public "getExecutor"(): $Executor
public "getPolicy"(): $WebSocketPolicy
public "disconnect"(): void
public "fillInterested"(): void
public "onUpgradeTo"(arg0: $ByteBuffer$Type): void
public "toConnectionString"(): string
public "setInputBufferSize"(arg0: integer): void
public "getBufferPool"(): $ByteBufferPool
public "isReading"(): boolean
public "getParser"(): $Parser
public "getGenerator"(): $Generator
public "onOpen"(): void
public "getRemoteAddress"(): $InetSocketAddress
public "getStats"(): $AbstractWebSocketConnection$Stats
public "getScheduler"(): $Scheduler
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "getIOState"(): $IOState
public "getIdleTimeout"(): long
public "onFillable"(): void
public "getMaxIdleTimeout"(): long
public "setMaxIdleTimeout"(arg0: long): void
public "getLocalAddress"(): $InetSocketAddress
public "setNextIncomingFrames"(arg0: $IncomingFrames$Type): void
get "open"(): boolean
get "id"(): string
set "extensions"(value: $List$Type<($ExtensionConfig$Type)>)
get "extensions"(): $List<($ExtensionConfig)>
get "executor"(): $Executor
get "policy"(): $WebSocketPolicy
set "inputBufferSize"(value: integer)
get "bufferPool"(): $ByteBufferPool
get "reading"(): boolean
get "parser"(): $Parser
get "generator"(): $Generator
get "remoteAddress"(): $InetSocketAddress
get "stats"(): $AbstractWebSocketConnection$Stats
get "scheduler"(): $Scheduler
get "iOState"(): $IOState
get "idleTimeout"(): long
get "maxIdleTimeout"(): long
set "maxIdleTimeout"(value: long)
get "localAddress"(): $InetSocketAddress
set "nextIncomingFrames"(value: $IncomingFrames$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractWebSocketConnection$Type = ($AbstractWebSocketConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractWebSocketConnection_ = $AbstractWebSocketConnection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropSequence" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$DropTakeSequence, $DropTakeSequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$DropTakeSequence"

export class $DropSequence<T> implements $Sequence<(T)>, $DropTakeSequence<(T)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: integer)

public "iterator"(): $Iterator<(T)>
public "drop"(arg0: integer): $Sequence<(T)>
public "take"(arg0: integer): $Sequence<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropSequence$Type<T> = ($DropSequence<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropSequence_<T> = $DropSequence$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$State" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $State extends $Enum<($State)> {
static readonly "Ready": $State
static readonly "NotReady": $State
static readonly "Done": $State
static readonly "Failed": $State


public static "values"(): ($State)[]
public static "valueOf"(arg0: string): $State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $State$Type = (("ready") | ("failed") | ("notready") | ("done")) | ($State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $State_ = $State$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayByteIterator" {
import {$ByteIterator, $ByteIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ByteIterator"

export class $ArrayByteIterator extends $ByteIterator {

constructor(arg0: (byte)[])

public "hasNext"(): boolean
public "nextByte"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayByteIterator$Type = ($ArrayByteIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayByteIterator_ = $ArrayByteIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$NativeWebSocketConfiguration" {
import {$PathSpec, $PathSpec$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpec"
import {$MappedWebSocketCreator, $MappedWebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$MappedWebSocketCreator"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$MappedResource, $MappedResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$MappedResource"
import {$WebSocketServerFactory, $WebSocketServerFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketServerFactory"
import {$WebSocketCreator, $WebSocketCreator$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$WebSocketCreator"
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$PathSpec as $PathSpec$0, $PathSpec$Type as $PathSpec$0$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/pathmap/$PathSpec"

export class $NativeWebSocketConfiguration extends $ContainerLifeCycle implements $MappedWebSocketCreator, $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $ServletContext$Type)
constructor(arg0: $WebSocketServerFactory$Type)

public "getFactory"(): $WebSocketServerFactory
public "removeMapping"(arg0: string): boolean
/**
 * 
 * @deprecated
 */
public "addMapping"(arg0: $PathSpec$0$Type, arg1: $WebSocketCreator$Type): void
public "addMapping"(arg0: $PathSpec$Type, arg1: $Class$Type<(any)>): void
public "addMapping"(arg0: string, arg1: $WebSocketCreator$Type): void
public "addMapping"(arg0: string, arg1: $Class$Type<(any)>): void
public "addMapping"(arg0: $PathSpec$Type, arg1: $WebSocketCreator$Type): void
public "getPolicy"(): $WebSocketPolicy
public "getMapping"(arg0: string): $WebSocketCreator
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(): string
public "doStop"(): void
public "getMatch"(arg0: string): $MappedResource<($WebSocketCreator)>
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
get "factory"(): $WebSocketServerFactory
get "policy"(): $WebSocketPolicy
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeWebSocketConfiguration$Type = ($NativeWebSocketConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeWebSocketConfiguration_ = $NativeWebSocketConfiguration$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$NetworkConnector" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ConnectionFactory, $ConnectionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$Scheduler, $Scheduler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export interface $NetworkConnector extends $Connector, $Closeable {

 "isOpen"(): boolean
 "close"(): void
 "open"(): void
 "getHost"(): string
 "getPort"(): integer
 "getLocalPort"(): integer
 "getName"(): string
 "getExecutor"(): $Executor
 "getProtocols"(): $List<(string)>
 "getServer"(): $Server
 "getDefaultConnectionFactory"(): $ConnectionFactory
 "getConnectedEndPoints"(): $Collection<($EndPoint)>
 "getConnectionFactories"(): $Collection<($ConnectionFactory)>
 "getConnectionFactory"(arg0: string): $ConnectionFactory
 "getConnectionFactory"<T>(arg0: $Class$Type<(T)>): T
 "getScheduler"(): $Scheduler
 "getByteBufferPool"(): $ByteBufferPool
 "getIdleTimeout"(): long
 "getTransport"(): any
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
 "shutdown"(): $Future<(void)>
}

export namespace $NetworkConnector {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkConnector$Type = ($NetworkConnector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkConnector_ = $NetworkConnector$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/serialization/$SerializerChain" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"

export class $SerializerChain {

constructor()

public "process"(arg0: $OutputStream$Type, arg1: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializerChain$Type = ($SerializerChain);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializerChain_ = $SerializerChain$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$TypeIntrinsics" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$ClassCastException, $ClassCastException$Type} from "packages/java/lang/$ClassCastException"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $TypeIntrinsics {

constructor()

public static "throwCce"(arg0: string): void
public static "throwCce"(arg0: $ClassCastException$Type): $ClassCastException
public static "throwCce"(arg0: any, arg1: string): void
public static "castToListIterator"(arg0: any): $ListIterator<(any)>
public static "castToCollection"(arg0: any): $Collection<(any)>
public static "castToList"(arg0: any): $List<(any)>
public static "isMutableIterator"(arg0: any): boolean
public static "isMutableIterable"(arg0: any): boolean
public static "asMutableIterator"(arg0: any, arg1: string): $Iterator<(any)>
public static "asMutableIterator"(arg0: any): $Iterator<(any)>
public static "asMutableList"(arg0: any, arg1: string): $List<(any)>
public static "asMutableList"(arg0: any): $List<(any)>
public static "castToIterator"(arg0: any): $Iterator<(any)>
public static "isMutableList"(arg0: any): boolean
public static "castToIterable"(arg0: any): $Iterable<(any)>
public static "asMutableIterable"(arg0: any, arg1: string): $Iterable<(any)>
public static "asMutableIterable"(arg0: any): $Iterable<(any)>
public static "asMutableSet"(arg0: any, arg1: string): $Set<(any)>
public static "asMutableSet"(arg0: any): $Set<(any)>
public static "isMutableMap"(arg0: any): boolean
public static "asMutableMap"(arg0: any): $Map<(any), (any)>
public static "asMutableMap"(arg0: any, arg1: string): $Map<(any), (any)>
public static "getFunctionArity"(arg0: any): integer
public static "castToMap"(arg0: any): $Map<(any), (any)>
public static "castToSet"(arg0: any): $Set<(any)>
public static "isMutableSet"(arg0: any): boolean
public static "asMutableMapEntry"(arg0: any, arg1: string): $Map$Entry<(any), (any)>
public static "asMutableMapEntry"(arg0: any): $Map$Entry<(any), (any)>
public static "castToMapEntry"(arg0: any): $Map$Entry<(any), (any)>
public static "isMutableMapEntry"(arg0: any): boolean
public static "isFunctionOfArity"(arg0: any, arg1: integer): boolean
public static "beforeCheckcastToFunctionOfArity"(arg0: any, arg1: integer): any
public static "beforeCheckcastToFunctionOfArity"(arg0: any, arg1: integer, arg2: string): any
public static "asMutableCollection"(arg0: any): $Collection<(any)>
public static "asMutableCollection"(arg0: any, arg1: string): $Collection<(any)>
public static "asMutableListIterator"(arg0: any, arg1: string): $ListIterator<(any)>
public static "asMutableListIterator"(arg0: any): $ListIterator<(any)>
public static "isMutableListIterator"(arg0: any): boolean
public static "isMutableCollection"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeIntrinsics$Type = ($TypeIntrinsics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeIntrinsics_ = $TypeIntrinsics$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilderValues" {
import {$KMutableCollection, $KMutableCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapBuilder, $MapBuilder$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$MapBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$AbstractMutableCollection, $AbstractMutableCollection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableCollection"

export class $MapBuilderValues<V> extends $AbstractMutableCollection<(V)> implements $Collection<(V)>, $KMutableCollection {

constructor(arg0: $MapBuilder$Type<(any), (V)>)

public "add"(arg0: V): boolean
public "remove"(arg0: any): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(V)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "getBacking"(): $MapBuilder<(any), (V)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
get "backing"(): $MapBuilder<(any), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBuilderValues$Type<V> = ($MapBuilderValues<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapBuilderValues_<V> = $MapBuilderValues$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/annotation/$ManagedObject" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ManagedObject extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ManagedObject {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManagedObject$Type = ($ManagedObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManagedObject_ = $ManagedObject$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt" {
import {$FilesKt__UtilsKt, $FilesKt__UtilsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/io/$FilesKt__UtilsKt"

export class $FilesKt extends $FilesKt__UtilsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilesKt$Type = ($FilesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilesKt_ = $FilesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPartialListener" {
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$Session"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WebSocketConnectionListener, $WebSocketConnectionListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $WebSocketPartialListener extends $WebSocketConnectionListener {

 "onWebSocketPartialText"(arg0: string, arg1: boolean): void
 "onWebSocketPartialBinary"(arg0: $ByteBuffer$Type, arg1: boolean): void
 "onWebSocketConnect"(arg0: $Session$Type): void
 "onWebSocketClose"(arg0: integer, arg1: string): void
 "onWebSocketError"(arg0: $Throwable$Type): void
}

export namespace $WebSocketPartialListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketPartialListener$Type = ($WebSocketPartialListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketPartialListener_ = $WebSocketPartialListener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslConnection$DecryptedEndPoint" {
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$SslConnection, $SslConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslConnection"
import {$AbstractEndPoint, $AbstractEndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$AbstractEndPoint"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $SslConnection$DecryptedEndPoint extends $AbstractEndPoint {

constructor(arg0: $SslConnection$Type)

public "toString"(): string
public "flush"(...arg0: ($ByteBuffer$Type)[]): boolean
public "fill"(arg0: $ByteBuffer$Type): integer
public "isOpen"(): boolean
public "getLocalAddress"(): $InetSocketAddress
public "setConnection"(arg0: $Connection$Type): void
public "isInputShutdown"(): boolean
public "isOutputShutdown"(): boolean
public "getRemoteAddress"(): $InetSocketAddress
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "getTransport"(): any
public "getSslConnection"(): $SslConnection
public "doClose"(): void
public "doShutdownOutput"(): void
get "open"(): boolean
get "localAddress"(): $InetSocketAddress
set "connection"(value: $Connection$Type)
get "inputShutdown"(): boolean
get "outputShutdown"(): boolean
get "remoteAddress"(): $InetSocketAddress
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "transport"(): any
get "sslConnection"(): $SslConnection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslConnection$DecryptedEndPoint$Type = ($SslConnection$DecryptedEndPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslConnection$DecryptedEndPoint_ = $SslConnection$DecryptedEndPoint$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$JettyServerFactory" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"

export interface $JettyServerFactory {

 "create"(arg0: integer, arg1: integer, arg2: integer): $Server

(arg0: integer, arg1: integer, arg2: integer): $Server
}

export namespace $JettyServerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyServerFactory$Type = ($JettyServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyServerFactory_ = $JettyServerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity" {
import {$UserIdentity$Scope, $UserIdentity$Scope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity$Scope"
import {$Subject, $Subject$Type} from "packages/javax/security/auth/$Subject"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"

export interface $UserIdentity {

 "getSubject"(): $Subject
 "isUserInRole"(arg0: string, arg1: $UserIdentity$Scope$Type): boolean
 "getUserPrincipal"(): $Principal
}

export namespace $UserIdentity {
const UNAUTHENTICATED_IDENTITY: $UserIdentity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UserIdentity$Type = ($UserIdentity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UserIdentity_ = $UserIdentity$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ArrayAsCollection" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $ArrayAsCollection<T> implements $Collection<(T)>, $KMappedMarker {

constructor(arg0: (T)[], arg1: boolean)

public "add"(arg0: T): boolean
public "remove"(arg0: any): boolean
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(T)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "isVarargs"(): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "getValues"(): (T)[]
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(T)>
public "spliterator"(): $Spliterator<(T)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(T)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<T>;
get "empty"(): boolean
get "varargs"(): boolean
get "values"(): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayAsCollection$Type<T> = ($ArrayAsCollection<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayAsCollection_<T> = $ArrayAsCollection$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult$Destructured" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$MatchResult, $MatchResult$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$MatchResult"

export class $MatchResult$Destructured {

constructor(arg0: $MatchResult$Type)

public "toList"(): $List<(string)>
public "getMatch"(): $MatchResult
get "match"(): $MatchResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchResult$Destructured$Type = ($MatchResult$Destructured);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchResult$Destructured_ = $MatchResult$Destructured$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler" {
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"
import {$Scheduler$Task, $Scheduler$Task$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Scheduler$Task"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $Scheduler extends $LifeCycle {

 "schedule"(arg0: $Runnable$Type, arg1: long, arg2: $TimeUnit$Type): $Scheduler$Task
 "start"(): void
 "stop"(): void
 "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
 "isRunning"(): boolean
 "isStarted"(): boolean
 "isStopped"(): boolean
 "isStopping"(): boolean
 "isStarting"(): boolean
 "isFailed"(): boolean
}

export namespace $Scheduler {
function start(arg0: any): void
function stop(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Scheduler$Type = ($Scheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Scheduler_ = $Scheduler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $Logger {

 "getName"(): string
 "info"(arg0: string, ...arg1: (any)[]): void
 "info"(arg0: $Throwable$Type): void
 "info"(arg0: string, arg1: $Throwable$Type): void
 "getLogger"(arg0: string): $Logger
 "debug"(arg0: string, ...arg1: (any)[]): void
 "debug"(arg0: string, arg1: long): void
 "debug"(arg0: $Throwable$Type): void
 "debug"(arg0: string, arg1: $Throwable$Type): void
 "ignore"(arg0: $Throwable$Type): void
 "warn"(arg0: string, ...arg1: (any)[]): void
 "warn"(arg0: string, arg1: $Throwable$Type): void
 "warn"(arg0: $Throwable$Type): void
 "isDebugEnabled"(): boolean
 "setDebugEnabled"(arg0: boolean): void
}

export namespace $Logger {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Logger$Type = ($Logger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Logger_ = $Logger$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSBIT" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkSBIT extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "setRGB"(arg0: integer, arg1: integer, arg2: integer): void
public "getRGB"(): (integer)[]
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "setGraysb"(arg0: integer): void
public "setAlphasb"(arg0: integer): void
public "getGraysb"(): integer
public "getAlphasb"(): integer
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "rGB"(): (integer)[]
set "graysb"(value: integer)
set "alphasb"(value: integer)
get "graysb"(): integer
get "alphasb"(): integer
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkSBIT$Type = ($PngChunkSBIT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkSBIT_ = $PngChunkSBIT$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterable" {
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"

export interface $KMutableIterable extends $KMappedMarker {

}

export namespace $KMutableIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableIterable$Type = ($KMutableIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableIterable_ = $KMutableIterable$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$JettyListenerEventDriver" {
import {$AbstractEventDriver, $AbstractEventDriver$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$AbstractEventDriver"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"
import {$WebSocketConnectionListener, $WebSocketConnectionListener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketConnectionListener"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$CloseInfo, $CloseInfo$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$CloseInfo"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $JettyListenerEventDriver extends $AbstractEventDriver {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $WebSocketPolicy$Type, arg1: $WebSocketConnectionListener$Type)

public "toString"(): string
public "onClose"(arg0: $CloseInfo$Type): void
public "onConnect"(): void
public "onTextFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onFrame"(arg0: $Frame$Type): void
public "onBinaryFrame"(arg0: $ByteBuffer$Type, arg1: boolean): void
public "onInputStream"(arg0: $InputStream$Type): void
public "onReader"(arg0: $Reader$Type): void
public "onTextMessage"(arg0: string): void
public "onError"(arg0: $Throwable$Type): void
public "onBinaryMessage"(arg0: (byte)[]): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JettyListenerEventDriver$Type = ($JettyListenerEventDriver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JettyListenerEventDriver_ = $JettyListenerEventDriver$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongProgressionIterator" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$ULongIterator, $ULongIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$ULongIterator"

export class $ULongProgressionIterator extends $ULongIterator {

constructor(arg0: long, arg1: long, arg2: long, arg3: $DefaultConstructorMarker$Type)

public "hasNext"(): boolean
public "nextULong-s-VKNKU"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongProgressionIterator$Type = ($ULongProgressionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongProgressionIterator_ = $ULongProgressionIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$RegexOption" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$FlagEnum, $FlagEnum$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$FlagEnum"

export class $RegexOption extends $Enum<($RegexOption)> implements $FlagEnum {
static readonly "IGNORE_CASE": $RegexOption
static readonly "MULTILINE": $RegexOption
static readonly "LITERAL": $RegexOption
static readonly "UNIX_LINES": $RegexOption
static readonly "COMMENTS": $RegexOption
static readonly "DOT_MATCHES_ALL": $RegexOption
static readonly "CANON_EQ": $RegexOption


public static "values"(): ($RegexOption)[]
public static "valueOf"(arg0: string): $RegexOption
public "getValue"(): integer
public "getMask"(): integer
get "value"(): integer
get "mask"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexOption$Type = (("ignore_case") | ("comments") | ("multiline") | ("unix_lines") | ("dot_matches_all") | ("canon_eq") | ("literal")) | ($RegexOption);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexOption_ = $RegexOption$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$TransformingSequence" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $TransformingSequence<T, R> implements $Sequence<(R)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Function1$Type<(any), (any)>)

public "flatten$kotlin_stdlib"<E>(arg0: $Function1$Type<(any), (any)>): $Sequence<(E)>
public "iterator"(): $Iterator<(R)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformingSequence$Type<T, R> = ($TransformingSequence<(T), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformingSequence_<T, R> = $TransformingSequence$Type<(T), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharRange$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$CharRange, $CharRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharRange"

export class $CharRange$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getEMPTY"(): $CharRange
get "eMPTY"(): $CharRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharRange$Companion$Type = ($CharRange$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharRange$Companion_ = $CharRange$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkCopyBehaviour" {
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$ChunkPredicate, $ChunkPredicate$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkPredicate"

export class $ChunkCopyBehaviour {
static readonly "COPY_NONE": integer
static readonly "COPY_PALETTE": integer
static readonly "COPY_ALL_SAFE": integer
static readonly "COPY_ALL": integer
static readonly "COPY_PHYS": integer
static readonly "COPY_TEXTUAL": integer
static readonly "COPY_TRANSPARENCY": integer
static readonly "COPY_UNKNOWN": integer
static readonly "COPY_ALMOSTALL": integer

constructor()

public static "createPredicate"(arg0: integer, arg1: $ImageInfo$Type): $ChunkPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkCopyBehaviour$Type = ($ChunkCopyBehaviour);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkCopyBehaviour_ = $ChunkCopyBehaviour$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AttributesMap" {
import {$Attributes, $Attributes$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Attributes"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AttributesMap implements $Attributes {

constructor()
constructor(arg0: $AttributesMap$Type)

public "toString"(): string
public "size"(): integer
public "addAll"(arg0: $Attributes$Type): void
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "removeAttribute"(arg0: string): void
public static "getAttributeNamesCopy"(arg0: $Attributes$Type): $Enumeration<(string)>
public "clearAttributes"(): void
public "getAttributeEntrySet"(): $Set<($Map$Entry<(string), (any)>)>
public "getAttributeNameSet"(): $Set<(string)>
public "getAttributeNames"(): $Enumeration<(string)>
get "attributeEntrySet"(): $Set<($Map$Entry<(string), (any)>)>
get "attributeNameSet"(): $Set<(string)>
get "attributeNames"(): $Enumeration<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributesMap$Type = ($AttributesMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributesMap_ = $AttributesMap$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$RangesKt___RangesKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$LongRange, $LongRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongRange"
import {$IntProgression, $IntProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgression"
import {$LongProgression, $LongProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression"
import {$ClosedFloatingPointRange, $ClosedFloatingPointRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedFloatingPointRange"
import {$CharRange, $CharRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharRange"
import {$RangesKt__RangesKt, $RangesKt__RangesKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$RangesKt__RangesKt"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"
import {$CharProgression, $CharProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $RangesKt___RangesKt extends $RangesKt__RangesKt {

constructor()

public static "step"(arg0: $CharProgression$Type, arg1: integer): $CharProgression
public static "step"(arg0: $IntProgression$Type, arg1: integer): $IntProgression
public static "step"(arg0: $LongProgression$Type, arg1: long): $LongProgression
public static "reversed"(arg0: $LongProgression$Type): $LongProgression
public static "reversed"(arg0: $CharProgression$Type): $CharProgression
public static "reversed"(arg0: $IntProgression$Type): $IntProgression
public static "random"(arg0: $CharRange$Type, arg1: $Random$Type): character
public static "random"(arg0: $LongRange$Type, arg1: $Random$Type): long
public static "random"(arg0: $IntRange$Type, arg1: $Random$Type): integer
public static "until"(arg0: long, arg1: long): $LongRange
public static "until"(arg0: byte, arg1: long): $LongRange
public static "until"(arg0: short, arg1: long): $LongRange
public static "until"(arg0: integer, arg1: long): $LongRange
public static "until"(arg0: short, arg1: integer): $IntRange
public static "until"(arg0: short, arg1: short): $IntRange
public static "until"(arg0: byte, arg1: short): $IntRange
public static "until"(arg0: long, arg1: short): $LongRange
public static "until"(arg0: integer, arg1: short): $IntRange
public static "until"(arg0: short, arg1: byte): $IntRange
public static "until"(arg0: byte, arg1: byte): $IntRange
public static "until"(arg0: long, arg1: byte): $LongRange
public static "until"(arg0: integer, arg1: byte): $IntRange
public static "until"(arg0: byte, arg1: integer): $IntRange
public static "until"(arg0: long, arg1: integer): $LongRange
public static "until"(arg0: integer, arg1: integer): $IntRange
public static "until"(arg0: character, arg1: character): $CharRange
public static "coerceAtMost"(arg0: integer, arg1: integer): integer
public static "coerceAtMost"(arg0: long, arg1: long): long
public static "coerceAtMost"(arg0: float, arg1: float): float
public static "coerceAtMost"(arg0: double, arg1: double): double
public static "coerceAtMost"(arg0: short, arg1: short): short
public static "coerceAtMost"(arg0: byte, arg1: byte): byte
public static "coerceAtMost"<T extends $Comparable<(any)>>(arg0: T, arg1: T): T
public static "coerceIn"(arg0: double, arg1: double, arg2: double): double
public static "coerceIn"<T extends $Comparable<(any)>>(arg0: T, arg1: $ClosedFloatingPointRange$Type<(T)>): T
public static "coerceIn"(arg0: float, arg1: float, arg2: float): float
public static "coerceIn"(arg0: long, arg1: long, arg2: long): long
public static "coerceIn"<T extends $Comparable<(any)>>(arg0: T, arg1: $ClosedRange$Type<(T)>): T
public static "coerceIn"(arg0: integer, arg1: $ClosedRange$Type<(integer)>): integer
public static "coerceIn"(arg0: long, arg1: $ClosedRange$Type<(long)>): long
public static "coerceIn"(arg0: byte, arg1: byte, arg2: byte): byte
public static "coerceIn"<T extends $Comparable<(any)>>(arg0: T, arg1: T, arg2: T): T
public static "coerceIn"(arg0: short, arg1: short, arg2: short): short
public static "coerceIn"(arg0: integer, arg1: integer, arg2: integer): integer
public static "intRangeContains"(arg0: $ClosedRange$Type<(integer)>, arg1: short): boolean
public static "intRangeContains"(arg0: $ClosedRange$Type<(integer)>, arg1: long): boolean
public static "intRangeContains"(arg0: $ClosedRange$Type<(integer)>, arg1: byte): boolean
public static "toIntExactOrNull"(arg0: long): integer
public static "toIntExactOrNull"(arg0: float): integer
public static "toIntExactOrNull"(arg0: double): integer
public static "toByteExactOrNull"(arg0: long): byte
public static "toByteExactOrNull"(arg0: integer): byte
public static "toByteExactOrNull"(arg0: double): byte
public static "toByteExactOrNull"(arg0: short): byte
public static "toByteExactOrNull"(arg0: float): byte
public static "floatRangeContains"(arg0: $ClosedRange$Type<(float)>, arg1: double): boolean
public static "toLongExactOrNull"(arg0: float): long
public static "toLongExactOrNull"(arg0: double): long
public static "toShortExactOrNull"(arg0: double): short
public static "toShortExactOrNull"(arg0: float): short
public static "toShortExactOrNull"(arg0: long): short
public static "toShortExactOrNull"(arg0: integer): short
public static "byteRangeContains"(arg0: $ClosedRange$Type<(byte)>, arg1: long): boolean
public static "byteRangeContains"(arg0: $ClosedRange$Type<(byte)>, arg1: short): boolean
public static "byteRangeContains"(arg0: $ClosedRange$Type<(byte)>, arg1: integer): boolean
public static "shortRangeContains"(arg0: $ClosedRange$Type<(short)>, arg1: integer): boolean
public static "shortRangeContains"(arg0: $ClosedRange$Type<(short)>, arg1: long): boolean
public static "shortRangeContains"(arg0: $ClosedRange$Type<(short)>, arg1: byte): boolean
public static "longRangeContains"(arg0: $ClosedRange$Type<(long)>, arg1: short): boolean
public static "longRangeContains"(arg0: $ClosedRange$Type<(long)>, arg1: integer): boolean
public static "longRangeContains"(arg0: $ClosedRange$Type<(long)>, arg1: byte): boolean
public static "randomOrNull"(arg0: $LongRange$Type, arg1: $Random$Type): long
public static "randomOrNull"(arg0: $CharRange$Type, arg1: $Random$Type): character
public static "randomOrNull"(arg0: $IntRange$Type, arg1: $Random$Type): integer
public static "doubleRangeContains"(arg0: $ClosedRange$Type<(double)>, arg1: float): boolean
public static "downTo"(arg0: integer, arg1: short): $IntProgression
public static "downTo"(arg0: short, arg1: long): $LongProgression
public static "downTo"(arg0: long, arg1: short): $LongProgression
public static "downTo"(arg0: byte, arg1: long): $LongProgression
public static "downTo"(arg0: long, arg1: long): $LongProgression
public static "downTo"(arg0: integer, arg1: byte): $IntProgression
public static "downTo"(arg0: long, arg1: byte): $LongProgression
public static "downTo"(arg0: byte, arg1: byte): $IntProgression
public static "downTo"(arg0: short, arg1: byte): $IntProgression
public static "downTo"(arg0: short, arg1: short): $IntProgression
public static "downTo"(arg0: byte, arg1: short): $IntProgression
public static "downTo"(arg0: integer, arg1: integer): $IntProgression
public static "downTo"(arg0: long, arg1: integer): $LongProgression
public static "downTo"(arg0: character, arg1: character): $CharProgression
public static "downTo"(arg0: integer, arg1: long): $LongProgression
public static "downTo"(arg0: short, arg1: integer): $IntProgression
public static "downTo"(arg0: byte, arg1: integer): $IntProgression
public static "coerceAtLeast"(arg0: integer, arg1: integer): integer
public static "coerceAtLeast"(arg0: short, arg1: short): short
public static "coerceAtLeast"(arg0: byte, arg1: byte): byte
public static "coerceAtLeast"<T extends $Comparable<(any)>>(arg0: T, arg1: T): T
public static "coerceAtLeast"(arg0: long, arg1: long): long
public static "coerceAtLeast"(arg0: float, arg1: float): float
public static "coerceAtLeast"(arg0: double, arg1: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangesKt___RangesKt$Type = ($RangesKt___RangesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangesKt___RangesKt_ = $RangesKt___RangesKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableCollection" {
import {$KMutableIterable, $KMutableIterable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableIterable"

export interface $KMutableCollection extends $KMutableIterable {

}

export namespace $KMutableCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableCollection$Type = ($KMutableCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableCollection_ = $KMutableCollection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableMap$Entry" {
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"

export interface $KMutableMap$Entry extends $KMappedMarker {

}

export namespace $KMutableMap$Entry {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMutableMap$Entry$Type = ($KMutableMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMutableMap$Entry_ = $KMutableMap$Entry$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/io/$FutureWriteCallback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$WriteCallback, $WriteCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WriteCallback"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$FutureCallback, $FutureCallback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$FutureCallback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $FutureWriteCallback extends $FutureCallback implements $WriteCallback {

constructor()

public "writeFailed"(arg0: $Throwable$Type): void
public "writeSuccess"(): void
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FutureWriteCallback$Type = ($FutureWriteCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FutureWriteCallback_ = $FutureWriteCallback$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField" {
import {$HttpHeader, $HttpHeader$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeader"
import {$HttpHeaderValue, $HttpHeaderValue$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpHeaderValue"

export class $HttpField {

constructor(arg0: $HttpHeader$Type, arg1: string, arg2: string)
constructor(arg0: string, arg1: string)
constructor(arg0: $HttpHeader$Type, arg1: $HttpHeaderValue$Type)
constructor(arg0: $HttpHeader$Type, arg1: string)

public "getName"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): string
public "contains"(arg0: string): boolean
public "getHeader"(): $HttpHeader
public "getIntValue"(): integer
public "isSameName"(arg0: $HttpField$Type): boolean
public "getLongValue"(): long
public "getValues"(): (string)[]
get "name"(): string
get "value"(): string
get "header"(): $HttpHeader
get "intValue"(): integer
get "longValue"(): long
get "values"(): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpField$Type = ($HttpField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpField_ = $HttpField$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle" {
import {$Dumpable, $Dumpable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Dumpable"
import {$ContainerLifeCycle$Managed, $ContainerLifeCycle$Managed$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle$Managed"
import {$Container$Listener, $Container$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container$Listener"
import {$Container, $Container$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Container"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Destroyable, $Destroyable$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$Destroyable"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$LifeCycle, $LifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle"
import {$AbstractLifeCycle, $AbstractLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$AbstractLifeCycle"

export class $ContainerLifeCycle extends $AbstractLifeCycle implements $Container, $Destroyable, $Dumpable {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "contains"(arg0: any): boolean
public "destroy"(): void
public "removeEventListener"(arg0: $Container$Listener$Type): void
public "addEventListener"(arg0: $Container$Listener$Type): void
public static "dump"(arg0: $Dumpable$Type): string
public "dump"(): string
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "dump"(arg0: $Appendable$Type): void
public static "dump"(arg0: $Appendable$Type, arg1: string, ...arg2: ($Collection$Type<(any)>)[]): void
public "setStopTimeout"(arg0: long): void
public "isManaged"(arg0: any): boolean
public "addManaged"(arg0: $LifeCycle$Type): void
public "setBeans"(arg0: $Collection$Type<(any)>): void
public "getBeans"(): $Collection<(any)>
public "getBeans"<T>(arg0: $Class$Type<(T)>): $Collection<(T)>
public "removeBeans"(): void
public "dumpStdErr"(): void
public "addBean"(arg0: any, arg1: $ContainerLifeCycle$Managed$Type): boolean
public "addBean"(arg0: any, arg1: boolean): boolean
public "addBean"(arg0: any): boolean
public "manage"(arg0: any): void
public "removeBean"(arg0: any): boolean
public "getBean"<T>(arg0: $Class$Type<(T)>): T
public "unmanage"(arg0: any): void
public "updateBean"(arg0: any, arg1: any, arg2: boolean): void
public "updateBean"(arg0: any, arg1: any): void
public static "dumpObject"(arg0: $Appendable$Type, arg1: any): void
public "updateBeans"(arg0: (any)[], arg1: (any)[]): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
set "stopTimeout"(value: long)
set "beans"(value: $Collection$Type<(any)>)
get "beans"(): $Collection<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerLifeCycle$Type = ($ContainerLifeCycle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerLifeCycle_ = $ContainerLifeCycle$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse" {
import {$ServletOutputStream, $ServletOutputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletOutputStream"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export interface $ServletResponse {

 "reset"(): void
 "flushBuffer"(): void
 "getLocale"(): $Locale
 "setLocale"(arg0: $Locale$Type): void
 "getContentType"(): string
 "getOutputStream"(): $ServletOutputStream
 "setContentType"(arg0: string): void
 "setContentLength"(arg0: integer): void
 "getCharacterEncoding"(): string
 "setContentLengthLong"(arg0: long): void
 "setCharacterEncoding"(arg0: string): void
 "setBufferSize"(arg0: integer): void
 "getBufferSize"(): integer
 "getWriter"(): $PrintWriter
 "isCommitted"(): boolean
 "resetBuffer"(): void
}

export namespace $ServletResponse {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletResponse$Type = ($ServletResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletResponse_ = $ServletResponse$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Deprecated" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$DeprecationLevel, $DeprecationLevel$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$DeprecationLevel"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ReplaceWith, $ReplaceWith$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$ReplaceWith"

export interface $Deprecated extends $Annotation {

 "message"(): string
 "replaceWith"(): $ReplaceWith
 "level"(): $DeprecationLevel
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Deprecated {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Deprecated$Type = ($Deprecated);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Deprecated_ = $Deprecated$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$CompressorStream" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$FilterOutputStream, $FilterOutputStream$Type} from "packages/java/io/$FilterOutputStream"

export class $CompressorStream extends $FilterOutputStream {
readonly "blockLen": integer
readonly "totalbytes": long

constructor(arg0: $OutputStream$Type, arg1: integer, arg2: long)

public "getBytesRaw"(): long
public "setStoreFirstByte"(arg0: boolean, arg1: integer): void
public "getFirstBytes"(): (byte)[]
public "getBytesCompressed"(): long
public "getOs"(): $OutputStream
public "flush"(): void
public "write"(arg0: (byte)[]): void
public "write"(arg0: integer): void
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "close"(): void
public "reset"(): void
public "reset"(arg0: $OutputStream$Type): void
public "isDone"(): boolean
public "done"(): void
public "isClosed"(): boolean
public "getCompressionRatio"(): double
get "bytesRaw"(): long
get "firstBytes"(): (byte)[]
get "bytesCompressed"(): long
get "os"(): $OutputStream
get "closed"(): boolean
get "compressionRatio"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompressorStream$Type = ($CompressorStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompressorStream_ = $CompressorStream$Type;
}}
declare module "packages/info/journeymap/shaded/org/jetbrains/annotations/$NotNull" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $NotNull extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $NotNull {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotNull$Type = ($NotNull);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotNull_ = $NotNull$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/descriptor/$JspPropertyGroupDescriptor" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $JspPropertyGroupDescriptor {

 "getBuffer"(): string
 "getScriptingInvalid"(): string
 "getTrimDirectiveWhitespaces"(): string
 "getErrorOnUndeclaredNamespace"(): string
 "getDeferredSyntaxAllowedAsLiteral"(): string
 "getDefaultContentType"(): string
 "getPageEncoding"(): string
 "getUrlPatterns"(): $Collection<(string)>
 "getIsXml"(): string
 "getIncludePreludes"(): $Collection<(string)>
 "getElIgnored"(): string
 "getIncludeCodas"(): $Collection<(string)>
}

export namespace $JspPropertyGroupDescriptor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JspPropertyGroupDescriptor$Type = ($JspPropertyGroupDescriptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JspPropertyGroupDescriptor_ = $JspPropertyGroupDescriptor$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharProgression$Companion, $CharProgression$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$CharProgression$Companion"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$CharIterator, $CharIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator"

export class $CharProgression implements $Iterable<(character)>, $KMappedMarker {
static readonly "Companion": $CharProgression$Companion

constructor(arg0: character, arg1: character, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $CharIterator
public "getFirst"(): character
public "getLast"(): character
public "getStep"(): integer
public "spliterator"(): $Spliterator<(character)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
get "empty"(): boolean
get "first"(): character
get "last"(): character
get "step"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharProgression$Type = ($CharProgression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharProgression_ = $CharProgression$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Locker" {
import {$Locker$Lock, $Locker$Lock$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Locker$Lock"
import {$Condition, $Condition$Type} from "packages/java/util/concurrent/locks/$Condition"

export class $Locker {

constructor()

public "lock"(): $Locker$Lock
public "newCondition"(): $Condition
public "isLocked"(): boolean
public "lockIfNotHeld"(): $Locker$Lock
get "locked"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Locker$Type = ($Locker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Locker_ = $Locker$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$RouteImpl" {
import {$Wrapper, $Wrapper$Type} from "packages/info/journeymap/shaded/kotlin/spark/utils/$Wrapper"
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Route, $Route$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Route"

export class $RouteImpl implements $Route, $Wrapper {


public "handle"(arg0: $Request$Type, arg1: $Response$Type): any
public static "create"(arg0: string, arg1: $Route$Type): $RouteImpl
public static "create"(arg0: string, arg1: string, arg2: $Route$Type): $RouteImpl
public "getPath"(): string
public "delegate"(): any
public "withPrefix"(arg0: string): $RouteImpl
public "render"(arg0: any): any
public "getAcceptType"(): string
get "path"(): string
get "acceptType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RouteImpl$Type = ($RouteImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RouteImpl_ = $RouteImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/builders/$ListBuilder" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$KMutableList, $KMutableList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$AbstractMutableList, $AbstractMutableList$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$AbstractMutableList"

export class $ListBuilder<E> extends $AbstractMutableList<(E)> implements $List<(E)>, $RandomAccess, $Serializable, $KMutableList {

constructor(arg0: integer)
constructor()

public "add"(arg0: integer, arg1: E): void
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): E
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "subList"(arg0: integer, arg1: integer): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<(E)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: E): E
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "listIterator"(arg0: integer): $ListIterator<(E)>
public "listIterator"(): $ListIterator<(E)>
public "build"(): $List<(E)>
public "removeAt"(arg0: integer): E
public "remove"(arg0: integer): E
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "size"(): integer
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListBuilder$Type<E> = ($ListBuilder<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListBuilder_<E> = $ListBuilder$Type<(E)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelOverHttp" {
import {$HttpConnection, $HttpConnection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConnection"
import {$HttpCompliance, $HttpCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance"
import {$HttpParser$ComplianceHandler, $HttpParser$ComplianceHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$ComplianceHandler"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpTransport, $HttpTransport$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpTransport"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$HttpParser$RequestHandler, $HttpParser$RequestHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$RequestHandler"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$HttpConfiguration, $HttpConfiguration$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export class $HttpChannelOverHttp extends $HttpChannel implements $HttpParser$RequestHandler, $HttpParser$ComplianceHandler {

constructor(arg0: $HttpConnection$Type, arg1: $Connector$Type, arg2: $HttpConfiguration$Type, arg3: $EndPoint$Type, arg4: $HttpTransport$Type)

public "content"(arg0: $ByteBuffer$Type): boolean
public "abort"(arg0: $Throwable$Type): void
public "recycle"(): void
public "asyncReadFillInterested"(): void
public "isExpecting100Continue"(): boolean
public "isExpecting102Processing"(): boolean
public "continue100"(arg0: integer): void
public "earlyEOF"(): void
public "onComplianceViolation"(arg0: $HttpCompliance$Type, arg1: $HttpCompliance$Type, arg2: string): void
public "messageComplete"(): boolean
public "parsedTrailer"(arg0: $HttpField$Type): void
public "contentComplete"(): boolean
public "parsedHeader"(arg0: $HttpField$Type): void
public "headerComplete"(): boolean
public "startRequest"(arg0: string, arg1: string, arg2: $HttpVersion$Type): boolean
public "badMessage"(arg0: integer, arg1: string): void
public "getHeaderCacheSize"(): integer
get "expecting100Continue"(): boolean
get "expecting102Processing"(): boolean
get "headerCacheSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpChannelOverHttp$Type = ($HttpChannelOverHttp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpChannelOverHttp_ = $HttpChannelOverHttp$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server" {
import {$RequestLog, $RequestLog$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$RequestLog"
import {$Attributes, $Attributes$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Attributes"
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$HandlerWrapper, $HandlerWrapper$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$HandlerWrapper"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$ErrorHandler, $ErrorHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ErrorHandler"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ThreadPool, $ThreadPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$ThreadPool"
import {$SessionIdManager, $SessionIdManager$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$SessionIdManager"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $Server extends $HandlerWrapper implements $Attributes {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor(arg0: $ThreadPool$Type)
constructor(arg0: $InetSocketAddress$Type)
constructor(arg0: integer)
constructor()

public static "main"(...arg0: (string)[]): void
public "toString"(): string
public "join"(): void
public "handle"(arg0: $HttpChannel$Type): void
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public static "getVersion"(): string
public "getURI"(): $URI
public "handleAsync"(arg0: $HttpChannel$Type): void
public "addConnector"(arg0: $Connector$Type): void
public "removeAttribute"(arg0: string): void
public "getSessionIdManager"(): $SessionIdManager
public "setSessionIdManager"(arg0: $SessionIdManager$Type): void
public "setErrorHandler"(arg0: $ErrorHandler$Type): void
public "getErrorHandler"(): $ErrorHandler
public "dump"(arg0: $Appendable$Type, arg1: string): void
public "setStopTimeout"(arg0: long): void
public "setConnectors"(arg0: ($Connector$Type)[]): void
public "getRequestLog"(): $RequestLog
public "getStopAtShutdown"(): boolean
public "setStopAtShutdown"(arg0: boolean): void
public "setDumpBeforeStop"(arg0: boolean): void
public "setRequestLog"(arg0: $RequestLog$Type): void
public "getConnectors"(): ($Connector)[]
public "getThreadPool"(): $ThreadPool
public "isDumpBeforeStop"(): boolean
public "getDateField"(): $HttpField
public "setDumpAfterStart"(arg0: boolean): void
public "removeConnector"(arg0: $Connector$Type): void
public "isDumpAfterStart"(): boolean
public "clearAttributes"(): void
public "getAttributeNames"(): $Enumeration<(string)>
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "version"(): string
get "uRI"(): $URI
get "sessionIdManager"(): $SessionIdManager
set "sessionIdManager"(value: $SessionIdManager$Type)
set "errorHandler"(value: $ErrorHandler$Type)
get "errorHandler"(): $ErrorHandler
set "stopTimeout"(value: long)
set "connectors"(value: ($Connector$Type)[])
get "requestLog"(): $RequestLog
get "stopAtShutdown"(): boolean
set "stopAtShutdown"(value: boolean)
set "dumpBeforeStop"(value: boolean)
set "requestLog"(value: $RequestLog$Type)
get "connectors"(): ($Connector)[]
get "threadPool"(): $ThreadPool
get "dumpBeforeStop"(): boolean
get "dateField"(): $HttpField
set "dumpAfterStart"(value: boolean)
get "dumpAfterStart"(): boolean
get "attributeNames"(): $Enumeration<(string)>
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Server$Type = ($Server);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Server_ = $Server$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$Charsets" {
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"

export class $Charsets {
static readonly "INSTANCE": $Charsets
static readonly "UTF_8": $Charset
static readonly "UTF_16": $Charset
static readonly "UTF_16BE": $Charset
static readonly "UTF_16LE": $Charset
static readonly "US_ASCII": $Charset
static readonly "ISO_8859_1": $Charset


public "UTF32"(): $Charset
public "UTF32_LE"(): $Charset
public "UTF32_BE"(): $Charset
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Charsets$Type = ($Charsets);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Charsets_ = $Charsets$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/annotation/$AnnotationRetention" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AnnotationRetention extends $Enum<($AnnotationRetention)> {
static readonly "SOURCE": $AnnotationRetention
static readonly "BINARY": $AnnotationRetention
static readonly "RUNTIME": $AnnotationRetention


public static "values"(): ($AnnotationRetention)[]
public static "valueOf"(arg0: string): $AnnotationRetention
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnnotationRetention$Type = (("binary") | ("runtime") | ("source")) | ($AnnotationRetention);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnnotationRetention_ = $AnnotationRetention$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$ResourceUtils" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$URLConnection, $URLConnection$Type} from "packages/java/net/$URLConnection"

export class $ResourceUtils {
static readonly "CLASSPATH_URL_PREFIX": string
static readonly "FILE_URL_PREFIX": string
static readonly "URL_PROTOCOL_FILE": string
static readonly "URL_PROTOCOL_JAR": string
static readonly "URL_PROTOCOL_ZIP": string
static readonly "URL_PROTOCOL_VFSZIP": string
static readonly "URL_PROTOCOL_WSJAR": string
static readonly "JAR_URL_SEPARATOR": string

constructor()

public static "isUrl"(arg0: string): boolean
public static "getFile"(arg0: $URI$Type): $File
public static "getFile"(arg0: $URL$Type, arg1: string): $File
public static "getFile"(arg0: $URI$Type, arg1: string): $File
public static "getFile"(arg0: $URL$Type): $File
public static "getFile"(arg0: string): $File
public static "toURI"(arg0: $URL$Type): $URI
public static "toURI"(arg0: string): $URI
public static "getURL"(arg0: string): $URL
public static "isFileURL"(arg0: $URL$Type): boolean
public static "extractJarFileURL"(arg0: $URL$Type): $URL
public static "isJarURL"(arg0: $URL$Type): boolean
public static "useCachesIfNecessary"(arg0: $URLConnection$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResourceUtils$Type = ($ResourceUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResourceUtils_ = $ResourceUtils$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$ComplianceHandler" {
import {$HttpCompliance, $HttpCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpCompliance"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpParser$HttpHandler, $HttpParser$HttpHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$HttpHandler"

export interface $HttpParser$ComplianceHandler extends $HttpParser$HttpHandler {

 "onComplianceViolation"(arg0: $HttpCompliance$Type, arg1: $HttpCompliance$Type, arg2: string): void
 "content"(arg0: $ByteBuffer$Type): boolean
 "earlyEOF"(): void
 "messageComplete"(): boolean
 "parsedTrailer"(arg0: $HttpField$Type): void
 "contentComplete"(): boolean
 "parsedHeader"(arg0: $HttpField$Type): void
 "headerComplete"(): boolean
 "badMessage"(arg0: integer, arg1: string): void
 "getHeaderCacheSize"(): integer
}

export namespace $HttpParser$ComplianceHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$ComplianceHandler$Type = ($HttpParser$ComplianceHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser$ComplianceHandler_ = $HttpParser$ComplianceHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/extensions/$WebSocketExtensionFactory" {
import {$Extension, $Extension$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Extension"
import {$WebSocketContainerScope, $WebSocketContainerScope$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/scopes/$WebSocketContainerScope"
import {$ExtensionConfig, $ExtensionConfig$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionConfig"
import {$ExtensionFactory, $ExtensionFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$ExtensionFactory"

export class $WebSocketExtensionFactory extends $ExtensionFactory {

constructor(arg0: $WebSocketContainerScope$Type)

public "newInstance"(arg0: $ExtensionConfig$Type): $Extension
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketExtensionFactory$Type = ($WebSocketExtensionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketExtensionFactory_ = $WebSocketExtensionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntRange$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$UIntRange, $UIntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntRange"

export class $UIntRange$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getEMPTY"(): $UIntRange
get "eMPTY"(): $UIntRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntRange$Companion$Type = ($UIntRange$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntRange$Companion_ = $UIntRange$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/unsigned/$UArraysKt" {
import {$UArraysKt___UArraysKt, $UArraysKt___UArraysKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/unsigned/$UArraysKt___UArraysKt"

export class $UArraysKt extends $UArraysKt___UArraysKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UArraysKt$Type = ($UArraysKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UArraysKt_ = $UArraysKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$PixelsWriterDefault" {
import {$PixelsWriter, $PixelsWriter$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/pixels/$PixelsWriter"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PixelsWriterDefault extends $PixelsWriter {

constructor(arg0: $ImageInfo$Type)

public "close"(): void
public "setFilterWeights"(arg0: (double)[]): void
public "tuneMemory"(arg0: double): void
public "getRowb"(): (byte)[]
public "setPreferenceForNone"(arg0: double): void
set "filterWeights"(value: (double)[])
get "rowb"(): (byte)[]
set "preferenceForNone"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PixelsWriterDefault$Type = ($PixelsWriterDefault);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PixelsWriterDefault_ = $PixelsWriterDefault$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/annotation/$HttpMethodConstraint" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$ServletSecurity$TransportGuarantee, $ServletSecurity$TransportGuarantee$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$TransportGuarantee"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletSecurity$EmptyRoleSemantic, $ServletSecurity$EmptyRoleSemantic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$EmptyRoleSemantic"

export interface $HttpMethodConstraint extends $Annotation {

 "rolesAllowed"(): (string)[]
 "transportGuarantee"(): $ServletSecurity$TransportGuarantee
 "emptyRoleSemantic"(): $ServletSecurity$EmptyRoleSemantic
 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $HttpMethodConstraint {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpMethodConstraint$Type = ($HttpMethodConstraint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpMethodConstraint_ = $HttpMethodConstraint$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkUNKNOWN" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$PngChunkMultiple, $PngChunkMultiple$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkMultiple"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PngChunkUNKNOWN extends $PngChunkMultiple {
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: string, arg1: $ImageInfo$Type)

public "getData"(): (byte)[]
public "setData"(arg0: (byte)[]): void
public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
get "data"(): (byte)[]
set "data"(value: (byte)[])
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkUNKNOWN$Type = ($PngChunkUNKNOWN);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkUNKNOWN_ = $PngChunkUNKNOWN$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/internal/$HidesMembers" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $HidesMembers extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $HidesMembers {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HidesMembers$Type = ($HidesMembers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HidesMembers_ = $HidesMembers$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt___StringsJvmKt" {
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$StringsKt__StringsKt, $StringsKt__StringsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringsKt"

export class $StringsKt___StringsJvmKt extends $StringsKt__StringsKt {

constructor()

public static "toSortedSet"(arg0: charseq): $SortedSet<(character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt___StringsJvmKt$Type = ($StringsKt___StringsJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt___StringsJvmKt_ = $StringsKt___StringsJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection$Listener" {
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"

export interface $Connection$Listener {

 "onClosed"(arg0: $Connection$Type): void
 "onOpened"(arg0: $Connection$Type): void
}

export namespace $Connection$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Connection$Listener$Type = ($Connection$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Connection$Listener_ = $Connection$Listener$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $MetaData implements $Iterable<($HttpField)> {

constructor(arg0: $HttpVersion$Type, arg1: $HttpFields$Type)
constructor(arg0: $HttpVersion$Type, arg1: $HttpFields$Type, arg2: long)

public "getTrailerSupplier"(): $Supplier<($HttpFields)>
public "isResponse"(): boolean
public "isRequest"(): boolean
public "toString"(): string
public "iterator"(): $Iterator<($HttpField)>
public "getFields"(): $HttpFields
/**
 * 
 * @deprecated
 */
public "getVersion"(): $HttpVersion
public "getContentLength"(): long
public "setHttpVersion"(arg0: $HttpVersion$Type): void
public "setTrailerSupplier"(arg0: $Supplier$Type<($HttpFields$Type)>): void
public "getHttpVersion"(): $HttpVersion
public "spliterator"(): $Spliterator<($HttpField)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$HttpField>;
get "trailerSupplier"(): $Supplier<($HttpFields)>
get "response"(): boolean
get "request"(): boolean
get "fields"(): $HttpFields
get "version"(): $HttpVersion
get "contentLength"(): long
set "httpVersion"(value: $HttpVersion$Type)
set "trailerSupplier"(value: $Supplier$Type<($HttpFields$Type)>)
get "httpVersion"(): $HttpVersion
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaData$Type = ($MetaData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaData_ = $MetaData$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt" {
import {$StringsKt___StringsKt, $StringsKt___StringsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt___StringsKt"

export class $StringsKt extends $StringsKt___StringsKt {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt$Type = ($StringsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt_ = $StringsKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$ConnectionState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ConnectionState extends $Enum<($ConnectionState)> {
static readonly "CONNECTING": $ConnectionState
static readonly "CONNECTED": $ConnectionState
static readonly "OPEN": $ConnectionState
static readonly "CLOSING": $ConnectionState
static readonly "CLOSED": $ConnectionState


public static "values"(): ($ConnectionState)[]
public static "valueOf"(arg0: string): $ConnectionState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionState$Type = (("connected") | ("closing") | ("closed") | ("connecting") | ("open")) | ($ConnectionState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionState_ = $ConnectionState$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionReferenceImpl" {
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$FunctionReference, $FunctionReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionReference"

export class $FunctionReferenceImpl extends $FunctionReference {
static readonly "NO_RECEIVER": any

constructor(arg0: integer, arg1: $KDeclarationContainer$Type, arg2: string, arg3: string)
constructor(arg0: integer, arg1: $Class$Type<(any)>, arg2: string, arg3: string, arg4: integer)
constructor(arg0: integer, arg1: any, arg2: $Class$Type<(any)>, arg3: string, arg4: string, arg5: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionReferenceImpl$Type = ($FunctionReferenceImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionReferenceImpl_ = $FunctionReferenceImpl$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$DebugMetadataKt" {
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"
import {$BaseContinuationImpl, $BaseContinuationImpl$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$BaseContinuationImpl"

export class $DebugMetadataKt {


public static "getStackTraceElement"(arg0: $BaseContinuationImpl$Type): $StackTraceElement
public static "getSpilledVariableFieldMapping"(arg0: $BaseContinuationImpl$Type): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugMetadataKt$Type = ($DebugMetadataKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DebugMetadataKt_ = $DebugMetadataKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/http/matching/$RequestWrapper" {
import {$RouteMatch, $RouteMatch$Type} from "packages/info/journeymap/shaded/kotlin/spark/routematch/$RouteMatch"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$QueryParamsMap, $QueryParamsMap$Type} from "packages/info/journeymap/shaded/kotlin/spark/$QueryParamsMap"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Session"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RequestWrapper extends $Request {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "url"(): string
public "host"(): string
public "port"(): integer
public "uri"(): string
public "params"(): $Map<(string), (string)>
public "params"(arg0: string): string
public "setDelegate"(arg0: $Request$Type): void
public "protocol"(): string
public "body"(): string
public "raw"(): $HttpServletRequest
public "scheme"(): string
public "attributes"(): $Set<(string)>
public "attribute"<T>(arg0: string): T
public "attribute"(arg0: string, arg1: any): void
public "contentType"(): string
public "contentLength"(): integer
public "ip"(): string
public "bodyAsBytes"(): (byte)[]
public "queryMap"(): $QueryParamsMap
public "queryMap"(arg0: string): $QueryParamsMap
public "splat"(): (string)[]
public "changeMatch"(arg0: $RouteMatch$Type): void
public "requestMethod"(): string
public "queryParams"(arg0: string): string
public "queryParams"(): $Set<(string)>
public "queryParamsValues"(arg0: string): (string)[]
public "userAgent"(): string
public "cookies"(): $Map<(string), (string)>
public "cookie"(arg0: string): string
public "headers"(): $Set<(string)>
public "headers"(arg0: string): string
public "contextPath"(): string
public "servletPath"(): string
public "pathInfo"(): string
public "queryString"(): string
public "session"(arg0: boolean): $Session
public "session"(): $Session
set "delegate"(value: $Request$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestWrapper$Type = ($RequestWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequestWrapper_ = $RequestWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$PathSpecGroup" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PathSpecGroup extends $Enum<($PathSpecGroup)> {
static readonly "ROOT": $PathSpecGroup
static readonly "EXACT": $PathSpecGroup
static readonly "MIDDLE_GLOB": $PathSpecGroup
static readonly "PREFIX_GLOB": $PathSpecGroup
static readonly "SUFFIX_GLOB": $PathSpecGroup
static readonly "DEFAULT": $PathSpecGroup


public static "values"(): ($PathSpecGroup)[]
public static "valueOf"(arg0: string): $PathSpecGroup
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathSpecGroup$Type = (("default") | ("middle_glob") | ("root") | ("exact") | ("prefix_glob") | ("suffix_glob")) | ($PathSpecGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathSpecGroup_ = $PathSpecGroup$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClass" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KCallable, $KCallable$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KCallable"
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KAnnotatedElement, $KAnnotatedElement$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KAnnotatedElement"

export interface $KClass<T> extends $KDeclarationContainer, $KAnnotatedElement, $KClassifier {

 "isCompanion"(): boolean
 "isFun"(): boolean
 "getNestedClasses"(): $Collection<($KClass<(any)>)>
 "getSupertypes"(): $List<($KType)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isInstance"(arg0: any): boolean
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getSimpleName"(): string
 "isOpen"(): boolean
 "getConstructors"(): $Collection<($KFunction<(T)>)>
 "isSealed"(): boolean
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "getMembers"(): $Collection<($KCallable<(any)>)>
 "getObjectInstance"(): T
 "getQualifiedName"(): string
 "isValue"(): boolean
 "getVisibility"(): $KVisibility
 "isInner"(): boolean
 "isData"(): boolean
 "getSealedSubclasses"(): $List<($KClass<(any)>)>
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KClass {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KClass$Type<T> = ($KClass<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KClass_<T> = $KClass$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunksList" {
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export class $ChunksList {
static readonly "CHUNK_GROUP_0_IDHR": integer
static readonly "CHUNK_GROUP_1_AFTERIDHR": integer
static readonly "CHUNK_GROUP_2_PLTE": integer
static readonly "CHUNK_GROUP_3_AFTERPLTE": integer
static readonly "CHUNK_GROUP_4_IDAT": integer
static readonly "CHUNK_GROUP_5_AFTERIDAT": integer
static readonly "CHUNK_GROUP_6_END": integer

constructor(arg0: $ImageInfo$Type)

public "toString"(): string
public "getChunks"(): $List<($PngChunk)>
public "appendReadChunk"(arg0: $PngChunk$Type, arg1: integer): void
public "toStringFull"(): string
public "getById1"(arg0: string): $PngChunk
public "getById1"(arg0: string, arg1: boolean): $PngChunk
public "getById1"(arg0: string, arg1: string, arg2: boolean): $PngChunk
public "getEquivalent"(arg0: $PngChunk$Type): $List<($PngChunk)>
public "getById"(arg0: string, arg1: string): $List<(any)>
public "getById"(arg0: string): $List<(any)>
get "chunks"(): $List<($PngChunk)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunksList$Type = ($ChunksList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunksList_ = $ChunksList$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequenceScope" {
import {$Continuation, $Continuation$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$Continuation"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SequenceScope<T> {

constructor()

public "yield"(arg0: T, arg1: $Continuation$Type<(any)>): any
public "yieldAll"(arg0: $Iterable$Type<(any)>, arg1: $Continuation$Type<(any)>): any
public "yieldAll"(arg0: $Sequence$Type<(any)>, arg1: $Continuation$Type<(any)>): any
public "yieldAll"(arg0: $Iterator$Type<(any)>, arg1: $Continuation$Type<(any)>): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequenceScope$Type<T> = ($SequenceScope<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequenceScope_<T> = $SequenceScope$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ErrorHandler" {
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$AbstractHandler, $AbstractHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandler"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $ErrorHandler extends $AbstractHandler {
static readonly "ERROR_PAGE": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public static "getErrorHandler"(arg0: $Server$Type, arg1: $ContextHandler$Type): $ErrorHandler
public "doError"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "badMessageError"(arg0: integer, arg1: string, arg2: $HttpFields$Type): $ByteBuffer
public "getCacheControl"(): string
public "setCacheControl"(arg0: string): void
public "isShowStacks"(): boolean
public "setShowStacks"(arg0: boolean): void
public "getShowMessageInTitle"(): boolean
public "setShowMessageInTitle"(arg0: boolean): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "cacheControl"(): string
set "cacheControl"(value: string)
get "showStacks"(): boolean
set "showStacks"(value: boolean)
get "showMessageInTitle"(): boolean
set "showMessageInTitle"(value: boolean)
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorHandler$Type = ($ErrorHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErrorHandler_ = $ErrorHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$LongProgression, $LongProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgression"

export class $LongProgression$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "fromClosedRange"(arg0: long, arg1: long, arg2: long): $LongProgression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongProgression$Companion$Type = ($LongProgression$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongProgression$Companion_ = $LongProgression$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$JarFileResource" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$JarResource, $JarResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$JarResource"

export class $JarFileResource extends $JarResource {
static "__defaultUseCaches": boolean


public static "getNonCachingResource"(arg0: $Resource$Type): $Resource
public "length"(): long
public "list"(): (string)[]
public "close"(): void
public "exists"(): boolean
public "isDirectory"(): boolean
public "lastModified"(): long
public "isContainedIn"(arg0: $Resource$Type): boolean
get "directory"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JarFileResource$Type = ($JarFileResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JarFileResource_ = $JarFileResource$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$HttpConstraintElement" {
import {$ServletSecurity$TransportGuarantee, $ServletSecurity$TransportGuarantee$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$TransportGuarantee"
import {$ServletSecurity$EmptyRoleSemantic, $ServletSecurity$EmptyRoleSemantic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/annotation/$ServletSecurity$EmptyRoleSemantic"

export class $HttpConstraintElement {

constructor(arg0: $ServletSecurity$EmptyRoleSemantic$Type, arg1: $ServletSecurity$TransportGuarantee$Type, ...arg2: (string)[])
constructor()
constructor(arg0: $ServletSecurity$EmptyRoleSemantic$Type)
constructor(arg0: $ServletSecurity$TransportGuarantee$Type, ...arg1: (string)[])

public "getRolesAllowed"(): (string)[]
public "getEmptyRoleSemantic"(): $ServletSecurity$EmptyRoleSemantic
public "getTransportGuarantee"(): $ServletSecurity$TransportGuarantee
get "rolesAllowed"(): (string)[]
get "emptyRoleSemantic"(): $ServletSecurity$EmptyRoleSemantic
get "transportGuarantee"(): $ServletSecurity$TransportGuarantee
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConstraintElement$Type = ($HttpConstraintElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConstraintElement_ = $HttpConstraintElement$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntProgressionIterator" {
import {$IntIterator, $IntIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IntIterator"

export class $IntProgressionIterator extends $IntIterator {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "hasNext"(): boolean
public "nextInt"(): integer
public "getStep"(): integer
get "step"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntProgressionIterator$Type = ($IntProgressionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntProgressionIterator_ = $IntProgressionIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandlerImpl" {
import {$Response, $Response$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Response"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Request"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$ExceptionHandler, $ExceptionHandler$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandler"

export class $ExceptionHandlerImpl<T extends $Exception> implements $ExceptionHandler<(T)> {

constructor(arg0: $Class$Type<(T)>)

public "handle"(arg0: T, arg1: $Request$Type, arg2: $Response$Type): void
public "exceptionClass"(): $Class<(any)>
public "exceptionClass"(arg0: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionHandlerImpl$Type<T> = ($ExceptionHandlerImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionHandlerImpl_<T> = $ExceptionHandlerImpl$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator" {
import {$MetaData$Response, $MetaData$Response$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Response"
import {$HttpGenerator$Result, $HttpGenerator$Result$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator$Result"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$HttpFields, $HttpFields$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpFields"
import {$MetaData$Request, $MetaData$Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$MetaData$Request"
import {$HttpGenerator$State, $HttpGenerator$State$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpGenerator$State"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $HttpGenerator {
static readonly "__STRICT": boolean
static readonly "CONTINUE_100_INFO": $MetaData$Response
static readonly "PROGRESS_102_INFO": $MetaData$Response
static readonly "RESPONSE_500_INFO": $MetaData$Response
static readonly "CHUNK_SIZE": integer

constructor()
constructor(arg0: boolean, arg1: boolean)

public "isChunking"(): boolean
public "generateRequest"(arg0: $MetaData$Request$Type, arg1: $ByteBuffer$Type, arg2: $ByteBuffer$Type, arg3: $ByteBuffer$Type, arg4: boolean): $HttpGenerator$Result
public "isNoContent"(): boolean
public "getContentPrepared"(): long
public "generateResponse"(arg0: $MetaData$Response$Type, arg1: boolean, arg2: $ByteBuffer$Type, arg3: $ByteBuffer$Type, arg4: $ByteBuffer$Type, arg5: boolean): $HttpGenerator$Result
/**
 * 
 * @deprecated
 */
public "generateResponse"(arg0: $MetaData$Response$Type, arg1: $ByteBuffer$Type, arg2: $ByteBuffer$Type, arg3: $ByteBuffer$Type, arg4: boolean): $HttpGenerator$Result
public static "getReasonBuffer"(arg0: integer): (byte)[]
public "toString"(): string
public "getState"(): $HttpGenerator$State
public "reset"(): void
public "abort"(): void
public "setPersistent"(arg0: boolean): void
public "isIdle"(): boolean
public "isWritten"(): boolean
public "isPersistent"(): boolean
public "isState"(arg0: $HttpGenerator$State$Type): boolean
public static "setJettyVersion"(arg0: string): void
public "isCommitted"(): boolean
public static "putTo"(arg0: $HttpField$Type, arg1: $ByteBuffer$Type): void
public static "putTo"(arg0: $HttpFields$Type, arg1: $ByteBuffer$Type): void
public "isEnd"(): boolean
/**
 * 
 * @deprecated
 */
public "getSendServerVersion"(): boolean
/**
 * 
 * @deprecated
 */
public "setSendServerVersion"(arg0: boolean): void
get "chunking"(): boolean
get "noContent"(): boolean
get "contentPrepared"(): long
get "state"(): $HttpGenerator$State
set "persistent"(value: boolean)
get "idle"(): boolean
get "written"(): boolean
get "persistent"(): boolean
set "jettyVersion"(value: string)
get "committed"(): boolean
get "end"(): boolean
get "sendServerVersion"(): boolean
set "sendServerVersion"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpGenerator$Type = ($HttpGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpGenerator_ = $HttpGenerator$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngIDatChunkOutputStream" {
import {$ProgressiveOutputStream, $ProgressiveOutputStream$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ProgressiveOutputStream"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"

export class $PngIDatChunkOutputStream extends $ProgressiveOutputStream {

constructor(arg0: $OutputStream$Type)
constructor(arg0: $OutputStream$Type, arg1: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngIDatChunkOutputStream$Type = ($PngIDatChunkOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngIDatChunkOutputStream_ = $PngIDatChunkOutputStream$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IBytesConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IBytesConsumer {

 "consume"(arg0: (byte)[], arg1: integer, arg2: integer): integer

(arg0: (byte)[], arg1: integer, arg2: integer): integer
}

export namespace $IBytesConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBytesConsumer$Type = ($IBytesConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBytesConsumer_ = $IBytesConsumer$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$RowInfo" {
import {$Deinterlacer, $Deinterlacer$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$Deinterlacer"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $RowInfo {
readonly "imgInfo": $ImageInfo
readonly "deinterlacer": $Deinterlacer
readonly "imode": boolean

constructor(arg0: $ImageInfo$Type, arg1: $Deinterlacer$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RowInfo$Type = ($RowInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RowInfo_ = $RowInfo$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharCategory" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$CharCategory$Companion, $CharCategory$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$CharCategory$Companion"

export class $CharCategory extends $Enum<($CharCategory)> {
static readonly "Companion": $CharCategory$Companion
static readonly "UNASSIGNED": $CharCategory
static readonly "UPPERCASE_LETTER": $CharCategory
static readonly "LOWERCASE_LETTER": $CharCategory
static readonly "TITLECASE_LETTER": $CharCategory
static readonly "MODIFIER_LETTER": $CharCategory
static readonly "OTHER_LETTER": $CharCategory
static readonly "NON_SPACING_MARK": $CharCategory
static readonly "ENCLOSING_MARK": $CharCategory
static readonly "COMBINING_SPACING_MARK": $CharCategory
static readonly "DECIMAL_DIGIT_NUMBER": $CharCategory
static readonly "LETTER_NUMBER": $CharCategory
static readonly "OTHER_NUMBER": $CharCategory
static readonly "SPACE_SEPARATOR": $CharCategory
static readonly "LINE_SEPARATOR": $CharCategory
static readonly "PARAGRAPH_SEPARATOR": $CharCategory
static readonly "CONTROL": $CharCategory
static readonly "FORMAT": $CharCategory
static readonly "PRIVATE_USE": $CharCategory
static readonly "SURROGATE": $CharCategory
static readonly "DASH_PUNCTUATION": $CharCategory
static readonly "START_PUNCTUATION": $CharCategory
static readonly "END_PUNCTUATION": $CharCategory
static readonly "CONNECTOR_PUNCTUATION": $CharCategory
static readonly "OTHER_PUNCTUATION": $CharCategory
static readonly "MATH_SYMBOL": $CharCategory
static readonly "CURRENCY_SYMBOL": $CharCategory
static readonly "MODIFIER_SYMBOL": $CharCategory
static readonly "OTHER_SYMBOL": $CharCategory
static readonly "INITIAL_QUOTE_PUNCTUATION": $CharCategory
static readonly "FINAL_QUOTE_PUNCTUATION": $CharCategory


public static "values"(): ($CharCategory)[]
public static "valueOf"(arg0: string): $CharCategory
public "getValue"(): integer
public "contains"(arg0: character): boolean
public "getCode"(): string
get "value"(): integer
get "code"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharCategory$Type = (("private_use") | ("paragraph_separator") | ("start_punctuation") | ("unassigned") | ("enclosing_mark") | ("connector_punctuation") | ("letter_number") | ("other_number") | ("math_symbol") | ("lowercase_letter") | ("space_separator") | ("surrogate") | ("initial_quote_punctuation") | ("decimal_digit_number") | ("other_punctuation") | ("dash_punctuation") | ("currency_symbol") | ("non_spacing_mark") | ("format") | ("modifier_letter") | ("control") | ("uppercase_letter") | ("other_symbol") | ("end_punctuation") | ("modifier_symbol") | ("other_letter") | ("line_separator") | ("titlecase_letter") | ("combining_spacing_mark") | ("final_quote_punctuation")) | ($CharCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharCategory_ = $CharCategory$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession" {
import {$HttpSessionContext, $HttpSessionContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSessionContext"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"

export interface $HttpSession {

/**
 * 
 * @deprecated
 */
 "getValue"(arg0: string): any
 "getId"(): string
 "setAttribute"(arg0: string, arg1: any): void
 "getAttribute"(arg0: string): any
/**
 * 
 * @deprecated
 */
 "putValue"(arg0: string, arg1: any): void
 "getCreationTime"(): long
 "invalidate"(): void
 "isNew"(): boolean
 "removeAttribute"(arg0: string): void
 "getServletContext"(): $ServletContext
 "getAttributeNames"(): $Enumeration<(string)>
/**
 * 
 * @deprecated
 */
 "getSessionContext"(): $HttpSessionContext
 "getLastAccessedTime"(): long
/**
 * 
 * @deprecated
 */
 "removeValue"(arg0: string): void
/**
 * 
 * @deprecated
 */
 "getValueNames"(): (string)[]
 "getMaxInactiveInterval"(): integer
 "setMaxInactiveInterval"(arg0: integer): void
}

export namespace $HttpSession {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpSession$Type = ($HttpSession);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpSession_ = $HttpSession$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt___CollectionsJvmKt" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$CollectionsKt__ReversedViewsKt, $CollectionsKt__ReversedViewsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CollectionsKt__ReversedViewsKt"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $CollectionsKt___CollectionsJvmKt extends $CollectionsKt__ReversedViewsKt {

constructor()

public static "reverse"<T>(arg0: $List$Type<(T)>): void
public static "toSortedSet"<T>(arg0: $Iterable$Type<(any)>, arg1: $Comparator$Type<(any)>): $SortedSet<(T)>
public static "toSortedSet"<T extends $Comparable<(any)>>(arg0: $Iterable$Type<(any)>): $SortedSet<(T)>
public static "filterIsInstanceTo"<C extends $Collection<(any)>, R>(arg0: $Iterable$Type<(any)>, arg1: C, arg2: $Class$Type<(R)>): C
public static "filterIsInstance"<R>(arg0: $Iterable$Type<(any)>, arg1: $Class$Type<(R)>): $List<(R)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionsKt___CollectionsJvmKt$Type = ($CollectionsKt___CollectionsJvmKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionsKt___CollectionsJvmKt_ = $CollectionsKt___CollectionsJvmKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AbstractTrie" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Trie, $Trie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Trie"

export class $AbstractTrie<V> implements $Trie<(V)> {


public "remove"(arg0: string): V
public "get"(arg0: $ByteBuffer$Type): V
public "get"(arg0: string): V
public "put"(arg0: V): boolean
public "getBest"(arg0: (byte)[], arg1: integer, arg2: integer): V
public "getBest"(arg0: string): V
public "isCaseInsensitive"(): boolean
public "get"(arg0: string, arg1: integer, arg2: integer): V
public "get"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "put"(arg0: string, arg1: V): boolean
public "clear"(): void
public "keySet"(): $Set<(string)>
public "isFull"(): boolean
public "getBest"(arg0: string, arg1: integer, arg2: integer): V
public "getBest"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
get "caseInsensitive"(): boolean
get "full"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractTrie$Type<V> = ($AbstractTrie<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractTrie_<V> = $AbstractTrie$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringsKt" {
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CharIterator, $CharIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$StringsKt__StringsJVMKt, $StringsKt__StringsJVMKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt__StringsJVMKt"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $StringsKt__StringsKt extends $StringsKt__StringsJVMKt {

constructor()

public static "indexOf"(arg0: charseq, arg1: character, arg2: integer, arg3: boolean): integer
public static "indexOf"(arg0: charseq, arg1: string, arg2: integer, arg3: boolean): integer
public static "startsWith"(arg0: charseq, arg1: charseq, arg2: boolean): boolean
public static "startsWith"(arg0: charseq, arg1: character, arg2: boolean): boolean
public static "startsWith"(arg0: charseq, arg1: charseq, arg2: integer, arg3: boolean): boolean
public static "lastIndexOf"(arg0: charseq, arg1: character, arg2: integer, arg3: boolean): integer
public static "lastIndexOf"(arg0: charseq, arg1: string, arg2: integer, arg3: boolean): integer
public static "substring"(arg0: charseq, arg1: $IntRange$Type): string
public static "substring"(arg0: string, arg1: $IntRange$Type): string
public static "split"(arg0: charseq, arg1: (character)[], arg2: boolean, arg3: integer): $List<(string)>
public static "split"(arg0: charseq, arg1: (string)[], arg2: boolean, arg3: integer): $List<(string)>
public static "iterator"(arg0: charseq): $CharIterator
public static "trim"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "trim"(arg0: string, ...arg1: (character)[]): string
public static "trim"(arg0: charseq, ...arg1: (character)[]): charseq
public static "trim"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "trim"(arg0: charseq): charseq
public static "lines"(arg0: charseq): $List<(string)>
public static "endsWith"(arg0: charseq, arg1: character, arg2: boolean): boolean
public static "endsWith"(arg0: charseq, arg1: charseq, arg2: boolean): boolean
public static "subSequence"(arg0: charseq, arg1: $IntRange$Type): charseq
public static "contains"(arg0: charseq, arg1: character, arg2: boolean): boolean
public static "contains"(arg0: charseq, arg1: charseq, arg2: boolean): boolean
public static "removeRange"(arg0: charseq, arg1: $IntRange$Type): charseq
public static "removeRange"(arg0: charseq, arg1: integer, arg2: integer): charseq
public static "padStart"(arg0: string, arg1: integer, arg2: character): string
public static "padStart"(arg0: charseq, arg1: integer, arg2: character): charseq
public static "substringBeforeLast"(arg0: string, arg1: string, arg2: string): string
public static "substringBeforeLast"(arg0: string, arg1: character, arg2: string): string
public static "lineSequence"(arg0: charseq): $Sequence<(string)>
public static "indexOfAny"(arg0: charseq, arg1: $Collection$Type<(string)>, arg2: integer, arg3: boolean): integer
public static "indexOfAny"(arg0: charseq, arg1: (character)[], arg2: integer, arg3: boolean): integer
public static "lastIndexOfAny"(arg0: charseq, arg1: $Collection$Type<(string)>, arg2: integer, arg3: boolean): integer
public static "lastIndexOfAny"(arg0: charseq, arg1: (character)[], arg2: integer, arg3: boolean): integer
public static "substringAfterLast"(arg0: string, arg1: character, arg2: string): string
public static "substringAfterLast"(arg0: string, arg1: string, arg2: string): string
public static "substringAfter"(arg0: string, arg1: string, arg2: string): string
public static "substringAfter"(arg0: string, arg1: character, arg2: string): string
public static "substringBefore"(arg0: string, arg1: character, arg2: string): string
public static "substringBefore"(arg0: string, arg1: string, arg2: string): string
public static "removeSuffix"(arg0: string, arg1: charseq): string
public static "removeSuffix"(arg0: charseq, arg1: charseq): charseq
public static "trimStart"(arg0: charseq, ...arg1: (character)[]): charseq
public static "trimStart"(arg0: string, ...arg1: (character)[]): string
public static "trimStart"(arg0: charseq): charseq
public static "trimStart"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "trimStart"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "replaceRange"(arg0: charseq, arg1: $IntRange$Type, arg2: charseq): charseq
public static "replaceRange"(arg0: charseq, arg1: integer, arg2: integer, arg3: charseq): charseq
public static "padEnd"(arg0: charseq, arg1: integer, arg2: character): charseq
public static "padEnd"(arg0: string, arg1: integer, arg2: character): string
public static "getLastIndex"(arg0: charseq): integer
public static "contentEqualsImpl"(arg0: charseq, arg1: charseq): boolean
public static "regionMatchesImpl"(arg0: charseq, arg1: integer, arg2: charseq, arg3: integer, arg4: integer, arg5: boolean): boolean
public static "findAnyOf"(arg0: charseq, arg1: $Collection$Type<(string)>, arg2: integer, arg3: boolean): $Pair<(integer), (string)>
public static "hasSurrogatePairAt"(arg0: charseq, arg1: integer): boolean
public static "commonSuffixWith"(arg0: charseq, arg1: charseq, arg2: boolean): string
public static "findLastAnyOf"(arg0: charseq, arg1: $Collection$Type<(string)>, arg2: integer, arg3: boolean): $Pair<(integer), (string)>
public static "commonPrefixWith"(arg0: charseq, arg1: charseq, arg2: boolean): string
public static "replaceAfterLast"(arg0: string, arg1: string, arg2: string, arg3: string): string
public static "replaceAfterLast"(arg0: string, arg1: character, arg2: string, arg3: string): string
public static "replaceBefore"(arg0: string, arg1: string, arg2: string, arg3: string): string
public static "replaceBefore"(arg0: string, arg1: character, arg2: string, arg3: string): string
public static "splitToSequence"(arg0: charseq, arg1: (character)[], arg2: boolean, arg3: integer): $Sequence<(string)>
public static "splitToSequence"(arg0: charseq, arg1: (string)[], arg2: boolean, arg3: integer): $Sequence<(string)>
public static "toBooleanStrict"(arg0: string): boolean
public static "removeSurrounding"(arg0: charseq, arg1: charseq): charseq
public static "removeSurrounding"(arg0: charseq, arg1: charseq, arg2: charseq): charseq
public static "removeSurrounding"(arg0: string, arg1: charseq): string
public static "removeSurrounding"(arg0: string, arg1: charseq, arg2: charseq): string
public static "replaceBeforeLast"(arg0: string, arg1: character, arg2: string, arg3: string): string
public static "replaceBeforeLast"(arg0: string, arg1: string, arg2: string, arg3: string): string
public static "removePrefix"(arg0: charseq, arg1: charseq): charseq
public static "removePrefix"(arg0: string, arg1: charseq): string
public static "replaceAfter"(arg0: string, arg1: string, arg2: string, arg3: string): string
public static "replaceAfter"(arg0: string, arg1: character, arg2: string, arg3: string): string
public static "trimEnd"(arg0: charseq): charseq
public static "trimEnd"(arg0: charseq, ...arg1: (character)[]): charseq
public static "trimEnd"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "trimEnd"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "trimEnd"(arg0: string, ...arg1: (character)[]): string
public static "getIndices"(arg0: charseq): $IntRange
public static "contentEqualsIgnoreCaseImpl"(arg0: charseq, arg1: charseq): boolean
public static "requireNonNegativeLimit"(arg0: integer): void
public static "toBooleanStrictOrNull"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt__StringsKt$Type = ($StringsKt__StringsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt__StringsKt_ = $StringsKt__StringsKt$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"

export class $PngChunk {
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: string, arg1: $ImageInfo$Type)

public "toString"(): string
public "setPriority"(arg0: boolean): void
public "getOffset"(): long
public "getRaw"(): $ChunkRaw
public "hasPriority"(): boolean
public "getChunkGroup"(): integer
public "getLen"(): integer
public "invalidateRawData"(): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "priority"(value: boolean)
get "offset"(): long
get "raw"(): $ChunkRaw
get "chunkGroup"(): integer
get "len"(): integer
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunk$Type = ($PngChunk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunk_ = $PngChunk$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UnsignedKt" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UnsignedKt {


public static "uintToDouble"(arg0: integer): double
public static "uintCompare"(arg0: integer, arg1: integer): integer
public static "uintDivide-J1ME1BU"(arg0: integer, arg1: integer): integer
public static "doubleToUInt"(arg0: double): integer
public static "ulongCompare"(arg0: long, arg1: long): integer
public static "doubleToULong"(arg0: double): long
public static "ulongToDouble"(arg0: long): double
public static "ulongToString"(arg0: long): string
public static "ulongToString"(arg0: long, arg1: integer): string
public static "uintRemainder-J1ME1BU"(arg0: integer, arg1: integer): integer
public static "ulongDivide-eb3DHEI"(arg0: long, arg1: long): long
public static "ulongRemainder-eb3DHEI"(arg0: long, arg1: long): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnsignedKt$Type = ($UnsignedKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnsignedKt_ = $UnsignedKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$Lazy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Lazy<T> {

 "getValue"(): T
 "isInitialized"(): boolean
}

export namespace $Lazy {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$Type<T> = ($Lazy<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lazy_<T> = $Lazy$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder" {
import {$Set, $Set$Type} from "packages/java/util/$Set"

export interface $PushBuilder {

 "method"(arg0: string): $PushBuilder
 "getMethod"(): string
 "path"(arg0: string): $PushBuilder
 "getPath"(): string
 "push"(): void
 "getHeader"(arg0: string): string
 "getQueryString"(): string
 "queryString"(arg0: string): $PushBuilder
 "addHeader"(arg0: string, arg1: string): $PushBuilder
 "getSessionId"(): string
 "setHeader"(arg0: string, arg1: string): $PushBuilder
 "getHeaderNames"(): $Set<(string)>
 "sessionId"(arg0: string): $PushBuilder
 "removeHeader"(arg0: string): $PushBuilder
}

export namespace $PushBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PushBuilder$Type = ($PushBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PushBuilder_ = $PushBuilder$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UByteArray" {
import {$UByte, $UByte$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UByte"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $UByteArray implements $Collection<($UByte)>, $KMappedMarker {


public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public "iterator"(): $Iterator<($UByte)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "set-VurrAj0"(arg0: (byte)[], arg1: integer, arg2: byte): void
public "contains-7apg3OU"(arg0: byte): boolean
public static "contains-7apg3OU"(arg0: (byte)[], arg1: byte): boolean
public "add-7apg3OU"(arg0: byte): boolean
public static "constructor-impl"(arg0: integer): (byte)[]
public static "constructor-impl"(arg0: (byte)[]): (byte)[]
public static "getSize-impl"(arg0: (byte)[]): integer
public static "equals-impl"(arg0: (byte)[], arg1: any): boolean
public static "containsAll-impl"(arg0: (byte)[], arg1: $Collection$Type<($UByte$Type)>): boolean
public static "hashCode-impl"(arg0: (byte)[]): integer
public static "iterator-impl"(arg0: (byte)[]): $Iterator<($UByte)>
public static "toString-impl"(arg0: (byte)[]): string
public static "isEmpty-impl"(arg0: (byte)[]): boolean
public static "equals-impl0"(arg0: (byte)[], arg1: (byte)[]): boolean
public static "get-w2LRezQ"(arg0: (byte)[], arg1: integer): byte
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<($UByte)>
public "spliterator"(): $Spliterator<($UByte)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<($UByte)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$UByte>;
get "empty"(): boolean
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UByteArray$Type = ($UByteArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UByteArray_ = $UByteArray$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongRange$Companion" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$ULongRange, $ULongRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ULongRange"

export class $ULongRange$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "getEMPTY"(): $ULongRange
get "eMPTY"(): $ULongRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ULongRange$Companion$Type = ($ULongRange$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ULongRange$Companion_ = $ULongRange$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$ArrayUtil" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"

export class $ArrayUtil implements $Cloneable, $Serializable {

constructor()

public static "add"<T>(arg0: (T)[], arg1: (T)[]): (T)[]
public static "prependToArray"<T>(arg0: T, arg1: (T)[], arg2: $Class$Type<(any)>): (T)[]
public static "removeFromArray"<T>(arg0: (T)[], arg1: any): (T)[]
public static "addToArray"<T>(arg0: (T)[], arg1: T, arg2: $Class$Type<(any)>): (T)[]
public static "removeNulls"<T>(arg0: (T)[]): (T)[]
public static "asMutableList"<E>(arg0: (E)[]): $List<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayUtil$Type = ($ArrayUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayUtil_ = $ArrayUtil$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/jvm/internal/$Boxing" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Boxing {


public static "boxByte"(arg0: byte): byte
public static "boxShort"(arg0: short): short
public static "boxBoolean"(arg0: boolean): boolean
public static "boxLong"(arg0: long): long
public static "boxFloat"(arg0: float): float
public static "boxDouble"(arg0: double): double
public static "boxInt"(arg0: integer): integer
public static "boxChar"(arg0: character): character
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boxing$Type = ($Boxing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boxing_ = $Boxing$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/$Parser" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketPolicy, $WebSocketPolicy$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketPolicy"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$IncomingFrames, $IncomingFrames$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames"
import {$ByteBufferPool, $ByteBufferPool$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$ByteBufferPool"

export class $Parser {

constructor(arg0: $WebSocketPolicy$Type, arg1: $ByteBufferPool$Type)

public "setIncomingFramesHandler"(arg0: $IncomingFrames$Type): void
public "toString"(): string
public "parse"(arg0: $ByteBuffer$Type): void
public "getPolicy"(): $WebSocketPolicy
public "isRsv2InUse"(): boolean
public "isRsv3InUse"(): boolean
public "isRsv1InUse"(): boolean
public "configureFromExtensions"(arg0: $List$Type<(any)>): void
public "getIncomingFramesHandler"(): $IncomingFrames
set "incomingFramesHandler"(value: $IncomingFrames$Type)
get "policy"(): $WebSocketPolicy
get "rsv2InUse"(): boolean
get "rsv3InUse"(): boolean
get "rsv1InUse"(): boolean
get "incomingFramesHandler"(): $IncomingFrames
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Parser$Type = ($Parser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Parser_ = $Parser$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$IO" {
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$File, $File$Type} from "packages/java/io/$File"
import {$GatheringByteChannel, $GatheringByteChannel$Type} from "packages/java/nio/channels/$GatheringByteChannel"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Writer, $Writer$Type} from "packages/java/io/$Writer"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $IO {
static readonly "CRLF": string
static readonly "CRLF_BYTES": (byte)[]
static readonly "bufferSize": integer

constructor()

public static "getNullPrintWriter"(): $PrintWriter
public static "getNullStream"(): $OutputStream
public static "getNullWriter"(): $Writer
public static "getClosedStream"(): $InputStream
public static "toString"(arg0: $InputStream$Type, arg1: string): string
public static "toString"(arg0: $InputStream$Type): string
public static "toString"(arg0: $Reader$Type): string
public static "toString"(arg0: $InputStream$Type, arg1: $Charset$Type): string
public static "write"(arg0: $GatheringByteChannel$Type, arg1: ($ByteBuffer$Type)[], arg2: integer, arg3: integer): long
public static "delete"(arg0: $File$Type): boolean
public static "close"(arg0: $OutputStream$Type): void
public static "close"(arg0: $Closeable$Type): void
public static "close"(arg0: $Writer$Type): void
public static "close"(arg0: $Reader$Type): void
public static "close"(arg0: $InputStream$Type): void
public static "copy"(arg0: $Reader$Type, arg1: $Writer$Type, arg2: long): void
public static "copy"(arg0: $InputStream$Type, arg1: $OutputStream$Type, arg2: long): void
public static "copy"(arg0: $Reader$Type, arg1: $Writer$Type): void
public static "copy"(arg0: $InputStream$Type, arg1: $OutputStream$Type): void
public static "copy"(arg0: $File$Type, arg1: $File$Type): void
public static "readBytes"(arg0: $InputStream$Type): (byte)[]
public static "copyFile"(arg0: $File$Type, arg1: $File$Type): void
public static "copyDir"(arg0: $File$Type, arg1: $File$Type): void
get "nullPrintWriter"(): $PrintWriter
get "nullStream"(): $OutputStream
get "nullWriter"(): $Writer
get "closedStream"(): $InputStream
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IO$Type = ($IO);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IO_ = $IO$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/websocket/$WebSocketHandlerWrapper" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $WebSocketHandlerWrapper {

 "getHandler"(): any

(): any
}

export namespace $WebSocketHandlerWrapper {
function validateHandlerClass(arg0: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketHandlerWrapper$Type = ($WebSocketHandlerWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketHandlerWrapper_ = $WebSocketHandlerWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Reflection" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$KProperty1, $KProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty1"
import {$KProperty2, $KProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty2"
import {$Lambda, $Lambda$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$Lambda"
import {$MutablePropertyReference0, $MutablePropertyReference0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference0"
import {$MutablePropertyReference1, $MutablePropertyReference1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference1"
import {$MutablePropertyReference2, $MutablePropertyReference2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$MutablePropertyReference2"
import {$FunctionBase, $FunctionBase$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionBase"
import {$KClass, $KClass$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClass"
import {$KDeclarationContainer, $KDeclarationContainer$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KDeclarationContainer"
import {$KTypeProjection, $KTypeProjection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection"
import {$KVariance, $KVariance$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVariance"
import {$PropertyReference2, $PropertyReference2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference2"
import {$FunctionReference, $FunctionReference$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$FunctionReference"
import {$PropertyReference0, $PropertyReference0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference0"
import {$PropertyReference1, $PropertyReference1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$PropertyReference1"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KClassifier, $KClassifier$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClassifier"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$KMutableProperty2, $KMutableProperty2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty2"
import {$KMutableProperty1, $KMutableProperty1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty1"
import {$KMutableProperty0, $KMutableProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KMutableProperty0"
import {$KProperty0, $KProperty0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0"

export class $Reflection {

constructor()

public static "function"(arg0: $FunctionReference$Type): $KFunction<(any)>
public static "mutableProperty2"(arg0: $MutablePropertyReference2$Type): $KMutableProperty2<(any), (any), (any)>
public static "setUpperBounds"(arg0: $KTypeParameter$Type, ...arg1: ($KType$Type)[]): void
public static "setUpperBounds"(arg0: $KTypeParameter$Type, arg1: $KType$Type): void
public static "nothingType"(arg0: $KType$Type): $KType
public static "nullableTypeOf"(arg0: $Class$Type<(any)>): $KType
public static "nullableTypeOf"(arg0: $Class$Type<(any)>, arg1: $KTypeProjection$Type): $KType
public static "nullableTypeOf"(arg0: $KClassifier$Type): $KType
public static "nullableTypeOf"(arg0: $Class$Type<(any)>, ...arg1: ($KTypeProjection$Type)[]): $KType
public static "nullableTypeOf"(arg0: $Class$Type<(any)>, arg1: $KTypeProjection$Type, arg2: $KTypeProjection$Type): $KType
public static "createKotlinClass"(arg0: $Class$Type<(any)>): $KClass<(any)>
public static "createKotlinClass"(arg0: $Class$Type<(any)>, arg1: string): $KClass<(any)>
public static "property0"(arg0: $PropertyReference0$Type): $KProperty0<(any)>
public static "mutableProperty0"(arg0: $MutablePropertyReference0$Type): $KMutableProperty0<(any)>
public static "property1"(arg0: $PropertyReference1$Type): $KProperty1<(any), (any)>
public static "property2"(arg0: $PropertyReference2$Type): $KProperty2<(any), (any), (any)>
public static "mutableProperty1"(arg0: $MutablePropertyReference1$Type): $KMutableProperty1<(any), (any)>
public static "typeOf"(arg0: $KClassifier$Type): $KType
public static "typeOf"(arg0: $Class$Type<(any)>, ...arg1: ($KTypeProjection$Type)[]): $KType
public static "typeOf"(arg0: $Class$Type<(any)>): $KType
public static "typeOf"(arg0: $Class$Type<(any)>, arg1: $KTypeProjection$Type): $KType
public static "typeOf"(arg0: $Class$Type<(any)>, arg1: $KTypeProjection$Type, arg2: $KTypeProjection$Type): $KType
public static "platformType"(arg0: $KType$Type, arg1: $KType$Type): $KType
public static "mutableCollectionType"(arg0: $KType$Type): $KType
public static "typeParameter"(arg0: any, arg1: string, arg2: $KVariance$Type, arg3: boolean): $KTypeParameter
public static "getOrCreateKotlinClasses"(arg0: ($Class$Type<(any)>)[]): ($KClass<(any)>)[]
public static "renderLambdaToString"(arg0: $FunctionBase$Type<(any)>): string
public static "renderLambdaToString"(arg0: $Lambda$Type<(any)>): string
public static "getOrCreateKotlinPackage"(arg0: $Class$Type<(any)>): $KDeclarationContainer
public static "getOrCreateKotlinPackage"(arg0: $Class$Type<(any)>, arg1: string): $KDeclarationContainer
public static "getOrCreateKotlinClass"(arg0: $Class$Type<(any)>, arg1: string): $KClass<(any)>
public static "getOrCreateKotlinClass"(arg0: $Class$Type<(any)>): $KClass<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reflection$Type = ($Reflection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reflection_ = $Reflection$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UByte" {
import {$UByte$Companion, $UByte$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UByte$Companion"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"

export class $UByte implements $Comparable<($UByte)> {
static readonly "Companion": $UByte$Companion
static readonly "MIN_VALUE": byte
static readonly "MAX_VALUE": byte
static readonly "SIZE_BYTES": integer
static readonly "SIZE_BITS": integer


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "constructor-impl"(arg0: byte): byte
public static "equals-impl"(arg0: byte, arg1: any): boolean
public static "hashCode-impl"(arg0: byte): integer
public static "toString-impl"(arg0: byte): string
public static "equals-impl0"(arg0: byte, arg1: byte): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UByte$Type = ($UByte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UByte_ = $UByte$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KFunction, $KFunction$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KFunction"
import {$KProperty$Accessor, $KProperty$Accessor$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Accessor"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty$Getter<V> extends $KProperty$Accessor<(V)>, $KFunction<(V)> {

 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty$Getter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty$Getter$Type<V> = ($KProperty$Getter<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty$Getter_<V> = $KProperty$Getter$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/annotated/$AbstractMethodAnnotationScanner" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $AbstractMethodAnnotationScanner<T> {

constructor()

public "isAnnotation"(arg0: $Annotation$Type, arg1: $Class$Type<(any)>): boolean
public "scanMethodAnnotations"(arg0: T, arg1: $Class$Type<(any)>): void
public "isSameParameters"(arg0: ($Class$Type<(any)>)[], arg1: ($Class$Type<(any)>)[]): boolean
public "onMethodAnnotation"(arg0: T, arg1: $Class$Type<(any)>, arg2: $Method$Type, arg3: $Annotation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMethodAnnotationScanner$Type<T> = ($AbstractMethodAnnotationScanner<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMethodAnnotationScanner_<T> = $AbstractMethodAnnotationScanner$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$DelimitedRangesSequence" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"

export class $DelimitedRangesSequence implements $Sequence<($IntRange)> {

constructor(arg0: charseq, arg1: integer, arg2: integer, arg3: $Function2$Type<(any), (any), ($Pair$Type<(integer), (integer)>)>)

public "iterator"(): $Iterator<($IntRange)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DelimitedRangesSequence$Type = ($DelimitedRangesSequence);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DelimitedRangesSequence_ = $DelimitedRangesSequence$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$CharIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $CharIterator implements $Iterator<(character)>, $KMappedMarker {

constructor()

public "remove"(): void
public "nextChar"(): character
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
public "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharIterator$Type = ($CharIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharIterator_ = $CharIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$FutureCallback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$ExecutionException, $ExecutionException$Type} from "packages/java/util/concurrent/$ExecutionException"
import {$Invocable$InvocationType, $Invocable$InvocationType$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/thread/$Invocable$InvocationType"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $FutureCallback implements $Future<(void)>, $Callback {

constructor(arg0: $Throwable$Type)
constructor(arg0: boolean)
constructor()

public "get"(): void
public "toString"(): string
public "isDone"(): boolean
public "cancel"(arg0: boolean): boolean
public static "rethrow"(arg0: $ExecutionException$Type): void
public "isCancelled"(): boolean
public "succeeded"(): void
public "failed"(arg0: $Throwable$Type): void
public static "from"(arg0: $CompletableFuture$Type<(any)>, arg1: $Invocable$InvocationType$Type): $Callback
public static "from"(arg0: $CompletableFuture$Type<(any)>): $Callback
public static "getInvocationType"(arg0: any): $Invocable$InvocationType
public "getInvocationType"(): $Invocable$InvocationType
public static "asPreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): $Runnable
public static "invokePreferred"(arg0: $Runnable$Type, arg1: $Invocable$InvocationType$Type): void
public static "invokeNonBlocking"(arg0: $Runnable$Type): void
public static "isNonBlockingInvocation"(): boolean
public static "invokePreferNonBlocking"(arg0: $Runnable$Type): void
get "done"(): boolean
get "cancelled"(): boolean
get "invocationType"(): $Invocable$InvocationType
get "nonBlockingInvocation"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FutureCallback$Type = ($FutureCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FutureCallback_ = $FutureCallback$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/route/$HttpMethod" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpMethod extends $Enum<($HttpMethod)> {
static readonly "get": $HttpMethod
static readonly "post": $HttpMethod
static readonly "put": $HttpMethod
static readonly "patch": $HttpMethod
static readonly "delete": $HttpMethod
static readonly "head": $HttpMethod
static readonly "trace": $HttpMethod
static readonly "connect": $HttpMethod
static readonly "options": $HttpMethod
static readonly "before": $HttpMethod
static readonly "after": $HttpMethod
static readonly "afterafter": $HttpMethod
static readonly "unsupported": $HttpMethod


public static "get"(arg0: string): $HttpMethod
public static "values"(): ($HttpMethod)[]
public static "valueOf"(arg0: string): $HttpMethod
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpMethod$Type = (("before") | ("afterafter") | ("delete") | ("put") | ("patch") | ("head") | ("trace") | ("unsupported") | ("post") | ("get") | ("options") | ("after") | ("connect")) | ($HttpMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpMethod_ = $HttpMethod$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjOutputException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$PngjException, $PngjException$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$PngjException"

export class $PngjOutputException extends $PngjException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngjOutputException$Type = ($PngjOutputException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngjOutputException_ = $PngjOutputException$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/$TreeTrie" {
import {$AbstractTrie, $AbstractTrie$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$AbstractTrie"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $TreeTrie<V> extends $AbstractTrie<(V)> {

constructor()

public "get"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "get"(arg0: string, arg1: integer, arg2: integer): V
public "put"(arg0: string, arg1: V): boolean
public "toString"(): string
public "clear"(): void
public "keySet"(): $Set<(string)>
public "isFull"(): boolean
public "getBest"(arg0: $ByteBuffer$Type, arg1: integer, arg2: integer): V
public "getBest"(arg0: (byte)[], arg1: integer, arg2: integer): V
public "getBest"(arg0: string, arg1: integer, arg2: integer): V
get "full"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeTrie$Type<V> = ($TreeTrie<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TreeTrie_<V> = $TreeTrie$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$AsyncListener, $AsyncListener$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncListener"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$AsyncContextEvent, $AsyncContextEvent$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$AsyncContextEvent"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$ContextHandler, $ContextHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ContextHandler"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$HttpChannelState$State, $HttpChannelState$State$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState$State"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"

export class $HttpChannelState {


public "getTimeout"(): long
public "dispatch"(arg0: $ServletContext$Type, arg1: string): void
public "toString"(): string
public "getState"(): $HttpChannelState$State
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "complete"(): void
public "setTimeout"(arg0: long): void
public "getServletResponse"(arg0: $AsyncContextEvent$Type): $ServletResponse
public "getServletResponse"(): $ServletResponse
public "isAsync"(): boolean
public "removeAttribute"(arg0: string): void
public "getAsyncContextEvent"(): $AsyncContextEvent
public "isIdle"(): boolean
public "isSuspended"(): boolean
public "addListener"(arg0: $AsyncListener$Type): void
public "upgrade"(): void
public "onReadEof"(): boolean
public "onReadUnready"(): void
public "onReadReady"(): boolean
public "onContentAdded"(): boolean
public "isAsyncStarted"(): boolean
public "startAsync"(arg0: $AsyncContextEvent$Type): void
public "errorComplete"(): void
public "getContextHandler"(): $ContextHandler
public "getBaseRequest"(): $Request
public "getHttpChannel"(): $HttpChannel
public "getStatusString"(): string
public "isExpired"(): boolean
public "onWritePossible"(): boolean
public "asyncError"(arg0: $Throwable$Type): void
public "toStringLocked"(): string
public "isAsyncComplete"(): boolean
public "isInitial"(): boolean
public "onReadPossible"(): boolean
get "timeout"(): long
get "state"(): $HttpChannelState$State
set "timeout"(value: long)
get "servletResponse"(): $ServletResponse
get "async"(): boolean
get "asyncContextEvent"(): $AsyncContextEvent
get "idle"(): boolean
get "suspended"(): boolean
get "asyncStarted"(): boolean
get "contextHandler"(): $ContextHandler
get "baseRequest"(): $Request
get "httpChannel"(): $HttpChannel
get "statusString"(): string
get "expired"(): boolean
get "asyncComplete"(): boolean
get "initial"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpChannelState$Type = ($HttpChannelState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpChannelState_ = $HttpChannelState$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$AbstractHandler" {
import {$ContainerLifeCycle, $ContainerLifeCycle$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$ContainerLifeCycle"
import {$Server, $Server$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Server"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Handler, $Handler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Handler"

export class $AbstractHandler extends $ContainerLifeCycle implements $Handler {
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "destroy"(): void
public "handle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "setServer"(arg0: $Server$Type): void
public "getServer"(): $Server
public "dumpThis"(arg0: $Appendable$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
set "server"(value: $Server$Type)
get "server"(): $Server
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractHandler$Type = ($AbstractHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractHandler_ = $AbstractHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$ConnectionFactory" {
import {$Connector, $Connector$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Connector"
import {$Connection, $Connection$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$Connection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EndPoint, $EndPoint$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/io/$EndPoint"

export interface $ConnectionFactory {

 "getProtocol"(): string
 "getProtocols"(): $List<(string)>
 "newConnection"(arg0: $Connector$Type, arg1: $EndPoint$Type): $Connection
}

export namespace $ConnectionFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionFactory$Type = ($ConnectionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionFactory_ = $ConnectionFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function15" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function15<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15): R
}

export namespace $Function15 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function15$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, R> = ($Function15<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function15_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, R> = $Function15$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function16" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function16<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16): R
}

export namespace $Function16 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function16$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, R> = ($Function16<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function16_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, R> = $Function16$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function13" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function13<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13): R
}

export namespace $Function13 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function13$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, R> = ($Function13<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function13_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, R> = $Function13$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function14" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function14<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14): R
}

export namespace $Function14 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function14$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, R> = ($Function14<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function14_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, R> = $Function14$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function11" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function11<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11): R
}

export namespace $Function11 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function11$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, R> = ($Function11<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function11_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, R> = $Function11$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function12" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function12<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12): R
}

export namespace $Function12 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function12$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, R> = ($Function12<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function12_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, R> = $Function12$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function10" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10): R
}

export namespace $Function10 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function10$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, R> = ($Function10<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function10_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, R> = $Function10$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$EmptyIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"

export class $EmptyIterator implements $ListIterator<(any)>, $KMappedMarker {
static readonly "INSTANCE": $EmptyIterator


public "add"(arg0: void): void
public "remove"(): void
public "hasNext"(): boolean
public "set"(arg0: void): void
public "nextIndex"(): integer
public "previousIndex"(): integer
public "hasPrevious"(): boolean
public "previous"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyIterator$Type = ($EmptyIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyIterator_ = $EmptyIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Service" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Routable, $Routable$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Routable"
import {$Service$StaticFiles, $Service$StaticFiles$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service$StaticFiles"
import {$FilterImpl, $FilterImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$FilterImpl"
import {$RouteImpl, $RouteImpl$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteImpl"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Redirect, $Redirect$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Redirect"
import {$HaltException, $HaltException$Type} from "packages/info/journeymap/shaded/kotlin/spark/$HaltException"
import {$RouteGroup, $RouteGroup$Type} from "packages/info/journeymap/shaded/kotlin/spark/$RouteGroup"
import {$Route, $Route$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Route"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$ExceptionHandler, $ExceptionHandler$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ExceptionHandler"
import {$HttpMethod, $HttpMethod$Type} from "packages/info/journeymap/shaded/kotlin/spark/route/$HttpMethod"

export class $Service extends $Routable {
static readonly "SPARK_DEFAULT_PORT": integer
readonly "redirect": $Redirect
readonly "staticFiles": $Service$StaticFiles


public static "ignite"(): $Service
public "init"(): void
public "exception"<T extends $Exception>(arg0: $Class$Type<(T)>, arg1: $ExceptionHandler$Type<(any)>): void
public "port"(arg0: integer): $Service
public "port"(): integer
public "stop"(): void
public "path"(arg0: string, arg1: $RouteGroup$Type): void
public "halt"(arg0: integer): $HaltException
public "halt"(arg0: integer, arg1: string): $HaltException
public "halt"(arg0: string): $HaltException
public "halt"(): $HaltException
public "secure"(arg0: string, arg1: string, arg2: string, arg3: string): $Service
public "secure"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: boolean): $Service
public "ipAddress"(arg0: string): $Service
public "notFound"(arg0: string): void
public "notFound"(arg0: $Route$Type): void
public "getPaths"(): string
public "staticFileLocation"(arg0: string): $Service
public "threadPool"(arg0: integer, arg1: integer, arg2: integer): $Service
public "threadPool"(arg0: integer): $Service
public "addRoute"(arg0: $HttpMethod$Type, arg1: $RouteImpl$Type): void
/**
 * 
 * @deprecated
 */
public "addRoute"(arg0: string, arg1: $RouteImpl$Type): void
public "addFilter"(arg0: $HttpMethod$Type, arg1: $FilterImpl$Type): void
/**
 * 
 * @deprecated
 */
public "addFilter"(arg0: string, arg1: $FilterImpl$Type): void
public "webSocket"(arg0: string, arg1: $Class$Type<(any)>): void
public "webSocket"(arg0: string, arg1: any): void
public "initExceptionHandler"(arg0: $Consumer$Type<($Exception$Type)>): void
public "webSocketIdleTimeoutMillis"(arg0: integer): $Service
public "internalServerError"(arg0: string): void
public "internalServerError"(arg0: $Route$Type): void
public "externalStaticFileLocation"(arg0: string): $Service
public "awaitInitialization"(): void
get "paths"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Service$Type = ($Service);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Service_ = $Service$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$WebSocketException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $WebSocketException extends $RuntimeException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketException$Type = ($WebSocketException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketException_ = $WebSocketException$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$MergingSequence" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $MergingSequence<T1, T2, V> implements $Sequence<(V)> {

constructor(arg0: $Sequence$Type<(any)>, arg1: $Sequence$Type<(any)>, arg2: $Function2$Type<(any), (any), (any)>)

public "iterator"(): $Iterator<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergingSequence$Type<T1, T2, V> = ($MergingSequence<(T1), (T2), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergingSequence_<T1, T2, V> = $MergingSequence$Type<(T1), (T2), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $KVisibility extends $Enum<($KVisibility)> {
static readonly "PUBLIC": $KVisibility
static readonly "PROTECTED": $KVisibility
static readonly "INTERNAL": $KVisibility
static readonly "PRIVATE": $KVisibility


public static "values"(): ($KVisibility)[]
public static "valueOf"(arg0: string): $KVisibility
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KVisibility$Type = (("internal") | ("private") | ("public") | ("protected")) | ($KVisibility);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KVisibility_ = $KVisibility$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function19" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function19<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19): R
}

export namespace $Function19 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function19$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, R> = ($Function19<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function19_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, R> = $Function19$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function17" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function17<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17): R
}

export namespace $Function17 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function17$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, R> = ($Function17<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function17_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, R> = $Function17$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function18" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function18<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18): R
}

export namespace $Function18 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function18$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, R> = ($Function18<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function18_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, R> = $Function18$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function22" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function22<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20, arg20: P21, arg21: P22): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20, arg20: P21, arg21: P22): R
}

export namespace $Function22 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function22$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, R> = ($Function22<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (P21), (P22), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function22_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, R> = $Function22$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (P21), (P22), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function20" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function20<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20): R
}

export namespace $Function20 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function20$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, R> = ($Function20<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function20_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, R> = $Function20$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (R)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function21" {
import {$Function, $Function$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Function"

export interface $Function21<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20, arg20: P21): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4, arg4: P5, arg5: P6, arg6: P7, arg7: P8, arg8: P9, arg9: P10, arg10: P11, arg11: P12, arg12: P13, arg13: P14, arg14: P15, arg15: P16, arg16: P17, arg17: P18, arg18: P19, arg19: P20, arg20: P21): R
}

export namespace $Function21 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function21$Type<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, R> = ($Function21<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (P21), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function21_<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, R> = $Function21$Type<(P1), (P2), (P3), (P4), (P5), (P6), (P7), (P8), (P9), (P10), (P11), (P12), (P13), (P14), (P15), (P16), (P17), (P18), (P19), (P20), (P21), (R)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpTokens" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $HttpTokens {

}

export namespace $HttpTokens {
const COLON: byte
const TAB: byte
const LINE_FEED: byte
const CARRIAGE_RETURN: byte
const SPACE: byte
const CRLF: (byte)[]
const SEMI_COLON: byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpTokens$Type = ($HttpTokens);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpTokens_ = $HttpTokens$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt___StringsKt" {
import {$Random, $Random$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/random/$Random"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$Function3, $Function3$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function3"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Grouping, $Grouping$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$Grouping"
import {$Pair, $Pair$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Pair"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$StringsKt___StringsJvmKt, $StringsKt___StringsJvmKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/text/$StringsKt___StringsJvmKt"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"
import {$IndexedValue, $IndexedValue$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue"
import {$IntRange, $IntRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$IntRange"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StringsKt___StringsKt extends $StringsKt___StringsJvmKt {

constructor()

public static "windowedSequence"(arg0: charseq, arg1: integer, arg2: integer, arg3: boolean): $Sequence<(string)>
public static "windowedSequence"<R>(arg0: charseq, arg1: integer, arg2: integer, arg3: boolean, arg4: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "firstOrNull"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "firstOrNull"(arg0: charseq): character
public static "mapTo"<R, C extends $Collection<(any)>>(arg0: charseq, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "reduceIndexedOrNull"(arg0: charseq, arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "runningReduceIndexed"(arg0: charseq, arg1: $Function3$Type<(any), (any), (any), (character)>): $List<(character)>
public static "mapIndexedNotNullTo"<R, C extends $Collection<(any)>>(arg0: charseq, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "map"<R>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "toList"(arg0: charseq): $List<(character)>
public static "count"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): integer
public static "last"(arg0: charseq): character
public static "last"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "single"(arg0: charseq): character
public static "single"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "filter"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "filter"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "first"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "first"(arg0: charseq): character
public static "flatMap"<R>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "forEach"(arg0: charseq, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "toSet"(arg0: charseq): $Set<(character)>
public static "reduce"(arg0: charseq, arg1: $Function2$Type<(any), (any), (character)>): character
public static "slice"(arg0: charseq, arg1: $IntRange$Type): charseq
public static "slice"(arg0: charseq, arg1: $Iterable$Type<(integer)>): charseq
public static "slice"(arg0: string, arg1: $IntRange$Type): string
public static "reversed"(arg0: charseq): charseq
public static "random"(arg0: charseq, arg1: $Random$Type): character
public static "scan"<R>(arg0: charseq, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "groupingBy"<K>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $Grouping<(character), (K)>
public static "drop"(arg0: charseq, arg1: integer): charseq
public static "drop"(arg0: string, arg1: integer): string
public static "all"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "take"(arg0: string, arg1: integer): string
public static "take"(arg0: charseq, arg1: integer): charseq
public static "toCollection"<C extends $Collection<(any)>>(arg0: charseq, arg1: C): C
public static "takeWhile"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "takeWhile"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "dropWhile"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "dropWhile"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "zip"(arg0: charseq, arg1: charseq): $List<($Pair<(character), (character)>)>
public static "zip"<V>(arg0: charseq, arg1: charseq, arg2: $Function2$Type<(any), (any), (any)>): $List<(V)>
public static "any"(arg0: charseq): boolean
public static "any"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "associate"<K, V>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "chunked"<R>(arg0: charseq, arg1: integer, arg2: $Function1$Type<(any), (any)>): $List<(R)>
public static "chunked"(arg0: charseq, arg1: integer): $List<(string)>
public static "none"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): boolean
public static "none"(arg0: charseq): boolean
public static "partition"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): $Pair<(charseq), (charseq)>
public static "partition"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): $Pair<(string), (string)>
public static "reduceRight"(arg0: charseq, arg1: $Function2$Type<(any), (any), (character)>): character
public static "getOrNull"(arg0: charseq, arg1: integer): character
public static "indexOfFirst"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): integer
public static "takeLast"(arg0: string, arg1: integer): string
public static "takeLast"(arg0: charseq, arg1: integer): charseq
public static "foldRightIndexed"<R>(arg0: charseq, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "dropLast"(arg0: string, arg1: integer): string
public static "dropLast"(arg0: charseq, arg1: integer): charseq
public static "chunkedSequence"<R>(arg0: charseq, arg1: integer, arg2: $Function1$Type<(any), (any)>): $Sequence<(R)>
public static "chunkedSequence"(arg0: charseq, arg1: integer): $Sequence<(string)>
public static "dropLastWhile"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "dropLastWhile"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "foldRight"<R>(arg0: charseq, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "reduceRightIndexed"(arg0: charseq, arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceRightOrNull"(arg0: charseq, arg1: $Function2$Type<(any), (any), (character)>): character
public static "takeLastWhile"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "takeLastWhile"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "randomOrNull"(arg0: charseq, arg1: $Random$Type): character
public static "asSequence"(arg0: charseq): $Sequence<(character)>
public static "associateByTo"<K, M extends $Map<(any), (any)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateByTo"<K, V, M extends $Map<(any), (any)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "associateBy"<K, V>(arg0: charseq, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), (V)>
public static "associateBy"<K>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $Map<(K), (character)>
public static "associateWithTo"<V, M extends $Map<(any), (any)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "associateTo"<K, V, M extends $Map<(any), (any)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "asIterable"(arg0: charseq): $Iterable<(character)>
public static "associateWith"<V>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $Map<(character), (V)>
public static "forEachIndexed"(arg0: charseq, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): void
public static "mapIndexed"<R>(arg0: charseq, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "mapIndexedNotNull"<R>(arg0: charseq, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "filterIndexed"(arg0: string, arg1: $Function2$Type<(any), (any), (boolean)>): string
public static "filterIndexed"(arg0: charseq, arg1: $Function2$Type<(any), (any), (boolean)>): charseq
public static "filterNot"(arg0: string, arg1: $Function1$Type<(any), (boolean)>): string
public static "filterNot"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): charseq
public static "filterTo"<C extends $Appendable>(arg0: charseq, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "flatMapTo"<R, C extends $Collection<(any)>>(arg0: charseq, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "filterIndexedTo"<C extends $Appendable>(arg0: charseq, arg1: C, arg2: $Function2$Type<(any), (any), (boolean)>): C
public static "groupBy"<K, V>(arg0: charseq, arg1: $Function1$Type<(any), (any)>, arg2: $Function1$Type<(any), (any)>): $Map<(K), ($List<(V)>)>
public static "groupBy"<K>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $Map<(K), ($List<(character)>)>
public static "foldIndexed"<R>(arg0: charseq, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): R
public static "groupByTo"<K, M extends $Map<(any), ($List<(character)>)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>): M
public static "groupByTo"<K, V, M extends $Map<(any), ($List<(V)>)>>(arg0: charseq, arg1: M, arg2: $Function1$Type<(any), (any)>, arg3: $Function1$Type<(any), (any)>): M
public static "filterNotTo"<C extends $Appendable>(arg0: charseq, arg1: C, arg2: $Function1$Type<(any), (boolean)>): C
public static "indexOfLast"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): integer
public static "minOrNull"(arg0: charseq): character
public static "mapNotNull"<R>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): $List<(R)>
public static "onEach"<S extends charseq>(arg0: S, arg1: $Function1$Type<(any), ($Unit$Type)>): S
public static "onEachIndexed"<S extends charseq>(arg0: S, arg1: $Function2$Type<(any), (any), ($Unit$Type)>): S
public static "minByOrNull"<R extends $Comparable<(any)>>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): character
public static "reduceIndexed"(arg0: charseq, arg1: $Function3$Type<(any), (any), (any), (character)>): character
public static "reduceOrNull"(arg0: charseq, arg1: $Function2$Type<(any), (any), (character)>): character
public static "maxWithOrNull"(arg0: charseq, arg1: $Comparator$Type<(any)>): character
public static "minWithOrNull"(arg0: charseq, arg1: $Comparator$Type<(any)>): character
public static "mapNotNullTo"<R, C extends $Collection<(any)>>(arg0: charseq, arg1: C, arg2: $Function1$Type<(any), (any)>): C
public static "maxOrNull"(arg0: charseq): character
public static "mapIndexedTo"<R, C extends $Collection<(any)>>(arg0: charseq, arg1: C, arg2: $Function2$Type<(any), (any), (any)>): C
public static "maxByOrNull"<R extends $Comparable<(any)>>(arg0: charseq, arg1: $Function1$Type<(any), (any)>): character
public static "runningFoldIndexed"<R>(arg0: charseq, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "singleOrNull"(arg0: charseq): character
public static "singleOrNull"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "sumBy"(arg0: charseq, arg1: $Function1$Type<(any), (integer)>): integer
public static "scanIndexed"<R>(arg0: charseq, arg1: R, arg2: $Function3$Type<(any), (any), (any), (any)>): $List<(R)>
public static "runningFold"<R>(arg0: charseq, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "sumByDouble"(arg0: charseq, arg1: $Function1$Type<(any), (double)>): double
public static "zipWithNext"(arg0: charseq): $List<($Pair<(character), (character)>)>
public static "zipWithNext"<R>(arg0: charseq, arg1: $Function2$Type<(any), (any), (any)>): $List<(R)>
public static "runningReduce"(arg0: charseq, arg1: $Function2$Type<(any), (any), (character)>): $List<(character)>
public static "toHashSet"(arg0: charseq): $HashSet<(character)>
public static "fold"<R>(arg0: charseq, arg1: R, arg2: $Function2$Type<(any), (any), (any)>): R
public static "windowed"<R>(arg0: charseq, arg1: integer, arg2: integer, arg3: boolean, arg4: $Function1$Type<(any), (any)>): $List<(R)>
public static "windowed"(arg0: charseq, arg1: integer, arg2: integer, arg3: boolean): $List<(string)>
public static "toMutableList"(arg0: charseq): $List<(character)>
public static "withIndex"(arg0: charseq): $Iterable<($IndexedValue<(character)>)>
public static "lastOrNull"(arg0: charseq, arg1: $Function1$Type<(any), (boolean)>): character
public static "lastOrNull"(arg0: charseq): character
public static "reduceRightIndexedOrNull"(arg0: charseq, arg1: $Function3$Type<(any), (any), (any), (character)>): character
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringsKt___StringsKt$Type = ($StringsKt___StringsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringsKt___StringsKt_ = $StringsKt___StringsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty0$Getter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KProperty$Getter, $KProperty$Getter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty$Getter"
import {$Function0, $Function0$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function0"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KProperty, $KProperty$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KProperty"
import {$KTypeParameter, $KTypeParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeParameter"
import {$KVisibility, $KVisibility$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KVisibility"
import {$KParameter, $KParameter$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KProperty0$Getter<V> extends $KProperty$Getter<(V)>, $Function0<(V)> {

 "invoke"(): V
 "getProperty"(): $KProperty<(V)>
 "isInline"(): boolean
 "isSuspend"(): boolean
 "isOperator"(): boolean
 "isExternal"(): boolean
 "isInfix"(): boolean
 "getName"(): string
 "getTypeParameters"(): $List<($KTypeParameter)>
 "getReturnType"(): $KType
 "isOpen"(): boolean
 "getParameters"(): $List<($KParameter)>
 "isFinal"(): boolean
 "isAbstract"(): boolean
 "call"(...arg0: (any)[]): V
 "callBy"(arg0: $Map$Type<($KParameter$Type), (any)>): V
 "getVisibility"(): $KVisibility
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KProperty0$Getter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KProperty0$Getter$Type<V> = ($KProperty0$Getter<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KProperty0$Getter_<V> = $KProperty0$Getter$Type<(V)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$IncomingFrames" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Frame, $Frame$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/extensions/$Frame"

export interface $IncomingFrames {

 "incomingFrame"(arg0: $Frame$Type): void
 "incomingError"(arg0: $Throwable$Type): void
}

export namespace $IncomingFrames {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IncomingFrames$Type = ($IncomingFrames);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IncomingFrames_ = $IncomingFrames$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KAnnotatedElement" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$List, $List$Type} from "packages/java/util/$List"

export interface $KAnnotatedElement {

 "getAnnotations"(): $List<($Annotation)>

(): $List<($Annotation)>
}

export namespace $KAnnotatedElement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KAnnotatedElement$Type = ($KAnnotatedElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KAnnotatedElement_ = $KAnnotatedElement$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection$Companion" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$KTypeProjection, $KTypeProjection$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KTypeProjection"

export class $KTypeProjection$Companion {

constructor(arg0: $DefaultConstructorMarker$Type)

public "invariant"(arg0: $KType$Type): $KTypeProjection
public "covariant"(arg0: $KType$Type): $KTypeProjection
public "getSTAR"(): $KTypeProjection
public "contravariant"(arg0: $KType$Type): $KTypeProjection
get "sTAR"(): $KTypeProjection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KTypeProjection$Companion$Type = ($KTypeProjection$Companion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KTypeProjection$Companion_ = $KTypeProjection$Companion$Type;
}}
declare module "packages/info/journeymap/shaded/org/javax/servlet/$Servlet" {
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$ServletConfig, $ServletConfig$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletConfig"

export interface $Servlet {

 "getServletConfig"(): $ServletConfig
 "getServletInfo"(): string
 "init"(arg0: $ServletConfig$Type): void
 "destroy"(): void
 "service"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): void
}

export namespace $Servlet {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Servlet$Type = ($Servlet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Servlet_ = $Servlet$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/comparisons/$ReversedComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export class $ReversedComparator<T> implements $Comparator<(T)> {

constructor(arg0: $Comparator$Type<(T)>)

public "compare"(arg0: T, arg1: T): integer
public "reversed"(): $Comparator<(T)>
public "getComparator"(): $Comparator<(T)>
public "equals"(arg0: any): boolean
public static "reverseOrder"<T extends $Comparable<(any)>>(): $Comparator<(T)>
public static "comparing"<T, U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(T)>
public static "comparing"<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(T)>
public "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(T)>
public "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(T)>
public "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(T)>
public static "comparingInt"<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(T)>
public static "comparingLong"<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(T)>
public static "comparingDouble"<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(T)>
public "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(T)>
public "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(T)>
public "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(T)>
public static "naturalOrder"<T extends $Comparable<(any)>>(): $Comparator<(T)>
public static "nullsFirst"<T>(arg0: $Comparator$Type<(any)>): $Comparator<(T)>
public static "nullsLast"<T>(arg0: $Comparator$Type<(any)>): $Comparator<(T)>
get "comparator"(): $Comparator<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReversedComparator$Type<T> = ($ReversedComparator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReversedComparator_<T> = $ReversedComparator$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$LongProgressionIterator" {
import {$LongIterator, $LongIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$LongIterator"

export class $LongProgressionIterator extends $LongIterator {

constructor(arg0: long, arg1: long, arg2: long)

public "hasNext"(): boolean
public "nextLong"(): long
public "getStep"(): long
get "step"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongProgressionIterator$Type = ($LongProgressionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongProgressionIterator_ = $LongProgressionIterator$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/security/$UserAuthentication" {
import {$AbstractUserAuthentication, $AbstractUserAuthentication$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/security/$AbstractUserAuthentication"
import {$UserIdentity, $UserIdentity$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$UserIdentity"

export class $UserAuthentication extends $AbstractUserAuthentication {

constructor(arg0: string, arg1: $UserIdentity$Type)

public "toString"(): string
public "logout"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UserAuthentication$Type = ($UserAuthentication);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UserAuthentication_ = $UserAuthentication$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntRange" {
import {$UIntRange$Companion, $UIntRange$Companion$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntRange$Companion"
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$UIntProgression, $UIntProgression$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgression"
import {$ClosedRange, $ClosedRange$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$ClosedRange"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"

export class $UIntRange extends $UIntProgression implements $ClosedRange<($UInt)> {
static readonly "Companion": $UIntRange$Companion

constructor(arg0: integer, arg1: integer, arg2: $DefaultConstructorMarker$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "getStart-pVg5ArA"(): integer
public "contains-WZ4Q5Ns"(arg0: integer): boolean
public "getEndInclusive-pVg5ArA"(): integer
get "empty"(): boolean
get "start-pVg5ArA"(): integer
get "endInclusive-pVg5ArA"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntRange$Type = ($UIntRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntRange_ = $UIntRange$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/api/$BatchMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BatchMode extends $Enum<($BatchMode)> {
static readonly "AUTO": $BatchMode
static readonly "ON": $BatchMode
static readonly "OFF": $BatchMode


public static "values"(): ($BatchMode)[]
public static "max"(arg0: $BatchMode$Type, arg1: $BatchMode$Type): $BatchMode
public static "valueOf"(arg0: string): $BatchMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BatchMode$Type = (("auto") | ("off") | ("on")) | ($BatchMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BatchMode_ = $BatchMode$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/$JvmClassMappingKt" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$KClass, $KClass$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KClass"

export class $JvmClassMappingKt {


public static "getJavaObjectType"<T>(arg0: $KClass$Type<(T)>): $Class<(T)>
public static "getJavaClass"<T>(arg0: T): $Class<(T)>
public static "getJavaClass"<T>(arg0: $KClass$Type<(T)>): $Class<(T)>
public static "getAnnotationClass"<T extends $Annotation>(arg0: T): $KClass<(any)>
public static "getKotlinClass"<T>(arg0: $Class$Type<(T)>): $KClass<(T)>
public static "getJavaPrimitiveType"<T>(arg0: $KClass$Type<(T)>): $Class<(T)>
public static "getRuntimeClassOfKClassInstance"<T>(arg0: $KClass$Type<(T)>): $Class<($KClass<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JvmClassMappingKt$Type = ($JvmClassMappingKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JvmClassMappingKt_ = $JvmClassMappingKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$IndexedValue" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $IndexedValue<T> {

constructor(arg0: integer, arg1: T)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): T
public "copy"(arg0: integer, arg1: T): $IndexedValue<(T)>
public "getIndex"(): integer
public "component2"(): T
public "component1"(): integer
get "value"(): T
get "index"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexedValue$Type<T> = ($IndexedValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexedValue_<T> = $IndexedValue$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$UpgradeHttpServletRequest" {
import {$ServletResponse, $ServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletResponse"
import {$Part, $Part$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Part"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$Cookie, $Cookie$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$Cookie"
import {$HttpServletMapping, $HttpServletMapping$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletMapping"
import {$RequestDispatcher, $RequestDispatcher$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$RequestDispatcher"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$AsyncContext, $AsyncContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$AsyncContext"
import {$HttpUpgradeHandler, $HttpUpgradeHandler$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpUpgradeHandler"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$HttpSession, $HttpSession$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpSession"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$ServletRequest, $ServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRequest"
import {$PushBuilder, $PushBuilder$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$PushBuilder"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UpgradeHttpServletRequest implements $HttpServletRequest {

constructor(arg0: $HttpServletRequest$Type)

public "getMethod"(): string
public "getScheme"(): string
public "getInputStream"(): $ServletInputStream
public "getProtocol"(): string
public "getAttributes"(): $Map<(string), (any)>
public "setAttribute"(arg0: string, arg1: any): void
public "getAttribute"(arg0: string): any
public "getLocale"(): $Locale
public "complete"(): void
public "getHeader"(arg0: string): string
public "getContentLength"(): integer
public "getRealPath"(arg0: string): string
public "getContentLengthLong"(): long
public "getContentType"(): string
public "getHeaders"(arg0: string): $Enumeration<(string)>
public "getHeaders"(): $Map<(string), ($List<(string)>)>
public "isSecure"(): boolean
public "authenticate"(arg0: $HttpServletResponse$Type): boolean
public "getParameter"(arg0: string): string
public "getRequestURI"(): string
public "getLocalName"(): string
public "getLocalPort"(): integer
public "getAuthType"(): string
public "getQueryString"(): string
public "removeAttribute"(arg0: string): void
public "getCharacterEncoding"(): string
public "isRequestedSessionIdValid"(): boolean
public "setCharacterEncoding"(arg0: string): void
public "isRequestedSessionIdFromCookie"(): boolean
public "isRequestedSessionIdFromURL"(): boolean
public "isRequestedSessionIdFromUrl"(): boolean
public "getRequestedSessionId"(): string
public "getRequestDispatcher"(arg0: string): $RequestDispatcher
public "getServerName"(): string
public "getContextPath"(): string
public "getReader"(): $BufferedReader
public "getSession"(): $HttpSession
public "getSession"(arg0: boolean): $HttpSession
public "upgrade"<T extends $HttpUpgradeHandler>(arg0: $Class$Type<(T)>): T
public "getPathInfo"(): string
public "getDispatcherType"(): $DispatcherType
public "getServletContext"(): $ServletContext
public "isAsyncStarted"(): boolean
public "getHeaderNames"(): $Enumeration<(string)>
public "getIntHeader"(arg0: string): integer
public "getPathTranslated"(): string
public "isUserInRole"(arg0: string): boolean
public "getDateHeader"(arg0: string): long
public "getRemoteUser"(): string
public "getUserPrincipal"(): $Principal
public "getCookies"(): ($Cookie)[]
public "getRequestURL"(): $StringBuffer
public "changeSessionId"(): string
public "getServletPath"(): string
public "getRemotePort"(): integer
public "getParameterNames"(): $Enumeration<(string)>
public "getParameterValues"(arg0: string): (string)[]
public "getLocalAddr"(): string
public "startAsync"(): $AsyncContext
public "startAsync"(arg0: $ServletRequest$Type, arg1: $ServletResponse$Type): $AsyncContext
public "getRemoteAddr"(): string
public "getParameterMap"(): $Map<(string), ((string)[])>
public "getLocales"(): $Enumeration<($Locale)>
public "getRemoteHost"(): string
public "getServerPort"(): integer
public "isAsyncSupported"(): boolean
public "getAsyncContext"(): $AsyncContext
public "login"(arg0: string, arg1: string): void
public "logout"(): void
public "getAttributeNames"(): $Enumeration<(string)>
public "getParts"(): $Collection<($Part)>
public "getPart"(arg0: string): $Part
public "getHttpServletRequest"(): $HttpServletRequest
public "getHttpServletMapping"(): $HttpServletMapping
public "isTrailerFieldsReady"(): boolean
public "getTrailerFields"(): $Map<(string), (string)>
public "newPushBuilder"(): $PushBuilder
get "method"(): string
get "scheme"(): string
get "inputStream"(): $ServletInputStream
get "protocol"(): string
get "attributes"(): $Map<(string), (any)>
get "locale"(): $Locale
get "contentLength"(): integer
get "contentLengthLong"(): long
get "contentType"(): string
get "headers"(): $Map<(string), ($List<(string)>)>
get "secure"(): boolean
get "requestURI"(): string
get "localName"(): string
get "localPort"(): integer
get "authType"(): string
get "queryString"(): string
get "characterEncoding"(): string
get "requestedSessionIdValid"(): boolean
set "characterEncoding"(value: string)
get "requestedSessionIdFromCookie"(): boolean
get "requestedSessionIdFromURL"(): boolean
get "requestedSessionIdFromUrl"(): boolean
get "requestedSessionId"(): string
get "serverName"(): string
get "contextPath"(): string
get "reader"(): $BufferedReader
get "session"(): $HttpSession
get "pathInfo"(): string
get "dispatcherType"(): $DispatcherType
get "servletContext"(): $ServletContext
get "asyncStarted"(): boolean
get "headerNames"(): $Enumeration<(string)>
get "pathTranslated"(): string
get "remoteUser"(): string
get "userPrincipal"(): $Principal
get "cookies"(): ($Cookie)[]
get "requestURL"(): $StringBuffer
get "servletPath"(): string
get "remotePort"(): integer
get "parameterNames"(): $Enumeration<(string)>
get "localAddr"(): string
get "remoteAddr"(): string
get "parameterMap"(): $Map<(string), ((string)[])>
get "locales"(): $Enumeration<($Locale)>
get "remoteHost"(): string
get "serverPort"(): integer
get "asyncSupported"(): boolean
get "asyncContext"(): $AsyncContext
get "attributeNames"(): $Enumeration<(string)>
get "parts"(): $Collection<($Part)>
get "httpServletRequest"(): $HttpServletRequest
get "httpServletMapping"(): $HttpServletMapping
get "trailerFieldsReady"(): boolean
get "trailerFields"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeHttpServletRequest$Type = ($UpgradeHttpServletRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeHttpServletRequest_ = $UpgradeHttpServletRequest$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/$IChunkFactory" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunk, $PngChunk$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk"

export interface $IChunkFactory {

 "createChunk"(arg0: $ChunkRaw$Type, arg1: $ImageInfo$Type): $PngChunk

(arg0: $ChunkRaw$Type, arg1: $ImageInfo$Type): $PngChunk
}

export namespace $IChunkFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChunkFactory$Type = ($IChunkFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChunkFactory_ = $IChunkFactory$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MutableMapWithDefault" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KMutableMap, $KMutableMap$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMutableMap"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MapWithDefault, $MapWithDefault$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$MapWithDefault"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $MutableMapWithDefault<K, V> extends $Map<(K), (V)>, $MapWithDefault<(K), (V)>, $KMutableMap {

 "getMap"(): $Map<(K), (V)>
 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "equals"(arg0: any): boolean
 "values"(): $Collection<(V)>
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "keySet"(): $Set<(K)>
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "getOrImplicitDefault"(arg0: K): V
}

export namespace $MutableMapWithDefault {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableMapWithDefault$Type<K, V> = ($MutableMapWithDefault<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableMapWithDefault_<K, V> = $MutableMapWithDefault$Type<(K), (V)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt___SetsKt" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$SetsKt__SetsKt, $SetsKt__SetsKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$SetsKt__SetsKt"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SetsKt___SetsKt extends $SetsKt__SetsKt {

constructor()

public static "plus"<T>(arg0: $Set$Type<(any)>, arg1: T): $Set<(T)>
public static "plus"<T>(arg0: $Set$Type<(any)>, arg1: (T)[]): $Set<(T)>
public static "plus"<T>(arg0: $Set$Type<(any)>, arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "plus"<T>(arg0: $Set$Type<(any)>, arg1: $Sequence$Type<(any)>): $Set<(T)>
public static "minus"<T>(arg0: $Set$Type<(any)>, arg1: T): $Set<(T)>
public static "minus"<T>(arg0: $Set$Type<(any)>, arg1: $Iterable$Type<(any)>): $Set<(T)>
public static "minus"<T>(arg0: $Set$Type<(any)>, arg1: $Sequence$Type<(any)>): $Set<(T)>
public static "minus"<T>(arg0: $Set$Type<(any)>, arg1: (T)[]): $Set<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetsKt___SetsKt$Type = ($SetsKt___SetsKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetsKt___SetsKt_ = $SetsKt___SetsKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$ArrayIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ArrayIterator<T> implements $Iterator<(T)>, $KMappedMarker {

constructor(arg0: (T)[])

public "remove"(): void
public "hasNext"(): boolean
public "next"(): T
public "getArray"(): (T)[]
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
get "array"(): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayIterator$Type<T> = ($ArrayIterator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayIterator_<T> = $ArrayIterator$Type<(T)>;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$EmptyCoroutineContext" {
import {$Function2, $Function2$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function2"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$CoroutineContext, $CoroutineContext$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext"
import {$CoroutineContext$Key, $CoroutineContext$Key$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Key"
import {$CoroutineContext$Element, $CoroutineContext$Element$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/coroutines/$CoroutineContext$Element"

export class $EmptyCoroutineContext implements $CoroutineContext, $Serializable {
static readonly "INSTANCE": $EmptyCoroutineContext


public "get"<E extends $CoroutineContext$Element>(arg0: $CoroutineContext$Key$Type<(E)>): E
public "toString"(): string
public "hashCode"(): integer
public "plus"(arg0: $CoroutineContext$Type): $CoroutineContext
public "minusKey"(arg0: $CoroutineContext$Key$Type<(any)>): $CoroutineContext
public "fold"<R>(arg0: R, arg1: $Function2$Type<(any), (any), (any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyCoroutineContext$Type = ($EmptyCoroutineContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyCoroutineContext_ = $EmptyCoroutineContext$Type;
}}
declare module "packages/info/journeymap/shaded/org/slf4j/helpers/$SubstituteLoggerFactory" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ILoggerFactory, $ILoggerFactory$Type} from "packages/info/journeymap/shaded/org/slf4j/$ILoggerFactory"
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/slf4j/$Logger"
import {$SubstituteLogger, $SubstituteLogger$Type} from "packages/info/journeymap/shaded/org/slf4j/helpers/$SubstituteLogger"

export class $SubstituteLoggerFactory implements $ILoggerFactory {

constructor()

public "clear"(): void
public "getLogger"(arg0: string): $Logger
public "getLoggerNames"(): $List<(string)>
public "getLoggers"(): $List<($SubstituteLogger)>
get "loggerNames"(): $List<(string)>
get "loggers"(): $List<($SubstituteLogger)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubstituteLoggerFactory$Type = ($SubstituteLoggerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubstituteLoggerFactory_ = $SubstituteLoggerFactory$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/io/ssl/$SslHandshakeListener$Event" {
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$EventObject, $EventObject$Type} from "packages/java/util/$EventObject"

export class $SslHandshakeListener$Event extends $EventObject {

constructor(arg0: any)

public "getSSLEngine"(): $SSLEngine
get "sSLEngine"(): $SSLEngine
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SslHandshakeListener$Event$Type = ($SslHandshakeListener$Event);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SslHandshakeListener$Event_ = $SslHandshakeListener$Event$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$BadResource" {
import {$Resource, $Resource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$Resource"
import {$File, $File$Type} from "packages/java/io/$File"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$URLResource, $URLResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/resource/$URLResource"

export class $BadResource extends $URLResource {
static "__defaultUseCaches": boolean


public "length"(): long
public "toString"(): string
public "list"(): (string)[]
public "delete"(): boolean
public "getInputStream"(): $InputStream
public "getFile"(): $File
public "exists"(): boolean
public "renameTo"(arg0: $Resource$Type): boolean
public "isDirectory"(): boolean
public "lastModified"(): long
public "copyTo"(arg0: $File$Type): void
get "inputStream"(): $InputStream
get "file"(): $File
get "directory"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BadResource$Type = ($BadResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BadResource_ = $BadResource$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$HandshakeRFC6455" {
import {$ServletUpgradeResponse, $ServletUpgradeResponse$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeResponse"
import {$ServletUpgradeRequest, $ServletUpgradeRequest$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/servlet/$ServletUpgradeRequest"
import {$WebSocketHandshake, $WebSocketHandshake$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/server/$WebSocketHandshake"

export class $HandshakeRFC6455 implements $WebSocketHandshake {
static readonly "VERSION": integer

constructor()

public "doHandshakeResponse"(arg0: $ServletUpgradeRequest$Type, arg1: $ServletUpgradeResponse$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeRFC6455$Type = ($HandshakeRFC6455);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeRFC6455_ = $HandshakeRFC6455$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$ResponseHandler" {
import {$HttpVersion, $HttpVersion$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpVersion"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpParser$HttpHandler, $HttpParser$HttpHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpParser$HttpHandler"

export interface $HttpParser$ResponseHandler extends $HttpParser$HttpHandler {

 "startResponse"(arg0: $HttpVersion$Type, arg1: integer, arg2: string): boolean
 "content"(arg0: $ByteBuffer$Type): boolean
 "earlyEOF"(): void
 "messageComplete"(): boolean
 "parsedTrailer"(arg0: $HttpField$Type): void
 "contentComplete"(): boolean
 "parsedHeader"(arg0: $HttpField$Type): void
 "headerComplete"(): boolean
 "badMessage"(arg0: integer, arg1: string): void
 "getHeaderCacheSize"(): integer
}

export namespace $HttpParser$ResponseHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpParser$ResponseHandler$Type = ($HttpParser$ResponseHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpParser$ResponseHandler_ = $HttpParser$ResponseHandler$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$CookieCompliance" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $CookieCompliance extends $Enum<($CookieCompliance)> {
static readonly "RFC6265": $CookieCompliance
static readonly "RFC2965": $CookieCompliance


public static "values"(): ($CookieCompliance)[]
public static "valueOf"(arg0: string): $CookieCompliance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CookieCompliance$Type = (("rfc2965") | ("rfc6265")) | ($CookieCompliance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CookieCompliance_ = $CookieCompliance$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/$UIntArray" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$KMappedMarker, $KMappedMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/markers/$KMappedMarker"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$UInt, $UInt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$UInt"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $UIntArray implements $Collection<($UInt)>, $KMappedMarker {


public "remove"(arg0: any): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<($UInt)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "getSize"(): integer
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public static "set-VXSXFK8"(arg0: (integer)[], arg1: integer, arg2: integer): void
public static "contains-WZ4Q5Ns"(arg0: (integer)[], arg1: integer): boolean
public "contains-WZ4Q5Ns"(arg0: integer): boolean
public static "constructor-impl"(arg0: integer): (integer)[]
public static "constructor-impl"(arg0: (integer)[]): (integer)[]
public static "getSize-impl"(arg0: (integer)[]): integer
public static "equals-impl"(arg0: (integer)[], arg1: any): boolean
public static "containsAll-impl"(arg0: (integer)[], arg1: $Collection$Type<($UInt$Type)>): boolean
public static "hashCode-impl"(arg0: (integer)[]): integer
public static "iterator-impl"(arg0: (integer)[]): $Iterator<($UInt)>
public static "toString-impl"(arg0: (integer)[]): string
public static "isEmpty-impl"(arg0: (integer)[]): boolean
public static "equals-impl0"(arg0: (integer)[], arg1: (integer)[]): boolean
public static "get-pVg5ArA"(arg0: (integer)[], arg1: integer): integer
public "add-WZ4Q5Ns"(arg0: integer): boolean
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<($UInt)>
public "spliterator"(): $Spliterator<($UInt)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<($UInt)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$UInt>;
get "empty"(): boolean
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntArray$Type = ($UIntArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntArray_ = $UIntArray$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/embeddedserver/jetty/$HttpRequestWrapper" {
import {$HttpServletRequestWrapper, $HttpServletRequestWrapper$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequestWrapper"
import {$ServletInputStream, $ServletInputStream$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletInputStream"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"

export class $HttpRequestWrapper extends $HttpServletRequestWrapper {

constructor(arg0: $HttpServletRequest$Type)

public "getInputStream"(): $ServletInputStream
public "notConsumed"(arg0: boolean): void
public "notConsumed"(): boolean
get "inputStream"(): $ServletInputStream
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpRequestWrapper$Type = ($HttpRequestWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpRequestWrapper_ = $HttpRequestWrapper$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter" {
import {$KType, $KType$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KType"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$KParameter$Kind, $KParameter$Kind$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KParameter$Kind"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KAnnotatedElement, $KAnnotatedElement$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/reflect/$KAnnotatedElement"

export interface $KParameter extends $KAnnotatedElement {

 "isVararg"(): boolean
 "getName"(): string
 "getType"(): $KType
 "getIndex"(): integer
 "isOptional"(): boolean
 "getKind"(): $KParameter$Kind
 "getAnnotations"(): $List<($Annotation)>
}

export namespace $KParameter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KParameter$Type = ($KParameter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KParameter_ = $KParameter$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHandler" {
import {$ScopedHandler, $ScopedHandler$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/$ScopedHandler"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ServletRegistration$Dynamic, $ServletRegistration$Dynamic$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletRegistration$Dynamic"
import {$LifeCycle$Listener, $LifeCycle$Listener$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/component/$LifeCycle$Listener"
import {$MappedResource, $MappedResource$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/pathmap/$MappedResource"
import {$Source, $Source$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$Source"
import {$ServletMapping, $ServletMapping$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletMapping"
import {$ListenerHolder, $ListenerHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ListenerHolder"
import {$HttpServletResponse, $HttpServletResponse$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletResponse"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$ServletHolder, $ServletHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHolder"
import {$ServletSecurityElement, $ServletSecurityElement$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletSecurityElement"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$FilterHolder, $FilterHolder$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$FilterHolder"
import {$Request, $Request$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$Request"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DispatcherType, $DispatcherType$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$DispatcherType"
import {$ServletContext, $ServletContext$Type} from "packages/info/journeymap/shaded/org/javax/servlet/$ServletContext"
import {$ServletHandler$CachedChain, $ServletHandler$CachedChain$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$ServletHandler$CachedChain"
import {$FilterMapping, $FilterMapping$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/servlet/$FilterMapping"

export class $ServletHandler extends $ScopedHandler {
static readonly "__DEFAULT_SERVLET": string
static readonly "STOPPED": string
static readonly "FAILED": string
static readonly "STARTING": string
static readonly "STARTED": string
static readonly "STOPPING": string
static readonly "RUNNING": string
static readonly "STOP_ON_FAILURE": $LifeCycle$Listener

constructor()

public "addServlet"(arg0: $ServletHolder$Type): void
public "getServlet"(arg0: string): $ServletHolder
public "getServlets"(): ($ServletHolder)[]
public "initialize"(): void
public "getFilter"(arg0: string): $FilterHolder
public "isAvailable"(): boolean
public "getListeners"(): ($ListenerHolder)[]
public "setFilters"(arg0: ($FilterHolder$Type)[]): void
public "getFilters"(): ($FilterHolder)[]
public "addListener"(arg0: $ListenerHolder$Type): void
public "addFilter"(arg0: $FilterHolder$Type, arg1: $FilterMapping$Type): void
public "addFilter"(arg0: $FilterHolder$Type): void
/**
 * 
 * @deprecated
 */
public "addFilter"(arg0: string, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): $FilterHolder
public "getServletContext"(): $ServletContext
public "isEnsureDefaultServlet"(): boolean
public "addServletWithMapping"(arg0: $Class$Type<(any)>, arg1: string): $ServletHolder
public "addServletWithMapping"(arg0: $ServletHolder$Type, arg1: string): void
public "addServletWithMapping"(arg0: string, arg1: string): $ServletHolder
public "isFilterChainsCached"(): boolean
public "setEnsureDefaultServlet"(arg0: boolean): void
public "setStartWithUnavailable"(arg0: boolean): void
public "isAllowDuplicateMappings"(): boolean
public "setAllowDuplicateMappings"(arg0: boolean): void
public "isStartWithUnavailable"(): boolean
public "setMaxFilterChainsCacheSize"(arg0: integer): void
public "addFilterWithMapping"(arg0: $FilterHolder$Type, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): void
public "addFilterWithMapping"(arg0: string, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): $FilterHolder
public "addFilterWithMapping"(arg0: $Class$Type<(any)>, arg1: string, arg2: $EnumSet$Type<($DispatcherType$Type)>): $FilterHolder
public "addFilterWithMapping"(arg0: $FilterHolder$Type, arg1: string, arg2: integer): void
public "addFilterWithMapping"(arg0: $Class$Type<(any)>, arg1: string, arg2: integer): $FilterHolder
public "addFilterWithMapping"(arg0: string, arg1: string, arg2: integer): $FilterHolder
public "setFilterChainsCached"(arg0: boolean): void
public "getMaxFilterChainsCacheSize"(): integer
public "prependFilterMapping"(arg0: $FilterMapping$Type): void
public "doHandle"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "doScope"(arg0: string, arg1: $Request$Type, arg2: $HttpServletRequest$Type, arg3: $HttpServletResponse$Type): void
public "getServletMapping"(arg0: string): $ServletMapping
public "getFilterMappings"(): ($FilterMapping)[]
public "getServletMappings"(): ($ServletMapping)[]
public "getHolderEntry"(arg0: string): $MappedResource<($ServletHolder)>
public "newCachedChain"(arg0: $List$Type<($FilterHolder$Type)>, arg1: $ServletHolder$Type): $ServletHandler$CachedChain
public "newServletHolder"(arg0: $Source$Type): $ServletHolder
public "newListenerHolder"(arg0: $Source$Type): $ListenerHolder
public "setListeners"(arg0: ($ListenerHolder$Type)[]): void
public "setServlets"(arg0: ($ServletHolder$Type)[]): void
public "addServletMapping"(arg0: $ServletMapping$Type): void
public "setServletMappings"(arg0: ($ServletMapping$Type)[]): void
public "newFilterHolder"(arg0: $Source$Type): $FilterHolder
public "setServletSecurity"(arg0: $ServletRegistration$Dynamic$Type, arg1: $ServletSecurityElement$Type): $Set<(string)>
public "setFilterMappings"(arg0: ($FilterMapping$Type)[]): void
public "addFilterMapping"(arg0: $FilterMapping$Type): void
public "start"(): void
public static "start"(arg0: any): void
public static "stop"(arg0: any): void
public "stop"(): void
public "removeLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "addLifeCycleListener"(arg0: $LifeCycle$Listener$Type): void
public "isRunning"(): boolean
public "isStarted"(): boolean
public "isStopped"(): boolean
public "isStopping"(): boolean
public "isStarting"(): boolean
public "isFailed"(): boolean
get "servlets"(): ($ServletHolder)[]
get "available"(): boolean
get "listeners"(): ($ListenerHolder)[]
set "filters"(value: ($FilterHolder$Type)[])
get "filters"(): ($FilterHolder)[]
get "servletContext"(): $ServletContext
get "ensureDefaultServlet"(): boolean
get "filterChainsCached"(): boolean
set "ensureDefaultServlet"(value: boolean)
set "startWithUnavailable"(value: boolean)
get "allowDuplicateMappings"(): boolean
set "allowDuplicateMappings"(value: boolean)
get "startWithUnavailable"(): boolean
set "maxFilterChainsCacheSize"(value: integer)
set "filterChainsCached"(value: boolean)
get "maxFilterChainsCacheSize"(): integer
get "filterMappings"(): ($FilterMapping)[]
get "servletMappings"(): ($ServletMapping)[]
set "listeners"(value: ($ListenerHolder$Type)[])
set "servlets"(value: ($ServletHolder$Type)[])
set "servletMappings"(value: ($ServletMapping$Type)[])
set "filterMappings"(value: ($FilterMapping$Type)[])
get "running"(): boolean
get "started"(): boolean
get "stopped"(): boolean
get "stopping"(): boolean
get "starting"(): boolean
get "failed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServletHandler$Type = ($ServletHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServletHandler_ = $ServletHandler$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/ranges/$UIntProgressionIterator" {
import {$DefaultConstructorMarker, $DefaultConstructorMarker$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/internal/$DefaultConstructorMarker"
import {$UIntIterator, $UIntIterator$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/collections/$UIntIterator"

export class $UIntProgressionIterator extends $UIntIterator {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $DefaultConstructorMarker$Type)

public "hasNext"(): boolean
public "nextUInt-pVg5ArA"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UIntProgressionIterator$Type = ($UIntProgressionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UIntProgressionIterator_ = $UIntProgressionIterator$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$SequencesKt___SequencesKt, $SequencesKt___SequencesKt$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$SequencesKt___SequencesKt"
import {$Sequence, $Sequence$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/sequences/$Sequence"

export class $SequencesKt extends $SequencesKt___SequencesKt {


public static "minOrNull"<T extends $Comparable<(any)>>(arg0: $Sequence$Type<(any)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencesKt$Type = ($SequencesKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencesKt_ = $SequencesKt$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$QuotedCSV" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $QuotedCSV implements $Iterable<(string)> {

constructor(...arg0: (string)[])
constructor(arg0: boolean, ...arg1: (string)[])

public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $Iterator<(string)>
public "addValue"(arg0: string): void
public static "unquote"(arg0: string): string
public "getValues"(): $List<(string)>
public "spliterator"(): $Spliterator<(string)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<string>;
get "empty"(): boolean
get "values"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuotedCSV$Type = ($QuotedCSV);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuotedCSV_ = $QuotedCSV$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/kotlin/$HttpKt" {
import {$ResponseTransformer, $ResponseTransformer$Type} from "packages/info/journeymap/shaded/kotlin/spark/$ResponseTransformer"
import {$Function1, $Function1$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/jvm/functions/$Function1"
import {$Redirect, $Redirect$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Redirect"
import {$HaltException, $HaltException$Type} from "packages/info/journeymap/shaded/kotlin/spark/$HaltException"
import {$TemplateEngine, $TemplateEngine$Type} from "packages/info/journeymap/shaded/kotlin/spark/$TemplateEngine"
import {$Filter, $Filter$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Filter"
import {$Unit, $Unit$Type} from "packages/info/journeymap/shaded/kotlin/kotlin/$Unit"
import {$Http, $Http$Type} from "packages/info/journeymap/shaded/kotlin/spark/kotlin/$Http"
import {$Service$StaticFiles, $Service$StaticFiles$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Service$StaticFiles"

export class $HttpKt {


public static "getDEFAULT_ACCEPT"(): string
public static "ignite"(): $Http
public static "get"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "get"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "get"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "put"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "put"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "put"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "trace"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "trace"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "trace"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "delete"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "delete"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "delete"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "connect"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "connect"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "connect"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "port"(): integer
public static "port"(arg0: integer): void
public static "stop"(): void
public static "options"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "options"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "options"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "before"(arg0: string, arg1: string, arg2: $Function1$Type<(any), ($Unit$Type)>): void
public static "before"(arg0: $Filter$Type, arg1: string): void
public static "after"(arg0: string, arg1: string, arg2: $Function1$Type<(any), ($Unit$Type)>): void
public static "halt"(arg0: integer, arg1: string): $HaltException
public static "halt"(): $HaltException
public static "halt"(arg0: integer): $HaltException
public static "halt"(arg0: string): $HaltException
public static "head"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "head"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "head"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "patch"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "patch"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "patch"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "post"(arg0: string, arg1: string, arg2: $Function1$Type<(any), (any)>): void
public static "post"(arg0: string, arg1: string, arg2: $TemplateEngine$Type, arg3: $Function1$Type<(any), (any)>): void
public static "post"(arg0: string, arg1: string, arg2: $ResponseTransformer$Type, arg3: $Function1$Type<(any), (any)>): void
public static "finally"(arg0: string, arg1: $Function1$Type<(any), ($Unit$Type)>): void
public static "secure"(arg0: string, arg1: string, arg2: string, arg3: string): void
public static "secure"(arg0: string, arg1: string, arg2: string, arg3: string, arg4: boolean): void
public static "ipAddress"(arg0: string): void
public static "notFound"(arg0: $Function1$Type<(any), (any)>): void
public static "getStaticFiles"(): $Service$StaticFiles
public static "threadPool"(arg0: integer, arg1: integer, arg2: integer): void
public static "threadPool"(arg0: integer): void
public static "getRedirect"(): $Redirect
public static "internalServerError"(arg0: $Function1$Type<(any), (any)>): void
get "dEFAULT_ACCEPT"(): string
get "staticFiles"(): $Service$StaticFiles
get "redirect"(): $Redirect
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpKt$Type = ($HttpKt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpKt_ = $HttpKt$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/resource/$UriPath" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UriPath {

constructor()

public static "canonical"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UriPath$Type = ($UriPath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UriPath_ = $UriPath$Type;
}}
declare module "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkHIST" {
import {$ChunkRaw, $ChunkRaw$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$ChunkRaw"
import {$PngChunk$ChunkOrderingConstraint, $PngChunk$ChunkOrderingConstraint$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunk$ChunkOrderingConstraint"
import {$ImageInfo, $ImageInfo$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/$ImageInfo"
import {$PngChunkSingle, $PngChunkSingle$Type} from "packages/info/journeymap/shaded/ar/com/hjg/pngj/chunks/$PngChunkSingle"

export class $PngChunkHIST extends $PngChunkSingle {
static readonly "ID": string
readonly "id": string
readonly "crit": boolean
readonly "pub": boolean
readonly "safe": boolean

constructor(arg0: $ImageInfo$Type)

public "createRawChunk"(): $ChunkRaw
public "parseFromRaw"(arg0: $ChunkRaw$Type): void
public "getOrderingConstraint"(): $PngChunk$ChunkOrderingConstraint
public "setHist"(arg0: (integer)[]): void
public "getHist"(): (integer)[]
get "orderingConstraint"(): $PngChunk$ChunkOrderingConstraint
set "hist"(value: (integer)[])
get "hist"(): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PngChunkHIST$Type = ($PngChunkHIST);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PngChunkHIST_ = $PngChunkHIST$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/util/ssl/$SniX509ExtendedKeyManager" {
import {$X509ExtendedKeyManager, $X509ExtendedKeyManager$Type} from "packages/javax/net/ssl/$X509ExtendedKeyManager"
import {$X509Certificate, $X509Certificate$Type} from "packages/java/security/cert/$X509Certificate"
import {$PrivateKey, $PrivateKey$Type} from "packages/java/security/$PrivateKey"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$Principal, $Principal$Type} from "packages/java/security/$Principal"
import {$Socket, $Socket$Type} from "packages/java/net/$Socket"

export class $SniX509ExtendedKeyManager extends $X509ExtendedKeyManager {
static readonly "SNI_X509": string

constructor(arg0: $X509ExtendedKeyManager$Type)

public "getCertificateChain"(arg0: string): ($X509Certificate)[]
public "getPrivateKey"(arg0: string): $PrivateKey
public "getClientAliases"(arg0: string, arg1: ($Principal$Type)[]): (string)[]
public "chooseClientAlias"(arg0: (string)[], arg1: ($Principal$Type)[], arg2: $Socket$Type): string
public "getServerAliases"(arg0: string, arg1: ($Principal$Type)[]): (string)[]
public "chooseServerAlias"(arg0: string, arg1: ($Principal$Type)[], arg2: $Socket$Type): string
public "chooseEngineClientAlias"(arg0: (string)[], arg1: ($Principal$Type)[], arg2: $SSLEngine$Type): string
public "chooseEngineServerAlias"(arg0: string, arg1: ($Principal$Type)[], arg2: $SSLEngine$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SniX509ExtendedKeyManager$Type = ($SniX509ExtendedKeyManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SniX509ExtendedKeyManager_ = $SniX509ExtendedKeyManager$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannelState$State" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HttpChannelState$State extends $Enum<($HttpChannelState$State)> {
static readonly "IDLE": $HttpChannelState$State
static readonly "DISPATCHED": $HttpChannelState$State
static readonly "THROWN": $HttpChannelState$State
static readonly "ASYNC_WAIT": $HttpChannelState$State
static readonly "ASYNC_WOKEN": $HttpChannelState$State
static readonly "ASYNC_IO": $HttpChannelState$State
static readonly "ASYNC_ERROR": $HttpChannelState$State
static readonly "COMPLETING": $HttpChannelState$State
static readonly "COMPLETED": $HttpChannelState$State
static readonly "UPGRADED": $HttpChannelState$State


public static "values"(): ($HttpChannelState$State)[]
public static "valueOf"(arg0: string): $HttpChannelState$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpChannelState$State$Type = (("upgraded") | ("dispatched") | ("idle") | ("async_wait") | ("thrown") | ("completing") | ("completed") | ("async_woken") | ("async_io") | ("async_error")) | ($HttpChannelState$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpChannelState$State_ = $HttpChannelState$State$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/websocket/common/events/$ParamList" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"

export class $ParamList extends $ArrayList<(($Class<(any)>)[])> {

constructor()

public "addParams"(...arg0: ($Class$Type<(any)>)[]): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParamList$Type = ($ParamList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParamList_ = $ParamList$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/http/$DateParser" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DateParser {

constructor()

public static "parseDate"(arg0: string): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DateParser$Type = ($DateParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DateParser_ = $DateParser$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Appendable, $Appendable$Type} from "packages/java/lang/$Appendable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CookieCompliance, $CookieCompliance$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$CookieCompliance"
import {$HttpConfiguration$Customizer, $HttpConfiguration$Customizer$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpConfiguration$Customizer"

export class $HttpConfiguration {
static readonly "SERVER_VERSION": string

constructor()
constructor(arg0: $HttpConfiguration$Type)

public "getSecureScheme"(): string
public "getSecurePort"(): integer
public "toString"(): string
public "isCookieCompliance"(arg0: $CookieCompliance$Type): boolean
public "getRequestHeaderSize"(): integer
public "getBlockingTimeout"(): long
public "setIdleTimeout"(arg0: long): void
public "getIdleTimeout"(): long
public "getCustomizers"(): $List<($HttpConfiguration$Customizer)>
public "getSendDateHeader"(): boolean
public "writePoweredBy"(arg0: $Appendable$Type, arg1: string, arg2: string): void
public "addCustomizer"(arg0: $HttpConfiguration$Customizer$Type): void
public "getCustomizer"<T>(arg0: $Class$Type<(T)>): T
public "getSendXPoweredBy"(): boolean
public "isDelayDispatchUntilContent"(): boolean
public "isPersistentConnectionsEnabled"(): boolean
public "isFormEncodedMethod"(arg0: string): boolean
public "setBlockingTimeout"(arg0: long): void
public "setSendXPoweredBy"(arg0: boolean): void
public "setSendDateHeader"(arg0: boolean): void
public "setSecureScheme"(arg0: string): void
public "setSecurePort"(arg0: integer): void
public "setHeaderCacheSize"(arg0: integer): void
public "setCustomizers"(arg0: $List$Type<($HttpConfiguration$Customizer$Type)>): void
public "getOutputBufferSize"(): integer
public "getOutputAggregationSize"(): integer
public "getResponseHeaderSize"(): integer
public "setPersistentConnectionsEnabled"(arg0: boolean): void
public "setDelayDispatchUntilContent"(arg0: boolean): void
public "setFormEncodedMethods"(...arg0: (string)[]): void
public "addFormEncodedMethod"(arg0: string): void
public "setOutputBufferSize"(arg0: integer): void
public "setResponseHeaderSize"(arg0: integer): void
public "setOutputAggregationSize"(arg0: integer): void
public "getFormEncodedMethods"(): $Set<(string)>
public "setRequestHeaderSize"(arg0: integer): void
public "getMaxErrorDispatches"(): integer
public "setMaxErrorDispatches"(arg0: integer): void
public "setMinRequestDataRate"(arg0: long): void
public "setCookieCompliance"(arg0: $CookieCompliance$Type): void
public "getCookieCompliance"(): $CookieCompliance
public "getHeaderCacheSize"(): integer
public "getSendServerVersion"(): boolean
public "setSendServerVersion"(arg0: boolean): void
public "getMinRequestDataRate"(): long
get "secureScheme"(): string
get "securePort"(): integer
get "requestHeaderSize"(): integer
get "blockingTimeout"(): long
set "idleTimeout"(value: long)
get "idleTimeout"(): long
get "customizers"(): $List<($HttpConfiguration$Customizer)>
get "sendDateHeader"(): boolean
get "sendXPoweredBy"(): boolean
get "delayDispatchUntilContent"(): boolean
get "persistentConnectionsEnabled"(): boolean
set "blockingTimeout"(value: long)
set "sendXPoweredBy"(value: boolean)
set "sendDateHeader"(value: boolean)
set "secureScheme"(value: string)
set "securePort"(value: integer)
set "headerCacheSize"(value: integer)
set "customizers"(value: $List$Type<($HttpConfiguration$Customizer$Type)>)
get "outputBufferSize"(): integer
get "outputAggregationSize"(): integer
get "responseHeaderSize"(): integer
set "persistentConnectionsEnabled"(value: boolean)
set "delayDispatchUntilContent"(value: boolean)
set "formEncodedMethods"(value: (string)[])
set "outputBufferSize"(value: integer)
set "responseHeaderSize"(value: integer)
set "outputAggregationSize"(value: integer)
get "formEncodedMethods"(): $Set<(string)>
set "requestHeaderSize"(value: integer)
get "maxErrorDispatches"(): integer
set "maxErrorDispatches"(value: integer)
set "minRequestDataRate"(value: long)
set "cookieCompliance"(value: $CookieCompliance$Type)
get "cookieCompliance"(): $CookieCompliance
get "headerCacheSize"(): integer
get "sendServerVersion"(): boolean
set "sendServerVersion"(value: boolean)
get "minRequestDataRate"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HttpConfiguration$Type = ($HttpConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HttpConfiguration_ = $HttpConfiguration$Type;
}}
declare module "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipHttpOutputInterceptor" {
import {$Logger, $Logger$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/log/$Logger"
import {$GzipFactory, $GzipFactory$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/handler/gzip/$GzipFactory"
import {$HttpField, $HttpField$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/http/$HttpField"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$HttpChannel, $HttpChannel$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpChannel"
import {$Callback, $Callback$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/util/$Callback"
import {$HttpOutput$Interceptor, $HttpOutput$Interceptor$Type} from "packages/info/journeymap/shaded/org/eclipse/jetty/server/$HttpOutput$Interceptor"

export class $GzipHttpOutputInterceptor implements $HttpOutput$Interceptor {
static "LOG": $Logger
static readonly "VARY_ACCEPT_ENCODING_USER_AGENT": $HttpField
static readonly "VARY_ACCEPT_ENCODING": $HttpField

constructor(arg0: $GzipFactory$Type, arg1: $HttpChannel$Type, arg2: $HttpOutput$Interceptor$Type, arg3: boolean)
constructor(arg0: $GzipFactory$Type, arg1: $HttpField$Type, arg2: $HttpChannel$Type, arg3: $HttpOutput$Interceptor$Type, arg4: boolean)
constructor(arg0: $GzipFactory$Type, arg1: $HttpField$Type, arg2: integer, arg3: $HttpChannel$Type, arg4: $HttpOutput$Interceptor$Type, arg5: boolean)

public "mightCompress"(): boolean
public "write"(arg0: $ByteBuffer$Type, arg1: boolean, arg2: $Callback$Type): void
public "noCompression"(): void
public "isOptimizedForDirectBuffers"(): boolean
public "getNextInterceptor"(): $HttpOutput$Interceptor
public "noCompressionIfPossible"(): void
public "resetBuffer"(): void
get "optimizedForDirectBuffers"(): boolean
get "nextInterceptor"(): $HttpOutput$Interceptor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GzipHttpOutputInterceptor$Type = ($GzipHttpOutputInterceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GzipHttpOutputInterceptor_ = $GzipHttpOutputInterceptor$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/utils/$MimeParse" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $MimeParse {
static readonly "NO_MIME_TYPE": string


public static "bestMatch"(arg0: $Collection$Type<(string)>, arg1: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MimeParse$Type = ($MimeParse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MimeParse_ = $MimeParse$Type;
}}
declare module "packages/info/journeymap/shaded/kotlin/spark/$Request" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$QueryParamsMap, $QueryParamsMap$Type} from "packages/info/journeymap/shaded/kotlin/spark/$QueryParamsMap"
import {$Session, $Session$Type} from "packages/info/journeymap/shaded/kotlin/spark/$Session"
import {$HttpServletRequest, $HttpServletRequest$Type} from "packages/info/journeymap/shaded/org/javax/servlet/http/$HttpServletRequest"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Request {


public "url"(): string
public "host"(): string
public "port"(): integer
public "uri"(): string
public "params"(): $Map<(string), (string)>
public "params"(arg0: string): string
public "protocol"(): string
public "body"(): string
public "raw"(): $HttpServletRequest
public "scheme"(): string
public "attributes"(): $Set<(string)>
public "attribute"<T>(arg0: string): T
public "attribute"(arg0: string, arg1: any): void
public "contentType"(): string
public "contentLength"(): integer
public "ip"(): string
public "bodyAsBytes"(): (byte)[]
public "queryMap"(): $QueryParamsMap
public "queryMap"(arg0: string): $QueryParamsMap
public "splat"(): (string)[]
public "requestMethod"(): string
public "queryParams"(arg0: string): string
public "queryParams"(): $Set<(string)>
public "queryParamsValues"(arg0: string): (string)[]
public "userAgent"(): string
public "cookies"(): $Map<(string), (string)>
public "cookie"(arg0: string): string
public "headers"(): $Set<(string)>
public "headers"(arg0: string): string
public "contextPath"(): string
public "servletPath"(): string
public "pathInfo"(): string
public "queryString"(): string
public "session"(arg0: boolean): $Session
public "session"(): $Session
public "queryParamOrDefault"(arg0: string, arg1: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Request$Type = ($Request);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Request_ = $Request$Type;
}}
