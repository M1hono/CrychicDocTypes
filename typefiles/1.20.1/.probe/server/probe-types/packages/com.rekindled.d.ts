declare module "packages/com/rekindled/embers/item/$CodebreakingSlateItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CodebreakingSlateItem extends $Item implements $MenuProvider {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getDisplayName"(): $Component
public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "createMenu"(arg0: integer, arg1: $Inventory$Type, arg2: $Player$Type): $AbstractContainerMenu
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodebreakingSlateItem$Type = ($CodebreakingSlateItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodebreakingSlateItem_ = $CodebreakingSlateItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberInjectorBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EmberInjectorBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberInjectorBlock$Type = ($EmberInjectorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberInjectorBlock_ = $EmberInjectorBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$SingleItemContainer" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"

export class $SingleItemContainer implements $Container {
 "stack": $ItemStack

constructor(arg0: $ItemStack$Type)

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
public "getItem"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleItemContainer$Type = ($SingleItemContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleItemContainer_ = $SingleItemContainer$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$MeltingBonusCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $MeltingBonusCategory implements $IRecipeCategory<($IMeltingRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IMeltingRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IMeltingRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IMeltingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IMeltingRecipe$Type): boolean
public "handleInput"(arg0: $IMeltingRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IMeltingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IMeltingRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IMeltingRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingBonusCategory$Type = ($MeltingBonusCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingBonusCategory_ = $MeltingBonusCategory$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$FluidHandlerContext" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $FluidHandlerContext implements $Container {
 "fluid": $IFluidHandler

constructor(arg0: $IFluidHandler$Type)

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
/**
 * 
 * @deprecated
 */
public "getItem"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
/**
 * 
 * @deprecated
 */
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidHandlerContext$Type = ($FluidHandlerContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidHandlerContext_ = $FluidHandlerContext$Type;
}}
declare module "packages/com/rekindled/embers/render/$SneakyBufferSourceWrapper" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$MultiBufferSource$BufferSource, $MultiBufferSource$BufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource$BufferSource"
import {$BufferBuilder, $BufferBuilder$Type} from "packages/com/mojang/blaze3d/vertex/$BufferBuilder"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SneakyBufferSourceWrapper implements $MultiBufferSource {
readonly "buffer": $MultiBufferSource

constructor(arg0: $MultiBufferSource$Type)

public "getBuffer"(arg0: $RenderType$Type): $VertexConsumer
public static "immediateWithBuffers"(layerBuffers: $Map$Type<(any), (any)>, fallbackBuffer: $BufferBuilder$Type): $MultiBufferSource$BufferSource
public static "immediate"(arg0: $BufferBuilder$Type): $MultiBufferSource$BufferSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SneakyBufferSourceWrapper$Type = ($SneakyBufferSourceWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SneakyBufferSourceWrapper_ = $SneakyBufferSourceWrapper$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$DawnstoneAnvilBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IHammerable, $IHammerable$Type} from "packages/com/rekindled/embers/api/tile/$IHammerable"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $DawnstoneAnvilBlockEntity extends $BlockEntity implements $IHammerable {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IDawnstoneAnvilRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "isValid"(): boolean
public "setChanged"(): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "onHit"(arg0: $BlockEntity$Type): void
public "onHit"(): boolean
public "getRenderBoundingBox"(): $AABB
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "valid"(): boolean
get "renderBoundingBox"(): $AABB
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DawnstoneAnvilBlockEntity$Type = ($DawnstoneAnvilBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DawnstoneAnvilBlockEntity_ = $DawnstoneAnvilBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/power/$DefaultEmberItemCapability" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $DefaultEmberItemCapability implements $IEmberCapability {
 "stack": $ItemStack
readonly "capOptional": $LazyOptional<(any)>

constructor(arg0: $ItemStack$Type, arg1: double)

public "invalidate"(): void
public "getEmber"(): double
public "getEmberCapacity"(): double
public "setEmber"(arg0: double): void
public "onContentsChanged"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "removeAmount"(arg0: double, arg1: boolean): double
public "addAmount"(arg0: double, arg1: boolean): double
public "setEmberCapacity"(arg0: double): void
public "writeToNBT"(arg0: $CompoundTag$Type): void
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "acceptsVolatile"(): boolean
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
get "ember"(): double
get "emberCapacity"(): double
set "ember"(value: double)
set "emberCapacity"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultEmberItemCapability$Type = ($DefaultEmberItemCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultEmberItemCapability_ = $DefaultEmberItemCapability$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$StampBaseBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"
import {$StampBaseBlockEntity, $StampBaseBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$StampBaseBlockEntity"

export class $StampBaseBlockEntityRenderer implements $BlockEntityRenderer<($StampBaseBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $StampBaseBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $StampBaseBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $StampBaseBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampBaseBlockEntityRenderer$Type = ($StampBaseBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampBaseBlockEntityRenderer_ = $StampBaseBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$AtmosphericBellowsUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $AtmosphericBellowsUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
public "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: integer, arg4: integer): T
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericBellowsUpgrade$Type = ($AtmosphericBellowsUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericBellowsUpgrade_ = $AtmosphericBellowsUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberActivatorBottomBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberActivatorBottomBlockEntity extends $BlockEntity implements $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "PROCESS_TIME": integer
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IEmberActivationRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberActivatorBottomBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberActivatorBottomBlockEntity$Type): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivatorBottomBlockEntity$Type = ($EmberActivatorBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivatorBottomBlockEntity_ = $EmberActivatorBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$GaseousFuelCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $GaseousFuelCategory implements $IRecipeCategory<($IGaseousFuelRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IGaseousFuelRecipe)>
public "draw"(arg0: $IGaseousFuelRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IGaseousFuelRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IGaseousFuelRecipe$Type): boolean
public "handleInput"(arg0: $IGaseousFuelRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IGaseousFuelRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IGaseousFuelRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IGaseousFuelRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaseousFuelCategory$Type = ($GaseousFuelCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GaseousFuelCategory_ = $GaseousFuelCategory$Type;
}}
declare module "packages/com/rekindled/embers/augment/$CinderJetAugment" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$LivingEvent$LivingTickEvent, $LivingEvent$LivingTickEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingTickEvent"

export class $CinderJetAugment extends $AugmentBase {
static "sprintingClient": $Map<($UUID), (boolean)>
static "sprintingServer": $Map<($UUID), (boolean)>

constructor(arg0: $ResourceLocation$Type)

public static "getSprinting"(arg0: $Level$Type): $Map<($UUID), (boolean)>
public "onLivingTick"(arg0: $LivingEvent$LivingTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CinderJetAugment$Type = ($CinderJetAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CinderJetAugment_ = $CinderJetAugment$Type;
}}
declare module "packages/com/rekindled/embers/block/$ReservoirBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ReservoirBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReservoirBlock$Type = ($ReservoirBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReservoirBlock_ = $ReservoirBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IMeltingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IMeltingRecipe extends $Recipe<($Container)> {

 "process"(arg0: $Container$Type): $FluidStack
 "getDisplayOutput"(): $FluidStack
 "getDisplayInput"(): $Ingredient
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getBonus"(): $FluidStack
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getOutput"(arg0: $Container$Type): $FluidStack
 "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IMeltingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMeltingRecipe$Type = ($IMeltingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMeltingRecipe_ = $IMeltingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/util/$AshenArmorMaterial" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"

export class $AshenArmorMaterial implements $ArmorMaterial {
static readonly "INSTANCE": $AshenArmorMaterial

constructor()

public "getDefenseForType"(arg0: $ArmorItem$Type$Type): integer
public "getEnchantmentValue"(): integer
public "getName"(): string
public "getToughness"(): float
public "getKnockbackResistance"(): float
public "getEquipSound"(): $SoundEvent
public "getRepairIngredient"(): $Ingredient
public "getDurabilityForType"(arg0: $ArmorItem$Type$Type): integer
get "enchantmentValue"(): integer
get "name"(): string
get "toughness"(): float
get "knockbackResistance"(): float
get "equipSound"(): $SoundEvent
get "repairIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AshenArmorMaterial$Type = ($AshenArmorMaterial);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AshenArmorMaterial_ = $AshenArmorMaterial$Type;
}}
declare module "packages/com/rekindled/embers/fluidtypes/$ViscousFluidType" {
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$EmbersFluidType$FluidInfo, $EmbersFluidType$FluidInfo$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$EmbersFluidType, $EmbersFluidType$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $ViscousFluidType extends $EmbersFluidType {
readonly "RENDER_OVERLAY": $ResourceLocation
readonly "TEXTURE_STILL": $ResourceLocation
readonly "TEXTURE_FLOW": $ResourceLocation
readonly "TEXTURE_OVERLAY": $ResourceLocation
readonly "FOG_COLOR": $Vector3f
readonly "fogStart": float
readonly "fogEnd": float
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(arg0: $FluidType$Properties$Type, arg1: $EmbersFluidType$FluidInfo$Type)

public "move"(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
public "initializeClient"(arg0: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
public "setItemMovement"(arg0: $ItemEntity$Type): void
set "itemMovement"(value: $ItemEntity$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViscousFluidType$Type = ($ViscousFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViscousFluidType_ = $ViscousFluidType$Type;
}}
declare module "packages/com/rekindled/embers/util/$FilterUtil" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IFilterComparator, $IFilterComparator$Type} from "packages/com/rekindled/embers/api/filter/$IFilterComparator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $FilterUtil {
static "ANY": $IFilterComparator
static "FILTER_ANY": $IFilter
static "FILTER_EXISTING": $IFilter
static "FILTER_NOT_EXISTING": $IFilter

constructor()

public static "registerComparator"(arg0: $IFilterComparator$Type): void
public static "deserializeFilter"(arg0: $CompoundTag$Type): $IFilter
public static "registerFilter"(arg0: $IFilter$Type): void
public static "registerFilter"(arg0: $ResourceLocation$Type, arg1: $Function$Type<($CompoundTag$Type), ($IFilter$Type)>): void
public static "getComparator"(arg0: string): $IFilterComparator
public static "getComparators"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $List<($IFilterComparator)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterUtil$Type = ($FilterUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterUtil_ = $FilterUtil$Type;
}}
declare module "packages/com/rekindled/embers/$RegistryManager$MetalCrystalSeed" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$CrystalSeedBlockEntity, $CrystalSeedBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CrystalSeedBlockEntity"

export class $RegistryManager$MetalCrystalSeed {
static "seeds": $HashMap<(string), ($RegistryManager$MetalCrystalSeed)>
 "name": string
readonly "BLOCK": $RegistryObject<($Block)>
 "ITEM": $RegistryObject<($Item)>
readonly "BLOCKENTITY": $RegistryObject<($BlockEntityType<($CrystalSeedBlockEntity)>)>

constructor(arg0: string)

public "makeItem"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$MetalCrystalSeed$Type = ($RegistryManager$MetalCrystalSeed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager$MetalCrystalSeed_ = $RegistryManager$MetalCrystalSeed$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemDialBlock" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$DialBaseBlock, $DialBaseBlock$Type} from "packages/com/rekindled/embers/block/$DialBaseBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $ItemDialBlock extends $DialBaseBlock {
static readonly "DIAL_TYPE": string
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getDialType"(): string
public static "formatItemStack"(arg0: $ItemStack$Type): $MutableComponent
public "hasAnalogOutputSignal"(arg0: $BlockState$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): integer
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "dialType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDialBlock$Type = ($ItemDialBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDialBlock_ = $ItemDialBlock$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$CharInstillerUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $CharInstillerUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
public "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: integer, arg4: integer): T
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharInstillerUpgrade$Type = ($CharInstillerUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharInstillerUpgrade_ = $CharInstillerUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GemSocketRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$GemSocketRecipe, $GemSocketRecipe$Type} from "packages/com/rekindled/embers/recipe/$GemSocketRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $GemSocketRecipe$Serializer implements $RecipeSerializer<($GemSocketRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $GemSocketRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $GemSocketRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $GemSocketRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $GemSocketRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemSocketRecipe$Serializer$Type = ($GemSocketRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemSocketRecipe$Serializer_ = $GemSocketRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoilingRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$BoilingRecipe, $BoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoilingRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $BoilingRecipe$Serializer implements $RecipeSerializer<($BoilingRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $BoilingRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $BoilingRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $BoilingRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $BoilingRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilingRecipe$Serializer$Type = ($BoilingRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilingRecipe$Serializer_ = $BoilingRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageResearchTick" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageResearchTick {
static readonly "NAME_MAX_LENGTH": integer
 "research": string
 "ticked": boolean

constructor(arg0: string, arg1: boolean)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageResearchTick
public static "encode"(arg0: $MessageResearchTick$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageResearchTick$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageResearchTick$Type = ($MessageResearchTick);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageResearchTick_ = $MessageResearchTick$Type;
}}
declare module "packages/com/rekindled/embers/block/$HeatInsulationBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $HeatInsulationBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatInsulationBlock$Type = ($HeatInsulationBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatInsulationBlock_ = $HeatInsulationBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IInflictorGemHolder" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $IInflictorGemHolder {

 "getAttachedGemCount"(arg0: $ItemStack$Type): integer
 "getTotalDamageResistance"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $ItemStack$Type): float
 "attachGem"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer): void
 "getGemSlots"(arg0: $ItemStack$Type): integer
 "getAttachedGems"(arg0: $ItemStack$Type): ($ItemStack)[]
 "canAttachGem"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "clearGems"(arg0: $ItemStack$Type): void
 "detachGem"(arg0: $ItemStack$Type, arg1: integer): $ItemStack
}

export namespace $IInflictorGemHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInflictorGemHolder$Type = ($IInflictorGemHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInflictorGemHolder_ = $IInflictorGemHolder$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemExtractorBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IOrderDestination, $IOrderDestination$Type} from "packages/com/rekindled/embers/api/tile/$IOrderDestination"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$OrderStack, $OrderStack$Type} from "packages/com/rekindled/embers/api/tile/$OrderStack"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemPipeBlockEntityBase, $ItemPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntityBase"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $ItemExtractorBlockEntity extends $ItemPipeBlockEntityBase implements $IOrderDestination {
static "FILTER_ANY": $IFilter
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "order"(arg0: $BlockEntity$Type, arg1: $IFilter$Type, arg2: integer): void
public "getCapacity"(): integer
public "getOrder"(arg0: $BlockEntity$Type): $OrderStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemExtractorBlockEntity$Type): void
public "resetOrder"(arg0: $BlockEntity$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemExtractorBlockEntity$Type = ($ItemExtractorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemExtractorBlockEntity_ = $ItemExtractorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageScalesData" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageScalesData {
 "scales": integer

constructor(arg0: double)
constructor(arg0: integer)
constructor()

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageScalesData
public static "encode"(arg0: $MessageScalesData$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageScalesData$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageScalesData$Type = ($MessageScalesData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageScalesData_ = $MessageScalesData$Type;
}}
declare module "packages/com/rekindled/embers/block/$PressureRefineryBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PressureRefineryBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressureRefineryBlock$Type = ($PressureRefineryBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressureRefineryBlock_ = $PressureRefineryBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$MechanicalCoreBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $MechanicalCoreBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onNeighborChange"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCoreBlock$Type = ($MechanicalCoreBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalCoreBlock_ = $MechanicalCoreBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $PipeBlockEntityBase extends $BlockEntity {
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "getConnection"(arg0: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "setChanged"(): void
public "setConnection"(arg0: $Direction$Type, arg1: $PipeBlockEntityBase$PipeConnection$Type): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $PipeBlockEntityBase$Type): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "initConnections"(): void
public "setConnections"(arg0: ($PipeBlockEntityBase$PipeConnection$Type)[]): void
public "resetFrom"(): void
public "setFrom"(arg0: $Direction$Type, arg1: boolean): void
public "writeConnections"(arg0: $CompoundTag$Type): void
public "writeCloggedFlag"(arg0: $CompoundTag$Type): void
public "loadConnections"(arg0: $CompoundTag$Type): void
public "writeLastTransfer"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
public "getModelData"(): $ModelData
set "connections"(value: ($PipeBlockEntityBase$PipeConnection$Type)[])
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockEntityBase$Type = ($PipeBlockEntityBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockEntityBase_ = $PipeBlockEntityBase$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$EmberBoreBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$EmberBoreBlockEntity, $EmberBoreBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $EmberBoreBlockEntityRenderer implements $BlockEntityRenderer<($EmberBoreBlockEntity)> {
static "blades": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $EmberBoreBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $EmberBoreBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $EmberBoreBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreBlockEntityRenderer$Type = ($EmberBoreBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreBlockEntityRenderer_ = $EmberBoreBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CreativeEmberBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CreativeEmberBlockEntity extends $BlockEntity {
 "capability": $IEmberCapability
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeEmberBlockEntity$Type = ($CreativeEmberBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeEmberBlockEntity_ = $CreativeEmberBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/gui/$SlateMenu" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $SlateMenu extends $AbstractContainerMenu {
static "slateHeight": integer
static "slateWidth": integer
static "slateMargin": integer
static "invHeight": integer
static "invWidth": integer
static "slotHeight": integer
static "slotCount": integer
static "layerHeight": integer
static "layerWidth": integer
 "inventory": $ItemStackHandler
 "slate": $ItemStack
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(arg0: integer, arg1: $Inventory$Type, arg2: $ItemStack$Type)

public "stillValid"(arg0: $Player$Type): boolean
public "removed"(arg0: $Player$Type): void
public static "fromBuffer"(arg0: integer, arg1: $Inventory$Type, arg2: $FriendlyByteBuf$Type): $SlateMenu
public "clicked"(arg0: integer, arg1: integer, arg2: $ClickType$Type, arg3: $Player$Type): void
public "quickMoveStack"(arg0: $Player$Type, arg1: integer): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlateMenu$Type = ($SlateMenu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlateMenu_ = $SlateMenu$Type;
}}
declare module "packages/com/rekindled/embers/api/upgrades/$IUpgradeUtil" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IUpgradeUtil {

 "getTotalEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
 "getTotalEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
 "getTotalSpeedModifier"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): double
 "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
 "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>): void
 "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>, arg4: integer): void
 "verifyUpgrades"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): void
 "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
 "getWorkTime"(arg0: $BlockEntity$Type, arg1: integer, arg2: $List$Type<($UpgradeContext$Type)>): integer
 "throwEvent"(arg0: $BlockEntity$Type, arg1: $UpgradeEvent$Type, arg2: $List$Type<($UpgradeContext$Type)>): void
 "transformOutput"(arg0: $BlockEntity$Type, arg1: $FluidStack$Type, arg2: $List$Type<($UpgradeContext$Type)>): $FluidStack
 "transformOutput"(arg0: $BlockEntity$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: $List$Type<($UpgradeContext$Type)>): void
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: integer, arg3: $List$Type<($UpgradeContext$Type)>): integer
 "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: $List$Type<($UpgradeContext$Type)>): T
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: string, arg3: $List$Type<($UpgradeContext$Type)>): string
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: boolean, arg3: $List$Type<($UpgradeContext$Type)>): boolean
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: $List$Type<($UpgradeContext$Type)>): double
 "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[]): $List<($UpgradeContext)>
 "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[], arg3: $List$Type<($UpgradeContext$Type)>): void
}

export namespace $IUpgradeUtil {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeUtil$Type = ($IUpgradeUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeUtil_ = $IUpgradeUtil$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$WildfireStirlingUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $WildfireStirlingUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public static "getMultiplier"(arg0: double, arg1: integer, arg2: integer): double
public "transformEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "getLimit"(arg0: $BlockEntity$Type): integer
public "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
public static "registerBlacklistedTile"(arg0: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WildfireStirlingUpgrade$Type = ($WildfireStirlingUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WildfireStirlingUpgrade_ = $WildfireStirlingUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$FilterSieve" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$EnumFilterSetting, $EnumFilterSetting$Type} from "packages/com/rekindled/embers/api/filter/$EnumFilterSetting"

export class $FilterSieve implements $IFilter {
static readonly "RESOURCE_LOCATION": $ResourceLocation

constructor(arg0: $CompoundTag$Type)
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $EnumFilterSetting$Type, arg4: boolean)

public "equals"(arg0: any): boolean
public "getType"(): $ResourceLocation
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "formatFilter"(): string
public "acceptsItem"(arg0: $ItemStack$Type): boolean
public "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterSieve$Type = ($FilterSieve);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterSieve_ = $FilterSieve$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemDialBlockEntity" {
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IDialEntity, $IDialEntity$Type} from "packages/com/rekindled/embers/api/tile/$IDialEntity"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ItemDialBlockEntity extends $BlockEntity implements $IDialEntity {
 "itemStacks": ($ItemStack)[]
 "extraLines": integer
 "display": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getUpdatePacket"(arg0: integer): $Packet<($ClientGamePacketListener)>
public "load"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(arg0: integer): $CompoundTag
public "getUpdateTag"(): $CompoundTag
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDialBlockEntity$Type = ($ItemDialBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDialBlockEntity_ = $ItemDialBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CatalysisCombustionRecipe, $CatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $CatalysisCombustionRecipeBuilder {
 "id": $ResourceLocation
 "ingredient": $Ingredient
 "machine": $Ingredient
 "burnTime": integer
 "multiplier": double

constructor()

public "id"(arg0: $ResourceLocation$Type): $CatalysisCombustionRecipeBuilder
public "domain"(arg0: string): $CatalysisCombustionRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $Ingredient$Type): $CatalysisCombustionRecipeBuilder
public static "create"(arg0: $TagKey$Type<($Item$Type)>): $CatalysisCombustionRecipeBuilder
public static "create"(arg0: $ItemStack$Type): $CatalysisCombustionRecipeBuilder
public static "create"(arg0: $Item$Type): $CatalysisCombustionRecipeBuilder
public "build"(): $CatalysisCombustionRecipe
public "multiplier"(arg0: double): $CatalysisCombustionRecipeBuilder
public "burnTime"(arg0: integer): $CatalysisCombustionRecipeBuilder
public "folder"(arg0: string): $CatalysisCombustionRecipeBuilder
public "combustion"(): $CatalysisCombustionRecipeBuilder
public "catalysis"(): $CatalysisCombustionRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisCombustionRecipeBuilder$Type = ($CatalysisCombustionRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisCombustionRecipeBuilder_ = $CatalysisCombustionRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IOrderSource" {
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export interface $IOrderSource {

 "getItemHandler"(): $IItemHandler

(): $IItemHandler
}

export namespace $IOrderSource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOrderSource$Type = ($IOrderSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOrderSource_ = $IOrderSource$Type;
}}
declare module "packages/com/rekindled/embers/render/$PipeModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $PipeModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $PipeModelBuilder<(T)>
public "parts"(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T): $PipeModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeModelBuilder$Type<T> = ($PipeModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeModelBuilder_<T> = $PipeModelBuilder$Type<(T)>;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteGaugeEdgeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $CaminiteGaugeEdgeBlock extends $MechEdgeBlockBase {
static readonly "X_AABB": $VoxelShape
static readonly "Z_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteGaugeEdgeBlock$Type = ($CaminiteGaugeEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteGaugeEdgeBlock_ = $CaminiteGaugeEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$UpgradeEvent" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export class $UpgradeEvent {

constructor(arg0: $BlockEntity$Type)

public "getTile"(): $BlockEntity
get "tile"(): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeEvent$Type = ($UpgradeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeEvent_ = $UpgradeEvent$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemPipeBlockEntityBase, $ItemPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntityBase"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $ItemPipeBlockEntity extends $ItemPipeBlockEntityBase {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemPipeBlockEntity$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeBlockEntity$Type = ($ItemPipeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeBlockEntity_ = $ItemPipeBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/power/$IEmberPacketProducer" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IEmberPacketProducer {

 "setTargetPosition"(arg0: $BlockPos$Type, arg1: $Direction$Type): void
 "getEmittingDirection"(arg0: $Direction$Type): $Direction
}

export namespace $IEmberPacketProducer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberPacketProducer$Type = ($IEmberPacketProducer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberPacketProducer_ = $IEmberPacketProducer$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageEmberGenOffset" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageEmberGenOffset {
 "offX": integer
 "offZ": integer

constructor()
constructor(arg0: integer, arg1: integer)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageEmberGenOffset
public static "encode"(arg0: $MessageEmberGenOffset$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageEmberGenOffset$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageEmberGenOffset$Type = ($MessageEmberGenOffset);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageEmberGenOffset_ = $MessageEmberGenOffset$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$CatalyticPlugBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"
import {$CatalyticPlugBlockEntity, $CatalyticPlugBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CatalyticPlugBlockEntity"

export class $CatalyticPlugBlockEntityRenderer implements $BlockEntityRenderer<($CatalyticPlugBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CatalyticPlugBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $CatalyticPlugBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CatalyticPlugBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalyticPlugBlockEntityRenderer$Type = ($CatalyticPlugBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalyticPlugBlockEntityRenderer_ = $CatalyticPlugBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/research/subtypes/$ResearchShowItem" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$GuiCodex, $GuiCodex$Type} from "packages/com/rekindled/embers/gui/$GuiCodex"
import {$Vec2i, $Vec2i$Type} from "packages/com/rekindled/embers/util/$Vec2i"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResearchShowItem$DisplayItem, $ResearchShowItem$DisplayItem$Type} from "packages/com/rekindled/embers/research/subtypes/$ResearchShowItem$DisplayItem"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ResearchShowItem extends $ResearchBase {
 "name": string
 "u": double
 "v": double
 "icon": $ItemStack
 "x": integer
 "y": integer
 "ancestors": $List<($ResearchBase)>
 "subCategory": $ResearchBase
 "iconBackground": $ResourceLocation
 "background": $ResourceLocation
 "firstPage": $ResearchBase
 "pageNumber": integer
 "selectedAmount": float
 "selectionTarget": float
 "shownAmount": float
 "shownTarget": float
 "checked": boolean

constructor(arg0: string, arg1: $ItemStack$Type, arg2: double, arg3: double)
constructor(arg0: string, arg1: $ItemStack$Type, arg2: $Vec2i$Type)

public "getLines"(arg0: $Font$Type, arg1: $FormattedText$Type, arg2: integer): $List<($FormattedCharSequence)>
public "addItem"(arg0: $ResearchShowItem$DisplayItem$Type): $ResearchShowItem
public "renderPageContent"(arg0: $GuiGraphics$Type, arg1: $GuiCodex$Type, arg2: integer, arg3: integer, arg4: $Font$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchShowItem$Type = ($ResearchShowItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchShowItem_ = $ResearchShowItem$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilRepairRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$AnvilRepairRecipe, $AnvilRepairRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $AnvilRepairRecipe$Serializer implements $RecipeSerializer<($AnvilRepairRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AnvilRepairRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AnvilRepairRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AnvilRepairRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AnvilRepairRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilRepairRecipe$Serializer$Type = ($AnvilRepairRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilRepairRecipe$Serializer_ = $AnvilRepairRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/augment/$FocalLensAugment" {
import {$EmberProjectileEvent, $EmberProjectileEvent$Type} from "packages/com/rekindled/embers/api/event/$EmberProjectileEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $FocalLensAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onProjectileFire"(arg0: $EmberProjectileEvent$Type): void
public static "isPVPEnabled"(arg0: $Level$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FocalLensAugment$Type = ($FocalLensAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FocalLensAugment_ = $FocalLensAugment$Type;
}}
declare module "packages/com/rekindled/embers/research/$ResearchBase" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiCodex, $GuiCodex$Type} from "packages/com/rekindled/embers/gui/$GuiCodex"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$Vec2i, $Vec2i$Type} from "packages/com/rekindled/embers/util/$Vec2i"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchCategory, $ResearchCategory$Type} from "packages/com/rekindled/embers/research/$ResearchCategory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ResearchBase {
 "name": string
 "u": double
 "v": double
 "icon": $ItemStack
 "x": integer
 "y": integer
 "ancestors": $List<($ResearchBase)>
 "subCategory": $ResearchBase
 "iconBackground": $ResourceLocation
 "background": $ResourceLocation
 "firstPage": $ResearchBase
 "pageNumber": integer
 "selectedAmount": float
 "selectionTarget": float
 "shownAmount": float
 "shownTarget": float
 "checked": boolean

constructor(arg0: string, arg1: $ItemStack$Type, arg2: double, arg3: double)
constructor(arg0: string, arg1: $ItemStack$Type, arg2: $Vec2i$Type)

public "getName"(): string
public "isHidden"(): boolean
public "check"(arg0: boolean): void
public "onClose"(arg0: $GuiCodex$Type): boolean
public "getText"(): $Component
public "areAncestorsChecked"(): boolean
public "getLines"(arg0: $Font$Type, arg1: $FormattedText$Type, arg2: integer): $List<($FormattedCharSequence)>
public "getPages"(): $List<($ResearchBase)>
public "getPreviousPage"(): $ResearchBase
public "getNextPage"(): $ResearchBase
public "getIcon"(): $ItemStack
public "getAllRequirements"(): $List<($ResearchBase)>
public "setIconBackground"(arg0: $ResourceLocation$Type, arg1: double, arg2: double): $ResearchBase
public "getNeededFor"(): $List<($ResearchCategory)>
public "findByTag"(arg0: string, arg1: $Map$Type<($ResearchBase$Type), (integer)>, arg2: $Set$Type<($ResearchCategory$Type)>): void
public "matchTags"(arg0: string): integer
public "renderPageContent"(arg0: $GuiGraphics$Type, arg1: $GuiCodex$Type, arg2: integer, arg3: integer, arg4: $Font$Type): void
public "hasMultiplePages"(): boolean
public "getIconBackground"(): $ResourceLocation
public "getIconBackgroundV"(): double
public "getFirstPage"(): $ResearchBase
public "isPathTowards"(arg0: $ResearchBase$Type): boolean
public "isChecked"(): boolean
public "getIconBackgroundU"(): double
public "getPageCount"(): integer
public "getAllResearch"(arg0: $Set$Type<($ResearchBase$Type)>): void
public "onOpen"(arg0: $GuiCodex$Type): boolean
public "getTooltip"(arg0: boolean): $List<($Component)>
public "getTitle"(): string
public "getBackground"(): $ResourceLocation
public "setBackground"(arg0: $ResourceLocation$Type): $ResearchBase
public "getPage"(arg0: integer): $ResearchBase
public "addPage"(arg0: $ResearchBase$Type): $ResearchBase
public "addAncestor"(arg0: $ResearchBase$Type): $ResearchBase
get "name"(): string
get "hidden"(): boolean
get "text"(): $Component
get "pages"(): $List<($ResearchBase)>
get "previousPage"(): $ResearchBase
get "nextPage"(): $ResearchBase
get "icon"(): $ItemStack
get "allRequirements"(): $List<($ResearchBase)>
get "neededFor"(): $List<($ResearchCategory)>
get "iconBackground"(): $ResourceLocation
get "iconBackgroundV"(): double
get "firstPage"(): $ResearchBase
get "checked"(): boolean
get "iconBackgroundU"(): double
get "pageCount"(): integer
get "title"(): string
get "background"(): $ResourceLocation
set "background"(value: $ResourceLocation$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchBase$Type = ($ResearchBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchBase_ = $ResearchBase$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MixerCentrifugeBottomBlockEntity" {
import {$IMixingRecipe, $IMixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMixingRecipe"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMechanicallyPowered, $IMechanicallyPowered$Type} from "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$MixerCentrifugeBottomBlockEntity$MixerFluidTank, $MixerCentrifugeBottomBlockEntity$MixerFluidTank$Type} from "packages/com/rekindled/embers/blockentity/$MixerCentrifugeBottomBlockEntity$MixerFluidTank"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MixerCentrifugeBottomBlockEntity extends $BlockEntity implements $IMechanicallyPowered, $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "EMBER_COST": double
 "north": $MixerCentrifugeBottomBlockEntity$MixerFluidTank
 "south": $MixerCentrifugeBottomBlockEntity$MixerFluidTank
 "east": $MixerCentrifugeBottomBlockEntity$MixerFluidTank
 "west": $MixerCentrifugeBottomBlockEntity$MixerFluidTank
 "tanks": ($MixerCentrifugeBottomBlockEntity$MixerFluidTank)[]
 "loaded": boolean
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "cachedRecipe": $IMixingRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MixerCentrifugeBottomBlockEntity$Type): void
public "getStandardPowerRatio"(): double
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MixerCentrifugeBottomBlockEntity$Type): void
public "getTanks"(): ($MixerCentrifugeBottomBlockEntity$MixerFluidTank)[]
public "playSound"(arg0: integer): void
public "getMechanicalSpeed"(arg0: double): double
public "getMinimumPower"(): double
public "getNominalSpeed"(): double
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getMaximumPower"(): double
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "standardPowerRatio"(): double
get "soundIDs"(): (integer)[]
get "tanks"(): ($MixerCentrifugeBottomBlockEntity$MixerFluidTank)[]
get "minimumPower"(): double
get "nominalSpeed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "maximumPower"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeBottomBlockEntity$Type = ($MixerCentrifugeBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeBottomBlockEntity_ = $MixerCentrifugeBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EmbersFluidType$FluidInfo {
 "name": string
 "color": integer
 "fogStart": float
 "fogEnd": float

constructor(arg0: string, arg1: integer, arg2: float, arg3: float)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersFluidType$FluidInfo$Type = ($EmbersFluidType$FluidInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersFluidType$FluidInfo_ = $EmbersFluidType$FluidInfo$Type;
}}
declare module "packages/com/rekindled/embers/block/$MixerCentrifugeBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MixerCentrifugeBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeBlock$Type = ($MixerCentrifugeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeBlock_ = $MixerCentrifugeBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$InfernoForgeBottomBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $InfernoForgeBottomBlockEntity extends $BlockEntity implements $IExtraDialInformation, $ISoundController {
static "EMBER_COST": double
static "MAX_LEVEL": integer
static "MAX_CRYSTAL_VALUE": double
static "CHANCE_MIDPOINT": double
static "PROCESS_TIME": integer
 "capability": $IEmberCapability
 "progress": integer
 "emberValue": double
 "cachedEmberRecipe": $IEmberActivationRecipe
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "updateProgress"(): void
public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $InfernoForgeBottomBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $InfernoForgeBottomBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfernoForgeBottomBlockEntity$Type = ($InfernoForgeBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfernoForgeBottomBlockEntity_ = $InfernoForgeBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$ComparatorNormal" {
import {$IFilterComparator, $IFilterComparator$Type} from "packages/com/rekindled/embers/api/filter/$IFilterComparator"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnumFilterSetting, $EnumFilterSetting$Type} from "packages/com/rekindled/embers/api/filter/$EnumFilterSetting"

export class $ComparatorNormal implements $IFilterComparator {

constructor(arg0: string, arg1: integer)

public "getName"(): string
public "getPriority"(): integer
public "format"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $EnumFilterSetting$Type, arg3: boolean): string
public "match"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public "isBetween"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $EnumFilterSetting$Type): boolean
public "getCompare"(arg0: $ItemStack$Type): integer
get "name"(): string
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorNormal$Type = ($ComparatorNormal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparatorNormal_ = $ComparatorNormal$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CatalyticPlugBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$CatalyticPlugUpgrade, $CatalyticPlugUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$CatalyticPlugUpgrade"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CatalyticPlugBlockEntity extends $BlockEntity implements $ISoundController, $IExtraCapabilityInformation {
static readonly "SOUND_OFF": integer
static readonly "SOUND_ON": integer
static readonly "SOUND_IDS": (integer)[]
 "renderOffset": float
 "activeTicks": integer
 "burnTime": integer
 "upgrade": $CatalyticPlugUpgrade
 "tank": $FluidTank
 "cachedRecipe": $IGaseousFuelRecipe
 "holder": $LazyOptional<($IFluidHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "setActive"(arg0: integer): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CatalyticPlugBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CatalyticPlugBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
set "active"(value: integer)
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalyticPlugBlockEntity$Type = ($CatalyticPlugBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalyticPlugBlockEntity_ = $CatalyticPlugBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$HeatInsulationBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$HeatInsulationUpgrade, $HeatInsulationUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$HeatInsulationUpgrade"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $HeatInsulationBlockEntity extends $BlockEntity {
 "upgrade": $HeatInsulationUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatInsulationBlockEntity$Type = ($HeatInsulationBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatInsulationBlockEntity_ = $HeatInsulationBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersItemModels" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ItemModelProvider, $ItemModelProvider$Type} from "packages/net/minecraftforge/client/model/generators/$ItemModelProvider"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$RegistryManager$ToolSet, $RegistryManager$ToolSet$Type} from "packages/com/rekindled/embers/$RegistryManager$ToolSet"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmbersItemModels extends $ItemModelProvider {
static readonly "BLOCK_FOLDER": string
static readonly "ITEM_FOLDER": string
readonly "generatedModels": $Map<($ResourceLocation), (T)>
readonly "existingFileHelper": $ExistingFileHelper

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type)

public "spawnEgg"(arg0: $RegistryObject$Type<(any)>): void
public "layeredItem"(arg0: $RegistryObject$Type<(any)>, arg1: string, ...arg2: (string)[]): void
public "bucketModel"(arg0: $RegistryObject$Type<(any)>, arg1: $Fluid$Type): void
public "itemWithTexture"(arg0: $RegistryObject$Type<(any)>, arg1: string, arg2: string): void
public "itemWithTexture"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "itemWithModel"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "toolModels"(arg0: $RegistryManager$ToolSet$Type): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersItemModels$Type = ($EmbersItemModels);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersItemModels_ = $EmbersItemModels$Type;
}}
declare module "packages/com/rekindled/embers/item/$ClockworkAxeItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ClockworkToolItem, $ClockworkToolItem$Type} from "packages/com/rekindled/embers/item/$ClockworkToolItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ClockworkAxeItem extends $ClockworkToolItem {
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "canPerformAction"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
public "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkAxeItem$Type = ($ClockworkAxeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkAxeItem_ = $ClockworkAxeItem$Type;
}}
declare module "packages/com/rekindled/embers/model/$AshenArmorModel" {
import {$HumanoidModel, $HumanoidModel$Type} from "packages/net/minecraft/client/model/$HumanoidModel"
import {$HumanoidModel$ArmPose, $HumanoidModel$ArmPose$Type} from "packages/net/minecraft/client/model/$HumanoidModel$ArmPose"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ModelPart, $ModelPart$Type} from "packages/net/minecraft/client/model/geom/$ModelPart"
import {$MeshDefinition, $MeshDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$MeshDefinition"
import {$CubeDeformation, $CubeDeformation$Type} from "packages/net/minecraft/client/model/geom/builders/$CubeDeformation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AshenArmorModel extends $HumanoidModel<($LivingEntity)> {
static readonly "ASHEN_ARMOR_HEAD": $ModelLayerLocation
static readonly "ASHEN_ARMOR_CHEST": $ModelLayerLocation
static readonly "ASHEN_ARMOR_LEGS": $ModelLayerLocation
static readonly "ASHEN_ARMOR_FEET": $ModelLayerLocation
static readonly "ARMOR_MODELS": $Map<($EquipmentSlot), ($AshenArmorModel)>
static readonly "ARMOR_MODEL_GETTER": $IClientItemExtensions
static "scale": $CubeDeformation
 "velocity": double
 "cape": $ModelPart
 "gems": ($ModelPart)[]
static readonly "OVERLAY_SCALE": float
static readonly "HAT_OVERLAY_SCALE": float
static readonly "LEGGINGS_OVERLAY_SCALE": float
static readonly "TOOT_HORN_XROT_BASE": float
static readonly "TOOT_HORN_YROT_BASE": float
readonly "head": $ModelPart
readonly "hat": $ModelPart
readonly "body": $ModelPart
readonly "rightArm": $ModelPart
readonly "leftArm": $ModelPart
readonly "rightLeg": $ModelPart
readonly "leftLeg": $ModelPart
 "leftArmPose": $HumanoidModel$ArmPose
 "rightArmPose": $HumanoidModel$ArmPose
 "crouching": boolean
 "swimAmount": float
readonly "scaleHead": boolean
readonly "babyYHeadOffset": float
readonly "babyZHeadOffset": float
readonly "babyHeadScale": float
readonly "babyBodyScale": float
readonly "bodyYOffset": float
 "attackTime": float
 "riding": boolean
 "young": boolean

constructor(arg0: $ModelPart$Type, arg1: $EquipmentSlot$Type)

public static "init"(arg0: $EntityRendererProvider$Context$Type): void
public "setup"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public static "createChestMesh"(): $MeshDefinition
public static "createFeetMesh"(): $MeshDefinition
public static "createLegsMesh"(): $MeshDefinition
public static "createHeadMesh"(): $MeshDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AshenArmorModel$Type = ($AshenArmorModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AshenArmorModel_ = $AshenArmorModel$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MithrilBlockEntity" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MithrilBlockEntity extends $BlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MithrilBlockEntity$Type = ($MithrilBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MithrilBlockEntity_ = $MithrilBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$AncientCodexItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AncientCodexItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AncientCodexItem$Type = ($AncientCodexItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AncientCodexItem_ = $AncientCodexItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberLanternBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $EmberLanternBlock extends $Block implements $SimpleWaterloggedBlock {
static readonly "EMBER": $GlowParticleOptions
static readonly "LANTERN_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberLanternBlock$Type = ($EmberLanternBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberLanternBlock_ = $EmberLanternBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$GeologicSeparatorBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$GeologicSeparatorBlockEntity, $GeologicSeparatorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$GeologicSeparatorBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $GeologicSeparatorBlockEntityRenderer implements $BlockEntityRenderer<($GeologicSeparatorBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $GeologicSeparatorBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $GeologicSeparatorBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $GeologicSeparatorBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeologicSeparatorBlockEntityRenderer$Type = ($GeologicSeparatorBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeologicSeparatorBlockEntityRenderer_ = $GeologicSeparatorBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$ScaleEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ScaleEvent extends $Event {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: float, arg2: $DamageSource$Type, arg3: double, arg4: double)

public "isCancelable"(): boolean
public "setScalePassRate"(arg0: double): void
public "getScaleDamageRate"(): double
public "setScaleDamageRate"(arg0: double): void
public "getScalePassRate"(): double
public "getDamageSource"(): $DamageSource
public "getEntity"(): $LivingEntity
public "getDamage"(): double
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
set "scalePassRate"(value: double)
get "scaleDamageRate"(): double
set "scaleDamageRate"(value: double)
get "scalePassRate"(): double
get "damageSource"(): $DamageSource
get "entity"(): $LivingEntity
get "damage"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScaleEvent$Type = ($ScaleEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScaleEvent_ = $ScaleEvent$Type;
}}
declare module "packages/com/rekindled/embers/augment/$ShiftingScalesAugment$ShardParticle" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ShiftingScalesAugment$ShardParticle {

constructor(arg0: double, arg1: double, arg2: integer, arg3: double, arg4: double, arg5: double)

public "update"(): void
public "getY"(): double
public "getX"(): double
public "getFrame"(): integer
get "y"(): double
get "x"(): double
get "frame"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShiftingScalesAugment$ShardParticle$Type = ($ShiftingScalesAugment$ShardParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShiftingScalesAugment$ShardParticle_ = $ShiftingScalesAugment$ShardParticle$Type;
}}
declare module "packages/com/rekindled/embers/block/$StamperBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $StamperBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StamperBlock$Type = ($StamperBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StamperBlock_ = $StamperBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MixingRecipe$Serializer" {
import {$MixingRecipe, $MixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MixingRecipe"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $MixingRecipe$Serializer implements $RecipeSerializer<($MixingRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $MixingRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $MixingRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $MixingRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $MixingRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixingRecipe$Serializer$Type = ($MixingRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixingRecipe$Serializer_ = $MixingRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteGaugeBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CaminiteGaugeBlock extends $Block implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteGaugeBlock$Type = ($CaminiteGaugeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteGaugeBlock_ = $CaminiteGaugeBlock$Type;
}}
declare module "packages/com/rekindled/embers/augment/$IntelligentApparatusAugment" {
import {$LivingExperienceDropEvent, $LivingExperienceDropEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingExperienceDropEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $IntelligentApparatusAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onXPDrop"(arg0: $LivingExperienceDropEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntelligentApparatusAugment$Type = ($IntelligentApparatusAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntelligentApparatusAugment_ = $IntelligentApparatusAugment$Type;
}}
declare module "packages/com/rekindled/embers/item/$GlimmerCrystalItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $GlimmerCrystalItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "place"(arg0: $BlockPlaceContext$Type): $InteractionResult
public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "getBarColor"(arg0: $ItemStack$Type): integer
public "isBarVisible"(arg0: $ItemStack$Type): boolean
public "inventoryTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Entity$Type, arg3: integer, arg4: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlimmerCrystalItem$Type = ($GlimmerCrystalItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlimmerCrystalItem_ = $GlimmerCrystalItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteRingEdgeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $CaminiteRingEdgeBlock extends $MechEdgeBlockBase {
static readonly "X_AABB": $VoxelShape
static readonly "Z_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteRingEdgeBlock$Type = ($CaminiteRingEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteRingEdgeBlock_ = $CaminiteRingEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$FluidDialBlock" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$DialBaseBlock, $DialBaseBlock$Type} from "packages/com/rekindled/embers/block/$DialBaseBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $FluidDialBlock extends $DialBaseBlock {
static readonly "DIAL_TYPE": string
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getDialType"(): string
public static "formatFluidStack"(arg0: $FluidStack$Type, arg1: integer): $MutableComponent
public "hasAnalogOutputSignal"(arg0: $BlockState$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): integer
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "dialType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDialBlock$Type = ($FluidDialBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDialBlock_ = $FluidDialBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IHammerable" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export interface $IHammerable {

 "isValid"(): boolean
 "onHit"(arg0: $BlockEntity$Type): void

(): boolean
}

export namespace $IHammerable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHammerable$Type = ($IHammerable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHammerable_ = $IHammerable$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipeBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MetalCoefficientRecipe, $MetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MetalCoefficientRecipeBuilder {
 "id": $ResourceLocation
 "blockTag": $ResourceLocation
 "coefficient": double

constructor()

public "id"(arg0: $ResourceLocation$Type): $MetalCoefficientRecipeBuilder
public "domain"(arg0: string): $MetalCoefficientRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $TagKey$Type<($Block$Type)>): $MetalCoefficientRecipeBuilder
public static "create"(arg0: $ResourceLocation$Type): $MetalCoefficientRecipeBuilder
public "build"(): $MetalCoefficientRecipe
public "folder"(arg0: string): $MetalCoefficientRecipeBuilder
public "coefficient"(arg0: double): $MetalCoefficientRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalCoefficientRecipeBuilder$Type = ($MetalCoefficientRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetalCoefficientRecipeBuilder_ = $MetalCoefficientRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/$ConfigManager" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ConfigManager {
static "MAX_PROXY_DISTANCE": $ForgeConfigSpec$ConfigValue<(integer)>
static "EMBER_BORE_SPEED_MOD": $ForgeConfigSpec$ConfigValue<(double)>
static "EMBER_BORE_TIME": $ForgeConfigSpec$ConfigValue<(integer)>
static "EMBER_BORE_FUEL_CONSUMPTION": $ForgeConfigSpec$ConfigValue<(double)>
static "RESERVOIR_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "MINI_BOILER_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "MINI_BOILER_HEAT_MULTIPLIER": $ForgeConfigSpec$ConfigValue<(double)>
static "MINI_BOILER_CAN_EXPLODE": $ForgeConfigSpec$ConfigValue<(boolean)>
static "INJECTOR_MAX_DISTANCE": $ForgeConfigSpec$ConfigValue<(integer)>
static "MELTER_PROCESS_TIME": $ForgeConfigSpec$ConfigValue<(integer)>
static "MELTER_EMBER_COST": $ForgeConfigSpec$ConfigValue<(double)>
static "MELTER_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "GEO_SEPARATOR_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "STAMP_BASE_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "CHARGER_MAX_TRANSFER": $ForgeConfigSpec$ConfigValue<(double)>
static "FLUID_VESSEL_CAPACITY": $ForgeConfigSpec$ConfigValue<(integer)>
static "HEARTH_COIL_EMBER_COST": $ForgeConfigSpec$ConfigValue<(double)>
static "HEARTH_COIL_HEATING_SPEED": $ForgeConfigSpec$ConfigValue<(double)>
static "HEARTH_COIL_COOLING_SPEED": $ForgeConfigSpec$ConfigValue<(double)>
static "HEARTH_COIL_MAX_HEAT": $ForgeConfigSpec$ConfigValue<(double)>
static "HEARTH_COIL_MIN_COOK_TIME": $ForgeConfigSpec$ConfigValue<(integer)>
static "HEARTH_COIL_MAX_COOK_TIME": $ForgeConfigSpec$ConfigValue<(integer)>
static "DAWNSTONE_ANVIL_MAX_HITS": $ForgeConfigSpec$ConfigValue<(integer)>
static "BLAZING_RAY_COST": $ForgeConfigSpec$ConfigValue<(double)>
static "BLAZING_RAY_COOLDOWN": $ForgeConfigSpec$ConfigValue<(integer)>
static "BLAZING_RAY_MAX_CHARGE": $ForgeConfigSpec$ConfigValue<(integer)>
static "BLAZING_RAY_DAMAGE": $ForgeConfigSpec$ConfigValue<(double)>
static "BLAZING_RAY_MAX_SPREAD": $ForgeConfigSpec$ConfigValue<(double)>
static "BLAZING_RAY_MAX_DISTANCE": $ForgeConfigSpec$ConfigValue<(double)>
static "CINDER_STAFF_COST": $ForgeConfigSpec$ConfigValue<(double)>
static "CINDER_STAFF_COOLDOWN": $ForgeConfigSpec$ConfigValue<(integer)>
static "CINDER_STAFF_MAX_CHARGE": $ForgeConfigSpec$ConfigValue<(integer)>
static "CINDER_STAFF_DAMAGE": $ForgeConfigSpec$ConfigValue<(double)>
static "CINDER_STAFF_SIZE": $ForgeConfigSpec$ConfigValue<(double)>
static "CINDER_STAFF_AOE_SIZE": $ForgeConfigSpec$ConfigValue<(double)>
static "CINDER_STAFF_LIFETIME": $ForgeConfigSpec$ConfigValue<(integer)>
static "ASHEN_GOGGLES_SLOTS": $ForgeConfigSpec$ConfigValue<(integer)>
static "ASHEN_CLOAK_SLOTS": $ForgeConfigSpec$ConfigValue<(integer)>
static "ASHEN_LEGGINGS_SLOTS": $ForgeConfigSpec$ConfigValue<(integer)>
static "ASHEN_BOOTS_SLOTS": $ForgeConfigSpec$ConfigValue<(integer)>
static "SCALE_DAMAGE_PASSES": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "SCALE_DAMAGE_RATES": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "CODEX_PROGRESSION": $ForgeConfigSpec$ConfigValue<(boolean)>
static "PVP_EVERYBODY_IS_ENEMY": $ForgeConfigSpec$ConfigValue<(boolean)>
static "TAG_PREFERENCES": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "ITEM_PREFERENCES": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "RENDER_FALLBACK": $ForgeConfigSpec$ConfigValue<(boolean)>

constructor()

public static "register"(): void
public static "getScaleDamageRate"(arg0: string): double
public static "getScaleDamagePass"(arg0: string): double
public static "registerClientConfigs"(): void
public static "registerCommonConfigs"(): void
public static "registerServerConfigs"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigManager$Type = ($ConfigManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigManager_ = $ConfigManager$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersLootModifiers" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$GlobalLootModifierProvider, $GlobalLootModifierProvider$Type} from "packages/net/minecraftforge/common/data/$GlobalLootModifierProvider"

export class $EmbersLootModifiers extends $GlobalLootModifierProvider {

constructor(arg0: $PackOutput$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersLootModifiers$Type = ($EmbersLootModifiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersLootModifiers_ = $EmbersLootModifiers$Type;
}}
declare module "packages/com/rekindled/embers/research/subtypes/$ResearchSwitchCategory" {
import {$GuiCodex, $GuiCodex$Type} from "packages/com/rekindled/embers/gui/$GuiCodex"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchCategory, $ResearchCategory$Type} from "packages/com/rekindled/embers/research/$ResearchCategory"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ResearchSwitchCategory extends $ResearchBase {
 "targetCategory": $ResearchCategory
 "name": string
 "u": double
 "v": double
 "icon": $ItemStack
 "x": integer
 "y": integer
 "ancestors": $List<($ResearchBase)>
 "subCategory": $ResearchBase
 "iconBackground": $ResourceLocation
 "background": $ResourceLocation
 "firstPage": $ResearchBase
 "pageNumber": integer
 "selectedAmount": float
 "selectionTarget": float
 "shownAmount": float
 "shownTarget": float
 "checked": boolean

constructor(arg0: string, arg1: $ItemStack$Type, arg2: double, arg3: double)

public "isHidden"(): boolean
public "check"(arg0: boolean): void
public "setMinEntries"(arg0: integer): $ResearchSwitchCategory
public "setTargetCategory"(arg0: $ResearchCategory$Type): $ResearchSwitchCategory
public "findByTag"(arg0: string, arg1: $Map$Type<($ResearchBase$Type), (integer)>, arg2: $Set$Type<($ResearchCategory$Type)>): void
public "isPathTowards"(arg0: $ResearchBase$Type): boolean
public "isChecked"(): boolean
public "getAllResearch"(arg0: $Set$Type<($ResearchBase$Type)>): void
public "onOpen"(arg0: $GuiCodex$Type): boolean
get "hidden"(): boolean
set "minEntries"(value: integer)
set "targetCategory"(value: $ResearchCategory$Type)
get "checked"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchSwitchCategory$Type = ($ResearchSwitchCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchSwitchCategory_ = $ResearchSwitchCategory$Type;
}}
declare module "packages/com/rekindled/embers/util/$MeltingBonus" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"

export class $MeltingBonus {
static readonly "IRON": $MeltingBonus
static readonly "GOLD": $MeltingBonus
static readonly "COPPER": $MeltingBonus
static readonly "LEAD": $MeltingBonus
static readonly "SILVER": $MeltingBonus
static readonly "NICKEL": $MeltingBonus
static readonly "TIN": $MeltingBonus
static readonly "ALUMINUM": $MeltingBonus
static readonly "ZINC": $MeltingBonus
static readonly "PLATINUM": $MeltingBonus
static readonly "URANIUM": $MeltingBonus
readonly "name": string
readonly "fluid": $Fluid
readonly "amount": integer
readonly "optional": boolean

constructor(arg0: string, arg1: $Fluid$Type, arg2: integer, arg3: boolean)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingBonus$Type = ($MeltingBonus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingBonus_ = $MeltingBonus$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$OrderStack" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IOrderSource, $IOrderSource$Type} from "packages/com/rekindled/embers/api/tile/$IOrderSource"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $OrderStack {

constructor(arg0: $BlockPos$Type, arg1: $IFilter$Type, arg2: integer)
constructor(arg0: $CompoundTag$Type)

public "increment"(arg0: integer): void
public "getSize"(): integer
public "reset"(arg0: $IFilter$Type, arg1: integer): void
public "getFilter"(): $IFilter
public "getSource"(arg0: $Level$Type): $IOrderSource
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "deplete"(arg0: integer): void
public "getPos"(): $BlockPos
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "acceptsItem"(arg0: $Level$Type, arg1: $ItemStack$Type): boolean
get "size"(): integer
get "filter"(): $IFilter
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderStack$Type = ($OrderStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrderStack_ = $OrderStack$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$StampingRecipeBuilder" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$StampingRecipe, $StampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$StampingRecipe$TagAmount, $StampingRecipe$TagAmount$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe$TagAmount"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"

export class $StampingRecipeBuilder {
 "id": $ResourceLocation
 "stamp": $Ingredient
 "input": $Ingredient
 "fluid": $FluidIngredient
 "output": $Either<($ItemStack), ($StampingRecipe$TagAmount)>

constructor()

public "id"(arg0: $ResourceLocation$Type): $StampingRecipeBuilder
public "domain"(arg0: string): $StampingRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $ItemStack$Type): $StampingRecipeBuilder
public static "create"(arg0: $Item$Type): $StampingRecipeBuilder
public static "create"(arg0: $TagKey$Type<($Item$Type)>, arg1: integer): $StampingRecipeBuilder
public static "create"(arg0: $TagKey$Type<($Item$Type)>): $StampingRecipeBuilder
public "input"(arg0: $Ingredient$Type): $StampingRecipeBuilder
public "input"(arg0: $TagKey$Type<($Item$Type)>): $StampingRecipeBuilder
public "input"(...arg0: ($ItemLike$Type)[]): $StampingRecipeBuilder
public "build"(): $StampingRecipe
public "stamp"(arg0: $TagKey$Type<($Item$Type)>): $StampingRecipeBuilder
public "stamp"(...arg0: ($ItemLike$Type)[]): $StampingRecipeBuilder
public "stamp"(arg0: $Ingredient$Type): $StampingRecipeBuilder
public "folder"(arg0: string): $StampingRecipeBuilder
public "fluid"(arg0: $FluidStack$Type): $StampingRecipeBuilder
public "fluid"(...arg0: ($FluidIngredient$Type)[]): $StampingRecipeBuilder
public "fluid"(arg0: $TagKey$Type<($Fluid$Type)>, arg1: integer): $StampingRecipeBuilder
public "fluid"(arg0: $Fluid$Type, arg1: integer): $StampingRecipeBuilder
public "fluid"(arg0: $FluidIngredient$Type): $StampingRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingRecipeBuilder$Type = ($StampingRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingRecipeBuilder_ = $StampingRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/block/$MechEdgeBlockBase" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $MechEdgeBlockBase extends $Block implements $SimpleWaterloggedBlock {
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "getCloneItemStack"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "centerBlock"(): $Block
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechEdgeBlockBase$Type = ($MechEdgeBlockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechEdgeBlockBase_ = $MechEdgeBlockBase$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$IUpgradeProvider, $IUpgradeProvider$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $DefaultUpgradeProvider implements $IUpgradeProvider {

constructor(arg0: $ResourceLocation$Type, arg1: $BlockEntity$Type)

public "invalidate"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getUpgradeId"(): $ResourceLocation
public "getPriority"(): integer
public "transformEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "transformEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
public "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
public "transformOutput"(arg0: $BlockEntity$Type, arg1: $FluidStack$Type, arg2: integer, arg3: integer): $FluidStack
public "transformOutput"(arg0: $BlockEntity$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: integer, arg3: integer): void
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: integer, arg3: integer, arg4: integer): integer
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: string, arg3: integer, arg4: integer): string
public "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: integer, arg4: integer): T
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: integer, arg4: integer): double
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: boolean, arg3: integer, arg4: integer): boolean
get "upgradeId"(): $ResourceLocation
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultUpgradeProvider$Type = ($DefaultUpgradeProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultUpgradeProvider_ = $DefaultUpgradeProvider$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IFluidPipePriority" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IFluidPipePriority {

 "getPriority"(arg0: $Direction$Type): integer

(arg0: $Direction$Type): integer
}

export namespace $IFluidPipePriority {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidPipePriority$Type = ($IFluidPipePriority);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidPipePriority_ = $IFluidPipePriority$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$ItemVisualEvent" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ItemVisualEvent extends $Event {

constructor(arg0: $LivingEntity$Type, arg1: $EquipmentSlot$Type, arg2: $ItemStack$Type, arg3: $Color$Type, arg4: $SoundEvent$Type, arg5: float, arg6: float, arg7: string)
constructor()

public "getSlot"(): $EquipmentSlot
public "setColor"(arg0: $Color$Type): void
public "getItem"(): $ItemStack
public "isCancelable"(): boolean
public "setSound"(arg0: $SoundEvent$Type): void
public "setVolume"(arg0: float): void
public "getVolume"(): float
public "getEntity"(): $LivingEntity
public "getColor"(): $Color
public "setPitch"(arg0: float): void
public "getPitch"(): float
public "setNoParticles"(): void
public "setNoSound"(): void
public "getUseState"(): string
public "hasSound"(): boolean
public "hasParticles"(): boolean
public "getSound"(): $SoundEvent
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "slot"(): $EquipmentSlot
set "color"(value: $Color$Type)
get "item"(): $ItemStack
get "cancelable"(): boolean
set "sound"(value: $SoundEvent$Type)
set "volume"(value: float)
get "volume"(): float
get "entity"(): $LivingEntity
get "color"(): $Color
set "pitch"(value: float)
get "pitch"(): float
get "useState"(): string
get "sound"(): $SoundEvent
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVisualEvent$Type = ($ItemVisualEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemVisualEvent_ = $ItemVisualEvent$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersPlacedFeatures" {
import {$PlacedFeature, $PlacedFeature$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacedFeature"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$PlacementModifier, $PlacementModifier$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacementModifier"
import {$BootstapContext, $BootstapContext$Type} from "packages/net/minecraft/data/worldgen/$BootstapContext"

export class $EmbersPlacedFeatures {
static readonly "ORE_LEAD_KEY": $ResourceKey<($PlacedFeature)>
static readonly "ORE_LEAD_PLACEMENT": $List<($PlacementModifier)>
static readonly "ORE_SILVER_KEY": $ResourceKey<($PlacedFeature)>
static readonly "ORE_SILVER_PLACEMENT": $List<($PlacementModifier)>

constructor()

public static "rareOrePlacement"(arg0: integer, arg1: $PlacementModifier$Type): $List<($PlacementModifier)>
public static "generate"(arg0: $BootstapContext$Type<($PlacedFeature$Type)>): void
public static "commonOrePlacement"(arg0: integer, arg1: $PlacementModifier$Type): $List<($PlacementModifier)>
public static "orePlacement"(arg0: $PlacementModifier$Type, arg1: $PlacementModifier$Type): $List<($PlacementModifier)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersPlacedFeatures$Type = ($EmbersPlacedFeatures);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersPlacedFeatures_ = $EmbersPlacedFeatures$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$EntropicEnumeratorBlockEntity$Move, $EntropicEnumeratorBlockEntity$Move$Type} from "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity$Move"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$EntropicEnumeratorBlockEntity$Cubie, $EntropicEnumeratorBlockEntity$Cubie$Type} from "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity$Cubie"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vector3d, $Vector3d$Type} from "packages/org/joml/$Vector3d"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$EntropicEnumeratorUpgrade, $EntropicEnumeratorUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$EntropicEnumeratorUpgrade"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EntropicEnumeratorBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
 "visualCube": ((($EntropicEnumeratorBlockEntity$Cubie)[])[])[]
 "previousMove": integer
 "cube": ((($EntropicEnumeratorBlockEntity$Cubie)[])[])[]
 "nextMoveTime": long
 "moveOffset": integer
 "moveQueue": ($EntropicEnumeratorBlockEntity$Move)[]
 "offsetQueue": (integer)[]
 "solving": boolean
static "seededRand": $Random
 "upgrade": $EntropicEnumeratorUpgrade
static readonly "GODS_NUMBER": integer
static readonly "B": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "B_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DB": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_B": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2B": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LB_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DLB_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2LB_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "B2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DB2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_B2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2B2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L_B_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LD_B2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "BDL_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "B2DL_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DL_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LU_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "BLU_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DL": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L2D_L": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DL2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "BL_B_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2L": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_L": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2L_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_L_U_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "F_DF": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LDLD_L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "F_D_F_DF2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "DL2D_L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LD_L_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "F_D2F": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "F_D_F": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LDL_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "L2D_L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "F2DF2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2F_DF": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_L2D_L2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_LD2L_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "LD2L_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "U": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "U2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D_": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "D2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_H": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_PI": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_ANTISUNE": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_SUNE": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_L": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_T": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "OLL_U": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_ADJ_ADJ": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_ADJ_DIAG": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_DIAG_ADJ": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_DIAG_DIAG": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_ADJ_U": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_ADJ_D": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_DIAG_U": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "PBL_DIAG_D": ($EntropicEnumeratorBlockEntity$Move)[]
static "solvingMoveTime": integer
static "moveTime": integer
static "queueSize": integer
static "queueTime": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "save"(arg0: $CompoundTag$Type): void
public "setChanged"(): void
public "solve"(arg0: boolean, arg1: integer): void
public "restartScramble"(arg0: integer): void
public static "isSolved"(arg0: ((($EntropicEnumeratorBlockEntity$Cubie$Type)[])[])[]): boolean
public "isSolved"(): boolean
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EntropicEnumeratorBlockEntity$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "optimizeAlgorithm"(arg0: ($EntropicEnumeratorBlockEntity$Move$Type)[]): ($EntropicEnumeratorBlockEntity$Move)[]
public "applyCurrentQueue"(arg0: ((($EntropicEnumeratorBlockEntity$Cubie$Type)[])[])[]): void
public static "updateColors"(arg0: ((($EntropicEnumeratorBlockEntity$Cubie$Type)[])[])[], arg1: ((($Vector3d$Type)[])[])[]): void
public "solveInefficient"(): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EntropicEnumeratorBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
get "solved"(): boolean
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorBlockEntity$Type = ($EntropicEnumeratorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorBlockEntity_ = $EntropicEnumeratorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$EmberBoreBlockEntity$EmberBoreInventory, $EmberBoreBlockEntity$EmberBoreInventory$Type} from "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity$EmberBoreInventory"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMechanicallyPowered, $IMechanicallyPowered$Type} from "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $EmberBoreBlockEntity extends $BlockEntity implements $ISoundController, $IMechanicallyPowered, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "SLOT_FUEL": integer
static readonly "SUPERSPEED_THRESHOLD": double
static readonly "SOUND_ON": integer
static readonly "SOUND_ON_DRILL": integer
static readonly "SOUND_ON_SUPERSPEED": integer
static readonly "SOUND_ON_DRILL_SUPERSPEED": integer
static readonly "SOUND_IDS": (integer)[]
 "ticksExisted": long
 "angle": float
 "ticksFueled": double
 "lastAngle": float
 "isRunning": boolean
 "upgrades": $List<($UpgradeContext)>
 "speedMod": double
 "inventory": $EmberBoreBlockEntity$EmberBoreInventory
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "insert"(arg0: $ArrayList$Type<($ItemStack$Type)>): void
public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberBoreBlockEntity$Type): void
public "getBladeBoundingBox"(): $AABB
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberBoreBlockEntity$Type): void
public static "commonTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberBoreBlockEntity$Type): void
public "canInsert"(arg0: $ArrayList$Type<($ItemStack$Type)>): boolean
public "playSound"(arg0: integer): void
public "canMine"(): boolean
public "isSuperSpeed"(): boolean
public "getMechanicalSpeed"(arg0: double): double
public "getMinimumPower"(): double
public "getNominalSpeed"(): double
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "handleSound"(): void
public "getStandardPowerRatio"(): double
public "getMaximumPower"(): double
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "bladeBoundingBox"(): $AABB
get "soundIDs"(): (integer)[]
get "renderBoundingBox"(): $AABB
get "superSpeed"(): boolean
get "minimumPower"(): double
get "nominalSpeed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "standardPowerRatio"(): double
get "maximumPower"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreBlockEntity$Type = ($EmberBoreBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreBlockEntity_ = $EmberBoreBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilBreakdownRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$AnvilBreakdownRecipe, $AnvilBreakdownRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilBreakdownRecipe"

export class $AnvilBreakdownRecipe$Serializer implements $RecipeSerializer<($AnvilBreakdownRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AnvilBreakdownRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AnvilBreakdownRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AnvilBreakdownRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AnvilBreakdownRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilBreakdownRecipe$Serializer$Type = ($AnvilBreakdownRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilBreakdownRecipe$Serializer_ = $AnvilBreakdownRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$BinBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BinBlockEntity, $BinBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$BinBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $BinBlockEntityRenderer implements $BlockEntityRenderer<($BinBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $BinBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $BinBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $BinBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinBlockEntityRenderer$Type = ($BinBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinBlockEntityRenderer_ = $BinBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberActivatorTopBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberActivatorTopBlockEntity extends $BlockEntity implements $ISoundController, $IExtraCapabilityInformation {
 "capability": $IEmberCapability
static readonly "SOUND_HAS_EMBER": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberActivatorTopBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivatorTopBlockEntity$Type = ($EmberActivatorTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivatorTopBlockEntity_ = $EmberActivatorTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MechanicalCoreBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IUpgradeProxy, $IUpgradeProxy$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeProxy"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MechanicalCoreBlockEntity$BlockEntityDirection, $MechanicalCoreBlockEntity$BlockEntityDirection$Type} from "packages/com/rekindled/embers/blockentity/$MechanicalCoreBlockEntity$BlockEntityDirection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MechanicalCoreBlockEntity extends $BlockEntity implements $IExtraDialInformation, $IExtraCapabilityInformation, $IUpgradeProxy {
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public "getAttachedMultiblock"(arg0: integer): $MechanicalCoreBlockEntity$BlockEntityDirection
public "getAttachedBlockEntity"(arg0: integer): $BlockEntity
public "getFace"(): $Direction
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "collectUpgrades"(arg0: $List$Type<($UpgradeContext$Type)>, arg1: integer): void
public "isProvider"(arg0: $Direction$Type): boolean
public "isSocket"(arg0: $Direction$Type): boolean
public "getAttachedSide"(): $Direction
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
get "face"(): $Direction
get "attachedSide"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCoreBlockEntity$Type = ($MechanicalCoreBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalCoreBlockEntity_ = $MechanicalCoreBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$AnvilAugmentRecipe, $AnvilAugmentRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $AnvilAugmentRecipe$Serializer implements $RecipeSerializer<($AnvilAugmentRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AnvilAugmentRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AnvilAugmentRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AnvilAugmentRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AnvilAugmentRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilAugmentRecipe$Serializer$Type = ($AnvilAugmentRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilAugmentRecipe$Serializer_ = $AnvilAugmentRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemDropperBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IItemPipePriority, $IItemPipePriority$Type} from "packages/com/rekindled/embers/blockentity/$IItemPipePriority"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ItemDropperBlockEntity extends $BlockEntity implements $IItemPipePriority {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getPriority"(arg0: $Direction$Type): integer
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemDropperBlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDropperBlockEntity$Type = ($ItemDropperBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDropperBlockEntity_ = $ItemDropperBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$FilterItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $FilterItem implements $IFilter {
static readonly "RESOURCE_LOCATION": $ResourceLocation

constructor(arg0: $ItemStack$Type)
constructor(arg0: $CompoundTag$Type)

public "equals"(arg0: any): boolean
public "getType"(): $ResourceLocation
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "formatFilter"(): string
public "acceptsItem"(arg0: $ItemStack$Type): boolean
public "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterItem$Type = ($FilterItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterItem_ = $FilterItem$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$MetalCoefficientRecipe, $MetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $MetalCoefficientRecipe$Serializer implements $RecipeSerializer<($MetalCoefficientRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $MetalCoefficientRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $MetalCoefficientRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $MetalCoefficientRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $MetalCoefficientRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalCoefficientRecipe$Serializer$Type = ($MetalCoefficientRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetalCoefficientRecipe$Serializer_ = $MetalCoefficientRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberRelayBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EmberReceiverBlock, $EmberReceiverBlock$Type} from "packages/com/rekindled/embers/block/$EmberReceiverBlock"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $EmberRelayBlock extends $EmberReceiverBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberRelayBlock$Type = ($EmberRelayBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberRelayBlock_ = $EmberRelayBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidPipeBlockEntityBase, $FluidPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntityBase"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $FluidPipeBlockEntity extends $FluidPipeBlockEntityBase {
static readonly "MAX_PUSH": integer
 "tank": $FluidTank
 "holder": $LazyOptional<($IFluidHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidPipeBlockEntity$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlockEntity$Type = ($FluidPipeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeBlockEntity_ = $FluidPipeBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/worldgen/$CaveStructure" {
import {$StructureTemplatePool, $StructureTemplatePool$Type} from "packages/net/minecraft/world/level/levelgen/structure/pools/$StructureTemplatePool"
import {$StructureType, $StructureType$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureType"
import {$Heightmap$Types, $Heightmap$Types$Type} from "packages/net/minecraft/world/level/levelgen/$Heightmap$Types"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$HeightProvider, $HeightProvider$Type} from "packages/net/minecraft/world/level/levelgen/heightproviders/$HeightProvider"
import {$Structure$GenerationStub, $Structure$GenerationStub$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$GenerationStub"
import {$Structure$GenerationContext, $Structure$GenerationContext$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$GenerationContext"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Structure$StructureSettings, $Structure$StructureSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$StructureSettings"

export class $CaveStructure extends $Structure {
static readonly "CODEC": $Codec<($CaveStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$Type, arg1: $Holder$Type<($StructureTemplatePool$Type)>, arg2: integer, arg3: $HeightProvider$Type, arg4: $HeightProvider$Type, arg5: boolean)
constructor(arg0: $Structure$StructureSettings$Type, arg1: $Holder$Type<($StructureTemplatePool$Type)>, arg2: integer, arg3: $HeightProvider$Type, arg4: $HeightProvider$Type, arg5: boolean, arg6: $Heightmap$Types$Type)

public static "verifyRange"(arg0: $CaveStructure$Type): $DataResult<($CaveStructure)>
public "type"(): $StructureType<(any)>
public "m_214086_"(arg0: $Structure$GenerationContext$Type): $Optional<($Structure$GenerationStub)>
public static "addPieces"(arg0: $Structure$GenerationContext$Type, arg1: $Holder$Type<($StructureTemplatePool$Type)>, arg2: $Optional$Type<($ResourceLocation$Type)>, arg3: integer, arg4: $BlockPos$Type, arg5: integer, arg6: boolean, arg7: $Optional$Type<($Heightmap$Types$Type)>, arg8: integer): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveStructure$Type = ($CaveStructure);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaveStructure_ = $CaveStructure$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoilingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidHandlerContext, $FluidHandlerContext$Type} from "packages/com/rekindled/embers/recipe/$FluidHandlerContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$BoilingRecipe$Serializer, $BoilingRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$BoilingRecipe$Serializer"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$IBoilingRecipe, $IBoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoilingRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $BoilingRecipe implements $IBoilingRecipe {
static readonly "SERIALIZER": $BoilingRecipe$Serializer
readonly "id": $ResourceLocation
readonly "input": $FluidIngredient
readonly "output": $FluidStack

constructor(arg0: $ResourceLocation$Type, arg1: $FluidIngredient$Type, arg2: $FluidStack$Type)

public "matches"(arg0: $FluidHandlerContext$Type, arg1: $Level$Type): boolean
public "process"(arg0: $FluidHandlerContext$Type, arg1: integer): $FluidStack
public "getDisplayOutput"(): $FluidStack
public "getDisplayInput"(): $FluidIngredient
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "getOutput"(arg0: $FluidHandlerContext$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $FluidHandlerContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $FluidHandlerContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $FluidStack
get "displayInput"(): $FluidIngredient
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilingRecipe$Type = ($BoilingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilingRecipe_ = $BoilingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilRepairMateriaRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$AnvilRepairMateriaRecipe, $AnvilRepairMateriaRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairMateriaRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $AnvilRepairMateriaRecipe$Serializer implements $RecipeSerializer<($AnvilRepairMateriaRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AnvilRepairMateriaRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AnvilRepairMateriaRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AnvilRepairMateriaRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AnvilRepairMateriaRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilRepairMateriaRecipe$Serializer$Type = ($AnvilRepairMateriaRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilRepairMateriaRecipe$Serializer_ = $AnvilRepairMateriaRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$EmberActivationRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$EmberActivationRecipe$Serializer, $EmberActivationRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$EmberActivationRecipe$Serializer"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $EmberActivationRecipe implements $IEmberActivationRecipe {
static readonly "SERIALIZER": $EmberActivationRecipe$Serializer
readonly "id": $ResourceLocation
readonly "ingredient": $Ingredient
readonly "ember": integer

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: integer)

public "process"(arg0: $Container$Type): integer
public "getDisplayOutput"(): integer
public "getDisplayInput"(): $Ingredient
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getOutput"(arg0: $Container$Type): integer
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): integer
get "displayInput"(): $Ingredient
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivationRecipe$Type = ($EmberActivationRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivationRecipe_ = $EmberActivationRecipe$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$AlchemyCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $AlchemyCategory implements $IRecipeCategory<($IAlchemyRecipe)> {
static "title": $Component
static "texture": $ResourceLocation
static "pillarTexture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IAlchemyRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IAlchemyRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IAlchemyRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IAlchemyRecipe$Type): boolean
public "handleInput"(arg0: $IAlchemyRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IAlchemyRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IAlchemyRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IAlchemyRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyCategory$Type = ($AlchemyCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyCategory_ = $AlchemyCategory$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$EmberRemoveEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $EmberRemoveEvent extends $Event {

constructor(arg0: $Player$Type, arg1: double)
constructor()

public "isCancelable"(): boolean
public "setAmount"(arg0: double): void
public "getOriginal"(): double
public "getAmount"(): double
public "getPlayer"(): $Player
public "addReduction"(arg0: double): void
public "getFinal"(): double
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
set "amount"(value: double)
get "original"(): double
get "amount"(): double
get "player"(): $Player
get "final"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberRemoveEvent$Type = ($EmberRemoveEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberRemoveEvent_ = $EmberRemoveEvent$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IHeldEmberCell" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHeldEmberCell {

}

export namespace $IHeldEmberCell {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHeldEmberCell$Type = ($IHeldEmberCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHeldEmberCell_ = $IHeldEmberCell$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IMechanicallyPowered {

 "getStandardPowerRatio"(): double
 "getMechanicalSpeed"(arg0: double): double
 "getMinimumPower"(): double
 "getNominalSpeed"(): double
 "getMaximumPower"(): double
}

export namespace $IMechanicallyPowered {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMechanicallyPowered$Type = ($IMechanicallyPowered);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMechanicallyPowered_ = $IMechanicallyPowered$Type;
}}
declare module "packages/com/rekindled/embers/util/sound/$ISoundController" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ISoundController {

 "shouldPlaySound"(arg0: integer): boolean
 "getSoundIDs"(): (integer)[]
 "getCurrentVolume"(arg0: integer, arg1: float): float
 "getCurrentPitch"(arg0: integer, arg1: float): float
 "stopSound"(arg0: integer): void
 "isSoundPlaying"(arg0: integer): boolean
 "handleSound"(): void
 "playSound"(arg0: integer): void
}

export namespace $ISoundController {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISoundController$Type = ($ISoundController);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISoundController_ = $ISoundController$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersStructures" {
import {$StructureTemplatePool, $StructureTemplatePool$Type} from "packages/net/minecraft/world/level/levelgen/structure/pools/$StructureTemplatePool"
import {$StructureProcessorList, $StructureProcessorList$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorList"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$StructureSet, $StructureSet$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureSet"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BootstapContext, $BootstapContext$Type} from "packages/net/minecraft/data/worldgen/$BootstapContext"

export class $EmbersStructures {
static readonly "RUIN_PROCESSORS": $ResourceKey<($StructureProcessorList)>
static readonly "SMALL_RUIN_POOL": $ResourceKey<($StructureTemplatePool)>
static readonly "SMALL_RUIN": $ResourceKey<($Structure)>
static readonly "SMALL_RUIN_SET": $ResourceKey<($StructureSet)>

constructor()

public static "generateProcessors"(arg0: $BootstapContext$Type<($StructureProcessorList$Type)>): void
public static "generateSets"(arg0: $BootstapContext$Type<($StructureSet$Type)>): void
public static "generatePools"(arg0: $BootstapContext$Type<($StructureTemplatePool$Type)>): void
public static "generateStructures"(arg0: $BootstapContext$Type<($Structure$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersStructures$Type = ($EmbersStructures);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersStructures_ = $EmbersStructures$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CatalysisChamberBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CatalysisChamberBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
static "machine": $ItemStack
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $ICatalysisCombustionRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CatalysisChamberBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisChamberBlockEntity$Type = ($CatalysisChamberBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisChamberBlockEntity_ = $CatalysisChamberBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$AlchemyHintItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AlchemyHintItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public static "getResult"(arg0: $ItemStack$Type): $ItemStack
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public static "getInputs"(arg0: $ItemStack$Type): $ArrayList<($ItemStack)>
public static "getBlackPins"(arg0: $ItemStack$Type): integer
public static "getWhitePins"(arg0: $ItemStack$Type): integer
public static "getAspects"(arg0: $ItemStack$Type): $ArrayList<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyHintItem$Type = ($AlchemyHintItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyHintItem_ = $AlchemyHintItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$ReservoirEdgeBlock" {
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $ReservoirEdgeBlock extends $MechEdgeBlockBase {
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReservoirEdgeBlock$Type = ($ReservoirEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReservoirEdgeBlock_ = $ReservoirEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity$Cubie" {
import {$Quaterniond, $Quaterniond$Type} from "packages/org/joml/$Quaterniond"
import {$Vector3d, $Vector3d$Type} from "packages/org/joml/$Vector3d"

export class $EntropicEnumeratorBlockEntity$Cubie {
static "zero": $Vector3d
 "basePosition": $Vector3d
 "baseColors": $Vector3d
 "rotation": $Quaterniond
 "currentPosition": $Vector3d
 "currentColors": $Vector3d

constructor(arg0: $Vector3d$Type, arg1: $Quaterniond$Type)
constructor(arg0: $Vector3d$Type, arg1: $Vector3d$Type)
constructor(arg0: $Vector3d$Type, arg1: $Vector3d$Type, arg2: $Quaterniond$Type)

public "getColors"(): $Vector3d
public "getPos"(): $Vector3d
public "setChanged"(): void
get "colors"(): $Vector3d
get "pos"(): $Vector3d
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorBlockEntity$Cubie$Type = ($EntropicEnumeratorBlockEntity$Cubie);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorBlockEntity$Cubie_ = $EntropicEnumeratorBlockEntity$Cubie$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$AnvilAugmentRecipe, $AnvilAugmentRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $AnvilAugmentRecipeBuilder {
 "id": $ResourceLocation
 "tool": $Ingredient
 "input": $Ingredient
 "augment": $IAugment

constructor()

public "id"(arg0: $ResourceLocation$Type): $AnvilAugmentRecipeBuilder
public "domain"(arg0: string): $AnvilAugmentRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $IAugment$Type): $AnvilAugmentRecipeBuilder
public "input"(...arg0: ($ItemLike$Type)[]): $AnvilAugmentRecipeBuilder
public "input"(arg0: $TagKey$Type<($Item$Type)>): $AnvilAugmentRecipeBuilder
public "input"(arg0: $Ingredient$Type): $AnvilAugmentRecipeBuilder
public "build"(): $AnvilAugmentRecipe
public "folder"(arg0: string): $AnvilAugmentRecipeBuilder
public "tool"(...arg0: ($ItemLike$Type)[]): $AnvilAugmentRecipeBuilder
public "tool"(arg0: $Ingredient$Type): $AnvilAugmentRecipeBuilder
public "tool"(arg0: $TagKey$Type<($Item$Type)>): $AnvilAugmentRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilAugmentRecipeBuilder$Type = ($AnvilAugmentRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilAugmentRecipeBuilder_ = $AnvilAugmentRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberReceiverBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IEmberPacketReceiver, $IEmberPacketReceiver$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketReceiver"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export class $EmberReceiverBlockEntity extends $BlockEntity implements $IEmberPacketReceiver {
 "capability": $IEmberCapability
static readonly "TRANSFER_RATE": integer
 "ticksExisted": long
 "random": $Random
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)
constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "onReceive"(arg0: $EmberPacketEntity$Type): boolean
public "hasRoomFor"(arg0: double): boolean
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberReceiverBlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberReceiverBlockEntity$Type = ($EmberReceiverBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberReceiverBlockEntity_ = $EmberReceiverBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersDamageTypes" {
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BootstapContext, $BootstapContext$Type} from "packages/net/minecraft/data/worldgen/$BootstapContext"

export class $EmbersDamageTypes {
static readonly "EMBER_KEY": $ResourceKey<($DamageType)>
static readonly "EMBER": $DamageType

constructor()

public static "generate"(arg0: $BootstapContext$Type<($DamageType$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersDamageTypes$Type = ($EmbersDamageTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersDamageTypes_ = $EmbersDamageTypes$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$GeologicSeparatorUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $GeologicSeparatorUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeologicSeparatorUpgrade$Type = ($GeologicSeparatorUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeologicSeparatorUpgrade_ = $GeologicSeparatorUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$AlchemyPedestalBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$AlchemyPedestalBlockEntity, $AlchemyPedestalBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalBlockEntity"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $AlchemyPedestalBlockEntityRenderer implements $BlockEntityRenderer<($AlchemyPedestalBlockEntity)> {
static "dist": double

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $AlchemyPedestalBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $AlchemyPedestalBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $AlchemyPedestalBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyPedestalBlockEntityRenderer$Type = ($AlchemyPedestalBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyPedestalBlockEntityRenderer_ = $AlchemyPedestalBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/augment/$CasterOrbAugment" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"
import {$PlayerInteractEvent$LeftClickBlock, $PlayerInteractEvent$LeftClickBlock$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PlayerInteractEvent$LeftClickEmpty, $PlayerInteractEvent$LeftClickEmpty$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickEmpty"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"

export class $CasterOrbAugment extends $AugmentBase {
static "prevCooledStrength": float
static "cooldownTicks": float
static "cooldownTicksServer": $HashMap<($UUID), (float)>

constructor(arg0: $ResourceLocation$Type)

public static "setCooldown"(arg0: $UUID$Type, arg1: float): void
public static "hasCooldown"(arg0: $UUID$Type): boolean
public "onSwing"(arg0: $PlayerInteractEvent$LeftClickEmpty$Type): void
public "onSwing"(arg0: $PlayerInteractEvent$LeftClickBlock$Type): void
public "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CasterOrbAugment$Type = ($CasterOrbAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CasterOrbAugment_ = $CasterOrbAugment$Type;
}}
declare module "packages/com/rekindled/embers/block/$CatalyticPlugBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CatalyticPlugBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalyticPlugBlock$Type = ($CatalyticPlugBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalyticPlugBlock_ = $CatalyticPlugBlock$Type;
}}
declare module "packages/com/rekindled/embers/power/$DefaultEmberCapability" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $DefaultEmberCapability implements $IEmberCapability {
static "allAcceptVolatile": boolean

constructor()
constructor(arg0: $IEmberCapability$Type)

public "invalidate"(): void
public "getEmber"(): double
public "getEmberCapacity"(): double
public "setEmber"(arg0: double): void
public "onContentsChanged"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "removeAmount"(arg0: double, arg1: boolean): double
public "acceptsVolatile"(): boolean
public "addAmount"(arg0: double, arg1: boolean): double
public "setEmberCapacity"(arg0: double): void
public "writeToNBT"(arg0: $CompoundTag$Type): void
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
get "ember"(): double
get "emberCapacity"(): double
set "ember"(value: double)
set "emberCapacity"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultEmberCapability$Type = ($DefaultEmberCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultEmberCapability_ = $DefaultEmberCapability$Type;
}}
declare module "packages/com/rekindled/embers/api/augment/$IAugment" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IAugment {

 "getName"(): $ResourceLocation
 "countTowardsTotalLevel"(): boolean
 "onApply"(arg0: $ItemStack$Type): void
 "canRemove"(): boolean
 "getCost"(): double
 "shouldRenderTooltip"(): boolean
 "onRemove"(arg0: $ItemStack$Type): void
}

export namespace $IAugment {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAugment$Type = ($IAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAugment_ = $IAugment$Type;
}}
declare module "packages/com/rekindled/embers/block/$ExtractorBlockBase" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeBlockBase, $PipeBlockBase$Type} from "packages/com/rekindled/embers/block/$PipeBlockBase"

export class $ExtractorBlockBase extends $PipeBlockBase {
static readonly "EXTRACTOR_AABB": $VoxelShape
static readonly "EXTRACTOR_SHAPES": ($VoxelShape)[]
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "connected"(arg0: $Direction$Type, arg1: $BlockState$Type): boolean
public "getCenterShape"(): $VoxelShape
public "getBlockSupportShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): $VoxelShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerShape"(): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtractorBlockBase$Type = ($ExtractorBlockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtractorBlockBase_ = $ExtractorBlockBase$Type;
}}
declare module "packages/com/rekindled/embers/item/$AlchemicalNoteItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AlchemicalNoteItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "initializeClient"(arg0: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemicalNoteItem$Type = ($AlchemicalNoteItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemicalNoteItem_ = $AlchemicalNoteItem$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$IgnemReactorBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $IgnemReactorBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "BASE_MULTIPLIER": double
static readonly "PROCESS_TIME": integer
 "capability": $IEmberCapability
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IEmberActivationRecipe
 "catalyzerMult": double
 "combustorMult": double
static readonly "SOUND_HAS_EMBER": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $IgnemReactorBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $IgnemReactorBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IgnemReactorBlockEntity$Type = ($IgnemReactorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IgnemReactorBlockEntity_ = $IgnemReactorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/augment/$AugmentUtil" {
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IAugmentUtil, $IAugmentUtil$Type} from "packages/com/rekindled/embers/api/augment/$IAugmentUtil"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $AugmentUtil {
static "IMPL": $IAugmentUtil
static readonly "HEAT_TAG": string

constructor()

public static "getLevel"(arg0: $ItemStack$Type): integer
public static "setLevel"(arg0: $ItemStack$Type, arg1: integer): void
public static "getTotalAugmentLevel"(arg0: $ItemStack$Type): integer
public static "getArmorAugmentLevel"(arg0: $LivingEntity$Type, arg1: $IAugment$Type): integer
public static "getAugment"(arg0: $ResourceLocation$Type): $IAugment
public static "getAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type): integer
public static "getAllAugments"(): $Collection<($IAugment)>
public static "getAugments"(arg0: $ItemStack$Type): $List<($IAugment)>
public static "addAugment"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $IAugment$Type): void
public static "setAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
public static "hasAugment"(arg0: $ItemStack$Type, arg1: $IAugment$Type): boolean
public static "hasHeat"(arg0: $ItemStack$Type): boolean
public static "addAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
public static "registerAugment"(arg0: $IAugment$Type): $IAugment
public static "getHeat"(arg0: $ItemStack$Type): float
public static "removeAllAugments"(arg0: $ItemStack$Type): $List<($ItemStack)>
public static "getMaxHeat"(arg0: $ItemStack$Type): float
public static "addHeat"(arg0: $ItemStack$Type, arg1: float): void
public static "setHeat"(arg0: $ItemStack$Type, arg1: float): void
get "allAugments"(): $Collection<($IAugment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AugmentUtil$Type = ($AugmentUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AugmentUtil_ = $AugmentUtil$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$CatalyticPlugUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $CatalyticPlugUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public static "getMultiplier"(arg0: double, arg1: integer, arg2: integer): double
public "transformEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
public static "registerBlacklistedTile"(arg0: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalyticPlugUpgrade$Type = ($CatalyticPlugUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalyticPlugUpgrade_ = $CatalyticPlugUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/research/$ResearchManager" {
import {$IResearchCapability, $IResearchCapability$Type} from "packages/com/rekindled/embers/research/capability/$IResearchCapability"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent$Clone, $PlayerEvent$Clone$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$Clone"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchCategory, $ResearchCategory$Type} from "packages/com/rekindled/embers/research/$ResearchCategory"
import {$AttachCapabilitiesEvent, $AttachCapabilitiesEvent$Type} from "packages/net/minecraftforge/event/$AttachCapabilitiesEvent"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ResearchManager {
static readonly "PLAYER_RESEARCH": $ResourceLocation
static readonly "PAGE_ICONS": $ResourceLocation
static readonly "PAGE_ICON_SIZE": double
static "researches": $List<($ResearchCategory)>
static "dials": $ResearchBase
static "ores": $ResearchBase
static "hammer": $ResearchBase
static "ancient_golem": $ResearchBase
static "gauge": $ResearchBase
static "caminite": $ResearchBase
static "access": $ResearchBase
static "bore": $ResearchBase
static "excavation_buckets": $ResearchBase
static "crystals": $ResearchBase
static "activator": $ResearchBase
static "tinker_lens": $ResearchBase
static "reaction_chamber": $ResearchBase
static "heat_exchanger": $ResearchBase
static "copper_cell": $ResearchBase
static "emitters": $ResearchBase
static "relays": $ResearchBase
static "dawnstone": $ResearchBase
static "melter": $ResearchBase
static "stamper": $ResearchBase
static "mixer": $ResearchBase
static "breaker": $ResearchBase
static "hearth_coil": $ResearchBase
static "char_instiller": $ResearchBase
static "atmospheric_bellows": $ResearchBase
static "heat_insulation": $ResearchBase
static "pressureRefinery": $ResearchBase
static "mini_boiler": $ResearchBase
static "pump": $ResearchBase
static "clockwork_attenuator": $ResearchBase
static "geo_separator": $ResearchBase
static "beam_cannon": $ResearchBase
static "pulser": $ResearchBase
static "splitter": $ResearchBase
static "crystal_cell": $ResearchBase
static "cinder_staff": $ResearchBase
static "clockwork_tools": $ResearchBase
static "blazing_ray": $ResearchBase
static "charger": $ResearchBase
static "jars": $ResearchBase
static "alchemy": $ResearchBase
static "cinder_plinth": $ResearchBase
static "aspecti": $ResearchBase
static "ember_siphon": $ResearchBase
static "tyrfing": $ResearchBase
static "waste": $ResearchBase
static "slate": $ResearchBase
static "mnemonic_inscriber": $ResearchBase
static "entropic_enumerator": $ResearchBase
static "catalytic_plug": $ResearchBase
static "cluster": $ResearchBase
static "ashen_cloak": $ResearchBase
static "inflictor": $ResearchBase
static "materia": $ResearchBase
static "field_chart": $ResearchBase
static "glimmer": $ResearchBase
static "metallurgic_dust": $ResearchBase
static "augments": $ResearchBase
static "inferno_forge": $ResearchBase
static "heat": $ResearchBase
static "dawnstone_anvil": $ResearchBase
static "autohammer": $ResearchBase
static "dismantling": $ResearchBase
static "pipes": $ResearchBase
static "tank": $ResearchBase
static "bin": $ResearchBase
static "dropper": $ResearchBase
static "reservoir": $ResearchBase
static "vacuum": $ResearchBase
static "transfer": $ResearchBase
static "golem_eye": $ResearchBase
static "requisition": $ResearchBase
static "adhesive": $ResearchBase
static "hellish_synthesis": $ResearchBase
static "archaic_brick": $ResearchBase
static "motive_core": $ResearchBase
static "dwarven_oil": $ResearchBase
static "wildfire": $ResearchBase
static "combustor": $ResearchBase
static "catalyzer": $ResearchBase
static "reactor": $ResearchBase
static "injector": $ResearchBase
static "stirling": $ResearchBase
static "ember_pipe": $ResearchBase
static "superheater": $ResearchBase
static "caster_orb": $ResearchBase
static "resonating_bell": $ResearchBase
static "blasting_core": $ResearchBase
static "winding_gears": $ResearchBase
static "cinder_jet": $ResearchBase
static "eldritch_insignia": $ResearchBase
static "intelligent_apparatus": $ResearchBase
static "flame_barrier": $ResearchBase
static "tinker_lens_augment": $ResearchBase
static "anti_tinker_lens": $ResearchBase
static "shifting_scales": $ResearchBase
static "diffraction_barrel": $ResearchBase
static "focal_lens": $ResearchBase
static "cost_reduction": $ResearchBase
static "mantle_bulb": $ResearchBase
static "explosion_charm": $ResearchBase
static "nonbeliever_amulet": $ResearchBase
static "ashen_amulet": $ResearchBase
static "dawnstone_mail": $ResearchBase
static "explosion_pedestal": $ResearchBase
static "gearbox": $ResearchBase
static "mergebox": $ResearchBase
static "axle_iron": $ResearchBase
static "gear_iron": $ResearchBase
static "actuator": $ResearchBase
static "steam_engine": $ResearchBase
static "categoryWorld": $ResearchCategory
static "categoryMechanisms": $ResearchCategory
static "categoryMetallurgy": $ResearchCategory
static "categoryAlchemy": $ResearchCategory
static "categorySmithing": $ResearchCategory
static "categoryMateria": $ResearchCategory
static "categoryCore": $ResearchCategory
static "subCategoryPipes": $ResearchCategory
static "subCategoryWeaponAugments": $ResearchCategory
static "subCategoryArmorAugments": $ResearchCategory
static "subCategoryProjectileAugments": $ResearchCategory
static "subCategoryMiscAugments": $ResearchCategory
static "subCategoryMechanicalPower": $ResearchCategory
static "subCategoryBaubles": $ResearchCategory
static "subCategorySimpleAlchemy": $ResearchCategory
static "subCategoryWildfire": $ResearchCategory

constructor()

public static "getPlayerResearch"(arg0: $Player$Type): $IResearchCapability
public static "sendResearchData"(arg0: $ServerPlayer$Type): void
public static "receiveResearchData"(arg0: $Map$Type<(string), (boolean)>): void
public static "onClone"(arg0: $PlayerEvent$Clone$Type): void
public static "initResearches"(): void
public static "findByTag"(arg0: string): $Map<($ResearchBase), (integer)>
public static "isPathTowards"(arg0: $ResearchBase$Type, arg1: $ResearchBase$Type): boolean
public static "getAllResearch"(): $List<($ResearchBase)>
public static "attachCapability"(arg0: $AttachCapabilitiesEvent$Type<($Entity$Type)>): void
public static "isPathToLock"(arg0: $ResearchBase$Type): boolean
public static "sendCheckmark"(arg0: $ResearchBase$Type, arg1: boolean): void
get "allResearch"(): $List<($ResearchBase)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchManager$Type = ($ResearchManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchManager_ = $ResearchManager$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$FilterNotExisting" {
import {$FilterExisting, $FilterExisting$Type} from "packages/com/rekindled/embers/api/filter/$FilterExisting"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $FilterNotExisting extends $FilterExisting {
static readonly "RESOURCE_LOCATION": $ResourceLocation

constructor()

public "getType"(): $ResourceLocation
public "formatFilter"(): string
public "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterNotExisting$Type = ($FilterNotExisting);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterNotExisting_ = $FilterNotExisting$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$StampingRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$StampingRecipe, $StampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $StampingRecipe$Serializer implements $RecipeSerializer<($StampingRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $StampingRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $StampingRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $StampingRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $StampingRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingRecipe$Serializer$Type = ($StampingRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingRecipe$Serializer_ = $StampingRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GemSocketRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$GemSocketRecipe, $GemSocketRecipe$Type} from "packages/com/rekindled/embers/recipe/$GemSocketRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $GemSocketRecipeBuilder {
 "id": $ResourceLocation
 "ingredient": $Ingredient

constructor()

public "id"(arg0: $ResourceLocation$Type): $GemSocketRecipeBuilder
public "domain"(arg0: string): $GemSocketRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $TagKey$Type<($Item$Type)>): $GemSocketRecipeBuilder
public static "create"(arg0: $ItemStack$Type): $GemSocketRecipeBuilder
public static "create"(arg0: $Ingredient$Type): $GemSocketRecipeBuilder
public static "create"(arg0: $Item$Type): $GemSocketRecipeBuilder
public "build"(): $GemSocketRecipe
public "folder"(arg0: string): $GemSocketRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemSocketRecipeBuilder$Type = ($GemSocketRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemSocketRecipeBuilder_ = $GemSocketRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MechanicalPumpBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$MechanicalPumpBottomBlockEntity, $MechanicalPumpBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MechanicalPumpBottomBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MechanicalPumpBlockEntityRenderer implements $BlockEntityRenderer<($MechanicalPumpBottomBlockEntity)> {
static "pistonBottom": $BakedModel
static "pistonTop": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MechanicalPumpBottomBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MechanicalPumpBottomBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MechanicalPumpBottomBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPumpBlockEntityRenderer$Type = ($MechanicalPumpBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPumpBlockEntityRenderer_ = $MechanicalPumpBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IInflictorGem" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $IInflictorGem {

 "getDamageResistance"(arg0: $ItemStack$Type, arg1: float): float
 "getAttunedSource"(arg0: $ItemStack$Type): string
 "attuneSource"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $DamageSource$Type): void
}

export namespace $IInflictorGem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInflictorGem$Type = ($IInflictorGem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInflictorGem_ = $IInflictorGem$Type;
}}
declare module "packages/com/rekindled/embers/api/power/$IEmberPacketReceiver" {
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export interface $IEmberPacketReceiver {

 "onReceive"(arg0: $EmberPacketEntity$Type): boolean
 "hasRoomFor"(arg0: double): boolean
}

export namespace $IEmberPacketReceiver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberPacketReceiver$Type = ($IEmberPacketReceiver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberPacketReceiver_ = $IEmberPacketReceiver$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilDisplayRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilDisplayRecipe implements $IDawnstoneAnvilRecipe {
readonly "id": $ResourceLocation
 "outputs": $List<($ItemStack)>
 "inputs": $List<($ItemStack)>
 "ingredient": $Ingredient

constructor(arg0: $ResourceLocation$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: $List$Type<($ItemStack$Type)>, arg3: $Ingredient$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilDisplayRecipe$Type = ($AnvilDisplayRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilDisplayRecipe_ = $AnvilDisplayRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$EmberProjectileEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EmberProjectileEvent extends $Event {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double, ...arg3: ($IProjectilePreset$Type)[])
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double, arg3: $List$Type<($IProjectilePreset$Type)>)

public "getStack"(): $ItemStack
public "getProjectiles"(): $List<($IProjectilePreset)>
public "isCancelable"(): boolean
public "getCharge"(): double
public "getShooter"(): $LivingEntity
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "stack"(): $ItemStack
get "projectiles"(): $List<($IProjectilePreset)>
get "cancelable"(): boolean
get "charge"(): double
get "shooter"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberProjectileEvent$Type = ($EmberProjectileEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberProjectileEvent_ = $EmberProjectileEvent$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$ExcavationBucketsUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $ExcavationBucketsUpgrade extends $DefaultUpgradeProvider {
static "buckets": $BakedModel

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "getLimit"(arg0: $BlockEntity$Type): integer
public "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationBucketsUpgrade$Type = ($ExcavationBucketsUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationBucketsUpgrade_ = $ExcavationBucketsUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/util/$NoiseGenUtil" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $NoiseGenUtil {

constructor()

public static "getSeed"(arg0: integer, arg1: integer, arg2: integer): long
public static "bilinear"(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): float
public static "getNoise"(arg0: long, arg1: integer, arg2: integer): float
public static "fastCos"(arg0: float): float
public static "fastSin"(arg0: float): float
public static "interpolate"(arg0: float, arg1: float, arg2: float): float
public static "getOctave"(arg0: long, arg1: integer, arg2: integer, arg3: integer): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseGenUtil$Type = ($NoiseGenUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoiseGenUtil_ = $NoiseGenUtil$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$IVisuallySplitRecipe, $IVisuallySplitRecipe$Type} from "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe"
import {$AnvilAugmentRecipe$Serializer, $AnvilAugmentRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe$Serializer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilAugmentRecipe implements $IDawnstoneAnvilRecipe, $IVisuallySplitRecipe<($IDawnstoneAnvilRecipe)> {
static readonly "SERIALIZER": $AnvilAugmentRecipe$Serializer
readonly "id": $ResourceLocation
readonly "tool": $Ingredient
readonly "input": $Ingredient
readonly "augment": $IAugment
static "visualRecipes": $List<($IDawnstoneAnvilRecipe)>

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $Ingredient$Type, arg3: $IAugment$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getVisualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "visualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilAugmentRecipe$Type = ($AnvilAugmentRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilAugmentRecipe_ = $AnvilAugmentRecipe$Type;
}}
declare module "packages/com/rekindled/embers/augment/$SuperheaterAugment" {
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $SuperheaterAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onHit"(arg0: $LivingHurtEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuperheaterAugment$Type = ($SuperheaterAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuperheaterAugment_ = $SuperheaterAugment$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$HeatExchangerUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $HeatExchangerUpgrade extends $DefaultUpgradeProvider {
static "multitplier": double
static "bonus": double

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "transformEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatExchangerUpgrade$Type = ($HeatExchangerUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatExchangerUpgrade_ = $HeatExchangerUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$HeatCoilVisualEvent" {
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $HeatCoilVisualEvent extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: $Color$Type, arg2: integer, arg3: float)

public "setColor"(arg0: $Color$Type): void
public "getColor"(): $Color
public "getParticles"(): integer
public "getVerticalSpeed"(): float
public "setVerticalSpeed"(arg0: float): void
public "setParticles"(arg0: integer): void
set "color"(value: $Color$Type)
get "color"(): $Color
get "particles"(): integer
get "verticalSpeed"(): float
set "verticalSpeed"(value: float)
set "particles"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatCoilVisualEvent$Type = ($HeatCoilVisualEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatCoilVisualEvent_ = $HeatCoilVisualEvent$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidExtractorBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidPipeBlockEntityBase, $FluidPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntityBase"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $FluidExtractorBlockEntity extends $FluidPipeBlockEntityBase {
static readonly "MAX_DRAIN": integer
static readonly "MAX_PUSH": integer
 "tank": $FluidTank
 "holder": $LazyOptional<($IFluidHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidExtractorBlockEntity$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidExtractorBlockEntity$Type = ($FluidExtractorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidExtractorBlockEntity_ = $FluidExtractorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberActivatorBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberActivatorBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivatorBlock$Type = ($EmberActivatorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivatorBlock_ = $EmberActivatorBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidHandlerContext, $FluidHandlerContext$Type} from "packages/com/rekindled/embers/recipe/$FluidHandlerContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$GaseousFuelRecipe$Serializer, $GaseousFuelRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe$Serializer"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $GaseousFuelRecipe implements $IGaseousFuelRecipe {
static readonly "SERIALIZER": $GaseousFuelRecipe$Serializer
readonly "id": $ResourceLocation
readonly "input": $FluidIngredient
readonly "burnTime": integer
readonly "powerMultiplier": double

constructor(arg0: $ResourceLocation$Type, arg1: $FluidIngredient$Type, arg2: integer, arg3: double)

public "matches"(arg0: $FluidHandlerContext$Type, arg1: $Level$Type): boolean
public "process"(arg0: $FluidHandlerContext$Type, arg1: integer): integer
public "getDisplayInput"(): $FluidIngredient
public "getPowerMultiplier"(arg0: $FluidHandlerContext$Type): double
public "getDisplayBurnTime"(): integer
public "getBurnTime"(arg0: $FluidHandlerContext$Type): integer
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "getDisplayMultiplier"(): double
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $FluidHandlerContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $FluidHandlerContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayInput"(): $FluidIngredient
get "displayBurnTime"(): integer
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayMultiplier"(): double
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaseousFuelRecipe$Type = ($GaseousFuelRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GaseousFuelRecipe_ = $GaseousFuelRecipe$Type;
}}
declare module "packages/com/rekindled/embers/entity/render/$GlimmerProjectileRenderer" {
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$GlimmerProjectileEntity, $GlimmerProjectileEntity$Type} from "packages/com/rekindled/embers/entity/$GlimmerProjectileEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GlimmerProjectileRenderer extends $EntityRenderer<($GlimmerProjectileEntity)> {
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "render"(arg0: $GlimmerProjectileEntity$Type, arg1: float, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer): void
public "getTextureLocation"(arg0: $GlimmerProjectileEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlimmerProjectileRenderer$Type = ($GlimmerProjectileRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlimmerProjectileRenderer_ = $GlimmerProjectileRenderer$Type;
}}
declare module "packages/com/rekindled/embers/entity/$GlimmerProjectileEntity" {
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SparkParticleOptions, $SparkParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SparkParticleOptions"
import {$EntityDataAccessor, $EntityDataAccessor$Type} from "packages/net/minecraft/network/syncher/$EntityDataAccessor"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$SmokeParticleOptions, $SmokeParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SmokeParticleOptions"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $GlimmerProjectileEntity extends $Projectile {
static readonly "EMBER": $GlowParticleOptions
static readonly "GLIMMER": $SparkParticleOptions
static readonly "SMOKE": $SmokeParticleOptions
static readonly "lifetime": $EntityDataAccessor<(integer)>
 "ownerUUID": $UUID
 "cachedOwner": $Entity
 "leftOwner": boolean
 "hasBeenShot": boolean
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)

public "tick"(): void
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
public "shootFromRotation"(arg0: $Entity$Type, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): void
public "shoot"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
public "m_8060_"(arg0: $BlockHitResult$Type): void
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlimmerProjectileEntity$Type = ($GlimmerProjectileEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlimmerProjectileEntity_ = $GlimmerProjectileEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberSiphonBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EmberSiphonUpgrade, $EmberSiphonUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$EmberSiphonUpgrade"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $EmberSiphonBlockEntity extends $BlockEntity {
 "upgrade": $EmberSiphonUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberSiphonBlockEntity$Type = ($EmberSiphonBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberSiphonBlockEntity_ = $EmberSiphonBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AlchemyRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$AlchemyContext, $AlchemyContext$Type} from "packages/com/rekindled/embers/recipe/$AlchemyContext"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$AlchemyResult, $AlchemyResult$Type} from "packages/com/rekindled/embers/api/misc/$AlchemyResult"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$AlchemyRecipe$Serializer, $AlchemyRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AlchemyRecipe$Serializer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AlchemyRecipe implements $IAlchemyRecipe {
static readonly "SERIALIZER": $AlchemyRecipe$Serializer
readonly "id": $ResourceLocation
readonly "tablet": $Ingredient
readonly "aspects": $ArrayList<($Ingredient)>
readonly "inputs": $ArrayList<($Ingredient)>
readonly "output": $ItemStack
readonly "failure": $ItemStack
 "cachedSeed": long
 "code": $ArrayList<($Ingredient)>

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $ArrayList$Type<($Ingredient$Type)>, arg3: $ArrayList$Type<($Ingredient$Type)>, arg4: $ItemStack$Type, arg5: $ItemStack$Type)

public "matches"(arg0: $AlchemyContext$Type, arg1: $Level$Type): boolean
public "getResult"(arg0: $AlchemyContext$Type): $AlchemyResult
public "getResultItem"(): $ItemStack
public "getCode"(arg0: long): $ArrayList<($Ingredient)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "assemble"(arg0: $AlchemyContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getInputs"(): $List<($Ingredient)>
public "getId"(): $ResourceLocation
public "getfailureItem"(): $ItemStack
public "getAspects"(): $List<($Ingredient)>
public "matchesCorrect"(arg0: $AlchemyContext$Type, arg1: $Level$Type): boolean
public "getCenterInput"(): $Ingredient
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getRemainingItems"(arg0: $AlchemyContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "resultItem"(): $ItemStack
get "serializer"(): $RecipeSerializer<(any)>
get "inputs"(): $List<($Ingredient)>
get "id"(): $ResourceLocation
get "failureItem"(): $ItemStack
get "aspects"(): $List<($Ingredient)>
get "centerInput"(): $Ingredient
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyRecipe$Type = ($AlchemyRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyRecipe_ = $AlchemyRecipe$Type;
}}
declare module "packages/com/rekindled/embers/block/$BinBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $BinBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinBlock$Type = ($BinBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinBlock_ = $BinBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CrystalCellBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $CrystalCellBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "MAX_CAPACITY": integer
 "ticksExisted": long
 "angle": float
 "seed": long
 "renderCapacity": double
 "renderCapacityLast": double
 "capability": $IEmberCapability
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IEmberActivationRecipe
static readonly "SOUND_AMBIENT": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "commonTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CrystalCellBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "renderBoundingBox"(): $AABB
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalCellBlockEntity$Type = ($CrystalCellBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalCellBlockEntity_ = $CrystalCellBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IOrderDestination" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"

export interface $IOrderDestination {

 "order"(arg0: $BlockEntity$Type, arg1: $IFilter$Type, arg2: integer): void
 "resetOrder"(arg0: $BlockEntity$Type): void
}

export namespace $IOrderDestination {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOrderDestination$Type = ($IOrderDestination);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOrderDestination_ = $IOrderDestination$Type;
}}
declare module "packages/com/rekindled/embers/block/$HeatExchangerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $HeatExchangerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "RADIATOR_NORTH_AABB": $VoxelShape
static readonly "RADIATOR_SOUTH_AABB": $VoxelShape
static readonly "RADIATOR_WEST_AABB": $VoxelShape
static readonly "RADIATOR_EAST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatExchangerBlock$Type = ($HeatExchangerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatExchangerBlock_ = $HeatExchangerBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$ComparatorMatch" {
import {$IFilterComparator, $IFilterComparator$Type} from "packages/com/rekindled/embers/api/filter/$IFilterComparator"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnumFilterSetting, $EnumFilterSetting$Type} from "packages/com/rekindled/embers/api/filter/$EnumFilterSetting"

export class $ComparatorMatch implements $IFilterComparator {

constructor(arg0: string, arg1: integer)

public "getName"(): string
public "getPriority"(): integer
public "isBetween"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $EnumFilterSetting$Type): boolean
public "getCompare"(arg0: $ItemStack$Type): integer
public "format"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $EnumFilterSetting$Type, arg3: boolean): string
public "match"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
get "name"(): string
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorMatch$Type = ($ComparatorMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparatorMatch_ = $ComparatorMatch$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IDialEntity" {
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"

export interface $IDialEntity {

 "getUpdatePacket"(arg0: integer): $Packet<($ClientGamePacketListener)>

(arg0: integer): $Packet<($ClientGamePacketListener)>
}

export namespace $IDialEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDialEntity$Type = ($IDialEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDialEntity_ = $IDialEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/$Misc" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$EntityHitResult, $EntityHitResult$Type} from "packages/net/minecraft/world/phys/$EntityHitResult"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"

export class $Misc {
static readonly "LOG_E": double
static "random": $Random
static "horizontals": ($Direction)[]
static readonly "IS_HOLDING_HAMMER": $List<($BiPredicate<($Player), ($InteractionHand)>)>
static readonly "GET_HAMMER_TARGET": $List<($Function<($Player), ($Pair<($BlockPos), ($Direction)>)>)>
static readonly "IS_WEARING_LENS": $List<($Predicate<($Player)>)>
static readonly "GET_EMBER_RESONANCE": $List<($Function<($ItemStack), (double)>)>
static "tagItems": $HashMap<($ResourceLocation), ($Item)>
static "lightstyle": (string)[]

constructor()

public static "useItemOnInventory"(arg0: $IItemHandlerModifiable$Type, arg1: $Level$Type, arg2: $Player$Type, arg3: $InteractionHand$Type): $InteractionResult
public static "getOtherAxis"(arg0: $Direction$Axis$Type, arg1: $Direction$Axis$Type): $Direction$Axis
public static "getDiminishedPower"(arg0: double, arg1: double, arg2: double): double
public static "readNullableFacing"(arg0: integer): $Direction
public static "lerpColor"(arg0: $Color$Type, arg1: $Color$Type, arg2: double): $Color
public static "getPreferredItem"(arg0: ($ItemStack$Type)[]): $ItemStack
public static "drawComponents"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, ...arg4: ($Component$Type)[]): void
public static "isGaseousFluid"(arg0: $FluidStack$Type): boolean
public static "isSideProxyable"(arg0: $BlockState$Type, arg1: $Direction$Type): boolean
public static "getLightBrightness"(arg0: integer, arg1: integer): float
public static "getEntityHitResults"(arg0: $Level$Type, arg1: $Entity$Type, arg2: $Entity$Type, arg3: $Vec3$Type, arg4: $Vec3$Type, arg5: $AABB$Type, arg6: $Predicate$Type<($Entity$Type)>, arg7: float): $List<($EntityHitResult)>
public static "makeRestrictedItemHandler"(arg0: $IItemHandler$Type, arg1: boolean, arg2: boolean): $IItemHandler
public static "makeRestrictedFluidHandler"(arg0: $IFluidHandler$Type, arg1: boolean, arg2: boolean): $IFluidHandler
public static "writeNullableFacing"(arg0: $Direction$Type): integer
public static "sendToTrackingPlayers"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Packet$Type<(any)>): void
public static "getRepairIngredient"(arg0: $Item$Type): $Ingredient
public static "serializeFluidStack"(arg0: $FluidStack$Type): $JsonObject
public static "deserializeFluidStack"(arg0: $JsonObject$Type): $FluidStack
public static "getHammerTarget"(arg0: $Player$Type): $Pair<($BlockPos), ($Direction)>
public static "isHoldingHammer"(arg0: $Player$Type, arg1: $InteractionHand$Type): boolean
public static "isWearingLens"(arg0: $Player$Type): boolean
public static "getTaggedItem"(arg0: $TagKey$Type<($Item$Type)>): $Item
public static "getEmberResonance"(arg0: $ItemStack$Type): double
public static "intColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): integer
public static "intColor"(arg0: integer, arg1: integer, arg2: integer): integer
public static "spawnInventoryInWorld"(arg0: $Level$Type, arg1: double, arg2: double, arg3: double, arg4: $IItemHandler$Type): void
public static "colorFromInt"(arg0: integer): $Vector3f
public static "handToSlot"(arg0: $InteractionHand$Type): $EquipmentSlot
public static "getRecipe"<C extends $Container, T extends $Recipe<(C)>>(arg0: T, arg1: $RecipeType$Type<(any)>, arg2: C, arg3: $Level$Type): T
public static "lerp"(arg0: integer, arg1: integer, arg2: double): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Misc$Type = ($Misc);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Misc_ = $Misc$Type;
}}
declare module "packages/com/rekindled/embers/item/$IEmbersCurioItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$ICurioItem, $ICurioItem$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurioItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"

export interface $IEmbersCurioItem extends $ICurioItem {

 "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
 "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
 "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
 "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
 "unequipSound"(): $SoundEvent
 "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
 "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
 "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
 "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
 "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
 "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
 "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
 "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
 "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "hasCurioCapability"(arg0: $ItemStack$Type): boolean
 "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
 "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
 "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
 "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
 "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
 "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
 "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
 "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
 "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
 "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
 "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
 "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
 "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
 "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
 "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
 "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
 "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
 "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
 "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
 "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
 "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
 "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
 "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
 "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
 "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
 "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
 "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}

export namespace $IEmbersCurioItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmbersCurioItem$Type = ($IEmbersCurioItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmbersCurioItem_ = $IEmbersCurioItem$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersSounds" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SoundDefinitionsProvider, $SoundDefinitionsProvider$Type} from "packages/net/minecraftforge/common/data/$SoundDefinitionsProvider"
import {$SoundDefinition, $SoundDefinition$Type} from "packages/net/minecraftforge/common/data/$SoundDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"

export class $EmbersSounds extends $SoundDefinitionsProvider {
static readonly "ALCHEMY_FAIL": $RegistryObject<($SoundEvent)>
static readonly "ALCHEMY_SUCCESS": $RegistryObject<($SoundEvent)>
static readonly "ALCHEMY_LOOP": $RegistryObject<($SoundEvent)>
static readonly "ALCHEMY_START": $RegistryObject<($SoundEvent)>
static readonly "PEDESTAL_LOOP": $RegistryObject<($SoundEvent)>
static readonly "BEAM_CANNON_FIRE": $RegistryObject<($SoundEvent)>
static readonly "BEAM_CANNON_HIT": $RegistryObject<($SoundEvent)>
static readonly "CRYSTAL_CELL_LOOP": $RegistryObject<($SoundEvent)>
static readonly "CRYSTAL_CELL_GROW": $RegistryObject<($SoundEvent)>
static readonly "GENERATOR_LOOP": $RegistryObject<($SoundEvent)>
static readonly "ACTIVATOR": $RegistryObject<($SoundEvent)>
static readonly "PRESSURE_REFINERY": $RegistryObject<($SoundEvent)>
static readonly "IGNEM_REACTOR": $RegistryObject<($SoundEvent)>
static readonly "BORE_START": $RegistryObject<($SoundEvent)>
static readonly "BORE_STOP": $RegistryObject<($SoundEvent)>
static readonly "BORE_LOOP": $RegistryObject<($SoundEvent)>
static readonly "BORE_LOOP_MINE": $RegistryObject<($SoundEvent)>
static readonly "BORE_LOOP_SUPERSPEED": $RegistryObject<($SoundEvent)>
static readonly "BORE_LOOP_MINE_SUPERSPEED": $RegistryObject<($SoundEvent)>
static readonly "CATALYTIC_PLUG_START": $RegistryObject<($SoundEvent)>
static readonly "CATALYTIC_PLUG_STOP": $RegistryObject<($SoundEvent)>
static readonly "CATALYTIC_PLUG_LOOP": $RegistryObject<($SoundEvent)>
static readonly "CATALYTIC_PLUG_LOOP_READY": $RegistryObject<($SoundEvent)>
static readonly "STAMPER_DOWN": $RegistryObject<($SoundEvent)>
static readonly "STAMPER_UP": $RegistryObject<($SoundEvent)>
static readonly "HEATCOIL_HIGH": $RegistryObject<($SoundEvent)>
static readonly "HEATCOIL_MID": $RegistryObject<($SoundEvent)>
static readonly "HEATCOIL_LOW": $RegistryObject<($SoundEvent)>
static readonly "HEATCOIL_COOK": $RegistryObject<($SoundEvent)>
static readonly "PLINTH_LOOP": $RegistryObject<($SoundEvent)>
static readonly "MELTER_LOOP": $RegistryObject<($SoundEvent)>
static readonly "MIXER_LOOP": $RegistryObject<($SoundEvent)>
static readonly "COPPER_CHARGER_LOOP": $RegistryObject<($SoundEvent)>
static readonly "COPPER_CHARGER_SIPHON_LOOP": $RegistryObject<($SoundEvent)>
static readonly "INJECTOR_LOOP": $RegistryObject<($SoundEvent)>
static readonly "METAL_SEED_LOOP": $RegistryObject<($SoundEvent)>
static readonly "METAL_SEED_PING": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_FAIL": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_SUCCESS": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_LOOP": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_START": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_OPEN": $RegistryObject<($SoundEvent)>
static readonly "INFERNO_FORGE_CLOSE": $RegistryObject<($SoundEvent)>
static readonly "FIELD_CHART_LOOP": $RegistryObject<($SoundEvent)>
static readonly "ENTROPIC_ENUMERATOR_TURN": $RegistryObject<($SoundEvent)>
static readonly "EMBER_EMIT": $RegistryObject<($SoundEvent)>
static readonly "EMBER_EMIT_BIG": $RegistryObject<($SoundEvent)>
static readonly "EMBER_RECEIVE": $RegistryObject<($SoundEvent)>
static readonly "EMBER_RECEIVE_BIG": $RegistryObject<($SoundEvent)>
static readonly "EMBER_RELAY": $RegistryObject<($SoundEvent)>
static readonly "STEAM_ENGINE_START_STEAM": $RegistryObject<($SoundEvent)>
static readonly "STEAM_ENGINE_START_BURN": $RegistryObject<($SoundEvent)>
static readonly "STEAM_ENGINE_LOOP_STEAM": $RegistryObject<($SoundEvent)>
static readonly "STEAM_ENGINE_LOOP_BURN": $RegistryObject<($SoundEvent)>
static readonly "STEAM_ENGINE_STOP": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_RUPTURE": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_LOOP_SLOW": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_LOOP_MID": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_LOOP_FAST": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_PRESSURE_LOW": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_PRESSURE_MID": $RegistryObject<($SoundEvent)>
static readonly "MINI_BOILER_PRESSURE_HIGH": $RegistryObject<($SoundEvent)>
static readonly "PUMP_SLOW": $RegistryObject<($SoundEvent)>
static readonly "PUMP_MID": $RegistryObject<($SoundEvent)>
static readonly "PUMP_FAST": $RegistryObject<($SoundEvent)>
static readonly "PIPE_CONNECT": $RegistryObject<($SoundEvent)>
static readonly "PIPE_DISCONNECT": $RegistryObject<($SoundEvent)>
static readonly "PIPE_VENT_LOOP": $RegistryObject<($SoundEvent)>
static readonly "FIREBALL_BIG": $RegistryObject<($SoundEvent)>
static readonly "FIREBALL_BIG_HIT": $RegistryObject<($SoundEvent)>
static readonly "FIREBALL": $RegistryObject<($SoundEvent)>
static readonly "FIREBALL_HIT": $RegistryObject<($SoundEvent)>
static readonly "BLAZING_RAY_FIRE": $RegistryObject<($SoundEvent)>
static readonly "BLAZING_RAY_EMPTY": $RegistryObject<($SoundEvent)>
static readonly "CINDER_STAFF_CHARGE": $RegistryObject<($SoundEvent)>
static readonly "CINDER_STAFF_FAIL": $RegistryObject<($SoundEvent)>
static readonly "CINDER_STAFF_LOOP": $RegistryObject<($SoundEvent)>
static readonly "ULTRASYD_7F_PATTERNS": $RegistryObject<($SoundEvent)>
static readonly "EXPLOSION_CHARM_ABSORB": $RegistryObject<($SoundEvent)>
static readonly "EXPLOSION_CHARM_RECHARGE": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_AMULET_BURN": $RegistryObject<($SoundEvent)>
static readonly "HEATED_ITEM_LEVELUP": $RegistryObject<($SoundEvent)>
static readonly "RESONATING_BELL": $RegistryObject<($SoundEvent)>
static readonly "CINDER_JET": $RegistryObject<($SoundEvent)>
static readonly "INFLICTOR_GEM": $RegistryObject<($SoundEvent)>
static readonly "METALLURGIC_DUST": $RegistryObject<($SoundEvent)>
static readonly "METALLURGIC_DUST_FAIL": $RegistryObject<($SoundEvent)>
static readonly "CODEX_OPEN": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CLOSE": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CATEGORY_OPEN": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CATEGORY_CLOSE": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CATEGORY_SELECT": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CATEGORY_UNSELECT": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CATEGORY_SWITCH": $RegistryObject<($SoundEvent)>
static readonly "CODEX_PAGE_OPEN": $RegistryObject<($SoundEvent)>
static readonly "CODEX_PAGE_CLOSE": $RegistryObject<($SoundEvent)>
static readonly "CODEX_PAGE_SWITCH": $RegistryObject<($SoundEvent)>
static readonly "CODEX_CHECK": $RegistryObject<($SoundEvent)>
static readonly "CODEX_UNCHECK": $RegistryObject<($SoundEvent)>
static readonly "CODEX_LOCK": $RegistryObject<($SoundEvent)>
static readonly "CODEX_UNLOCK": $RegistryObject<($SoundEvent)>
static readonly "BAUBLE_EQUIP": $RegistryObject<($SoundEvent)>
static readonly "BAUBLE_UNEQUIP": $RegistryObject<($SoundEvent)>
static readonly "TYRFING_HIT": $RegistryObject<($SoundEvent)>
static readonly "SHIFTING_SCALES_BREAK": $RegistryObject<($SoundEvent)>
static readonly "WINDING_GEARS_SPRING": $RegistryObject<($SoundEvent)>
static readonly "ANCIENT_GOLEM_STEP": $RegistryObject<($SoundEvent)>
static readonly "ANCIENT_GOLEM_HURT": $RegistryObject<($SoundEvent)>
static readonly "ANCIENT_GOLEM_PUNCH": $RegistryObject<($SoundEvent)>
static readonly "ANCIENT_GOLEM_DEATH": $RegistryObject<($SoundEvent)>
static readonly "MULTIBLOCK_PACK": $RegistryObject<($SoundEvent)>
static readonly "MULTIBLOCK_UNPACK": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE_BREAK": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE_STEP": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE_PLACE": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE_HIT": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE_FALL": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_STONE_BREAK": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_STONE_STEP": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_STONE_PLACE": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_STONE_HIT": $RegistryObject<($SoundEvent)>
static readonly "ASHEN_STONE_FALL": $RegistryObject<($SoundEvent)>
static readonly "SOLID_METAL_BREAK": $RegistryObject<($SoundEvent)>
static readonly "SOLID_METAL_PLACE": $RegistryObject<($SoundEvent)>
static readonly "MACHINE_BREAK": $RegistryObject<($SoundEvent)>
static readonly "MACHINE_PLACE": $RegistryObject<($SoundEvent)>
static readonly "CAMINITE": $SoundType
static readonly "ASHEN_STONE": $SoundType
static readonly "LIGHT_METAL": $SoundType
static readonly "SOLID_METAL": $SoundType
static readonly "MACHINE": $SoundType
static readonly "LIGHT_MACHINE": $SoundType
static readonly "MULTIBLOCK_CENTER": $SoundType
static readonly "CAMINITE_MULTIBLOCK_CENTER": $SoundType
static readonly "ARCHAIC_MULTIBLOCK_CENTER": $SoundType
static readonly "MULTIBLOCK_EXTRA": $SoundType
static readonly "CAMINITE_MULTIBLOCK_EXTRA": $SoundType
static readonly "ARCHAIC_MULTIBLOCK_EXTRA": $SoundType

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type)

public static "init"(): void
public "resource"(arg0: string): $ResourceLocation
public static "registerSound"(arg0: string): $RegistryObject<($SoundEvent)>
public static "playItemSoundClient"(arg0: $LivingEntity$Type, arg1: $Item$Type, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float): void
public static "playItemSound"(arg0: $LivingEntity$Type, arg1: $Item$Type, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float): void
public "registerSounds"(): void
public "withSubtitle"(arg0: $RegistryObject$Type<($SoundEvent$Type)>, arg1: $SoundDefinition$Type): void
public static "playMachineSound"(arg0: $BlockEntity$Type, arg1: integer, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersSounds$Type = ($EmbersSounds);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersSounds_ = $EmbersSounds$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$MiniBoilerUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $MiniBoilerUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiniBoilerUpgrade$Type = ($MiniBoilerUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiniBoilerUpgrade_ = $MiniBoilerUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$StamperBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IStampingRecipe, $IStampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IStampingRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMechanicallyPowered, $IMechanicallyPowered$Type} from "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $StamperBlockEntity extends $BlockEntity implements $IMechanicallyPowered, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "EMBER_COST": double
static readonly "STAMP_TIME": integer
static readonly "RETRACT_TIME": integer
 "capability": $IEmberCapability
 "prevPowered": boolean
 "powered": boolean
 "ticksExisted": long
 "stamp": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IStampingRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $StamperBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $StamperBlockEntity$Type): void
public "getMechanicalSpeed"(arg0: double): double
public "getMinimumPower"(): double
public "getNominalSpeed"(): double
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getStandardPowerRatio"(): double
public "getMaximumPower"(): double
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "renderBoundingBox"(): $AABB
get "minimumPower"(): double
get "nominalSpeed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "standardPowerRatio"(): double
get "maximumPower"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StamperBlockEntity$Type = ($StamperBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StamperBlockEntity_ = $StamperBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$AlchemyResultEvent" {
import {$AlchemyResult, $AlchemyResult$Type} from "packages/com/rekindled/embers/api/misc/$AlchemyResult"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $AlchemyResultEvent extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: $IAlchemyRecipe$Type, arg2: $AlchemyResult$Type, arg3: integer)

public "setResult"(arg0: $AlchemyResult$Type): void
public "getResult"(): $AlchemyResult
public "isFailure"(): boolean
public "setFailure"(arg0: boolean): void
public "setRecipe"(arg0: $IAlchemyRecipe$Type): void
public "setResultStack"(arg0: $ItemStack$Type): void
public "getResultStack"(): $ItemStack
public "setconsumeAmount"(arg0: integer): void
public "getConsumeAmount"(): integer
public "getRecipe"(): $IAlchemyRecipe
set "result"(value: $AlchemyResult$Type)
get "result"(): $AlchemyResult
get "failure"(): boolean
set "failure"(value: boolean)
set "recipe"(value: $IAlchemyRecipe$Type)
set "resultStack"(value: $ItemStack$Type)
get "resultStack"(): $ItemStack
set "consumeAmount"(value: integer)
get "consumeAmount"(): integer
get "recipe"(): $IAlchemyRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyResultEvent$Type = ($AlchemyResultEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyResultEvent_ = $AlchemyResultEvent$Type;
}}
declare module "packages/com/rekindled/embers/block/$HearthCoilBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $HearthCoilBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HearthCoilBlock$Type = ($HearthCoilBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HearthCoilBlock_ = $HearthCoilBlock$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberBulbItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$EmberStorageItem, $EmberStorageItem$Type} from "packages/com/rekindled/embers/item/$EmberStorageItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberBulbItem extends $EmberStorageItem implements $IEmbersCurioItem {
static readonly "CAPACITY": double
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getCapacity"(): double
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
public "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
get "capacity"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBulbItem$Type = ($EmberBulbItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBulbItem_ = $EmberBulbItem$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersItemTags" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$TagsProvider$TagLookup, $TagsProvider$TagLookup$Type} from "packages/net/minecraft/data/tags/$TagsProvider$TagLookup"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RegistryManager$ToolSet, $RegistryManager$ToolSet$Type} from "packages/com/rekindled/embers/$RegistryManager$ToolSet"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ItemTagsProvider, $ItemTagsProvider$Type} from "packages/net/minecraft/data/tags/$ItemTagsProvider"

export class $EmbersItemTags extends $ItemTagsProvider {
static readonly "PIPE_UNCLOGGER": $TagKey<($Item)>
static readonly "MATERIA_BLACKLIST": $TagKey<($Item)>
static readonly "BREAKDOWN_BLACKLIST": $TagKey<($Item)>
static readonly "REPAIR_BLACKLIST": $TagKey<($Item)>
static readonly "TINKER_HAMMER": $TagKey<($Item)>
static readonly "INSCRIBABLE_PAPER": $TagKey<($Item)>
static readonly "TOOLS_HAMMERS": $TagKey<($Item)>
static readonly "NORMAL_WALK_SPEED_TOOL": $TagKey<($Item)>
static readonly "AUGMENTABLE": $TagKey<($Item)>
static readonly "AUGMENTABLE_TOOLS_AND_ARMORS": $TagKey<($Item)>
static readonly "AUGMENTABLE_TOOLS": $TagKey<($Item)>
static readonly "AUGMENTABLE_PROJECTILE_WEAPONS": $TagKey<($Item)>
static readonly "AUGMENTABLE_ARMORS": $TagKey<($Item)>
static readonly "AUGMENTABLE_HELMETS": $TagKey<($Item)>
static readonly "AUGMENTABLE_CHESTPLATES": $TagKey<($Item)>
static readonly "AUGMENTABLE_LEGGINGS": $TagKey<($Item)>
static readonly "AUGMENTABLE_BOOTS": $TagKey<($Item)>
static readonly "TINKER_LENS_HELMETS": $TagKey<($Item)>
static readonly "ASPECTUS": $TagKey<($Item)>
static readonly "IRON_ASPECTUS": $TagKey<($Item)>
static readonly "COPPER_ASPECTUS": $TagKey<($Item)>
static readonly "LEAD_ASPECTUS": $TagKey<($Item)>
static readonly "SILVER_ASPECTUS": $TagKey<($Item)>
static readonly "DAWNSTONE_ASPECTUS": $TagKey<($Item)>
static readonly "ASHEN_STONE": $TagKey<($Item)>
static readonly "PLATES": $TagKey<($Item)>
static readonly "IRON_PLATE": $TagKey<($Item)>
static readonly "COPPER_PLATE": $TagKey<($Item)>
static readonly "COPPER_NUGGET": $TagKey<($Item)>
static readonly "LEAD_ORE": $TagKey<($Item)>
static readonly "RAW_LEAD_BLOCK": $TagKey<($Item)>
static readonly "LEAD_BLOCK": $TagKey<($Item)>
static readonly "RAW_LEAD": $TagKey<($Item)>
static readonly "LEAD_INGOT": $TagKey<($Item)>
static readonly "LEAD_NUGGET": $TagKey<($Item)>
static readonly "LEAD_PLATE": $TagKey<($Item)>
static readonly "SILVER_ORE": $TagKey<($Item)>
static readonly "RAW_SILVER_BLOCK": $TagKey<($Item)>
static readonly "SILVER_BLOCK": $TagKey<($Item)>
static readonly "RAW_SILVER": $TagKey<($Item)>
static readonly "SILVER_INGOT": $TagKey<($Item)>
static readonly "SILVER_NUGGET": $TagKey<($Item)>
static readonly "SILVER_PLATE": $TagKey<($Item)>
static readonly "DAWNSTONE_BLOCK": $TagKey<($Item)>
static readonly "DAWNSTONE_INGOT": $TagKey<($Item)>
static readonly "DAWNSTONE_NUGGET": $TagKey<($Item)>
static readonly "DAWNSTONE_PLATE": $TagKey<($Item)>
static readonly "NICKEL_INGOT": $TagKey<($Item)>
static readonly "TIN_INGOT": $TagKey<($Item)>
static readonly "ALUMINUM_INGOT": $TagKey<($Item)>
static readonly "ZINC_INGOT": $TagKey<($Item)>
static readonly "NICKEL_NUGGET": $TagKey<($Item)>
static readonly "TIN_NUGGET": $TagKey<($Item)>
static readonly "ALUMINUM_NUGGET": $TagKey<($Item)>
static readonly "ZINC_NUGGET": $TagKey<($Item)>
static readonly "CAMINITE_BRICK": $TagKey<($Item)>
static readonly "ARCHAIC_BRICK": $TagKey<($Item)>
static readonly "ASH_DUST": $TagKey<($Item)>
static readonly "WORLD_BOTTOM": $TagKey<($Item)>
static readonly "SNOW": $TagKey<($Item)>
static readonly "PRISTINE_COPPER": $TagKey<($Item)>
static readonly "EXPOSED_COPPER": $TagKey<($Item)>
static readonly "WEATHERED_COPPER": $TagKey<($Item)>
static readonly "OXIDIZED_COPPER": $TagKey<($Item)>
static readonly "CRYSTAL_SEEDS": $TagKey<($Item)>
static readonly "COPPER_SEED": $TagKey<($Item)>
static readonly "IRON_SEED": $TagKey<($Item)>
static readonly "GOLD_SEED": $TagKey<($Item)>
static readonly "LEAD_SEED": $TagKey<($Item)>
static readonly "SILVER_SEED": $TagKey<($Item)>
static readonly "NICKEL_SEED": $TagKey<($Item)>
static readonly "TIN_SEED": $TagKey<($Item)>
static readonly "ALUMINUM_SEED": $TagKey<($Item)>
static readonly "ZINC_SEED": $TagKey<($Item)>
static readonly "PLATINUM_SEED": $TagKey<($Item)>
static readonly "URANIUM_SEED": $TagKey<($Item)>
static readonly "DAWNSTONE_SEED": $TagKey<($Item)>
static readonly "ANY_CURIO": $TagKey<($Item)>
static readonly "RING_CURIO": $TagKey<($Item)>
static readonly "BELT_CURIO": $TagKey<($Item)>
static readonly "AMULET_CURIO": $TagKey<($Item)>
static readonly "BODY_CURIO": $TagKey<($Item)>
static readonly "CHARM_CURIO": $TagKey<($Item)>

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $CompletableFuture$Type<($TagsProvider$TagLookup$Type<($Block$Type)>)>, arg3: $ExistingFileHelper$Type)

public "toolTags"(arg0: $RegistryManager$ToolSet$Type): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersItemTags$Type = ($EmbersItemTags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersItemTags_ = $EmbersItemTags$Type;
}}
declare module "packages/com/rekindled/embers/util/$MatchCurioLootCondition" {
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition$Builder, $LootItemCondition$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition$Builder"
import {$LootContextParam, $LootContextParam$Type} from "packages/net/minecraft/world/level/storage/loot/parameters/$LootContextParam"
import {$ItemPredicate$Builder, $ItemPredicate$Builder$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate$Builder"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ValidationContext, $ValidationContext$Type} from "packages/net/minecraft/world/level/storage/loot/$ValidationContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"

export class $MatchCurioLootCondition implements $LootItemCondition {
static readonly "LOOT_CONDITION_TYPE": $LootItemConditionType

constructor(arg0: $ItemPredicate$Type)

public "test"(arg0: $LootContext$Type): boolean
public "getType"(): $LootItemConditionType
public "getReferencedContextParams"(): $Set<($LootContextParam<(any)>)>
public static "curioMatches"(arg0: $ItemPredicate$Builder$Type): $LootItemCondition$Builder
public "validate"(arg0: $ValidationContext$Type): void
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public "negate"(): $Predicate<($LootContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
public "applyLootHandler"(context: $LootContext$Type, loot: $List$Type<($ItemStack$Type)>): boolean
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchCurioLootCondition$Type = ($MatchCurioLootCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MatchCurioLootCondition_ = $MatchCurioLootCondition$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$ExcavationRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ExcavationRecipe, $ExcavationRecipe$Type} from "packages/com/rekindled/embers/recipe/$ExcavationRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ExcavationRecipe$Serializer implements $RecipeSerializer<($ExcavationRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $ExcavationRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $ExcavationRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $ExcavationRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $ExcavationRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationRecipe$Serializer$Type = ($ExcavationRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationRecipe$Serializer_ = $ExcavationRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntityBase" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IFluidPipePriority, $IFluidPipePriority$Type} from "packages/com/rekindled/embers/api/tile/$IFluidPipePriority"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PipeBlockEntityBase, $PipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $FluidPipeBlockEntityBase extends $PipeBlockEntityBase implements $IFluidPipePriority {
static readonly "MAX_PUSH": integer
 "tank": $FluidTank
 "holder": $LazyOptional<($IFluidHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "getPriority"(arg0: $Direction$Type): integer
public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidPipeBlockEntityBase$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidPipeBlockEntityBase$Type): void
public "writeTank"(arg0: $CompoundTag$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlockEntityBase$Type = ($FluidPipeBlockEntityBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeBlockEntityBase_ = $FluidPipeBlockEntityBase$Type;
}}
declare module "packages/com/rekindled/embers/worldgen/$CaveStructurePiece" {
import {$BoundingBox, $BoundingBox$Type} from "packages/net/minecraft/world/level/levelgen/structure/$BoundingBox"
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ChunkGenerator, $ChunkGenerator$Type} from "packages/net/minecraft/world/level/chunk/$ChunkGenerator"
import {$StructurePoolElement, $StructurePoolElement$Type} from "packages/net/minecraft/world/level/levelgen/structure/pools/$StructurePoolElement"
import {$WorldGenLevel, $WorldGenLevel$Type} from "packages/net/minecraft/world/level/$WorldGenLevel"
import {$StructureTemplateManager, $StructureTemplateManager$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplateManager"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Structure$GenerationContext, $Structure$GenerationContext$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$GenerationContext"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$StructureManager, $StructureManager$Type} from "packages/net/minecraft/world/level/$StructureManager"
import {$PoolElementStructurePiece, $PoolElementStructurePiece$Type} from "packages/net/minecraft/world/level/levelgen/structure/$PoolElementStructurePiece"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CaveStructurePiece extends $PoolElementStructurePiece {
 "context": $Structure$GenerationContext
 "maxHeight": integer

constructor(arg0: $StructureTemplateManager$Type, arg1: $StructurePoolElement$Type, arg2: $BlockPos$Type, arg3: integer, arg4: $Rotation$Type, arg5: $BoundingBox$Type, arg6: $Structure$GenerationContext$Type, arg7: integer)

public "postProcess"(arg0: $WorldGenLevel$Type, arg1: $StructureManager$Type, arg2: $ChunkGenerator$Type, arg3: $RandomSource$Type, arg4: $BoundingBox$Type, arg5: $ChunkPos$Type, arg6: $BlockPos$Type): void
public static "isValidBiome"(arg0: $BlockPos$Type, arg1: $Structure$GenerationContext$Type): boolean
public static "getCaveFloor"(arg0: $BlockPos$Type, arg1: integer, arg2: $WorldGenLevel$Type, arg3: $Structure$GenerationContext$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveStructurePiece$Type = ($CaveStructurePiece);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaveStructurePiece_ = $CaveStructurePiece$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberDialBlockEntity" {
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IDialEntity, $IDialEntity$Type} from "packages/com/rekindled/embers/api/tile/$IDialEntity"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberDialBlockEntity extends $BlockEntity implements $IDialEntity {
 "ember": double
 "capacity": double
 "display": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getUpdatePacket"(arg0: integer): $Packet<($ClientGamePacketListener)>
public "load"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberDialBlockEntity$Type = ($EmberDialBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberDialBlockEntity_ = $EmberDialBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/render/$FluidCuboid$FluidFace" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $FluidCuboid$FluidFace extends $Record {
static readonly "NORMAL": $FluidCuboid$FluidFace
static readonly "DOWN": $FluidCuboid$FluidFace

constructor(isFlowing: boolean, rotation: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "rotation"(): integer
public "isFlowing"(): boolean
get "flowing"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidCuboid$FluidFace$Type = ($FluidCuboid$FluidFace);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidCuboid$FluidFace_ = $FluidCuboid$FluidFace$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CharInstillerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$CharInstillerUpgrade, $CharInstillerUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$CharInstillerUpgrade"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CharInstillerBlockEntity extends $BlockEntity {
 "upgrade": $CharInstillerUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharInstillerBlockEntity$Type = ($CharInstillerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharInstillerBlockEntity_ = $CharInstillerBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$EffectArea" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EffectArea implements $IProjectileEffect {

constructor(arg0: $IProjectileEffect$Type, arg1: double, arg2: boolean)

public "getRadius"(): double
public "setRadius"(arg0: double): void
public "onFizzle"(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $IProjectilePreset$Type): void
public "setEffect"(arg0: $IProjectileEffect$Type): void
public "onHit"(arg0: $Level$Type, arg1: $HitResult$Type, arg2: $IProjectilePreset$Type): void
public "getEffect"(): $IProjectileEffect
public "setActivateOnFizzle"(arg0: boolean): void
public "doesActivateOnFizzle"(): boolean
public "onBlockImpact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IProjectilePreset$Type): void
public "onEntityImpact"(arg0: $Entity$Type, arg1: $IProjectilePreset$Type): void
get "radius"(): double
set "radius"(value: double)
set "effect"(value: $IProjectileEffect$Type)
get "effect"(): $IProjectileEffect
set "activateOnFizzle"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectArea$Type = ($EffectArea);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectArea_ = $EffectArea$Type;
}}
declare module "packages/com/rekindled/embers/entity/$AncientGolemEntity" {
import {$GoalSelector, $GoalSelector$Type} from "packages/net/minecraft/world/entity/ai/goal/$GoalSelector"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$WalkAnimationState, $WalkAnimationState$Type} from "packages/net/minecraft/world/entity/$WalkAnimationState"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$PathNavigation, $PathNavigation$Type} from "packages/net/minecraft/world/entity/ai/navigation/$PathNavigation"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$AttributeSupplier$Builder, $AttributeSupplier$Builder$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeSupplier$Builder"
import {$AttributeMap, $AttributeMap$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeMap"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Monster, $Monster$Type} from "packages/net/minecraft/world/entity/monster/$Monster"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AncientGolemEntity extends $Monster {
 "entityJs$builder": any
static readonly "MAX_WEARING_ARMOR_CHANCE": float
static readonly "MAX_PICKUP_LOOT_CHANCE": float
static readonly "MAX_ENCHANTED_ARMOR_CHANCE": float
static readonly "MAX_ENCHANTED_WEAPON_CHANCE": float
static readonly "LEASH_TAG": string
static readonly "DEFAULT_EQUIPMENT_DROP_CHANCE": float
static readonly "PRESERVE_ITEM_DROP_CHANCE": integer
static readonly "UPDATE_GOAL_SELECTOR_EVERY_N_TICKS": integer
 "ambientSoundTime": integer
 "navigation": $PathNavigation
readonly "goalSelector": $GoalSelector
readonly "targetSelector": $GoalSelector
 "leashInfoTag": $CompoundTag
static readonly "HAND_SLOTS": integer
static readonly "ARMOR_SLOTS": integer
static readonly "EQUIPMENT_SLOT_OFFSET": integer
static readonly "ARMOR_SLOT_OFFSET": integer
static readonly "SWING_DURATION": integer
static readonly "PLAYER_HURT_EXPERIENCE_TIME": integer
static readonly "MIN_MOVEMENT_DISTANCE": double
static readonly "DEFAULT_BASE_GRAVITY": double
static readonly "DEATH_DURATION": integer
static readonly "USE_ITEM_INTERVAL": integer
static readonly "EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT": float
 "attributes": $AttributeMap
readonly "activeEffects": $Map<($MobEffect), ($MobEffectInstance)>
 "swinging": boolean
 "swingingArm": $InteractionHand
 "swingTime": integer
 "removeArrowTime": integer
 "removeStingerTime": integer
 "hurtTime": integer
 "hurtDuration": integer
 "deathTime": integer
 "oAttackAnim": float
 "attackAnim": float
 "attackStrengthTicker": integer
readonly "walkAnimation": $WalkAnimationState
readonly "invulnerableDuration": integer
readonly "timeOffs": float
readonly "rotA": float
 "yBodyRot": float
 "yBodyRotO": float
 "yHeadRot": float
 "yHeadRotO": float
 "dead": boolean
 "jumping": boolean
 "xxa": float
 "yya": float
 "zza": float
 "effectsDirty": boolean
 "noJumpDelay": integer
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)

public static "createAttributes"(): $AttributeSupplier$Builder
public "tick"(): void
public "doHurtTarget"(arg0: $Entity$Type): boolean
public "lithiumOnEquipmentChanged"(): void
public "tdv$getDynamicLightX"(): double
public "tdv$getDynamicLightZ"(): double
public "tdv$getDynamicLightWorld"(): $Level
public "tdv$shouldUpdateDynamicLight"(): boolean
public "tdv$resetDynamicLight"(): void
public "tdv$getDynamicLightY"(): double
public "tdv$lambdynlights$scheduleTrackedChunksRebuild"(arg0: $LevelRenderer$Type): void
public "tdv$lambdynlights$updateDynamicLight"(arg0: $LevelRenderer$Type): boolean
public "getCachedFeetBlockState"(): $BlockState
get "cachedFeetBlockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AncientGolemEntity$Type = ($AncientGolemEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AncientGolemEntity_ = $AncientGolemEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IProjectileWeapon" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IProjectileWeapon {

}

export namespace $IProjectileWeapon {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProjectileWeapon$Type = ($IProjectileWeapon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProjectileWeapon_ = $IProjectileWeapon$Type;
}}
declare module "packages/com/rekindled/embers/research/$ResearchCategory" {
import {$LinkedList, $LinkedList$Type} from "packages/java/util/$LinkedList"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Vec2i, $Vec2i$Type} from "packages/com/rekindled/embers/util/$Vec2i"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ResearchCategory {
static readonly "NO_PREREQUISITES": $ArrayList<($ResearchBase)>
 "name": string
 "u": double
 "v": double
 "texture": $ResourceLocation
 "background": $ResourceLocation
 "researches": $ArrayList<($ResearchBase)>
 "prerequisites": $ArrayList<($ResearchBase)>
 "goodLocations": $LinkedList<($Vec2i)>

constructor(arg0: string, arg1: $ResourceLocation$Type, arg2: double, arg3: double)
constructor(arg0: string, arg1: double, arg2: double)
constructor(arg0: string, arg1: double)

public "getName"(): string
public "getIconU"(): double
public "getIconV"(): double
public "pushGoodLocations"(...arg0: ($Vec2i$Type)[]): $ResearchCategory
public "addPrerequisite"(arg0: $ResearchBase$Type): $ResearchCategory
public "popGoodLocation"(): $Vec2i
public "getPrerequisites"(): $List<($ResearchBase)>
public "findByTag"(arg0: string, arg1: $Map$Type<($ResearchBase$Type), (integer)>, arg2: $Set$Type<($ResearchCategory$Type)>): void
public "isChecked"(): boolean
public "getAllResearch"(arg0: $Set$Type<($ResearchBase$Type)>): void
public "getTooltip"(arg0: boolean): $List<($Component)>
public "addResearch"(arg0: $ResearchBase$Type): $ResearchCategory
public "getIndexTexture"(): $ResourceLocation
public "getBackgroundTexture"(): $ResourceLocation
get "name"(): string
get "iconU"(): double
get "iconV"(): double
get "prerequisites"(): $List<($ResearchBase)>
get "checked"(): boolean
get "indexTexture"(): $ResourceLocation
get "backgroundTexture"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchCategory$Type = ($ResearchCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchCategory_ = $ResearchCategory$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MechanicalPumpBottomBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMechanicallyPowered, $IMechanicallyPowered$Type} from "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $MechanicalPumpBottomBlockEntity extends $BlockEntity implements $IMechanicallyPowered, $IExtraDialInformation {
 "capability": $IEmberCapability
static readonly "EMBER_COST": double
 "progress": integer
 "totalProgress": integer
 "lastProgress": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MechanicalPumpBottomBlockEntity$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MechanicalPumpBottomBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getMechanicalSpeed"(arg0: double): double
public "getMinimumPower"(): double
public "getNominalSpeed"(): double
public "attemptPump"(arg0: $BlockPos$Type): boolean
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getStandardPowerRatio"(): double
public "getMaximumPower"(): double
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
get "renderBoundingBox"(): $AABB
get "minimumPower"(): double
get "nominalSpeed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "standardPowerRatio"(): double
get "maximumPower"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPumpBottomBlockEntity$Type = ($MechanicalPumpBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPumpBottomBlockEntity_ = $MechanicalPumpBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CrystalSeedBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IEmberInjectable, $IEmberInjectable$Type} from "packages/com/rekindled/embers/api/tile/$IEmberInjectable"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CrystalSeedBlockEntity extends $BlockEntity implements $IEmberInjectable, $ISoundController, $IExtraCapabilityInformation {
 "type": string
 "texture": $ResourceLocation
 "tag": $TagKey<($Item)>
 "willSpawn": (boolean)[]
 "size": integer
 "xp": integer
static "bonusParts": integer
 "ticksExisted": integer
static readonly "SOUND_AMBIENT": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type, arg2: string)
constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: string)

public "setSize"(arg0: integer): void
public static "getLevel"(arg0: integer): integer
public "setChanged"(): void
public "inject"(arg0: $BlockEntity$Type, arg1: double): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CrystalSeedBlockEntity$Type): void
public static "getSpawns"(arg0: integer): (boolean)[]
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public static "getLevelBonus"(arg0: integer): integer
public static "getSpawnString"(arg0: (boolean)[]): string
public "stopSound"(arg0: integer): void
public "addExperience"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "getRequiredExperienceForLevel"(arg0: integer): integer
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
public "loadSpawnsFromString"(arg0: string): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CrystalSeedBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "isValid"(): boolean
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
set "size"(value: integer)
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalSeedBlockEntity$Type = ($CrystalSeedBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalSeedBlockEntity_ = $CrystalSeedBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$CharInstillerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CharInstillerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharInstillerBlock$Type = ($CharInstillerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharInstillerBlock_ = $CharInstillerBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoringRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$BoringRecipe, $BoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoringRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $BoringRecipe$Serializer implements $RecipeSerializer<($BoringRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $BoringRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $BoringRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $BoringRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $BoringRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoringRecipe$Serializer$Type = ($BoringRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoringRecipe$Serializer_ = $BoringRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/block/$FieldChartBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $FieldChartBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "INVERTED": $BooleanProperty
static readonly "CHART_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldChartBlock$Type = ($FieldChartBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldChartBlock_ = $FieldChartBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$FieldChartEdgeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $FieldChartEdgeBlock extends $MechEdgeBlockBase {
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldChartEdgeBlock$Type = ($FieldChartEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldChartEdgeBlock_ = $FieldChartEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$FieldChartBlockEntityRenderer$IChartSource" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FieldChartBlockEntityRenderer$IChartSource {

 "get"(arg0: integer, arg1: integer): float

(arg0: integer, arg1: integer): float
}

export namespace $FieldChartBlockEntityRenderer$IChartSource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldChartBlockEntityRenderer$IChartSource$Type = ($FieldChartBlockEntityRenderer$IChartSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldChartBlockEntityRenderer$IChartSource_ = $FieldChartBlockEntityRenderer$IChartSource$Type;
}}
declare module "packages/com/rekindled/embers/block/$IgnemReactorBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $IgnemReactorBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IgnemReactorBlock$Type = ($IgnemReactorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IgnemReactorBlock_ = $IgnemReactorBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IExtraCapabilityInformation$EnumIOType extends $Enum<($IExtraCapabilityInformation$EnumIOType)> {
static readonly "NONE": $IExtraCapabilityInformation$EnumIOType
static readonly "INPUT": $IExtraCapabilityInformation$EnumIOType
static readonly "OUTPUT": $IExtraCapabilityInformation$EnumIOType
static readonly "BOTH": $IExtraCapabilityInformation$EnumIOType


public static "values"(): ($IExtraCapabilityInformation$EnumIOType)[]
public static "valueOf"(arg0: string): $IExtraCapabilityInformation$EnumIOType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtraCapabilityInformation$EnumIOType$Type = (("output") | ("input") | ("none") | ("both")) | ($IExtraCapabilityInformation$EnumIOType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtraCapabilityInformation$EnumIOType_ = $IExtraCapabilityInformation$EnumIOType$Type;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteValveBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CaminiteValveBlock extends $Block implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteValveBlock$Type = ($CaminiteValveBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteValveBlock_ = $CaminiteValveBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MixerCentrifugeBottomBlockEntity$MixerFluidTank" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"

export class $MixerCentrifugeBottomBlockEntity$MixerFluidTank extends $FluidTank {
readonly "entity": $BlockEntity
 "renderOffset": float
 "previousFluid": integer

constructor(arg0: integer, arg1: $BlockEntity$Type)

public "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeBottomBlockEntity$MixerFluidTank$Type = ($MixerCentrifugeBottomBlockEntity$MixerFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeBottomBlockEntity$MixerFluidTank_ = $MixerCentrifugeBottomBlockEntity$MixerFluidTank$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GemUnsocketRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$CraftingRecipe, $CraftingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$CraftingRecipe"
import {$GemUnsocketRecipe$Serializer, $GemUnsocketRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$GemUnsocketRecipe$Serializer"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $GemUnsocketRecipe implements $CraftingRecipe {
static readonly "SERIALIZER": $GemUnsocketRecipe$Serializer
readonly "id": $ResourceLocation

constructor(arg0: $ResourceLocation$Type)

public "matches"(arg0: $CraftingContainer$Type, arg1: $Level$Type): boolean
public "getRemainingItems"(arg0: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
public "showNotification"(): boolean
public "category"(): $CraftingBookCategory
public "assemble"(arg0: $CraftingContainer$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getId"(): $ResourceLocation
public "isSpecial"(): boolean
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "special"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemUnsocketRecipe$Type = ($GemUnsocketRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemUnsocketRecipe_ = $GemUnsocketRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BlockStateContext" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $BlockStateContext implements $Container {
 "state": $BlockState

constructor(arg0: $BlockState$Type)

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
/**
 * 
 * @deprecated
 */
public "getItem"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
/**
 * 
 * @deprecated
 */
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateContext$Type = ($BlockStateContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateContext_ = $BlockStateContext$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $PipeBlockEntityBase$PipeConnection extends $Enum<($PipeBlockEntityBase$PipeConnection)> implements $StringRepresentable {
static readonly "NONE": $PipeBlockEntityBase$PipeConnection
static readonly "DISABLED": $PipeBlockEntityBase$PipeConnection
static readonly "PIPE": $PipeBlockEntityBase$PipeConnection
static readonly "END": $PipeBlockEntityBase$PipeConnection
static readonly "LEVER": $PipeBlockEntityBase$PipeConnection
readonly "index": integer
readonly "visualIndex": integer
readonly "transfer": boolean
static readonly "visualValues": ($PipeBlockEntityBase$PipeConnection)[]


public "toString"(): string
public static "values"(): ($PipeBlockEntityBase$PipeConnection)[]
public static "valueOf"(arg0: string): $PipeBlockEntityBase$PipeConnection
public "getSerializedName"(): string
public static "visual"(): ($PipeBlockEntityBase$PipeConnection)[]
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockEntityBase$PipeConnection$Type = (("disabled") | ("pipe") | ("end") | ("none") | ("lever")) | ($PipeBlockEntityBase$PipeConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockEntityBase$PipeConnection_ = $PipeBlockEntityBase$PipeConnection$Type;
}}
declare module "packages/com/rekindled/embers/$RegistryManager" {
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$CaveStructure, $CaveStructure$Type} from "packages/com/rekindled/embers/worldgen/$CaveStructure"
import {$MechanicalCoreBlockEntity, $MechanicalCoreBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MechanicalCoreBlockEntity"
import {$ExcavationBucketsBlockEntity, $ExcavationBucketsBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ExcavationBucketsBlockEntity"
import {$GemUnsocketRecipe, $GemUnsocketRecipe$Type} from "packages/com/rekindled/embers/recipe/$GemUnsocketRecipe"
import {$EmberActivatorBottomBlockEntity, $EmberActivatorBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberActivatorBottomBlockEntity"
import {$AnvilAugmentRecipe, $AnvilAugmentRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRecipe"
import {$AutomaticHammerBlockEntity, $AutomaticHammerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AutomaticHammerBlockEntity"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$AnvilAugmentRemoveRecipe, $AnvilAugmentRemoveRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRemoveRecipe"
import {$PressureRefineryTopBlockEntity, $PressureRefineryTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$PressureRefineryTopBlockEntity"
import {$GeologicSeparatorBlockEntity, $GeologicSeparatorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$GeologicSeparatorBlockEntity"
import {$EmberActivationRecipe, $EmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$EmberActivationRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MirrorRelayBlockEntity, $MirrorRelayBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MirrorRelayBlockEntity"
import {$BoringRecipe, $BoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoringRecipe"
import {$EntityType$Builder, $EntityType$Builder$Type} from "packages/net/minecraft/world/entity/$EntityType$Builder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"
import {$CatalyticPlugBlockEntity, $CatalyticPlugBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CatalyticPlugBlockEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$DawnstoneAnvilBlockEntity, $DawnstoneAnvilBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$DawnstoneAnvilBlockEntity"
import {$StampingRecipe, $StampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe"
import {$CopperCellBlockEntity, $CopperCellBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CopperCellBlockEntity"
import {$MelterBottomBlockEntity, $MelterBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MelterBottomBlockEntity"
import {$MetalCoefficientRecipe, $MetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$StamperBlockEntity, $StamperBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$StamperBlockEntity"
import {$ItemTransferBlockEntity, $ItemTransferBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemTransferBlockEntity"
import {$EntityMobilizerStructureProcessor, $EntityMobilizerStructureProcessor$Type} from "packages/com/rekindled/embers/worldgen/$EntityMobilizerStructureProcessor"
import {$EmberDialBlockEntity, $EmberDialBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberDialBlockEntity"
import {$AnvilRepairRecipe, $AnvilRepairRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairRecipe"
import {$GrandhammerLootModifier, $GrandhammerLootModifier$Type} from "packages/com/rekindled/embers/util/$GrandhammerLootModifier"
import {$ButtonBlock, $ButtonBlock$Type} from "packages/net/minecraft/world/level/block/$ButtonBlock"
import {$StarParticleOptions, $StarParticleOptions$Type} from "packages/com/rekindled/embers/particle/$StarParticleOptions"
import {$BoilingRecipe, $BoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoilingRecipe"
import {$ItemPipeBlockEntity, $ItemPipeBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntity"
import {$IgnemReactorBlockEntity, $IgnemReactorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$IgnemReactorBlockEntity"
import {$IBoringRecipe, $IBoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoringRecipe"
import {$EmberBoreBlockEntity, $EmberBoreBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity"
import {$CatalysisChamberBlockEntity, $CatalysisChamberBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CatalysisChamberBlockEntity"
import {$MixingRecipe, $MixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MixingRecipe"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$RegistryManager$MetalCrystalSeed, $RegistryManager$MetalCrystalSeed$Type} from "packages/com/rekindled/embers/$RegistryManager$MetalCrystalSeed"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$ItemVacuumBlockEntity, $ItemVacuumBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemVacuumBlockEntity"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$MithrilBlockEntity, $MithrilBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MithrilBlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CreativeEmberBlockEntity, $CreativeEmberBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CreativeEmberBlockEntity"
import {$ItemDropperBlockEntity, $ItemDropperBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemDropperBlockEntity"
import {$SuperHeaterLootModifier, $SuperHeaterLootModifier$Type} from "packages/com/rekindled/embers/util/$SuperHeaterLootModifier"
import {$FluidDialBlockEntity, $FluidDialBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidDialBlockEntity"
import {$SparkParticleOptions, $SparkParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SparkParticleOptions"
import {$SlateMenu, $SlateMenu$Type} from "packages/com/rekindled/embers/gui/$SlateMenu"
import {$StampBaseBlockEntity, $StampBaseBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$StampBaseBlockEntity"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ItemExtractorBlockEntity, $ItemExtractorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemExtractorBlockEntity"
import {$ItemDialBlockEntity, $ItemDialBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemDialBlockEntity"
import {$CombustionChamberBlockEntity, $CombustionChamberBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CombustionChamberBlockEntity"
import {$BeamCannonBlockEntity, $BeamCannonBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$BeamCannonBlockEntity"
import {$IMixingRecipe, $IMixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMixingRecipe"
import {$StructureType, $StructureType$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureType"
import {$EmberActivatorTopBlockEntity, $EmberActivatorTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberActivatorTopBlockEntity"
import {$MelterTopBlockEntity, $MelterTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MelterTopBlockEntity"
import {$MeltingRecipe, $MeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MeltingRecipe"
import {$EmbersFluidType$FluidInfo, $EmbersFluidType$FluidInfo$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo"
import {$FluidPipeBlockEntity, $FluidPipeBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntity"
import {$AnvilBreakdownRecipe, $AnvilBreakdownRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilBreakdownRecipe"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$CrystalSeedStructureProcessor, $CrystalSeedStructureProcessor$Type} from "packages/com/rekindled/embers/worldgen/$CrystalSeedStructureProcessor"
import {$VaporParticleOptions, $VaporParticleOptions$Type} from "packages/com/rekindled/embers/particle/$VaporParticleOptions"
import {$GaseousFuelRecipe, $GaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe"
import {$AnvilRepairMateriaRecipe, $AnvilRepairMateriaRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairMateriaRecipe"
import {$HeatExchangerBlockEntity, $HeatExchangerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$HeatExchangerBlockEntity"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"
import {$EmberInjectorBlockEntity, $EmberInjectorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberInjectorBlockEntity"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$IMetalCoefficientRecipe, $IMetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe"
import {$AtmosphericBellowsBlockEntity, $AtmosphericBellowsBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AtmosphericBellowsBlockEntity"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$HeatInsulationBlockEntity, $HeatInsulationBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$HeatInsulationBlockEntity"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$EmberReceiverBlockEntity, $EmberReceiverBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberReceiverBlockEntity"
import {$RegistryManager$ToolSet, $RegistryManager$ToolSet$Type} from "packages/com/rekindled/embers/$RegistryManager$ToolSet"
import {$LegacyDeferredRegister, $LegacyDeferredRegister$Type} from "packages/com/rekindled/embers/util/$LegacyDeferredRegister"
import {$TyrfingParticleOptions, $TyrfingParticleOptions$Type} from "packages/com/rekindled/embers/particle/$TyrfingParticleOptions"
import {$ReservoirBlockEntity, $ReservoirBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ReservoirBlockEntity"
import {$SmokeParticleOptions, $SmokeParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SmokeParticleOptions"
import {$AtmosphericGaugeBlockEntity, $AtmosphericGaugeBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AtmosphericGaugeBlockEntity"
import {$EmberRelayBlockEntity, $EmberRelayBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberRelayBlockEntity"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$EmberEjectorBlockEntity, $EmberEjectorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberEjectorBlockEntity"
import {$CrystalCellBlockEntity, $CrystalCellBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CrystalCellBlockEntity"
import {$EmberFunnelBlockEntity, $EmberFunnelBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberFunnelBlockEntity"
import {$MiniBoilerBlockEntity, $MiniBoilerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MiniBoilerBlockEntity"
import {$MixerCentrifugeTopBlockEntity, $MixerCentrifugeTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MixerCentrifugeTopBlockEntity"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IStampingRecipe, $IStampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IStampingRecipe"
import {$AlchemyTabletBlockEntity, $AlchemyTabletBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity"
import {$ForgeFlowingFluid$Properties, $ForgeFlowingFluid$Properties$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Properties"
import {$AlchemyPedestalBlockEntity, $AlchemyPedestalBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalBlockEntity"
import {$ForgeFlowingFluid$Flowing, $ForgeFlowingFluid$Flowing$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Flowing"
import {$HearthCoilBlockEntity, $HearthCoilBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$HearthCoilBlockEntity"
import {$InfernoForgeTopBlockEntity, $InfernoForgeTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$InfernoForgeTopBlockEntity"
import {$EmberEmitterBlockEntity, $EmberEmitterBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberEmitterBlockEntity"
import {$MechanicalPumpBottomBlockEntity, $MechanicalPumpBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MechanicalPumpBottomBlockEntity"
import {$CatalysisCombustionRecipe, $CatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe"
import {$GlimmerProjectileEntity, $GlimmerProjectileEntity$Type} from "packages/com/rekindled/embers/entity/$GlimmerProjectileEntity"
import {$BeamSplitterBlockEntity, $BeamSplitterBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$BeamSplitterBlockEntity"
import {$WildfireStirlingBlockEntity, $WildfireStirlingBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$WildfireStirlingBlockEntity"
import {$CopperChargerBlockEntity, $CopperChargerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CopperChargerBlockEntity"
import {$IBoilingRecipe, $IBoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoilingRecipe"
import {$CharInstillerBlockEntity, $CharInstillerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CharInstillerBlockEntity"
import {$FieldChartBlockEntity, $FieldChartBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FieldChartBlockEntity"
import {$MnemonicInscriberBlockEntity, $MnemonicInscriberBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MnemonicInscriberBlockEntity"
import {$MechanicalPumpTopBlockEntity, $MechanicalPumpTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MechanicalPumpTopBlockEntity"
import {$EmberSiphonBlockEntity, $EmberSiphonBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberSiphonBlockEntity"
import {$InfernoForgeBottomBlockEntity, $InfernoForgeBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$InfernoForgeBottomBlockEntity"
import {$AlchemyCircleParticleOptions, $AlchemyCircleParticleOptions$Type} from "packages/com/rekindled/embers/particle/$AlchemyCircleParticleOptions"
import {$ForgeFlowingFluid$Source, $ForgeFlowingFluid$Source$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Source"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$CaminiteValveBlockEntity, $CaminiteValveBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CaminiteValveBlockEntity"
import {$EmberProjectileEntity, $EmberProjectileEntity$Type} from "packages/com/rekindled/embers/entity/$EmberProjectileEntity"
import {$RegistryManager$FluidStuff, $RegistryManager$FluidStuff$Type} from "packages/com/rekindled/embers/$RegistryManager$FluidStuff"
import {$LiquidBlock, $LiquidBlock$Type} from "packages/net/minecraft/world/level/block/$LiquidBlock"
import {$CinderPlinthBlockEntity, $CinderPlinthBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CinderPlinthBlockEntity"
import {$MixerCentrifugeBottomBlockEntity, $MixerCentrifugeBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MixerCentrifugeBottomBlockEntity"
import {$FluidTransferBlockEntity, $FluidTransferBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidTransferBlockEntity"
import {$PressureRefineryBottomBlockEntity, $PressureRefineryBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$PressureRefineryBottomBlockEntity"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$AlchemyRecipe, $AlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$AlchemyRecipe"
import {$XRayGlowParticleOptions, $XRayGlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$XRayGlowParticleOptions"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FluidVesselBlockEntity, $FluidVesselBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidVesselBlockEntity"
import {$AlchemyPedestalTopBlockEntity, $AlchemyPedestalTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalTopBlockEntity"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$AshenAmuletLootModifier, $AshenAmuletLootModifier$Type} from "packages/com/rekindled/embers/util/$AshenAmuletLootModifier"
import {$AncientGolemEntity, $AncientGolemEntity$Type} from "packages/com/rekindled/embers/entity/$AncientGolemEntity"
import {$FluidExtractorBlockEntity, $FluidExtractorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidExtractorBlockEntity"
import {$BinBlockEntity, $BinBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$BinBlockEntity"
import {$ClockworkAttenuatorBlockEntity, $ClockworkAttenuatorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ClockworkAttenuatorBlockEntity"
import {$ExcavationRecipe, $ExcavationRecipe$Type} from "packages/com/rekindled/embers/recipe/$ExcavationRecipe"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RotatedPillarBlock, $RotatedPillarBlock$Type} from "packages/net/minecraft/world/level/block/$RotatedPillarBlock"
import {$EntropicEnumeratorBlockEntity, $EntropicEnumeratorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$GemSocketRecipe, $GemSocketRecipe$Type} from "packages/com/rekindled/embers/recipe/$GemSocketRecipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegistryManager {
static readonly "BLOCKS": $DeferredRegister<($Block)>
static readonly "ITEMS": $DeferredRegister<($Item)>
static readonly "FLUIDTYPES": $DeferredRegister<($FluidType)>
static readonly "FLUIDS": $DeferredRegister<($Fluid)>
static readonly "ENTITY_TYPES": $DeferredRegister<($EntityType<(any)>)>
static readonly "BLOCK_ENTITY_TYPES_NEW": $DeferredRegister<($BlockEntityType<(any)>)>
static readonly "BLOCK_ENTITY_TYPES_OLD": $DeferredRegister<($BlockEntityType<(any)>)>
static readonly "BLOCK_ENTITY_TYPES": $LegacyDeferredRegister<($BlockEntityType<(any)>)>
static readonly "CREATIVE_TABS": $DeferredRegister<($CreativeModeTab)>
static readonly "PARTICLE_TYPES": $DeferredRegister<($ParticleType<(any)>)>
static readonly "SOUND_EVENTS": $DeferredRegister<($SoundEvent)>
static readonly "RECIPE_TYPES": $DeferredRegister<($RecipeType<(any)>)>
static readonly "RECIPE_SERIALIZERS": $DeferredRegister<($RecipeSerializer<(any)>)>
static readonly "LOOT_MODIFIERS": $DeferredRegister<($Codec<(any)>)>
static readonly "MENU_TYPES": $DeferredRegister<($MenuType<(any)>)>
static readonly "STRUCTURE_TYPES": $DeferredRegister<($StructureType<(any)>)>
static readonly "STRUCTURE_PROCESSOR_TYPES": $DeferredRegister<($StructureProcessorType<(any)>)>
static "augmentRegistry": $Map<($ResourceLocation), ($IAugment)>
static "fluidList": $List<($RegistryManager$FluidStuff)>
static readonly "LEAD_ORE": $RegistryObject<($Block)>
static readonly "DEEPSLATE_LEAD_ORE": $RegistryObject<($Block)>
static readonly "RAW_LEAD_BLOCK": $RegistryObject<($Block)>
static readonly "LEAD_BLOCK": $RegistryObject<($Block)>
static readonly "SILVER_ORE": $RegistryObject<($Block)>
static readonly "DEEPSLATE_SILVER_ORE": $RegistryObject<($Block)>
static readonly "RAW_SILVER_BLOCK": $RegistryObject<($Block)>
static readonly "SILVER_BLOCK": $RegistryObject<($Block)>
static readonly "DAWNSTONE_BLOCK": $RegistryObject<($Block)>
static readonly "MITHRIL_BLOCK": $RegistryObject<($Block)>
static readonly "CAMINITE_BRICKS": $RegistryObject<($Block)>
static readonly "CAMINITE_BRICKS_DECO": $RegistryManager$StoneDecoBlocks
static readonly "CAMINITE_LARGE_BRICKS": $RegistryObject<($Block)>
static readonly "CAMINITE_LARGE_BRICKS_DECO": $RegistryManager$StoneDecoBlocks
static readonly "RAW_CAMINITE_BLOCK": $RegistryObject<($Block)>
static readonly "CAMINITE_LARGE_TILE": $RegistryObject<($Block)>
static readonly "CAMINITE_LARGE_TILE_DECO": $RegistryManager$StoneDecoBlocks
static readonly "CAMINITE_TILES": $RegistryObject<($Block)>
static readonly "CAMINITE_TILES_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ARCHAIC_BRICKS": $RegistryObject<($Block)>
static readonly "ARCHAIC_BRICKS_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ARCHAIC_EDGE": $RegistryObject<($Block)>
static readonly "ARCHAIC_TILE": $RegistryObject<($Block)>
static readonly "ARCHAIC_TILE_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ARCHAIC_LARGE_BRICKS": $RegistryObject<($Block)>
static readonly "ARCHAIC_LARGE_BRICKS_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ARCHAIC_LIGHT": $RegistryObject<($Block)>
static readonly "ASHEN_STONE": $RegistryObject<($Block)>
static readonly "ASHEN_STONE_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ASHEN_BRICK": $RegistryObject<($Block)>
static readonly "ASHEN_BRICK_DECO": $RegistryManager$StoneDecoBlocks
static readonly "ASHEN_TILE": $RegistryObject<($Block)>
static readonly "ASHEN_TILE_DECO": $RegistryManager$StoneDecoBlocks
static readonly "SEALED_PLANKS": $RegistryObject<($Block)>
static readonly "SEALED_PLANKS_DECO": $RegistryManager$StoneDecoBlocks
static readonly "REINFORCED_SEALED_PLANKS": $RegistryObject<($Block)>
static readonly "SEALED_WOOD_TILE": $RegistryObject<($Block)>
static readonly "SEALED_WOOD_TILE_DECO": $RegistryManager$StoneDecoBlocks
static readonly "SEALED_WOOD_PILLAR": $RegistryObject<($RotatedPillarBlock)>
static readonly "SEALED_WOOD_KEG": $RegistryObject<($RotatedPillarBlock)>
static readonly "SOLIDIFIED_METAL": $RegistryObject<($Block)>
static readonly "METAL_PLATFORM": $RegistryObject<($Block)>
static readonly "METAL_PLATFORM_DECO": $RegistryManager$StoneDecoBlocks
static readonly "EMBER_LANTERN": $RegistryObject<($Block)>
static readonly "COPPER_CELL": $RegistryObject<($Block)>
static readonly "CREATIVE_EMBER": $RegistryObject<($Block)>
static readonly "EMBER_DIAL": $RegistryObject<($Block)>
static readonly "ITEM_DIAL": $RegistryObject<($Block)>
static readonly "FLUID_DIAL": $RegistryObject<($Block)>
static readonly "ATMOSPHERIC_GAUGE": $RegistryObject<($Block)>
static readonly "EMBER_EMITTER": $RegistryObject<($Block)>
static readonly "EMBER_RECEIVER": $RegistryObject<($Block)>
static readonly "CAMINITE_LEVER": $RegistryObject<($Block)>
static readonly "CAMINITE_BUTTON": $RegistryObject<($ButtonBlock)>
static readonly "ITEM_PIPE": $RegistryObject<($Block)>
static readonly "ITEM_EXTRACTOR": $RegistryObject<($Block)>
static readonly "EMBER_BORE": $RegistryObject<($Block)>
static readonly "EMBER_BORE_EDGE": $RegistryObject<($Block)>
static readonly "MECHANICAL_CORE": $RegistryObject<($Block)>
static readonly "EMBER_ACTIVATOR": $RegistryObject<($Block)>
static readonly "MELTER": $RegistryObject<($Block)>
static readonly "FLUID_PIPE": $RegistryObject<($Block)>
static readonly "FLUID_EXTRACTOR": $RegistryObject<($Block)>
static readonly "FLUID_VESSEL": $RegistryObject<($Block)>
static readonly "STAMPER": $RegistryObject<($Block)>
static readonly "STAMP_BASE": $RegistryObject<($Block)>
static readonly "BIN": $RegistryObject<($Block)>
static readonly "MIXER_CENTRIFUGE": $RegistryObject<($Block)>
static readonly "ITEM_DROPPER": $RegistryObject<($Block)>
static readonly "PRESSURE_REFINERY": $RegistryObject<($Block)>
static readonly "EMBER_EJECTOR": $RegistryObject<($Block)>
static readonly "EMBER_FUNNEL": $RegistryObject<($Block)>
static readonly "EMBER_RELAY": $RegistryObject<($Block)>
static readonly "MIRROR_RELAY": $RegistryObject<($Block)>
static readonly "BEAM_SPLITTER": $RegistryObject<($Block)>
static readonly "ITEM_VACUUM": $RegistryObject<($Block)>
static readonly "HEARTH_COIL": $RegistryObject<($Block)>
static readonly "HEARTH_COIL_EDGE": $RegistryObject<($Block)>
static readonly "RESERVOIR": $RegistryObject<($Block)>
static readonly "RESERVOIR_EDGE": $RegistryObject<($Block)>
static readonly "CAMINITE_RING": $RegistryObject<($Block)>
static readonly "CAMINITE_RING_EDGE": $RegistryObject<($Block)>
static readonly "CAMINITE_GAUGE": $RegistryObject<($Block)>
static readonly "CAMINITE_GAUGE_EDGE": $RegistryObject<($Block)>
static readonly "CAMINITE_VALVE": $RegistryObject<($Block)>
static readonly "CAMINITE_VALVE_EDGE": $RegistryObject<($Block)>
static readonly "CRYSTAL_CELL": $RegistryObject<($Block)>
static readonly "CRYSTAL_CELL_EDGE": $RegistryObject<($Block)>
static readonly "CLOCKWORK_ATTENUATOR": $RegistryObject<($Block)>
static readonly "GEOLOGIC_SEPARATOR": $RegistryObject<($Block)>
static readonly "COPPER_CHARGER": $RegistryObject<($Block)>
static readonly "EMBER_SIPHON": $RegistryObject<($Block)>
static readonly "ITEM_TRANSFER": $RegistryObject<($Block)>
static readonly "FLUID_TRANSFER": $RegistryObject<($Block)>
static readonly "ALCHEMY_PEDESTAL": $RegistryObject<($Block)>
static readonly "ALCHEMY_TABLET": $RegistryObject<($Block)>
static readonly "BEAM_CANNON": $RegistryObject<($Block)>
static readonly "MECHANICAL_PUMP": $RegistryObject<($Block)>
static readonly "MINI_BOILER": $RegistryObject<($Block)>
static readonly "CATALYTIC_PLUG": $RegistryObject<($Block)>
static readonly "WILDFIRE_STIRLING": $RegistryObject<($Block)>
static readonly "EMBER_INJECTOR": $RegistryObject<($Block)>
static readonly "COPPER_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "IRON_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "GOLD_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "LEAD_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "SILVER_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "NICKEL_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "TIN_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "ALUMINUM_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "ZINC_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "PLATINUM_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "URANIUM_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "DAWNSTONE_CRYSTAL_SEED": $RegistryManager$MetalCrystalSeed
static readonly "FIELD_CHART": $RegistryObject<($Block)>
static readonly "FIELD_CHART_EDGE": $RegistryObject<($Block)>
static readonly "IGNEM_REACTOR": $RegistryObject<($Block)>
static readonly "CATALYSIS_CHAMBER": $RegistryObject<($Block)>
static readonly "COMBUSTION_CHAMBER": $RegistryObject<($Block)>
static readonly "GLIMMER": $RegistryObject<($Block)>
static readonly "CINDER_PLINTH": $RegistryObject<($Block)>
static readonly "DAWNSTONE_ANVIL": $RegistryObject<($Block)>
static readonly "AUTOMATIC_HAMMER": $RegistryObject<($Block)>
static readonly "INFERNO_FORGE": $RegistryObject<($Block)>
static readonly "INFERNO_FORGE_EDGE": $RegistryObject<($Block)>
static readonly "MNEMONIC_INSCRIBER": $RegistryObject<($Block)>
static readonly "CHAR_INSTILLER": $RegistryObject<($Block)>
static readonly "ATMOSPHERIC_BELLOWS": $RegistryObject<($Block)>
static readonly "ENTROPIC_ENUMERATOR": $RegistryObject<($Block)>
static readonly "HEAT_EXCHANGER": $RegistryObject<($Block)>
static readonly "HEAT_INSULATION": $RegistryObject<($Block)>
static readonly "EXCAVATION_BUCKETS": $RegistryObject<($Block)>
static readonly "TINKER_HAMMER": $RegistryObject<($Item)>
static readonly "TINKER_LENS": $RegistryObject<($Item)>
static readonly "SMOKY_TINKER_LENS": $RegistryObject<($Item)>
static readonly "ANCIENT_CODEX": $RegistryObject<($Item)>
static readonly "ATMOSPHERIC_GAUGE_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_JAR": $RegistryObject<($Item)>
static readonly "EMBER_CARTRIDGE": $RegistryObject<($Item)>
static readonly "CLOCKWORK_PICKAXE": $RegistryObject<($Item)>
static readonly "CLOCKWORK_AXE": $RegistryObject<($Item)>
static readonly "GRANDHAMMER": $RegistryObject<($Item)>
static readonly "BLAZING_RAY": $RegistryObject<($Item)>
static readonly "CINDER_STAFF": $RegistryObject<($Item)>
static readonly "ALCHEMICAL_WASTE": $RegistryObject<($Item)>
static readonly "ALCHEMICAL_NOTE": $RegistryObject<($Item)>
static readonly "CODEBREAKING_SLATE": $RegistryObject<($Item)>
static readonly "TYRFING": $RegistryObject<($Item)>
static readonly "INFLICTOR_GEM": $RegistryObject<($Item)>
static readonly "ASHEN_GOGGLES": $RegistryObject<($Item)>
static readonly "ASHEN_CLOAK": $RegistryObject<($Item)>
static readonly "ASHEN_LEGGINGS": $RegistryObject<($Item)>
static readonly "ASHEN_BOOTS": $RegistryObject<($Item)>
static readonly "GLIMMER_CRYSTAL": $RegistryObject<($Item)>
static readonly "GLIMMER_LAMP": $RegistryObject<($Item)>
static readonly "COPPER_CELL_ITEM": $RegistryObject<($Item)>
static readonly "CREATIVE_EMBER_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_DIAL_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_DIAL_ITEM": $RegistryObject<($Item)>
static readonly "FLUID_DIAL_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_EMITTER_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_RECEIVER_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_LEVER_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_BUTTON_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_PIPE_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_EXTRACTOR_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_BORE_ITEM": $RegistryObject<($Item)>
static readonly "MECHANICAL_CORE_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_ACTIVATOR_ITEM": $RegistryObject<($Item)>
static readonly "MELTER_ITEM": $RegistryObject<($Item)>
static readonly "FLUID_PIPE_ITEM": $RegistryObject<($Item)>
static readonly "FLUID_EXTRACTOR_ITEM": $RegistryObject<($Item)>
static readonly "FLUID_VESSEL_ITEM": $RegistryObject<($Item)>
static readonly "STAMPER_ITEM": $RegistryObject<($Item)>
static readonly "STAMP_BASE_ITEM": $RegistryObject<($Item)>
static readonly "BIN_ITEM": $RegistryObject<($Item)>
static readonly "MIXER_CENTRIFUGE_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_DROPPER_ITEM": $RegistryObject<($Item)>
static readonly "PRESSURE_REFINERY_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_EJECTOR_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_FUNNEL_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_RELAY_ITEM": $RegistryObject<($Item)>
static readonly "MIRROR_RELAY_ITEM": $RegistryObject<($Item)>
static readonly "BEAM_SPLITTER_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_VACUUM_ITEM": $RegistryObject<($Item)>
static readonly "HEARTH_COIL_ITEM": $RegistryObject<($Item)>
static readonly "RESERVOIR_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_RING_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_GAUGE_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_VALVE_ITEM": $RegistryObject<($Item)>
static readonly "CRYSTAL_CELL_ITEM": $RegistryObject<($Item)>
static readonly "CLOCKWORK_ATTENUATOR_ITEM": $RegistryObject<($Item)>
static readonly "GEOLOGIC_SEPARATOR_ITEM": $RegistryObject<($Item)>
static readonly "COPPER_CHARGER_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_SIPHON_ITEM": $RegistryObject<($Item)>
static readonly "ITEM_TRANSFER_ITEM": $RegistryObject<($Item)>
static readonly "FLUID_TRANSFER_ITEM": $RegistryObject<($Item)>
static readonly "ALCHEMY_PEDESTAL_ITEM": $RegistryObject<($Item)>
static readonly "ALCHEMY_TABLET_ITEM": $RegistryObject<($Item)>
static readonly "BEAM_CANNON_ITEM": $RegistryObject<($Item)>
static readonly "MECHANICAL_PUMP_ITEM": $RegistryObject<($Item)>
static readonly "MINI_BOILER_ITEM": $RegistryObject<($Item)>
static readonly "CATALYTIC_PLUG_ITEM": $RegistryObject<($Item)>
static readonly "WILDFIRE_STIRLING_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_INJECTOR_ITEM": $RegistryObject<($Item)>
static readonly "FIELD_CHART_ITEM": $RegistryObject<($Item)>
static readonly "IGNEM_REACTOR_ITEM": $RegistryObject<($Item)>
static readonly "CATALYSIS_CHAMBER_ITEM": $RegistryObject<($Item)>
static readonly "COMBUSTION_CHAMBER_ITEM": $RegistryObject<($Item)>
static readonly "CINDER_PLINTH_ITEM": $RegistryObject<($Item)>
static readonly "DAWNSTONE_ANVIL_ITEM": $RegistryObject<($Item)>
static readonly "AUTOMATIC_HAMMER_ITEM": $RegistryObject<($Item)>
static readonly "INFERNO_FORGE_ITEM": $RegistryObject<($Item)>
static readonly "MNEMONIC_INSCRIBER_ITEM": $RegistryObject<($Item)>
static readonly "CHAR_INSTILLER_ITEM": $RegistryObject<($Item)>
static readonly "ATMOSPHERIC_BELLOWS_ITEM": $RegistryObject<($Item)>
static readonly "ENTROPIC_ENUMERATOR_ITEM": $RegistryObject<($Item)>
static readonly "HEAT_EXCHANGER_ITEM": $RegistryObject<($Item)>
static readonly "HEAT_INSULATION_ITEM": $RegistryObject<($Item)>
static readonly "EXCAVATION_BUCKETS_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_CRYSTAL": $RegistryObject<($Item)>
static readonly "EMBER_SHARD": $RegistryObject<($Item)>
static readonly "EMBER_GRIT": $RegistryObject<($Item)>
static readonly "CAMINITE_BLEND": $RegistryObject<($Item)>
static readonly "CAMINITE_BRICK": $RegistryObject<($Item)>
static readonly "ARCHAIC_BRICK": $RegistryObject<($Item)>
static readonly "ANCIENT_MOTIVE_CORE": $RegistryObject<($Item)>
static readonly "ASH": $RegistryObject<($Item)>
static readonly "ASHEN_FABRIC": $RegistryObject<($Item)>
static readonly "EMBER_CRYSTAL_CLUSTER": $RegistryObject<($Item)>
static readonly "WILDFIRE_CORE": $RegistryObject<($Item)>
static readonly "ISOLATED_MATERIA": $RegistryObject<($Item)>
static readonly "ADHESIVE": $RegistryObject<($Item)>
static readonly "ARCHAIC_CIRCUIT": $RegistryObject<($Item)>
static readonly "SUPERHEATER": $RegistryObject<($Item)>
static readonly "CINDER_JET": $RegistryObject<($Item)>
static readonly "MUSIC_DISC_7F_PATTERNS": $RegistryObject<($Item)>
static readonly "BLASTING_CORE": $RegistryObject<($Item)>
static readonly "CASTER_ORB": $RegistryObject<($Item)>
static readonly "RESONATING_BELL": $RegistryObject<($Item)>
static readonly "FLAME_BARRIER": $RegistryObject<($Item)>
static readonly "ELDRITCH_INSIGNIA": $RegistryObject<($Item)>
static readonly "INTELLIGENT_APPARATUS": $RegistryObject<($Item)>
static readonly "DIFFRACTION_BARREL": $RegistryObject<($Item)>
static readonly "FOCAL_LENS": $RegistryObject<($Item)>
static readonly "SHIFTING_SCALES": $RegistryObject<($Item)>
static readonly "WINDING_GEARS": $RegistryObject<($Item)>
static readonly "RAW_CAMINITE_PLATE": $RegistryObject<($Item)>
static readonly "RAW_FLAT_STAMP": $RegistryObject<($Item)>
static readonly "RAW_INGOT_STAMP": $RegistryObject<($Item)>
static readonly "RAW_NUGGET_STAMP": $RegistryObject<($Item)>
static readonly "RAW_PLATE_STAMP": $RegistryObject<($Item)>
static readonly "RAW_GEAR_STAMP": $RegistryObject<($Item)>
static readonly "CAMINITE_PLATE": $RegistryObject<($Item)>
static readonly "FLAT_STAMP": $RegistryObject<($Item)>
static readonly "INGOT_STAMP": $RegistryObject<($Item)>
static readonly "NUGGET_STAMP": $RegistryObject<($Item)>
static readonly "PLATE_STAMP": $RegistryObject<($Item)>
static readonly "GEAR_STAMP": $RegistryObject<($Item)>
static readonly "IRON_ASPECTUS": $RegistryObject<($Item)>
static readonly "COPPER_ASPECTUS": $RegistryObject<($Item)>
static readonly "LEAD_ASPECTUS": $RegistryObject<($Item)>
static readonly "SILVER_ASPECTUS": $RegistryObject<($Item)>
static readonly "DAWNSTONE_ASPECTUS": $RegistryObject<($Item)>
static readonly "IRON_PLATE": $RegistryObject<($Item)>
static readonly "COPPER_PLATE": $RegistryObject<($Item)>
static readonly "COPPER_NUGGET": $RegistryObject<($Item)>
static readonly "RAW_LEAD": $RegistryObject<($Item)>
static readonly "LEAD_INGOT": $RegistryObject<($Item)>
static readonly "LEAD_NUGGET": $RegistryObject<($Item)>
static readonly "LEAD_PLATE": $RegistryObject<($Item)>
static readonly "LEAD_ORE_ITEM": $RegistryObject<($Item)>
static readonly "DEEPSLATE_LEAD_ORE_ITEM": $RegistryObject<($Item)>
static readonly "RAW_LEAD_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "LEAD_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "RAW_SILVER": $RegistryObject<($Item)>
static readonly "SILVER_INGOT": $RegistryObject<($Item)>
static readonly "SILVER_NUGGET": $RegistryObject<($Item)>
static readonly "SILVER_PLATE": $RegistryObject<($Item)>
static readonly "SILVER_ORE_ITEM": $RegistryObject<($Item)>
static readonly "DEEPSLATE_SILVER_ORE_ITEM": $RegistryObject<($Item)>
static readonly "RAW_SILVER_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "SILVER_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "DAWNSTONE_INGOT": $RegistryObject<($Item)>
static readonly "DAWNSTONE_NUGGET": $RegistryObject<($Item)>
static readonly "DAWNSTONE_PLATE": $RegistryObject<($Item)>
static readonly "DAWNSTONE_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "MITHRIL_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "LEAD_TOOLS": $RegistryManager$ToolSet
static readonly "SILVER_TOOLS": $RegistryManager$ToolSet
static readonly "DAWNSTONE_TOOLS": $RegistryManager$ToolSet
static readonly "CAMINITE_BRICKS_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_LARGE_BRICKS_ITEM": $RegistryObject<($Item)>
static readonly "RAW_CAMINITE_BLOCK_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_LARGE_TILE_ITEM": $RegistryObject<($Item)>
static readonly "CAMINITE_TILES_ITEM": $RegistryObject<($Item)>
static readonly "ARCHAIC_BRICKS_ITEM": $RegistryObject<($Item)>
static readonly "ARCHAIC_EDGE_ITEM": $RegistryObject<($Item)>
static readonly "ARCHAIC_TILE_ITEM": $RegistryObject<($Item)>
static readonly "ARCHAIC_LARGE_BRICKS_ITEM": $RegistryObject<($Item)>
static readonly "ARCHAIC_LIGHT_ITEM": $RegistryObject<($Item)>
static readonly "ASHEN_STONE_ITEM": $RegistryObject<($Item)>
static readonly "ASHEN_BRICK_ITEM": $RegistryObject<($Item)>
static readonly "ASHEN_TILE_ITEM": $RegistryObject<($Item)>
static readonly "SEALED_PLANKS_ITEM": $RegistryObject<($Item)>
static readonly "REINFORCED_SEALED_PLANKS_ITEM": $RegistryObject<($Item)>
static readonly "SEALED_WOOD_TILE_ITEM": $RegistryObject<($Item)>
static readonly "SEALED_WOOD_PILLAR_ITEM": $RegistryObject<($Item)>
static readonly "SEALED_WOOD_KEG_ITEM": $RegistryObject<($Item)>
static readonly "SOLIDIFIED_METAL_ITEM": $RegistryObject<($Item)>
static readonly "METAL_PLATFORM_ITEM": $RegistryObject<($Item)>
static readonly "EMBER_LANTERN_ITEM": $RegistryObject<($Item)>
static readonly "MOLTEN_IRON": $RegistryManager$FluidStuff
static readonly "MOLTEN_GOLD": $RegistryManager$FluidStuff
static readonly "MOLTEN_COPPER": $RegistryManager$FluidStuff
static readonly "MOLTEN_LEAD": $RegistryManager$FluidStuff
static readonly "MOLTEN_SILVER": $RegistryManager$FluidStuff
static readonly "MOLTEN_DAWNSTONE": $RegistryManager$FluidStuff
static readonly "MOLTEN_NICKEL": $RegistryManager$FluidStuff
static readonly "MOLTEN_TIN": $RegistryManager$FluidStuff
static readonly "MOLTEN_ALUMINUM": $RegistryManager$FluidStuff
static readonly "MOLTEN_ZINC": $RegistryManager$FluidStuff
static readonly "MOLTEN_PLATINUM": $RegistryManager$FluidStuff
static readonly "MOLTEN_URANIUM": $RegistryManager$FluidStuff
static readonly "MOLTEN_BRONZE": $RegistryManager$FluidStuff
static readonly "MOLTEN_ELECTRUM": $RegistryManager$FluidStuff
static readonly "MOLTEN_BRASS": $RegistryManager$FluidStuff
static readonly "MOLTEN_CONSTANTAN": $RegistryManager$FluidStuff
static readonly "MOLTEN_INVAR": $RegistryManager$FluidStuff
static readonly "STEAM": $RegistryManager$FluidStuff
static readonly "SOUL_CRUDE": $RegistryManager$FluidStuff
static readonly "DWARVEN_OIL": $RegistryManager$FluidStuff
static readonly "DWARVEN_GAS": $RegistryManager$FluidStuff
static readonly "COPPER_CELL_ENTITY": $RegistryObject<($BlockEntityType<($CopperCellBlockEntity)>)>
static readonly "CREATIVE_EMBER_ENTITY": $RegistryObject<($BlockEntityType<($CreativeEmberBlockEntity)>)>
static readonly "EMBER_DIAL_ENTITY": $RegistryObject<($BlockEntityType<($EmberDialBlockEntity)>)>
static readonly "ITEM_DIAL_ENTITY": $RegistryObject<($BlockEntityType<($ItemDialBlockEntity)>)>
static readonly "FLUID_DIAL_ENTITY": $RegistryObject<($BlockEntityType<($FluidDialBlockEntity)>)>
static readonly "ATMOSPHERIC_GAUGE_ENTITY": $RegistryObject<($BlockEntityType<($AtmosphericGaugeBlockEntity)>)>
static readonly "EMBER_EMITTER_ENTITY": $RegistryObject<($BlockEntityType<($EmberEmitterBlockEntity)>)>
static readonly "EMBER_RECEIVER_ENTITY": $RegistryObject<($BlockEntityType<($EmberReceiverBlockEntity)>)>
static readonly "ITEM_PIPE_ENTITY": $RegistryObject<($BlockEntityType<($ItemPipeBlockEntity)>)>
static readonly "ITEM_EXTRACTOR_ENTITY": $RegistryObject<($BlockEntityType<($ItemExtractorBlockEntity)>)>
static readonly "EMBER_BORE_ENTITY": $RegistryObject<($BlockEntityType<($EmberBoreBlockEntity)>)>
static readonly "MECHANICAL_CORE_ENTITY": $RegistryObject<($BlockEntityType<($MechanicalCoreBlockEntity)>)>
static readonly "EMBER_ACTIVATOR_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($EmberActivatorBottomBlockEntity)>)>
static readonly "EMBER_ACTIVATOR_TOP_ENTITY": $RegistryObject<($BlockEntityType<($EmberActivatorTopBlockEntity)>)>
static readonly "MELTER_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($MelterBottomBlockEntity)>)>
static readonly "MELTER_TOP_ENTITY": $RegistryObject<($BlockEntityType<($MelterTopBlockEntity)>)>
static readonly "FLUID_PIPE_ENTITY": $RegistryObject<($BlockEntityType<($FluidPipeBlockEntity)>)>
static readonly "FLUID_EXTRACTOR_ENTITY": $RegistryObject<($BlockEntityType<($FluidExtractorBlockEntity)>)>
static readonly "FLUID_VESSEL_ENTITY": $RegistryObject<($BlockEntityType<($FluidVesselBlockEntity)>)>
static readonly "STAMPER_ENTITY": $RegistryObject<($BlockEntityType<($StamperBlockEntity)>)>
static readonly "STAMP_BASE_ENTITY": $RegistryObject<($BlockEntityType<($StampBaseBlockEntity)>)>
static readonly "BIN_ENTITY": $RegistryObject<($BlockEntityType<($BinBlockEntity)>)>
static readonly "MIXER_CENTRIFUGE_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($MixerCentrifugeBottomBlockEntity)>)>
static readonly "MIXER_CENTRIFUGE_TOP_ENTITY": $RegistryObject<($BlockEntityType<($MixerCentrifugeTopBlockEntity)>)>
static readonly "ITEM_DROPPER_ENTITY": $RegistryObject<($BlockEntityType<($ItemDropperBlockEntity)>)>
static readonly "PRESSURE_REFINERY_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($PressureRefineryBottomBlockEntity)>)>
static readonly "PRESSURE_REFINERY_TOP_ENTITY": $RegistryObject<($BlockEntityType<($PressureRefineryTopBlockEntity)>)>
static readonly "EMBER_EJECTOR_ENTITY": $RegistryObject<($BlockEntityType<($EmberEjectorBlockEntity)>)>
static readonly "EMBER_FUNNEL_ENTITY": $RegistryObject<($BlockEntityType<($EmberFunnelBlockEntity)>)>
static readonly "EMBER_RELAY_ENTITY": $RegistryObject<($BlockEntityType<($EmberRelayBlockEntity)>)>
static readonly "MIRROR_RELAY_ENTITY": $RegistryObject<($BlockEntityType<($MirrorRelayBlockEntity)>)>
static readonly "BEAM_SPLITTER_ENTITY": $RegistryObject<($BlockEntityType<($BeamSplitterBlockEntity)>)>
static readonly "ITEM_VACUUM_ENTITY": $RegistryObject<($BlockEntityType<($ItemVacuumBlockEntity)>)>
static readonly "HEARTH_COIL_ENTITY": $RegistryObject<($BlockEntityType<($HearthCoilBlockEntity)>)>
static readonly "RESERVOIR_ENTITY": $RegistryObject<($BlockEntityType<($ReservoirBlockEntity)>)>
static readonly "CAMINITE_VALVE_ENTITY": $RegistryObject<($BlockEntityType<($CaminiteValveBlockEntity)>)>
static readonly "CRYSTAL_CELL_ENTITY": $RegistryObject<($BlockEntityType<($CrystalCellBlockEntity)>)>
static readonly "CLOCKWORK_ATTENUATOR_ENTITY": $RegistryObject<($BlockEntityType<($ClockworkAttenuatorBlockEntity)>)>
static readonly "GEOLOGIC_SEPARATOR_ENTITY": $RegistryObject<($BlockEntityType<($GeologicSeparatorBlockEntity)>)>
static readonly "COPPER_CHARGER_ENTITY": $RegistryObject<($BlockEntityType<($CopperChargerBlockEntity)>)>
static readonly "EMBER_SIPHON_ENTITY": $RegistryObject<($BlockEntityType<($EmberSiphonBlockEntity)>)>
static readonly "ITEM_TRANSFER_ENTITY": $RegistryObject<($BlockEntityType<($ItemTransferBlockEntity)>)>
static readonly "FLUID_TRANSFER_ENTITY": $RegistryObject<($BlockEntityType<($FluidTransferBlockEntity)>)>
static readonly "ALCHEMY_PEDESTAL_ENTITY": $RegistryObject<($BlockEntityType<($AlchemyPedestalBlockEntity)>)>
static readonly "ALCHEMY_PEDESTAL_TOP_ENTITY": $RegistryObject<($BlockEntityType<($AlchemyPedestalTopBlockEntity)>)>
static readonly "ALCHEMY_TABLET_ENTITY": $RegistryObject<($BlockEntityType<($AlchemyTabletBlockEntity)>)>
static readonly "BEAM_CANNON_ENTITY": $RegistryObject<($BlockEntityType<($BeamCannonBlockEntity)>)>
static readonly "MECHANICAL_PUMP_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($MechanicalPumpBottomBlockEntity)>)>
static readonly "MECHANICAL_PUMP_TOP_ENTITY": $RegistryObject<($BlockEntityType<($MechanicalPumpTopBlockEntity)>)>
static readonly "MINI_BOILER_ENTITY": $RegistryObject<($BlockEntityType<($MiniBoilerBlockEntity)>)>
static readonly "CATALYTIC_PLUG_ENTITY": $RegistryObject<($BlockEntityType<($CatalyticPlugBlockEntity)>)>
static readonly "WILDFIRE_STIRLING_ENTITY": $RegistryObject<($BlockEntityType<($WildfireStirlingBlockEntity)>)>
static readonly "EMBER_INJECTOR_ENTITY": $RegistryObject<($BlockEntityType<($EmberInjectorBlockEntity)>)>
static readonly "FIELD_CHART_ENTITY": $RegistryObject<($BlockEntityType<($FieldChartBlockEntity)>)>
static readonly "IGNEM_REACTOR_ENTITY": $RegistryObject<($BlockEntityType<($IgnemReactorBlockEntity)>)>
static readonly "CATALYSIS_CHAMBER_ENTITY": $RegistryObject<($BlockEntityType<($CatalysisChamberBlockEntity)>)>
static readonly "COMBUSTION_CHAMBER_ENTITY": $RegistryObject<($BlockEntityType<($CombustionChamberBlockEntity)>)>
static readonly "CINDER_PLINTH_ENTITY": $RegistryObject<($BlockEntityType<($CinderPlinthBlockEntity)>)>
static readonly "DAWNSTONE_ANVIL_ENTITY": $RegistryObject<($BlockEntityType<($DawnstoneAnvilBlockEntity)>)>
static readonly "AUTOMATIC_HAMMER_ENTITY": $RegistryObject<($BlockEntityType<($AutomaticHammerBlockEntity)>)>
static readonly "INFERNO_FORGE_BOTTOM_ENTITY": $RegistryObject<($BlockEntityType<($InfernoForgeBottomBlockEntity)>)>
static readonly "INFERNO_FORGE_TOP_ENTITY": $RegistryObject<($BlockEntityType<($InfernoForgeTopBlockEntity)>)>
static readonly "MNEMONIC_INSCRIBER_ENTITY": $RegistryObject<($BlockEntityType<($MnemonicInscriberBlockEntity)>)>
static readonly "CHAR_INSTILLER_ENTITY": $RegistryObject<($BlockEntityType<($CharInstillerBlockEntity)>)>
static readonly "ATMOSPHERIC_BELLOWS_ENTITY": $RegistryObject<($BlockEntityType<($AtmosphericBellowsBlockEntity)>)>
static readonly "ENTROPIC_ENUMERATOR_ENTITY": $RegistryObject<($BlockEntityType<($EntropicEnumeratorBlockEntity)>)>
static readonly "MITHRIL_BLOCK_ENTITY": $RegistryObject<($BlockEntityType<($MithrilBlockEntity)>)>
static readonly "HEAT_EXCHANGER_ENTITY": $RegistryObject<($BlockEntityType<($HeatExchangerBlockEntity)>)>
static readonly "HEAT_INSULATION_ENTITY": $RegistryObject<($BlockEntityType<($HeatInsulationBlockEntity)>)>
static readonly "EXCAVATION_BUCKETS_ENTITY": $RegistryObject<($BlockEntityType<($ExcavationBucketsBlockEntity)>)>
static readonly "EMBERS_TAB": $RegistryObject<($CreativeModeTab)>
static readonly "EMBER_PACKET": $RegistryObject<($EntityType<($EmberPacketEntity)>)>
static readonly "EMBER_PROJECTILE": $RegistryObject<($EntityType<($EmberProjectileEntity)>)>
static readonly "GLIMMER_PROJECTILE": $RegistryObject<($EntityType<($GlimmerProjectileEntity)>)>
static readonly "ANCIENT_GOLEM": $RegistryObject<($EntityType<($AncientGolemEntity)>)>
static readonly "ANCIENT_GOLEM_SPAWN_EGG": $RegistryObject<($Item)>
static readonly "CORE_AUGMENT": $IAugment
static readonly "TINKER_LENS_AUGMENT": $IAugment
static readonly "SMOKY_LENS_AUGMENT": $IAugment
static readonly "SUPERHEATER_AUGMENT": $IAugment
static readonly "CINDER_JET_AUGMENT": $IAugment
static readonly "BLASTING_CORE_AUGMENT": $IAugment
static readonly "CASTER_ORB_AUGMENT": $IAugment
static readonly "RESONATING_BELL_AUGMENT": $IAugment
static readonly "FLAME_BARRIER_AUGMENT": $IAugment
static readonly "ELDRITCH_INSIGNIA_AUGMENT": $IAugment
static readonly "INTELLIGENT_APPARATUS_AUGMENT": $IAugment
static readonly "DIFFRACTION_BARREL_AUGMENT": $IAugment
static readonly "FOCAL_LENS_AUGMENT": $IAugment
static readonly "SHIFTING_SCALES_AUGMENT": $IAugment
static readonly "WINDING_GEARS_AUGMENT": $IAugment
static readonly "GLOW_PARTICLE": $RegistryObject<($ParticleType<($GlowParticleOptions)>)>
static readonly "STAR_PARTICLE": $RegistryObject<($ParticleType<($StarParticleOptions)>)>
static readonly "SPARK_PARTICLE": $RegistryObject<($ParticleType<($SparkParticleOptions)>)>
static readonly "SMOKE_PARTICLE": $RegistryObject<($ParticleType<($SmokeParticleOptions)>)>
static readonly "VAPOR_PARTICLE": $RegistryObject<($ParticleType<($VaporParticleOptions)>)>
static readonly "ALCHEMY_CIRCLE_PARTICLE": $RegistryObject<($ParticleType<($AlchemyCircleParticleOptions)>)>
static readonly "TYRFING_PARTICLE": $RegistryObject<($ParticleType<($TyrfingParticleOptions)>)>
static readonly "XRAY_GLOW_PARTICLE": $RegistryObject<($ParticleType<($XRayGlowParticleOptions)>)>
static readonly "BORING": $RegistryObject<($RecipeType<($IBoringRecipe)>)>
static readonly "EXCAVATION": $RegistryObject<($RecipeType<($IBoringRecipe)>)>
static readonly "EMBER_ACTIVATION": $RegistryObject<($RecipeType<($IEmberActivationRecipe)>)>
static readonly "MELTING": $RegistryObject<($RecipeType<($IMeltingRecipe)>)>
static readonly "STAMPING": $RegistryObject<($RecipeType<($IStampingRecipe)>)>
static readonly "MIXING": $RegistryObject<($RecipeType<($IMixingRecipe)>)>
static readonly "METAL_COEFFICIENT": $RegistryObject<($RecipeType<($IMetalCoefficientRecipe)>)>
static readonly "ALCHEMY": $RegistryObject<($RecipeType<($IAlchemyRecipe)>)>
static readonly "BOILING": $RegistryObject<($RecipeType<($IBoilingRecipe)>)>
static readonly "GASEOUS_FUEL": $RegistryObject<($RecipeType<($IGaseousFuelRecipe)>)>
static readonly "CATALYSIS_COMBUSTION": $RegistryObject<($RecipeType<($ICatalysisCombustionRecipe)>)>
static readonly "DAWNSTONE_ANVIL_RECIPE": $RegistryObject<($RecipeType<($IDawnstoneAnvilRecipe)>)>
static readonly "BORING_SERIALIZER": $RegistryObject<($RecipeSerializer<($BoringRecipe)>)>
static readonly "EXCAVATION_SERIALIZER": $RegistryObject<($RecipeSerializer<($ExcavationRecipe)>)>
static readonly "EMBER_ACTIVATION_SERIALIZER": $RegistryObject<($RecipeSerializer<($EmberActivationRecipe)>)>
static readonly "MELTING_SERIALIZER": $RegistryObject<($RecipeSerializer<($MeltingRecipe)>)>
static readonly "STAMPING_SERIALIZER": $RegistryObject<($RecipeSerializer<($StampingRecipe)>)>
static readonly "MIXING_SERIALIZER": $RegistryObject<($RecipeSerializer<($MixingRecipe)>)>
static readonly "METAL_COEFFICIENT_SERIALIZER": $RegistryObject<($RecipeSerializer<($MetalCoefficientRecipe)>)>
static readonly "ALCHEMY_SERIALIZER": $RegistryObject<($RecipeSerializer<($AlchemyRecipe)>)>
static readonly "BOILING_SERIALIZER": $RegistryObject<($RecipeSerializer<($BoilingRecipe)>)>
static readonly "GASEOUS_FUEL_SERIALIZER": $RegistryObject<($RecipeSerializer<($GaseousFuelRecipe)>)>
static readonly "CATALYSIS_COMBUSTION_SERIALIZER": $RegistryObject<($RecipeSerializer<($CatalysisCombustionRecipe)>)>
static readonly "GEM_SOCKET_SERIALIZER": $RegistryObject<($RecipeSerializer<($GemSocketRecipe)>)>
static readonly "GEM_UNSOCKET_SERIALIZER": $RegistryObject<($RecipeSerializer<($GemUnsocketRecipe)>)>
static readonly "TOOL_REPAIR": $RegistryObject<($RecipeSerializer<($AnvilRepairRecipe)>)>
static readonly "MATERIA_REPAIR": $RegistryObject<($RecipeSerializer<($AnvilRepairMateriaRecipe)>)>
static readonly "TOOL_BREAKDOWN": $RegistryObject<($RecipeSerializer<($AnvilBreakdownRecipe)>)>
static readonly "TOOL_AUGMENT": $RegistryObject<($RecipeSerializer<($AnvilAugmentRecipe)>)>
static readonly "TOOL_AUGMENT_REMOVE": $RegistryObject<($RecipeSerializer<($AnvilAugmentRemoveRecipe)>)>
static readonly "GRANDHAMMER_MODIFIER": $RegistryObject<($Codec<($GrandhammerLootModifier)>)>
static readonly "SUPERHEATER_MODIFIER": $RegistryObject<($Codec<($SuperHeaterLootModifier)>)>
static readonly "ASHENAMULET_MODIFIER": $RegistryObject<($Codec<($AshenAmuletLootModifier)>)>
static readonly "SLATE_MENU": $RegistryObject<($MenuType<($SlateMenu)>)>
static readonly "CAVE_STRUCTURE": $RegistryObject<($StructureType<($CaveStructure)>)>
static readonly "CRYSTAL_SEED_PROCESSOR": $RegistryObject<($StructureProcessorType<($CrystalSeedStructureProcessor)>)>
static readonly "ENTITY_MOBILIZER_PROCESSOR": $RegistryObject<($StructureProcessorType<($EntityMobilizerStructureProcessor)>)>

constructor()

public static "init"(arg0: $FMLCommonSetupEvent$Type): void
public static "registerEntity"<T extends $Entity>(arg0: string, arg1: $EntityType$Builder$Type<(T)>): $RegistryObject<($EntityType<(T)>)>
public static "registerRecipeType"<T extends $Recipe<(any)>>(arg0: string): $RegistryObject<($RecipeType<(T)>)>
public static "addFluid"(arg0: string, arg1: $EmbersFluidType$FluidInfo$Type, arg2: $BiFunction$Type<($FluidType$Properties$Type), ($EmbersFluidType$FluidInfo$Type), ($FluidType$Type)>, arg3: $BiFunction$Type<($Supplier$Type<(any)>), ($BlockBehaviour$Properties$Type), ($LiquidBlock$Type)>, arg4: $Consumer$Type<($ForgeFlowingFluid$Properties$Type)>, arg5: $FluidType$Properties$Type): $RegistryManager$FluidStuff
public static "addFluid"(arg0: string, arg1: $EmbersFluidType$FluidInfo$Type, arg2: $BiFunction$Type<($FluidType$Properties$Type), ($EmbersFluidType$FluidInfo$Type), ($FluidType$Type)>, arg3: $BiFunction$Type<($Supplier$Type<(any)>), ($BlockBehaviour$Properties$Type), ($LiquidBlock$Type)>, arg4: $Function$Type<($ForgeFlowingFluid$Properties$Type), ($ForgeFlowingFluid$Source$Type)>, arg5: $Function$Type<($ForgeFlowingFluid$Properties$Type), ($ForgeFlowingFluid$Flowing$Type)>, arg6: $Consumer$Type<($ForgeFlowingFluid$Properties$Type)>, arg7: $FluidType$Properties$Type): $RegistryManager$FluidStuff
public static "registerParticle"<T extends $ParticleOptions>(arg0: string, arg1: boolean, arg2: $ParticleOptions$Deserializer$Type<(T)>, arg3: $Codec$Type<(T)>): $RegistryObject<($ParticleType<(T)>)>
public static "moltenMetalProps"(): $FluidType$Properties
public static "moltenMetalFluidInteractions"(arg0: $FluidType$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$Type = ($RegistryManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager_ = $RegistryManager$Type;
}}
declare module "packages/com/rekindled/embers/block/$CrystalCellEdgeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $CrystalCellEdgeBlock extends $MechEdgeBlockBase {
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalCellEdgeBlock$Type = ($CrystalCellEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalCellEdgeBlock_ = $CrystalCellEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$EmberActivationRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$EmberActivationRecipe, $EmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$EmberActivationRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $EmberActivationRecipeBuilder {
 "id": $ResourceLocation
 "ingredient": $Ingredient
 "ember": integer

constructor()

public "id"(arg0: $ResourceLocation$Type): $EmberActivationRecipeBuilder
public "domain"(arg0: string): $EmberActivationRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $TagKey$Type<($Item$Type)>): $EmberActivationRecipeBuilder
public static "create"(arg0: $ItemStack$Type): $EmberActivationRecipeBuilder
public static "create"(arg0: $Ingredient$Type): $EmberActivationRecipeBuilder
public static "create"(arg0: $Item$Type): $EmberActivationRecipeBuilder
public "build"(): $EmberActivationRecipe
public "folder"(arg0: string): $EmberActivationRecipeBuilder
public "ember"(arg0: integer): $EmberActivationRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivationRecipeBuilder$Type = ($EmberActivationRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivationRecipeBuilder_ = $EmberActivationRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$CrystalSeedBlockEntityRenderer" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"
import {$CrystalSeedBlockEntity, $CrystalSeedBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CrystalSeedBlockEntity"

export class $CrystalSeedBlockEntityRenderer implements $BlockEntityRenderer<($CrystalSeedBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CrystalSeedBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "drawCrystal"(arg0: $VertexConsumer$Type, arg1: $Matrix4f$Type, arg2: $Matrix3f$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: integer, arg13: integer): void
public "shouldRender"(arg0: $CrystalSeedBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CrystalSeedBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalSeedBlockEntityRenderer$Type = ($CrystalSeedBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalSeedBlockEntityRenderer_ = $CrystalSeedBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/particle/$TyrfingParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $TyrfingParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "TYRFING": $TyrfingParticleOptions
static readonly "TYRFING_NOMOTION": $TyrfingParticleOptions
static readonly "CODEC": $Codec<($TyrfingParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($TyrfingParticleOptions)>

constructor(arg0: float)
constructor(arg0: float, arg1: integer)
constructor(arg0: $Vec3$Type, arg1: float)
constructor(arg0: $Vec3$Type, arg1: float, arg2: integer)

public "getLifetime"(): integer
public "getMotion"(): $Vec3
public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVec3"(arg0: $FriendlyByteBuf$Type): $Vec3
public static "readVec3"(arg0: $StringReader$Type): $Vec3
public "getScale"(): float
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "lifetime"(): integer
get "motion"(): $Vec3
get "scale"(): float
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TyrfingParticleOptions$Type = ($TyrfingParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TyrfingParticleOptions_ = $TyrfingParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/particle/$SparkParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"
import {$SparkParticleOptions, $SparkParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SparkParticleOptions"

export class $SparkParticle extends $TextureSheetParticle {
 "rBase": float
 "gBase": float
 "bBase": float
 "rotScale": float
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $SparkParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkParticle$Type = ($SparkParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkParticle_ = $SparkParticle$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ReservoirBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpenTankBlockEntity, $OpenTankBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $ReservoirBlockEntity extends $OpenTankBlockEntity {
 "renderOffset": float
 "height": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ReservoirBlockEntity$Type): void
public "updateCapacity"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public "getRenderBoundingBox"(): $AABB
public static "commonTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ReservoirBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
get "renderBoundingBox"(): $AABB
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReservoirBlockEntity$Type = ($ReservoirBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReservoirBlockEntity_ = $ReservoirBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IEmberChargedTool" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IEmberChargedTool {

 "hasEmber"(arg0: $ItemStack$Type): boolean

(arg0: $ItemStack$Type): boolean
}

export namespace $IEmberChargedTool {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberChargedTool$Type = ($IEmberChargedTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberChargedTool_ = $IEmberChargedTool$Type;
}}
declare module "packages/com/rekindled/embers/model/$AncientGolemModel" {
import {$HierarchicalModel, $HierarchicalModel$Type} from "packages/net/minecraft/client/model/$HierarchicalModel"
import {$ModelPart, $ModelPart$Type} from "packages/net/minecraft/client/model/geom/$ModelPart"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AncientGolemModel<T extends $Entity> extends $HierarchicalModel<(T)> {
 "attackTime": float
 "riding": boolean
 "young": boolean

constructor(arg0: $ModelPart$Type)

public static "createLayer"(): $LayerDefinition
public "setupAnim"(arg0: $Entity$Type, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): void
public "root"(): $ModelPart
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AncientGolemModel$Type<T> = ($AncientGolemModel<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AncientGolemModel_<T> = $AncientGolemModel$Type<(T)>;
}}
declare module "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity$Move" {
import {$Vector3i, $Vector3i$Type} from "packages/org/joml/$Vector3i"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EntropicEnumeratorBlockEntity$Cubie, $EntropicEnumeratorBlockEntity$Cubie$Type} from "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity$Cubie"
import {$Vector3d, $Vector3d$Type} from "packages/org/joml/$Vector3d"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $EntropicEnumeratorBlockEntity$Move extends $Enum<($EntropicEnumeratorBlockEntity$Move)> {
static readonly "U": $EntropicEnumeratorBlockEntity$Move
static readonly "U_": $EntropicEnumeratorBlockEntity$Move
static readonly "U2": $EntropicEnumeratorBlockEntity$Move
static readonly "D": $EntropicEnumeratorBlockEntity$Move
static readonly "D_": $EntropicEnumeratorBlockEntity$Move
static readonly "D2": $EntropicEnumeratorBlockEntity$Move
static readonly "L": $EntropicEnumeratorBlockEntity$Move
static readonly "L_": $EntropicEnumeratorBlockEntity$Move
static readonly "L2": $EntropicEnumeratorBlockEntity$Move
static readonly "R": $EntropicEnumeratorBlockEntity$Move
static readonly "R_": $EntropicEnumeratorBlockEntity$Move
static readonly "R2": $EntropicEnumeratorBlockEntity$Move
static readonly "F": $EntropicEnumeratorBlockEntity$Move
static readonly "F_": $EntropicEnumeratorBlockEntity$Move
static readonly "F2": $EntropicEnumeratorBlockEntity$Move
static readonly "B": $EntropicEnumeratorBlockEntity$Move
static readonly "B_": $EntropicEnumeratorBlockEntity$Move
static readonly "B2": $EntropicEnumeratorBlockEntity$Move
static readonly "X": $EntropicEnumeratorBlockEntity$Move
static readonly "X_": $EntropicEnumeratorBlockEntity$Move
static readonly "X2": $EntropicEnumeratorBlockEntity$Move
static readonly "Y": $EntropicEnumeratorBlockEntity$Move
static readonly "Y_": $EntropicEnumeratorBlockEntity$Move
static readonly "Y2": $EntropicEnumeratorBlockEntity$Move
static readonly "Z": $EntropicEnumeratorBlockEntity$Move
static readonly "Z_": $EntropicEnumeratorBlockEntity$Move
static readonly "Z2": $EntropicEnumeratorBlockEntity$Move
static readonly "axisMoves": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "quarterMoves": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesX": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesY": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesZ": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "halfMoves": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesX2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesY2": ($EntropicEnumeratorBlockEntity$Move)[]
static readonly "movesZ2": ($EntropicEnumeratorBlockEntity$Move)[]
readonly "name": string
readonly "axis": $Vector3d
readonly "angle": double
readonly "length": integer
readonly "pieces": ($Vector3i)[]


public static "values"(): ($EntropicEnumeratorBlockEntity$Move)[]
public static "valueOf"(arg0: string): $EntropicEnumeratorBlockEntity$Move
public "getOpposite"(): $EntropicEnumeratorBlockEntity$Move
public "makePartialMove"(arg0: $Quaternionf$Type, arg1: $Vector3d$Type, arg2: float): $Quaternionf
public static "makeMoves"(arg0: ((($EntropicEnumeratorBlockEntity$Cubie$Type)[])[])[], arg1: ($EntropicEnumeratorBlockEntity$Move$Type)[]): void
public "makeMove"(arg0: ((($EntropicEnumeratorBlockEntity$Cubie$Type)[])[])[]): void
public static "getNextMoves"(arg0: $EntropicEnumeratorBlockEntity$Move$Type): ($EntropicEnumeratorBlockEntity$Move)[]
public static "getMoves"(arg0: string): ($EntropicEnumeratorBlockEntity$Move)[]
get "opposite"(): $EntropicEnumeratorBlockEntity$Move
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorBlockEntity$Move$Type = (("r2") | ("l2") | ("y_") | ("u_") | ("f2") | ("d2") | ("b2") | ("y2") | ("u2") | ("b") | ("d") | ("z_") | ("f") | ("x_") | ("l") | ("r_") | ("r") | ("l_") | ("u") | ("x") | ("z2") | ("f_") | ("y") | ("x2") | ("z") | ("d_") | ("b_")) | ($EntropicEnumeratorBlockEntity$Move);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorBlockEntity$Move_ = $EntropicEnumeratorBlockEntity$Move$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$StampingContext" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$RecipeWrapper, $RecipeWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RecipeWrapper"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"

export class $StampingContext extends $RecipeWrapper {
 "fluids": $IFluidHandler
 "stamp": $ItemStack

constructor(arg0: $IItemHandlerModifiable$Type, arg1: $IFluidHandler$Type, arg2: $ItemStack$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingContext$Type = ($StampingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingContext_ = $StampingContext$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ExcavationBucketsBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ExcavationBucketsUpgrade, $ExcavationBucketsUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$ExcavationBucketsUpgrade"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ExcavationBucketsBlockEntity extends $BlockEntity {
 "upgrade": $ExcavationBucketsUpgrade
 "angle": float
 "lastAngle": float
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationBucketsBlockEntity$Type = ($ExcavationBucketsBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationBucketsBlockEntity_ = $ExcavationBucketsBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MixerCentrifugeBottomBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MixerCentrifugeBottomBlockEntity, $MixerCentrifugeBottomBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MixerCentrifugeBottomBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MixerCentrifugeBottomBlockEntityRenderer implements $BlockEntityRenderer<($MixerCentrifugeBottomBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MixerCentrifugeBottomBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MixerCentrifugeBottomBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MixerCentrifugeBottomBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeBottomBlockEntityRenderer$Type = ($MixerCentrifugeBottomBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeBottomBlockEntityRenderer_ = $MixerCentrifugeBottomBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GemSocketRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$GemSocketRecipe$Serializer, $GemSocketRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$GemSocketRecipe$Serializer"
import {$CraftingRecipe, $CraftingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$CraftingRecipe"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $GemSocketRecipe implements $CraftingRecipe {
static readonly "SERIALIZER": $GemSocketRecipe$Serializer
readonly "id": $ResourceLocation
readonly "ingredient": $Ingredient

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type)

public "matches"(arg0: $CraftingContainer$Type, arg1: $Level$Type): boolean
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
public "showNotification"(): boolean
public "category"(): $CraftingBookCategory
public "assemble"(arg0: $CraftingContainer$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getId"(): $ResourceLocation
public "isSpecial"(): boolean
public "getRemainingItems"(arg0: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "special"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemSocketRecipe$Type = ($GemSocketRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemSocketRecipe_ = $GemSocketRecipe$Type;
}}
declare module "packages/com/rekindled/embers/entity/render/$EmberProjectileRenderer" {
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$EmberProjectileEntity, $EmberProjectileEntity$Type} from "packages/com/rekindled/embers/entity/$EmberProjectileEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $EmberProjectileRenderer extends $EntityRenderer<($EmberProjectileEntity)> {
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "render"(arg0: $EmberProjectileEntity$Type, arg1: float, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer): void
public "getTextureLocation"(arg0: $EmberProjectileEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberProjectileRenderer$Type = ($EmberProjectileRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberProjectileRenderer_ = $EmberProjectileRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$ReservoirBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$ReservoirBlockEntity, $ReservoirBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ReservoirBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $ReservoirBlockEntityRenderer implements $BlockEntityRenderer<($ReservoirBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $ReservoirBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $ReservoirBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $ReservoirBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReservoirBlockEntityRenderer$Type = ($ReservoirBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReservoirBlockEntityRenderer_ = $ReservoirBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/particle/$GlowParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $GlowParticle extends $TextureSheetParticle {
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $GlowParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlowParticle$Type = ($GlowParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlowParticle_ = $GlowParticle$Type;
}}
declare module "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$StairBlock, $StairBlock$Type} from "packages/net/minecraft/world/level/block/$StairBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$SlabBlock, $SlabBlock$Type} from "packages/net/minecraft/world/level/block/$SlabBlock"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$WallBlock, $WallBlock$Type} from "packages/net/minecraft/world/level/block/$WallBlock"

export class $RegistryManager$StoneDecoBlocks {
 "name": string
 "block": $RegistryObject<($Block)>
 "stairs": $RegistryObject<($StairBlock)>
 "stairsItem": $RegistryObject<($Item)>
 "slab": $RegistryObject<($SlabBlock)>
 "slabItem": $RegistryObject<($Item)>
 "wall": $RegistryObject<($WallBlock)>
 "wallItem": $RegistryObject<($Item)>

constructor(arg0: string, arg1: $RegistryObject$Type<($Block$Type)>, arg2: $BlockBehaviour$Properties$Type, arg3: boolean, arg4: boolean, arg5: boolean)
constructor(arg0: string, arg1: $RegistryObject$Type<($Block$Type)>, arg2: $BlockBehaviour$Properties$Type)

public "makeItems"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$StoneDecoBlocks$Type = ($RegistryManager$StoneDecoBlocks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager$StoneDecoBlocks_ = $RegistryManager$StoneDecoBlocks$Type;
}}
declare module "packages/com/rekindled/embers/particle/$SparkParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $SparkParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "EMBER": $SparkParticleOptions
static readonly "CODEC": $Codec<($SparkParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($SparkParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float)

public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkParticleOptions$Type = ($SparkParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkParticleOptions_ = $SparkParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/item/$ClockworkHammerItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ClockworkToolItem, $ClockworkToolItem$Type} from "packages/com/rekindled/embers/item/$ClockworkToolItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ClockworkHammerItem extends $ClockworkToolItem {
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "canPerformAction"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
public "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkHammerItem$Type = ($ClockworkHammerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkHammerItem_ = $ClockworkHammerItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$CatalysisChamberBlock" {
import {$ChamberBlockBase$ChamberConnection, $ChamberBlockBase$ChamberConnection$Type} from "packages/com/rekindled/embers/block/$ChamberBlockBase$ChamberConnection"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$ChamberBlockBase, $ChamberBlockBase$Type} from "packages/com/rekindled/embers/block/$ChamberBlockBase"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CatalysisChamberBlock extends $ChamberBlockBase {
 "topSound": $SoundType
static readonly "CONNECTION": $EnumProperty<($ChamberBlockBase$ChamberConnection)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisChamberBlock$Type = ($CatalysisChamberBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisChamberBlock_ = $CatalysisChamberBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AtmosphericBellowsBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$AtmosphericBellowsUpgrade, $AtmosphericBellowsUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$AtmosphericBellowsUpgrade"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $AtmosphericBellowsBlockEntity extends $BlockEntity {
 "upgrade": $AtmosphericBellowsUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericBellowsBlockEntity$Type = ($AtmosphericBellowsBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericBellowsBlockEntity_ = $AtmosphericBellowsBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$CopperChargerBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$CopperChargerBlockEntity, $CopperChargerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CopperChargerBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $CopperChargerBlockEntityRenderer implements $BlockEntityRenderer<($CopperChargerBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CopperChargerBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $CopperChargerBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CopperChargerBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperChargerBlockEntityRenderer$Type = ($CopperChargerBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperChargerBlockEntityRenderer_ = $CopperChargerBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/block/$CopperCellBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CopperCellBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getDrops"(arg0: $BlockState$Type, arg1: $LootParams$Builder$Type): $List<($ItemStack)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperCellBlock$Type = ($CopperCellBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperCellBlock_ = $CopperCellBlock$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$ClockworkAttenuatorUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ClockworkAttenuatorUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkAttenuatorUpgrade$Type = ($ClockworkAttenuatorUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkAttenuatorUpgrade_ = $ClockworkAttenuatorUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$AutomaticHammerBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$AutomaticHammerBlockEntity, $AutomaticHammerBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AutomaticHammerBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $AutomaticHammerBlockEntityRenderer implements $BlockEntityRenderer<($AutomaticHammerBlockEntity)> {
static "hammer": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $AutomaticHammerBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $AutomaticHammerBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $AutomaticHammerBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutomaticHammerBlockEntityRenderer$Type = ($AutomaticHammerBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutomaticHammerBlockEntityRenderer_ = $AutomaticHammerBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageDialUpdateRequest" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MessageDialUpdateRequest {
 "pos": long
 "maxLines": integer

constructor(arg0: long, arg1: integer)
constructor(arg0: $BlockPos$Type, arg1: integer)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageDialUpdateRequest
public static "encode"(arg0: $MessageDialUpdateRequest$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageDialUpdateRequest$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageDialUpdateRequest$Type = ($MessageDialUpdateRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageDialUpdateRequest_ = $MessageDialUpdateRequest$Type;
}}
declare module "packages/com/rekindled/embers/item/$AshenArmorItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArmorItem, $ArmorItem$Type} from "packages/net/minecraft/world/item/$ArmorItem"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AshenArmorItem extends $ArmorItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $ArmorMaterial$Type, arg1: $ArmorItem$Type$Type, arg2: $Item$Properties$Type)

public "isBroken"(arg0: $ItemStack$Type): boolean
public "initializeClient"(arg0: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "getArmorTexture"(arg0: $ItemStack$Type, arg1: $Entity$Type, arg2: $EquipmentSlot$Type, arg3: string): string
public "setDamage"(arg0: $ItemStack$Type, arg1: integer): void
public "damageItem"<T extends $LivingEntity>(arg0: $ItemStack$Type, arg1: integer, arg2: T, arg3: $Consumer$Type<(T)>): integer
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AshenArmorItem$Type = ($AshenArmorItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AshenArmorItem_ = $AshenArmorItem$Type;
}}
declare module "packages/com/rekindled/embers/particle/$SmokeParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $SmokeParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "SMOKE_COLOR": $Vector3f
static readonly "SMOKE": $SmokeParticleOptions
static readonly "BIG_SMOKE": $SmokeParticleOptions
static readonly "CODEC": $Codec<($SmokeParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($SmokeParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float)

public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmokeParticleOptions$Type = ($SmokeParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmokeParticleOptions_ = $SmokeParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/particle/$StarParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$StarParticleOptions, $StarParticleOptions$Type} from "packages/com/rekindled/embers/particle/$StarParticleOptions"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $StarParticle extends $TextureSheetParticle {
 "rBase": float
 "gBase": float
 "bBase": float
 "rotScale": float
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $StarParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StarParticle$Type = ($StarParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StarParticle_ = $StarParticle$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ClockworkAttenuatorBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$ClockworkAttenuatorUpgrade, $ClockworkAttenuatorUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$ClockworkAttenuatorUpgrade"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ClockworkAttenuatorBlockEntity extends $BlockEntity {
 "upgrade": $ClockworkAttenuatorUpgrade
 "activeSpeed": double
 "inactiveSpeed": double
 "validSpeeds": (double)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getNext"(arg0: double): double
public "setChanged"(): void
public "getPrevious"(arg0: double): double
public "getSpeed"(): double
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "speed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkAttenuatorBlockEntity$Type = ($ClockworkAttenuatorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkAttenuatorBlockEntity_ = $ClockworkAttenuatorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IEmberInjectable" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export interface $IEmberInjectable {

 "isValid"(): boolean
 "inject"(arg0: $BlockEntity$Type, arg1: double): void

(): boolean
}

export namespace $IEmberInjectable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberInjectable$Type = ($IEmberInjectable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberInjectable_ = $IEmberInjectable$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemVacuumBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ItemVacuumBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVacuumBlock$Type = ($ItemVacuumBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemVacuumBlock_ = $ItemVacuumBlock$Type;
}}
declare module "packages/com/rekindled/embers/util/$EmberInventoryUtil" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $EmberInventoryUtil {

constructor()

public static "getEmberCapacityTotal"(arg0: $Player$Type): double
public static "getEmberTotal"(arg0: $Player$Type): double
public static "removeEmber"(arg0: $Player$Type, arg1: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberInventoryUtil$Type = ($EmberInventoryUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberInventoryUtil_ = $EmberInventoryUtil$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$AlchemyPedestalTopBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$AlchemyPedestalTopBlockEntity, $AlchemyPedestalTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalTopBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $AlchemyPedestalTopBlockEntityRenderer implements $BlockEntityRenderer<($AlchemyPedestalTopBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $AlchemyPedestalTopBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $AlchemyPedestalTopBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $AlchemyPedestalTopBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyPedestalTopBlockEntityRenderer$Type = ($AlchemyPedestalTopBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyPedestalTopBlockEntityRenderer_ = $AlchemyPedestalTopBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/entity/$EmberProjectileEntity" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EntityDataAccessor, $EntityDataAccessor$Type} from "packages/net/minecraft/network/syncher/$EntityDataAccessor"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EmberProjectileEntity extends $Projectile {
static readonly "value": $EntityDataAccessor<(float)>
static readonly "dead": $EntityDataAccessor<(boolean)>
static readonly "lifetime": $EntityDataAccessor<(integer)>
static readonly "color": $EntityDataAccessor<(integer)>
 "effect": $IProjectileEffect
 "ownerUUID": $UUID
 "cachedOwner": $Entity
 "leftOwner": boolean
 "hasBeenShot": boolean
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)

public "setColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "shoot"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float, arg5: double): void
public "setGravity"(arg0: double): void
public "setEffect"(arg0: $IProjectileEffect$Type): void
public "tick"(): void
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
public "m_6532_"(arg0: $HitResult$Type): void
public "shootFromRotation"(arg0: $Entity$Type, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: double): void
public "setHoming"(arg0: integer, arg1: double, arg2: integer, arg3: integer, arg4: $Predicate$Type<($Entity$Type)>): void
public "setPreset"(arg0: $IProjectilePreset$Type): void
public "setLifetime"(arg0: integer): void
set "gravity"(value: double)
set "effect"(value: $IProjectileEffect$Type)
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
set "preset"(value: $IProjectilePreset$Type)
set "lifetime"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberProjectileEntity$Type = ($EmberProjectileEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberProjectileEntity_ = $EmberProjectileEntity$Type;
}}
declare module "packages/com/rekindled/embers/$RegistryManager$FluidStuff" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$ForgeFlowingFluid$Properties, $ForgeFlowingFluid$Properties$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Properties"
import {$ForgeFlowingFluid$Source, $ForgeFlowingFluid$Source$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Source"
import {$BucketItem, $BucketItem$Type} from "packages/net/minecraft/world/item/$BucketItem"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$ForgeFlowingFluid$Flowing, $ForgeFlowingFluid$Flowing$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Flowing"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LiquidBlock, $LiquidBlock$Type} from "packages/net/minecraft/world/level/block/$LiquidBlock"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"

export class $RegistryManager$FluidStuff {
readonly "PROPERTIES": $ForgeFlowingFluid$Properties
readonly "FLUID": $RegistryObject<($ForgeFlowingFluid$Source)>
readonly "FLUID_FLOW": $RegistryObject<($ForgeFlowingFluid$Flowing)>
readonly "TYPE": $RegistryObject<($FluidType)>
readonly "FLUID_BLOCK": $RegistryObject<($LiquidBlock)>
readonly "FLUID_BUCKET": $RegistryObject<($BucketItem)>
readonly "name": string
readonly "localizedName": string
readonly "color": integer

constructor(arg0: string, arg1: string, arg2: integer, arg3: $FluidType$Type, arg4: $BiFunction$Type<($Supplier$Type<(any)>), ($BlockBehaviour$Properties$Type), ($LiquidBlock$Type)>, arg5: $Consumer$Type<($ForgeFlowingFluid$Properties$Type)>, arg6: $Function$Type<($ForgeFlowingFluid$Properties$Type), ($ForgeFlowingFluid$Source$Type)>, arg7: $Function$Type<($ForgeFlowingFluid$Properties$Type), ($ForgeFlowingFluid$Flowing$Type)>)

public "getFluidProperties"(): $ForgeFlowingFluid$Properties
get "fluidProperties"(): $ForgeFlowingFluid$Properties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$FluidStuff$Type = ($RegistryManager$FluidStuff);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager$FluidStuff_ = $RegistryManager$FluidStuff$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IFilterItem" {
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IFilterItem {

 "getFilter"(arg0: $ItemStack$Type): $IFilter

(arg0: $ItemStack$Type): $IFilter
}

export namespace $IFilterItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilterItem$Type = ($IFilterItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilterItem_ = $IFilterItem$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AlchemyRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$AlchemyRecipe, $AlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$AlchemyRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $AlchemyRecipe$Serializer implements $RecipeSerializer<($AlchemyRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AlchemyRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AlchemyRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AlchemyRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AlchemyRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyRecipe$Serializer$Type = ($AlchemyRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyRecipe$Serializer_ = $AlchemyRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemTransferBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemPipeBlockEntityBase, $ItemPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntityBase"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $ItemTransferBlockEntity extends $ItemPipeBlockEntityBase {
static readonly "PRIORITY_TRANSFER": integer
 "filterItem": $ItemStack
 "syncFilter": boolean
 "outputHolder": $LazyOptional<($IItemHandler)>
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getPriority"(arg0: $Direction$Type): integer
public "getConnection"(arg0: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getCapacity"(): integer
public "setupFilter"(): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemTransferBlockEntity$Type): void
public "acceptsItem"(arg0: $ItemStack$Type): boolean
public "getUpdateTag"(): $CompoundTag
get "capacity"(): integer
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransferBlockEntity$Type = ($ItemTransferBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransferBlockEntity_ = $ItemTransferBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/particle/$VaporParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $VaporParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "VAPOR_COLOR": $Vector3f
static readonly "VAPOR": $VaporParticleOptions
static readonly "CODEC": $Codec<($VaporParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($VaporParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: $Vec3$Type, arg2: float)
constructor(arg0: $Vector3f$Type, arg1: float)

public "getMotion"(): $Vec3
public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public static "readVec3"(arg0: $StringReader$Type): $Vec3
public static "readVec3"(arg0: $FriendlyByteBuf$Type): $Vec3
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "motion"(): $Vec3
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaporParticleOptions$Type = ($VaporParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VaporParticleOptions_ = $VaporParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/api/upgrades/$IUpgradeProvider" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IUpgradeProvider {

 "getPriority"(): integer
 "transformEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
 "transformEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
 "getLimit"(arg0: $BlockEntity$Type): integer
 "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
 "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
 "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: integer, arg3: integer): boolean
 "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
 "transformOutput"(arg0: $BlockEntity$Type, arg1: $FluidStack$Type, arg2: integer, arg3: integer): $FluidStack
 "transformOutput"(arg0: $BlockEntity$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: integer, arg3: integer): void
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: integer, arg3: integer, arg4: integer): integer
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: string, arg3: integer, arg4: integer): string
 "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: integer, arg4: integer): T
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: integer, arg4: integer): double
 "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: boolean, arg3: integer, arg4: integer): boolean
 "getUpgradeId"(): $ResourceLocation

(): integer
}

export namespace $IUpgradeProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeProvider$Type = ($IUpgradeProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeProvider_ = $IUpgradeProvider$Type;
}}
declare module "packages/com/rekindled/embers/entity/render/$AncientGolemRenderer" {
import {$RenderLayer, $RenderLayer$Type} from "packages/net/minecraft/client/renderer/entity/layers/$RenderLayer"
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EntityModel, $EntityModel$Type} from "packages/net/minecraft/client/model/$EntityModel"
import {$MobRenderer, $MobRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$MobRenderer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AncientGolemEntity, $AncientGolemEntity$Type} from "packages/com/rekindled/embers/entity/$AncientGolemEntity"
import {$AncientGolemModel, $AncientGolemModel$Type} from "packages/com/rekindled/embers/model/$AncientGolemModel"

export class $AncientGolemRenderer extends $MobRenderer<($AncientGolemEntity), ($AncientGolemModel<($AncientGolemEntity)>)> {
static readonly "LAYER_LOCATION": $ModelLayerLocation
static readonly "TEXTURE": $ResourceLocation
static readonly "LEASH_RENDER_STEPS": integer
 "model": M
 "layers": $List<($RenderLayer<(T), (M)>)>
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "getTextureLocation"(arg0: $AncientGolemEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AncientGolemRenderer$Type = ($AncientGolemRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AncientGolemRenderer_ = $AncientGolemRenderer$Type;
}}
declare module "packages/com/rekindled/embers/block/$AutomaticHammerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $AutomaticHammerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "HAMMER_NORTH_AABB": $VoxelShape
static readonly "HAMMER_EAST_AABB": $VoxelShape
static readonly "HAMMER_SOUTH_AABB": $VoxelShape
static readonly "HAMMER_WEST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutomaticHammerBlock$Type = ($AutomaticHammerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutomaticHammerBlock_ = $AutomaticHammerBlock$Type;
}}
declare module "packages/com/rekindled/embers/particle/$StarParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $StarParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "EMBER": $StarParticleOptions
static readonly "CODEC": $Codec<($StarParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($StarParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float)

public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StarParticleOptions$Type = ($StarParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StarParticleOptions_ = $StarParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/research/capability/$ResearchCapabilityProvider" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IResearchCapability, $IResearchCapability$Type} from "packages/com/rekindled/embers/research/capability/$IResearchCapability"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ResearchCapabilityProvider implements $ICapabilityProvider, $INBTSerializable<($CompoundTag)> {
 "holder": $LazyOptional<($IResearchCapability)>
static readonly "researchCapability": $Capability<($IResearchCapability)>

constructor()
constructor(arg0: $IResearchCapability$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchCapabilityProvider$Type = ($ResearchCapabilityProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchCapabilityProvider_ = $ResearchCapabilityProvider$Type;
}}
declare module "packages/com/rekindled/embers/util/$EmberWorldData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SavedData, $SavedData$Type} from "packages/net/minecraft/world/level/saveddata/$SavedData"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $EmberWorldData extends $SavedData {

constructor(arg0: $CompoundTag$Type)

public static "get"(arg0: $ServerLevel$Type): $EmberWorldData
public "save"(arg0: $CompoundTag$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberWorldData$Type = ($EmberWorldData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberWorldData_ = $EmberWorldData$Type;
}}
declare module "packages/com/rekindled/embers/particle/$GlowParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $GlowParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "EMBER_COLOR": $Vector3f
static readonly "EMBER": $GlowParticleOptions
static readonly "EMBER_NOMOTION": $GlowParticleOptions
static readonly "CODEC": $Codec<($GlowParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($GlowParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float)
constructor(arg0: $Vector3f$Type, arg1: float, arg2: integer)
constructor(arg0: $Vector3f$Type, arg1: $Vec3$Type, arg2: float)
constructor(arg0: $Vector3f$Type, arg1: $Vec3$Type, arg2: float, arg3: integer)

public "getLifetime"(): integer
public "getMotion"(): $Vec3
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVec3"(arg0: $StringReader$Type): $Vec3
public static "readVec3"(arg0: $FriendlyByteBuf$Type): $Vec3
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "lifetime"(): integer
get "motion"(): $Vec3
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlowParticleOptions$Type = ($GlowParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlowParticleOptions_ = $GlowParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MeltingRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$MeltingRecipe, $MeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MeltingRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $MeltingRecipe$Serializer implements $RecipeSerializer<($MeltingRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $MeltingRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $MeltingRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $MeltingRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $MeltingRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingRecipe$Serializer$Type = ($MeltingRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingRecipe$Serializer_ = $MeltingRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$CrystalCellBlockEntityRenderer" {
import {$CrystalCellBlockEntity, $CrystalCellBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CrystalCellBlockEntity"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $CrystalCellBlockEntityRenderer implements $BlockEntityRenderer<($CrystalCellBlockEntity)> {
 "texture": $ResourceLocation

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CrystalCellBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $CrystalCellBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CrystalCellBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalCellBlockEntityRenderer$Type = ($CrystalCellBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalCellBlockEntityRenderer_ = $CrystalCellBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$FluidIngredient" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $FluidIngredient {
static readonly "EMPTY": $FluidIngredient

constructor()

public "test"(arg0: $FluidStack$Type): boolean
public "test"(arg0: $Fluid$Type): boolean
public static "of"(arg0: $Fluid$Type, arg1: integer): $FluidIngredient
public static "of"(arg0: $FluidStack$Type): $FluidIngredient
public static "of"(...arg0: ($FluidIngredient$Type)[]): $FluidIngredient
public static "of"(arg0: $TagKey$Type<($Fluid$Type)>, arg1: integer): $FluidIngredient
public "write"(arg0: $FriendlyByteBuf$Type): void
public static "read"(arg0: $FriendlyByteBuf$Type): $FluidIngredient
public static "deserialize"(arg0: $JsonObject$Type, arg1: string): $FluidIngredient
public static "deserialize"(arg0: $JsonElement$Type, arg1: string): $FluidIngredient
public "getAmount"(arg0: $Fluid$Type): integer
public "serialize"(): $JsonElement
public "getFluids"(): $List<($FluidStack)>
get "fluids"(): $List<($FluidStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredient$Type = ($FluidIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredient_ = $FluidIngredient$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$PressureRefineryTopBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PressureRefineryTopBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
 "capability": $IEmberCapability
static readonly "SOUND_HAS_EMBER": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $PressureRefineryTopBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressureRefineryTopBlockEntity$Type = ($PressureRefineryTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressureRefineryTopBlockEntity_ = $PressureRefineryTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/sound/$MachineSound" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$AbstractTickableSoundInstance, $AbstractTickableSoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$AbstractTickableSoundInstance"

export class $MachineSound extends $AbstractTickableSoundInstance {

constructor(arg0: $BlockEntity$Type, arg1: integer, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float)

public "tick"(): void
public "isStopped"(): boolean
public static "createUnseededRandom"(): $RandomSource
get "stopped"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineSound$Type = ($MachineSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineSound_ = $MachineSound$Type;
}}
declare module "packages/com/rekindled/embers/block/$FluidVesselBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $FluidVesselBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getDrops"(arg0: $BlockState$Type, arg1: $LootParams$Builder$Type): $List<($ItemStack)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidVesselBlock$Type = ($FluidVesselBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidVesselBlock_ = $FluidVesselBlock$Type;
}}
declare module "packages/com/rekindled/embers/util/$ExplosionCharmWorldInfo" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ExplosionCharmWorldInfo {

constructor()

public "put"(arg0: $BlockPos$Type): void
public "getClosestExplosionCharm"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: integer): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionCharmWorldInfo$Type = ($ExplosionCharmWorldInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionCharmWorldInfo_ = $ExplosionCharmWorldInfo$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$IItemPipePriority" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IItemPipePriority {

 "getPriority"(arg0: $Direction$Type): integer

(arg0: $Direction$Type): integer
}

export namespace $IItemPipePriority {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemPipePriority$Type = ($IItemPipePriority);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemPipePriority_ = $IItemPipePriority$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberBoreEdgeBlock" {
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $EmberBoreEdgeBlock extends $MechEdgeBlockBase {
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreEdgeBlock$Type = ($EmberBoreEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreEdgeBlock_ = $EmberBoreEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteRingBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CaminiteRingBlock extends $Block implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteRingBlock$Type = ($CaminiteRingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteRingBlock_ = $CaminiteRingBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemExtractorBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ExtractorBlockBase, $ExtractorBlockBase$Type} from "packages/com/rekindled/embers/block/$ExtractorBlockBase"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ItemExtractorBlock extends $ExtractorBlockBase {
static readonly "EXTRACTOR_AABB": $VoxelShape
static readonly "EXTRACTOR_SHAPES": ($VoxelShape)[]
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "connectToTile"(arg0: $BlockEntity$Type, arg1: $Direction$Type): boolean
public "unclog"(arg0: $BlockEntity$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getConnectionTag"(): $TagKey<($Block)>
public "getToggleConnectionTag"(): $TagKey<($Block)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "connectionTag"(): $TagKey<($Block)>
get "toggleConnectionTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemExtractorBlock$Type = ($ItemExtractorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemExtractorBlock_ = $ItemExtractorBlock$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$BoringCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBoringRecipe, $IBoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoringRecipe"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $BoringCategory implements $IRecipeCategory<($IBoringRecipe)> {
 "icon": $IDrawable
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IBoringRecipe)>
public "draw"(arg0: $IBoringRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IBoringRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getTooltipStrings"(arg0: $IBoringRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IBoringRecipe$Type): boolean
public "handleInput"(arg0: $IBoringRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getRegistryName"(arg0: $IBoringRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IBoringRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoringCategory$Type = ($BoringCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoringCategory_ = $BoringCategory$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$ITargetable" {
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $ITargetable {

 "setTarget"(arg0: $BlockPos$Type): void

(arg0: $BlockPos$Type): void
}

export namespace $ITargetable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITargetable$Type = ($ITargetable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITargetable_ = $ITargetable$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MixerCentrifugeTopBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$MixerCentrifugeTopBlockEntity, $MixerCentrifugeTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MixerCentrifugeTopBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MixerCentrifugeTopBlockEntityRenderer implements $BlockEntityRenderer<($MixerCentrifugeTopBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MixerCentrifugeTopBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MixerCentrifugeTopBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MixerCentrifugeTopBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeTopBlockEntityRenderer$Type = ($MixerCentrifugeTopBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeTopBlockEntityRenderer_ = $MixerCentrifugeTopBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/api/upgrades/$IUpgradeProxy" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IUpgradeProxy {

 "collectUpgrades"(arg0: $List$Type<($UpgradeContext$Type)>, arg1: integer): void
 "isProvider"(arg0: $Direction$Type): boolean
 "isSocket"(arg0: $Direction$Type): boolean
}

export namespace $IUpgradeProxy {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeProxy$Type = ($IUpgradeProxy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeProxy_ = $IUpgradeProxy$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$IFilterComparator" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnumFilterSetting, $EnumFilterSetting$Type} from "packages/com/rekindled/embers/api/filter/$EnumFilterSetting"

export interface $IFilterComparator {

 "getName"(): string
 "format"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $EnumFilterSetting$Type, arg3: boolean): string
 "match"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "getPriority"(): integer
 "isBetween"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $EnumFilterSetting$Type): boolean
 "getCompare"(arg0: $ItemStack$Type): integer
}

export namespace $IFilterComparator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilterComparator$Type = ($IFilterComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilterComparator_ = $IFilterComparator$Type;
}}
declare module "packages/com/rekindled/embers/block/$DoubleTallMachineBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $DoubleTallMachineBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "getSoundType"(arg0: $BlockState$Type): $SoundType
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleTallMachineBlock$Type = ($DoubleTallMachineBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleTallMachineBlock_ = $DoubleTallMachineBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MeltingRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$MeltingRecipe, $MeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MeltingRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $MeltingRecipeBuilder {
 "id": $ResourceLocation
 "ingredient": $Ingredient
 "output": $FluidStack
 "bonus": $FluidStack

constructor()

public "id"(arg0: $ResourceLocation$Type): $MeltingRecipeBuilder
public "domain"(arg0: string): $MeltingRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $Ingredient$Type): $MeltingRecipeBuilder
public static "create"(arg0: $TagKey$Type<($Item$Type)>): $MeltingRecipeBuilder
public static "create"(arg0: $ItemStack$Type): $MeltingRecipeBuilder
public static "create"(arg0: $Item$Type): $MeltingRecipeBuilder
public "build"(): $MeltingRecipe
public "output"(arg0: $Fluid$Type, arg1: integer): $MeltingRecipeBuilder
public "output"(arg0: $FluidStack$Type): $MeltingRecipeBuilder
public "folder"(arg0: string): $MeltingRecipeBuilder
public "bonusName"(arg0: string): $MeltingRecipeBuilder
public "bonus"(arg0: $FluidStack$Type): $MeltingRecipeBuilder
public "bonus"(arg0: $Fluid$Type, arg1: integer): $MeltingRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingRecipeBuilder$Type = ($MeltingRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingRecipeBuilder_ = $MeltingRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/block/$ExcavationBucketsBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ExcavationBucketsBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationBucketsBlock$Type = ($ExcavationBucketsBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationBucketsBlock_ = $ExcavationBucketsBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity$EmberBoreInventory" {
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EmberBoreBlockEntity, $EmberBoreBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberBoreBlockEntity"

export class $EmberBoreBlockEntity$EmberBoreInventory extends $ItemStackHandler {

constructor(arg0: $EmberBoreBlockEntity$Type, arg1: $NonNullList$Type<(any)>)
constructor(arg0: $EmberBoreBlockEntity$Type, arg1: integer)
constructor(arg0: $EmberBoreBlockEntity$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "insertItemInternal"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreBlockEntity$EmberBoreInventory$Type = ($EmberBoreBlockEntity$EmberBoreInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreBlockEntity$EmberBoreInventory_ = $EmberBoreBlockEntity$EmberBoreInventory$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$BinBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IBin, $IBin$Type} from "packages/com/rekindled/embers/api/tile/$IBin"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BinBlockEntity extends $BlockEntity implements $IBin {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getInventory"(): $IItemHandler
public "setChanged"(): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BinBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "inventory"(): $IItemHandler
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinBlockEntity$Type = ($BinBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinBlockEntity_ = $BinBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$GenericCurioItemItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GenericCurioItemItem extends $Item implements $IEmbersCurioItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
public "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericCurioItemItem$Type = ($GenericCurioItemItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericCurioItemItem_ = $GenericCurioItemItem$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageEmberRayFX" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageEmberRayFX {
static "random": $Random

constructor()
constructor(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: integer)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageEmberRayFX
public static "encode"(arg0: $MessageEmberRayFX$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageEmberRayFX$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
public static "spawnParticles"(arg0: $MessageEmberRayFX$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageEmberRayFX$Type = ($MessageEmberRayFX);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageEmberRayFX_ = $MessageEmberRayFX$Type;
}}
declare module "packages/com/rekindled/embers/augment/$ShiftingScalesAugment" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$AttachCapabilitiesEvent, $AttachCapabilitiesEvent$Type} from "packages/net/minecraftforge/event/$AttachCapabilitiesEvent"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ShiftingScalesAugment$ShardParticle, $ShiftingScalesAugment$ShardParticle$Type} from "packages/com/rekindled/embers/augment/$ShiftingScalesAugment$ShardParticle"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$LivingEvent$LivingTickEvent, $LivingEvent$LivingTickEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $ShiftingScalesAugment extends $AugmentBase {
static readonly "TEXTURE_HUD": $ResourceLocation
static readonly "SCALES": $ResourceLocation
static readonly "COOLDOWN": integer
static readonly "MOVE_PER_SECOND_THRESHOLD": double
static "unaffectedDamageTypes": $HashSet<(string)>
static "cooldownTicksServer": $HashMap<($UUID), (integer)>
static "lastPositionServer": $HashMap<($UUID), ($Vec3)>
static "shards": $ArrayList<($ShiftingScalesAugment$ShardParticle)>
static "scales": integer
static "scalesLast": integer

constructor(arg0: $ResourceLocation$Type)

public static "setCooldown"(arg0: $UUID$Type, arg1: integer): void
public static "hasCooldown"(arg0: $UUID$Type): boolean
public static "setLastPosition"(arg0: $UUID$Type, arg1: $Vec3$Type): void
public static "getMoveDistance"(arg0: $UUID$Type, arg1: $Vec3$Type): double
public static "sendScalesData"(arg0: $ServerPlayer$Type): void
public static "setMaxCooldown"(arg0: $UUID$Type, arg1: integer): void
public "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
public static "attachCapability"(arg0: $AttachCapabilitiesEvent$Type<($Entity$Type)>): void
public "onHit"(arg0: $LivingDamageEvent$Type): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
public "onUpdate"(arg0: $LivingEvent$LivingTickEvent$Type): void
public static "renderHeartsOverlay"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public static "renderIngameOverlay"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShiftingScalesAugment$Type = ($ShiftingScalesAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShiftingScalesAugment_ = $ShiftingScalesAugment$Type;
}}
declare module "packages/com/rekindled/embers/api/block/$IPipeConnection" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export interface $IPipeConnection {

 "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection

(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
}

export namespace $IPipeConnection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPipeConnection$Type = ($IPipeConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPipeConnection_ = $IPipeConnection$Type;
}}
declare module "packages/com/rekindled/embers/particle/$SmokeParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$SmokeParticleOptions, $SmokeParticleOptions$Type} from "packages/com/rekindled/embers/particle/$SmokeParticleOptions"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $SmokeParticle extends $TextureSheetParticle {
 "rotScale": float
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $SmokeParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmokeParticle$Type = ($SmokeParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmokeParticle_ = $SmokeParticle$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$PressureRefineryBottomBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMetalCoefficientRecipe, $IMetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidHandlerBlockEntity, $FluidHandlerBlockEntity$Type} from "packages/net/minecraftforge/fluids/capability/$FluidHandlerBlockEntity"

export class $PressureRefineryBottomBlockEntity extends $FluidHandlerBlockEntity implements $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "BASE_MULTIPLIER": float
static readonly "FLUID_CONSUMED": integer
static readonly "PER_BLOCK_MULTIPLIER": float
static readonly "PROCESS_TIME": integer
static "capacity": integer
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $IEmberActivationRecipe
 "cachedCoefficient": $IMetalCoefficientRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getMultiplier"(): double
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $PressureRefineryBottomBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $PressureRefineryBottomBlockEntity$Type): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "multiplier"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressureRefineryBottomBlockEntity$Type = ($PressureRefineryBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressureRefineryBottomBlockEntity_ = $PressureRefineryBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/$ConsumerWrapperBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $ConsumerWrapperBuilder {


public static "wrap"(arg0: $ResourceLocation$Type): $ConsumerWrapperBuilder
public static "wrap"(arg0: $RecipeSerializer$Type<(any)>): $ConsumerWrapperBuilder
public static "wrap"(): $ConsumerWrapperBuilder
public "build"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): $Consumer<($FinishedRecipe)>
public "addCondition"(arg0: $ICondition$Type): $ConsumerWrapperBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsumerWrapperBuilder$Type = ($ConsumerWrapperBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsumerWrapperBuilder_ = $ConsumerWrapperBuilder$Type;
}}
declare module "packages/com/rekindled/embers/util/$GlowingTextTooltip" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"

export class $GlowingTextTooltip implements $TooltipComponent {
 "normalText": $FormattedCharSequence
 "glowingText": $FormattedCharSequence

constructor(arg0: $FormattedCharSequence$Type, arg1: $FormattedCharSequence$Type)
constructor(arg0: $FormattedCharSequence$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlowingTextTooltip$Type = ($GlowingTextTooltip);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlowingTextTooltip_ = $GlowingTextTooltip$Type;
}}
declare module "packages/com/rekindled/embers/research/$ResearchCategoryComingSoon" {
import {$LinkedList, $LinkedList$Type} from "packages/java/util/$LinkedList"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Vec2i, $Vec2i$Type} from "packages/com/rekindled/embers/util/$Vec2i"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ResearchCategory, $ResearchCategory$Type} from "packages/com/rekindled/embers/research/$ResearchCategory"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ResearchCategoryComingSoon extends $ResearchCategory {
static readonly "NO_PREREQUISITES": $ArrayList<($ResearchBase)>
 "name": string
 "u": double
 "v": double
 "texture": $ResourceLocation
 "background": $ResourceLocation
 "researches": $ArrayList<($ResearchBase)>
 "prerequisites": $ArrayList<($ResearchBase)>
 "goodLocations": $LinkedList<($Vec2i)>

constructor(arg0: string, arg1: $ResourceLocation$Type, arg2: double, arg3: double)
constructor(arg0: string, arg1: double, arg2: double)
constructor(arg0: string, arg1: double)

public "isChecked"(): boolean
public "getTooltip"(arg0: boolean): $List<($Component)>
get "checked"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchCategoryComingSoon$Type = ($ResearchCategoryComingSoon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchCategoryComingSoon_ = $ResearchCategoryComingSoon$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe" {
import {$MetalCoefficientRecipe$Serializer, $MetalCoefficientRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$MetalCoefficientRecipe$Serializer"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IMetalCoefficientRecipe, $IMetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$BlockStateContext, $BlockStateContext$Type} from "packages/com/rekindled/embers/recipe/$BlockStateContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $MetalCoefficientRecipe implements $IMetalCoefficientRecipe {
static readonly "SERIALIZER": $MetalCoefficientRecipe$Serializer
readonly "id": $ResourceLocation
readonly "blockTag": $TagKey<($Block)>
readonly "coefficient": double

constructor(arg0: $ResourceLocation$Type, arg1: $TagKey$Type<($Block$Type)>, arg2: double)

public "matches"(arg0: $BlockStateContext$Type, arg1: $Level$Type): boolean
public "getDisplayInput"(): $List<($ItemStack)>
public "getCoefficient"(arg0: $BlockStateContext$Type): double
public "getSerializer"(): $RecipeSerializer<(any)>
public "getDisplayCoefficient"(): double
public "getId"(): $ResourceLocation
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $BlockStateContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $BlockStateContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayInput"(): $List<($ItemStack)>
get "serializer"(): $RecipeSerializer<(any)>
get "displayCoefficient"(): double
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalCoefficientRecipe$Type = ($MetalCoefficientRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetalCoefficientRecipe_ = $MetalCoefficientRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MeltingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MeltingRecipe$Serializer, $MeltingRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$MeltingRecipe$Serializer"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $MeltingRecipe implements $IMeltingRecipe {
static readonly "SERIALIZER": $MeltingRecipe$Serializer
readonly "id": $ResourceLocation
readonly "ingredient": $Ingredient
readonly "output": $FluidStack
readonly "bonus": $FluidStack

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $FluidStack$Type, arg3: $FluidStack$Type)
constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $FluidStack$Type)

public "process"(arg0: $Container$Type): $FluidStack
public "getDisplayOutput"(): $FluidStack
public "getDisplayInput"(): $Ingredient
public "getBonus"(): $FluidStack
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getOutput"(arg0: $Container$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $FluidStack
get "displayInput"(): $Ingredient
get "bonus"(): $FluidStack
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingRecipe$Type = ($MeltingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingRecipe_ = $MeltingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$FilterAny" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $FilterAny implements $IFilter {
static readonly "RESOURCE_LOCATION": $ResourceLocation

constructor()

public "getType"(): $ResourceLocation
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "formatFilter"(): string
public "acceptsItem"(arg0: $ItemStack$Type): boolean
public "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterAny$Type = ($FilterAny);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterAny_ = $FilterAny$Type;
}}
declare module "packages/com/rekindled/embers/block/$CrystalSeedBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $CrystalSeedBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static "CRYSTAL_AABB": $VoxelShape
 "type": string
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: string)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalSeedBlock$Type = ($CrystalSeedBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalSeedBlock_ = $CrystalSeedBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MechEdgeBlockBase$MechEdge extends $Enum<($MechEdgeBlockBase$MechEdge)> implements $StringRepresentable {
static readonly "NORTH": $MechEdgeBlockBase$MechEdge
static readonly "NORTHEAST": $MechEdgeBlockBase$MechEdge
static readonly "EAST": $MechEdgeBlockBase$MechEdge
static readonly "SOUTHEAST": $MechEdgeBlockBase$MechEdge
static readonly "SOUTH": $MechEdgeBlockBase$MechEdge
static readonly "SOUTHWEST": $MechEdgeBlockBase$MechEdge
static readonly "WEST": $MechEdgeBlockBase$MechEdge
static readonly "NORTHWEST": $MechEdgeBlockBase$MechEdge
readonly "index": integer
readonly "centerPos": $Vec3i
readonly "corner": boolean
readonly "rotation": integer


public "toString"(): string
public static "values"(): ($MechEdgeBlockBase$MechEdge)[]
public static "valueOf"(arg0: string): $MechEdgeBlockBase$MechEdge
public "getSerializedName"(): string
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechEdgeBlockBase$MechEdge$Type = (("southwest") | ("east") | ("south") | ("north") | ("northwest") | ("west") | ("northeast") | ("southeast")) | ($MechEdgeBlockBase$MechEdge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechEdgeBlockBase$MechEdge_ = $MechEdgeBlockBase$MechEdge$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemDropperBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ItemDropperBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDropperBlock$Type = ($ItemDropperBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDropperBlock_ = $ItemDropperBlock$Type;
}}
declare module "packages/com/rekindled/embers/util/$LegacyDeferredRegister" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $LegacyDeferredRegister<T> {

constructor(arg0: $DeferredRegister$Type<(T)>, arg1: $DeferredRegister$Type<(T)>)

public "register"<I extends T>(arg0: string, arg1: $Supplier$Type<(any)>): $RegistryObject<(I)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyDeferredRegister$Type<T> = ($LegacyDeferredRegister<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyDeferredRegister_<T> = $LegacyDeferredRegister$Type<(T)>;
}}
declare module "packages/com/rekindled/embers/block/$ChamberBlockBase$ChamberConnection" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ChamberBlockBase$ChamberConnection extends $Enum<($ChamberBlockBase$ChamberConnection)> implements $StringRepresentable {
static readonly "BOTTOM": $ChamberBlockBase$ChamberConnection
static readonly "TOP": $ChamberBlockBase$ChamberConnection
static readonly "NORTH": $ChamberBlockBase$ChamberConnection
static readonly "SOUTH": $ChamberBlockBase$ChamberConnection
static readonly "WEST": $ChamberBlockBase$ChamberConnection
static readonly "EAST": $ChamberBlockBase$ChamberConnection
 "direction": $Direction


public "toString"(): string
public static "values"(): ($ChamberBlockBase$ChamberConnection)[]
public static "valueOf"(arg0: string): $ChamberBlockBase$ChamberConnection
public static "getConnection"(arg0: $Direction$Type): $ChamberBlockBase$ChamberConnection
public "getSerializedName"(): string
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChamberBlockBase$ChamberConnection$Type = (("east") | ("top") | ("south") | ("bottom") | ("north") | ("west")) | ($ChamberBlockBase$ChamberConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChamberBlockBase$ChamberConnection_ = $ChamberBlockBase$ChamberConnection$Type;
}}
declare module "packages/com/rekindled/embers/gui/$SlateScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SlateMenu, $SlateMenu$Type} from "packages/com/rekindled/embers/gui/$SlateMenu"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $SlateScreen extends $AbstractContainerScreen<($SlateMenu)> {
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $SlateMenu$Type, arg1: $Inventory$Type, arg2: $Component$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "m_280003_"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer): void
public "m_7286_"(arg0: $GuiGraphics$Type, arg1: float, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlateScreen$Type = ($SlateScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlateScreen_ = $SlateScreen$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AutomaticHammerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMechanicallyPowered, $IMechanicallyPowered$Type} from "packages/com/rekindled/embers/api/tile/$IMechanicallyPowered"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $AutomaticHammerBlockEntity extends $BlockEntity implements $IMechanicallyPowered, $IExtraDialInformation {
static readonly "EMBER_COST": double
static readonly "PROCESS_TIME": integer
 "capability": $IEmberCapability
 "startTime": long
 "processTime": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AutomaticHammerBlockEntity$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AutomaticHammerBlockEntity$Type): void
public "getMechanicalSpeed"(arg0: double): double
public "getMinimumPower"(): double
public "getNominalSpeed"(): double
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getStandardPowerRatio"(): double
public "getMaximumPower"(): double
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
get "renderBoundingBox"(): $AABB
get "minimumPower"(): double
get "nominalSpeed"(): double
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "standardPowerRatio"(): double
get "maximumPower"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutomaticHammerBlockEntity$Type = ($AutomaticHammerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutomaticHammerBlockEntity_ = $AutomaticHammerBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/sound/$ItemUseSound" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$AbstractTickableSoundInstance, $AbstractTickableSoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$AbstractTickableSoundInstance"

export class $ItemUseSound extends $AbstractTickableSoundInstance {

constructor(arg0: $LivingEntity$Type, arg1: $Item$Type, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float)

public "tick"(): void
public static "createUnseededRandom"(): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemUseSound$Type = ($ItemUseSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemUseSound_ = $ItemUseSound$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemVacuumBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ItemVacuumBlockEntity extends $BlockEntity {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public static "tick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemVacuumBlockEntity$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVacuumBlockEntity$Type = ($ItemVacuumBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemVacuumBlockEntity_ = $ItemVacuumBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$CaminiteValveEdgeBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $CaminiteValveEdgeBlock extends $MechEdgeBlockBase implements $EntityBlock {
static readonly "X_AABB": $VoxelShape
static readonly "Z_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getCenterBlock"(): $Block
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteValveEdgeBlock$Type = ($CaminiteValveEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteValveEdgeBlock_ = $CaminiteValveEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$MetalCoefficientCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$IMetalCoefficientRecipe, $IMetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $MetalCoefficientCategory implements $IRecipeCategory<($IMetalCoefficientRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IMetalCoefficientRecipe)>
public "draw"(arg0: $IMetalCoefficientRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IMetalCoefficientRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IMetalCoefficientRecipe$Type): boolean
public "handleInput"(arg0: $IMetalCoefficientRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IMetalCoefficientRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IMetalCoefficientRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IMetalCoefficientRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalCoefficientCategory$Type = ($MetalCoefficientCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetalCoefficientCategory_ = $MetalCoefficientCategory$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoringRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BoringRecipe$Serializer, $BoringRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$BoringRecipe$Serializer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BoringContext, $BoringContext$Type} from "packages/com/rekindled/embers/recipe/$BoringContext"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$WeightedItemStack, $WeightedItemStack$Type} from "packages/com/rekindled/embers/util/$WeightedItemStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBoringRecipe, $IBoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoringRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $BoringRecipe implements $IBoringRecipe {
static readonly "SERIALIZER": $BoringRecipe$Serializer
readonly "id": $ResourceLocation
readonly "result": $WeightedItemStack
readonly "minHeight": integer
readonly "maxHeight": integer
readonly "dimensions": $HashSet<($ResourceLocation)>
readonly "biomes": $HashSet<($ResourceLocation)>
readonly "requiredBlock": $TagKey<($Block)>
readonly "amountRequired": integer
readonly "chance": double

constructor(arg0: $ResourceLocation$Type, arg1: $WeightedItemStack$Type, arg2: integer, arg3: integer, arg4: $HashSet$Type<($ResourceLocation$Type)>, arg5: $HashSet$Type<($ResourceLocation$Type)>, arg6: $TagKey$Type<($Block$Type)>, arg7: integer, arg8: double)

public "matches"(arg0: $BoringContext$Type, arg1: $Level$Type): boolean
public "getDimensions"(): $Collection<($ResourceLocation)>
public "getBiomes"(): $Collection<($ResourceLocation)>
public "getMinHeight"(): integer
public "getMaxHeight"(): integer
public "getDisplayOutput"(): $WeightedItemStack
public "getDisplayInput"(): $List<($ItemStack)>
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getSerializer"(): $RecipeSerializer<(any)>
public "getChance"(): double
public "getId"(): $ResourceLocation
public "getOutput"(arg0: $BoringContext$Type): $WeightedItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $BoringContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $BoringContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "dimensions"(): $Collection<($ResourceLocation)>
get "biomes"(): $Collection<($ResourceLocation)>
get "minHeight"(): integer
get "maxHeight"(): integer
get "displayOutput"(): $WeightedItemStack
get "displayInput"(): $List<($ItemStack)>
get "serializer"(): $RecipeSerializer<(any)>
get "chance"(): double
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoringRecipe$Type = ($BoringRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoringRecipe_ = $BoringRecipe$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidDialBlockEntity" {
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IDialEntity, $IDialEntity$Type} from "packages/com/rekindled/embers/api/tile/$IDialEntity"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidDialBlockEntity extends $BlockEntity implements $IDialEntity {
 "fluids": ($FluidStack)[]
 "capacities": (integer)[]
 "extraLines": integer
 "display": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getUpdatePacket"(arg0: integer): $Packet<($ClientGamePacketListener)>
public "load"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(arg0: integer): $CompoundTag
public "getUpdateTag"(): $CompoundTag
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDialBlockEntity$Type = ($FluidDialBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDialBlockEntity_ = $FluidDialBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/research/subtypes/$ResearchShowItem$DisplayItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ResearchShowItem$DisplayItem {
 "stacks": ($ItemStack)[]
 "sideText": string

constructor(...arg0: ($ItemStack$Type)[])
constructor(arg0: string, ...arg1: ($ItemStack$Type)[])

public "getSideText"(): $Component
public "getStacks"(): ($ItemStack)[]
get "sideText"(): $Component
get "stacks"(): ($ItemStack)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchShowItem$DisplayItem$Type = ($ResearchShowItem$DisplayItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchShowItem$DisplayItem_ = $ResearchShowItem$DisplayItem$Type;
}}
declare module "packages/com/rekindled/embers/item/$CinderStaffItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IProjectileWeapon, $IProjectileWeapon$Type} from "packages/com/rekindled/embers/api/item/$IProjectileWeapon"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CinderStaffItem extends $Item implements $IProjectileWeapon {
static "soundPlaying": boolean
static "rand": $Random
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "getUseDuration"(arg0: $ItemStack$Type): integer
public "onUseTick"(arg0: $Level$Type, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): void
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "getUseAnimation"(arg0: $ItemStack$Type): $UseAnim
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CinderStaffItem$Type = ($CinderStaffItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CinderStaffItem_ = $CinderStaffItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$FluidExtractorBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ExtractorBlockBase, $ExtractorBlockBase$Type} from "packages/com/rekindled/embers/block/$ExtractorBlockBase"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidExtractorBlock extends $ExtractorBlockBase {
static readonly "EXTRACTOR_AABB": $VoxelShape
static readonly "EXTRACTOR_SHAPES": ($VoxelShape)[]
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "connectToTile"(arg0: $BlockEntity$Type, arg1: $Direction$Type): boolean
public "unclog"(arg0: $BlockEntity$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getConnectionTag"(): $TagKey<($Block)>
public "getToggleConnectionTag"(): $TagKey<($Block)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "connectionTag"(): $TagKey<($Block)>
get "toggleConnectionTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidExtractorBlock$Type = ($FluidExtractorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidExtractorBlock_ = $FluidExtractorBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/$EmbersAPI" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IEmbersAPI, $IEmbersAPI$Type} from "packages/com/rekindled/embers/api/$IEmbersAPI"

export class $EmbersAPI {
static "IMPL": $IEmbersAPI

constructor()

public static "registerWearableLens"(arg0: $Ingredient$Type): void
public static "registerHammerTargetGetter"(arg0: $Function$Type<($Player$Type), ($Pair$Type<($BlockPos$Type), ($Direction$Type)>)>): void
public static "registerHammerTargetGetter"(arg0: $Item$Type): void
public static "getEmberCapacityTotal"(arg0: $Player$Type): double
public static "registerEmberResonance"(arg0: $Ingredient$Type, arg1: double): void
public static "registerLinkingHammer"(arg0: $BiPredicate$Type<($Player$Type), ($InteractionHand$Type)>): void
public static "registerLinkingHammer"(arg0: $Item$Type): void
public static "getEmberDensity"(arg0: long, arg1: integer, arg2: integer): float
public static "getEmberStability"(arg0: long, arg1: integer, arg2: integer): float
public static "registerLens"(arg0: $Ingredient$Type): void
public static "registerLens"(arg0: $Predicate$Type<($Player$Type)>): void
public static "setScales"(arg0: $LivingEntity$Type, arg1: double): void
public static "getScales"(arg0: $LivingEntity$Type): double
public static "getEmberTotal"(arg0: $Player$Type): double
public static "removeEmber"(arg0: $Player$Type, arg1: double): void
public static "getEmberResonance"(arg0: $ItemStack$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersAPI$Type = ($EmbersAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersAPI_ = $EmbersAPI$Type;
}}
declare module "packages/com/rekindled/embers/item/$FluidVesselBlockItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FluidVesselBlockItem extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type, arg1: $Item$Properties$Type)

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
public "getMaxStackSize"(arg0: $ItemStack$Type): integer
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidVesselBlockItem$Type = ($FluidVesselBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidVesselBlockItem_ = $FluidVesselBlockItem$Type;
}}
declare module "packages/com/rekindled/embers/util/$Vec2i" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Vec2i {
 "x": integer
 "y": integer

constructor(arg0: integer, arg1: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Vec2i$Type = ($Vec2i);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Vec2i_ = $Vec2i$Type;
}}
declare module "packages/com/rekindled/embers/item/$CopperCellBlockItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CopperCellBlockItem extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type, arg1: $Item$Properties$Type)

public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "getBarColor"(arg0: $ItemStack$Type): integer
public "isBarVisible"(arg0: $ItemStack$Type): boolean
public "getBarWidth"(arg0: $ItemStack$Type): integer
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public static "getCharged"(): $ItemStack
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
get "charged"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperCellBlockItem$Type = ($CopperCellBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperCellBlockItem_ = $CopperCellBlockItem$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ExplosionPedestalBlockEntity" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ExplosionPedestalBlockEntity extends $BlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "absorb"(arg0: $Explosion$Type): void
public "onLoad"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionPedestalBlockEntity$Type = ($ExplosionPedestalBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionPedestalBlockEntity_ = $ExplosionPedestalBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/augment/$CoreAugment" {
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $CoreAugment extends $AugmentBase {

constructor()

public "countTowardsTotalLevel"(): boolean
public "canRemove"(): boolean
public "shouldRenderTooltip"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreAugment$Type = ($CoreAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreAugment_ = $CoreAugment$Type;
}}
declare module "packages/com/rekindled/embers/util/$AshenAmuletLootModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootModifier, $LootModifier$Type} from "packages/net/minecraftforge/common/loot/$LootModifier"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"

export class $AshenAmuletLootModifier extends $LootModifier {
static readonly "CODEC": $Codec<($AshenAmuletLootModifier)>

constructor(arg0: ($LootItemCondition$Type)[])

public "doApply"(arg0: $ObjectArrayList$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $ObjectArrayList<($ItemStack)>
public "codec"(): $Codec<($AshenAmuletLootModifier)>
public static "getJson"<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AshenAmuletLootModifier$Type = ($AshenAmuletLootModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AshenAmuletLootModifier_ = $AshenAmuletLootModifier$Type;
}}
declare module "packages/com/rekindled/embers/item/$ClockworkToolItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DiggerItem, $DiggerItem$Type} from "packages/net/minecraft/world/item/$DiggerItem"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IEmberChargedTool, $IEmberChargedTool$Type} from "packages/com/rekindled/embers/api/item/$IEmberChargedTool"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ClockworkToolItem extends $DiggerItem implements $IEmberChargedTool {
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: float, arg1: float, arg2: $Tier$Type, arg3: $TagKey$Type<($Block$Type)>, arg4: $Item$Properties$Type)

public "hasEmber"(arg0: $ItemStack$Type): boolean
public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
public "shouldCauseBlockBreakReset"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public "getDestroySpeed"(arg0: $ItemStack$Type, arg1: $BlockState$Type): float
public "hurtEnemy"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type): boolean
public "mineBlock"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type, arg4: $LivingEntity$Type): boolean
public "inventoryTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Entity$Type, arg3: integer, arg4: boolean): void
public "isEnchantable"(arg0: $ItemStack$Type): boolean
public "onLeftClickEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $Entity$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkToolItem$Type = ($ClockworkToolItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkToolItem_ = $ClockworkToolItem$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$DawnstoneAnvilCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $DawnstoneAnvilCategory implements $IRecipeCategory<($IDawnstoneAnvilRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IDawnstoneAnvilRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IDawnstoneAnvilRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IDawnstoneAnvilRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IDawnstoneAnvilRecipe$Type): boolean
public "handleInput"(arg0: $IDawnstoneAnvilRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IDawnstoneAnvilRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IDawnstoneAnvilRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IDawnstoneAnvilRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DawnstoneAnvilCategory$Type = ($DawnstoneAnvilCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DawnstoneAnvilCategory_ = $DawnstoneAnvilCategory$Type;
}}
declare module "packages/com/rekindled/embers/apiimpl/$AugmentUtilImpl" {
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IAugmentUtil, $IAugmentUtil$Type} from "packages/com/rekindled/embers/api/augment/$IAugmentUtil"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $AugmentUtilImpl implements $IAugmentUtil {

constructor()

public "getLevel"(arg0: $ItemStack$Type): integer
public "setLevel"(arg0: $ItemStack$Type, arg1: integer): void
public "getTotalAugmentLevel"(arg0: $ItemStack$Type): integer
public "getArmorAugmentLevel"(arg0: $LivingEntity$Type, arg1: $IAugment$Type): integer
public "getAugment"(arg0: $ResourceLocation$Type): $IAugment
public "getAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type): integer
public "getAllAugments"(): $Collection<($IAugment)>
public "getAugments"(arg0: $ItemStack$Type): $List<($IAugment)>
public "addAugment"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $IAugment$Type): void
public "setAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
public "hasAugment"(arg0: $ItemStack$Type, arg1: $IAugment$Type): boolean
public "hasHeat"(arg0: $ItemStack$Type): boolean
public "addAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
public "registerAugment"(arg0: $IAugment$Type): $IAugment
public "getHeat"(arg0: $ItemStack$Type): float
public "removeAllAugments"(arg0: $ItemStack$Type): $List<($ItemStack)>
public "getMaxHeat"(arg0: $ItemStack$Type): float
public "addHeat"(arg0: $ItemStack$Type, arg1: float): void
public "setHeat"(arg0: $ItemStack$Type, arg1: float): void
public static "checkForTag"(arg0: $ItemStack$Type): void
get "allAugments"(): $Collection<($IAugment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AugmentUtilImpl$Type = ($AugmentUtilImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AugmentUtilImpl_ = $AugmentUtilImpl$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CinderPlinthBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $CinderPlinthBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static "EMBER_COST": double
static "PROCESS_TIME": integer
 "capability": $IEmberCapability
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CinderPlinthBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CinderPlinthBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "renderBoundingBox"(): $AABB
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CinderPlinthBlockEntity$Type = ($CinderPlinthBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CinderPlinthBlockEntity_ = $CinderPlinthBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/$MultiblockSoundType" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"

export class $MultiblockSoundType extends $SoundType {
readonly "type": $SoundType
static readonly "EMPTY": $SoundType
static readonly "WOOD": $SoundType
static readonly "GRAVEL": $SoundType
static readonly "GRASS": $SoundType
static readonly "LILY_PAD": $SoundType
static readonly "STONE": $SoundType
static readonly "METAL": $SoundType
static readonly "GLASS": $SoundType
static readonly "WOOL": $SoundType
static readonly "SAND": $SoundType
static readonly "SNOW": $SoundType
static readonly "POWDER_SNOW": $SoundType
static readonly "LADDER": $SoundType
static readonly "ANVIL": $SoundType
static readonly "SLIME_BLOCK": $SoundType
static readonly "HONEY_BLOCK": $SoundType
static readonly "WET_GRASS": $SoundType
static readonly "CORAL_BLOCK": $SoundType
static readonly "BAMBOO": $SoundType
static readonly "BAMBOO_SAPLING": $SoundType
static readonly "SCAFFOLDING": $SoundType
static readonly "SWEET_BERRY_BUSH": $SoundType
static readonly "CROP": $SoundType
static readonly "HARD_CROP": $SoundType
static readonly "VINE": $SoundType
static readonly "NETHER_WART": $SoundType
static readonly "LANTERN": $SoundType
static readonly "STEM": $SoundType
static readonly "NYLIUM": $SoundType
static readonly "FUNGUS": $SoundType
static readonly "ROOTS": $SoundType
static readonly "SHROOMLIGHT": $SoundType
static readonly "WEEPING_VINES": $SoundType
static readonly "TWISTING_VINES": $SoundType
static readonly "SOUL_SAND": $SoundType
static readonly "SOUL_SOIL": $SoundType
static readonly "BASALT": $SoundType
static readonly "WART_BLOCK": $SoundType
static readonly "NETHERRACK": $SoundType
static readonly "NETHER_BRICKS": $SoundType
static readonly "NETHER_SPROUTS": $SoundType
static readonly "NETHER_ORE": $SoundType
static readonly "BONE_BLOCK": $SoundType
static readonly "NETHERITE_BLOCK": $SoundType
static readonly "ANCIENT_DEBRIS": $SoundType
static readonly "LODESTONE": $SoundType
static readonly "CHAIN": $SoundType
static readonly "NETHER_GOLD_ORE": $SoundType
static readonly "GILDED_BLACKSTONE": $SoundType
static readonly "CANDLE": $SoundType
static readonly "AMETHYST": $SoundType
static readonly "AMETHYST_CLUSTER": $SoundType
static readonly "SMALL_AMETHYST_BUD": $SoundType
static readonly "MEDIUM_AMETHYST_BUD": $SoundType
static readonly "LARGE_AMETHYST_BUD": $SoundType
static readonly "TUFF": $SoundType
static readonly "CALCITE": $SoundType
static readonly "DRIPSTONE_BLOCK": $SoundType
static readonly "POINTED_DRIPSTONE": $SoundType
static readonly "COPPER": $SoundType
static readonly "CAVE_VINES": $SoundType
static readonly "SPORE_BLOSSOM": $SoundType
static readonly "AZALEA": $SoundType
static readonly "FLOWERING_AZALEA": $SoundType
static readonly "MOSS_CARPET": $SoundType
static readonly "PINK_PETALS": $SoundType
static readonly "MOSS": $SoundType
static readonly "BIG_DRIPLEAF": $SoundType
static readonly "SMALL_DRIPLEAF": $SoundType
static readonly "ROOTED_DIRT": $SoundType
static readonly "HANGING_ROOTS": $SoundType
static readonly "AZALEA_LEAVES": $SoundType
static readonly "SCULK_SENSOR": $SoundType
static readonly "SCULK_CATALYST": $SoundType
static readonly "SCULK": $SoundType
static readonly "SCULK_VEIN": $SoundType
static readonly "SCULK_SHRIEKER": $SoundType
static readonly "GLOW_LICHEN": $SoundType
static readonly "DEEPSLATE": $SoundType
static readonly "DEEPSLATE_BRICKS": $SoundType
static readonly "DEEPSLATE_TILES": $SoundType
static readonly "POLISHED_DEEPSLATE": $SoundType
static readonly "FROGLIGHT": $SoundType
static readonly "FROGSPAWN": $SoundType
static readonly "MANGROVE_ROOTS": $SoundType
static readonly "MUDDY_MANGROVE_ROOTS": $SoundType
static readonly "MUD": $SoundType
static readonly "MUD_BRICKS": $SoundType
static readonly "PACKED_MUD": $SoundType
static readonly "HANGING_SIGN": $SoundType
static readonly "NETHER_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD": $SoundType
static readonly "NETHER_WOOD": $SoundType
static readonly "CHERRY_WOOD": $SoundType
static readonly "CHERRY_SAPLING": $SoundType
static readonly "CHERRY_LEAVES": $SoundType
static readonly "CHERRY_WOOD_HANGING_SIGN": $SoundType
static readonly "CHISELED_BOOKSHELF": $SoundType
static readonly "SUSPICIOUS_SAND": $SoundType
static readonly "SUSPICIOUS_GRAVEL": $SoundType
static readonly "DECORATED_POT": $SoundType
static readonly "DECORATED_POT_CRACKED": $SoundType
readonly "volume": float
readonly "pitch": float

constructor(arg0: $SoundType$Type)

public "getFallSound"(): $SoundEvent
public "getStepSound"(): $SoundEvent
public "getHitSound"(): $SoundEvent
public "getBreakSound"(): $SoundEvent
public "getPlaceSound"(): $SoundEvent
get "fallSound"(): $SoundEvent
get "stepSound"(): $SoundEvent
get "hitSound"(): $SoundEvent
get "breakSound"(): $SoundEvent
get "placeSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSoundType$Type = ($MultiblockSoundType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSoundType_ = $MultiblockSoundType$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$HeatInsulationUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $HeatInsulationUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "transformEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
public "getLimit"(arg0: $BlockEntity$Type): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: integer, arg4: integer): double
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatInsulationUpgrade$Type = ($HeatInsulationUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatInsulationUpgrade_ = $HeatInsulationUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/api/upgrades/$UpgradeContext" {
import {$IUpgradeProvider, $IUpgradeProvider$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeProvider"

export class $UpgradeContext {

constructor(arg0: $IUpgradeProvider$Type, arg1: integer, arg2: integer)
constructor(arg0: $IUpgradeProvider$Type, arg1: integer)

public "count"(): integer
public "distance"(): integer
public "upgrade"(): $IUpgradeProvider
public "setCount"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeContext$Type = ($UpgradeContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeContext_ = $UpgradeContext$Type;
}}
declare module "packages/com/rekindled/embers/item/$AshenArmorGemItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$IInflictorGemHolder, $IInflictorGemHolder$Type} from "packages/com/rekindled/embers/api/item/$IInflictorGemHolder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$AshenArmorItem, $AshenArmorItem$Type} from "packages/com/rekindled/embers/item/$AshenArmorItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"

export class $AshenArmorGemItem extends $AshenArmorItem implements $IInflictorGemHolder {
 "gemSlots": $Supplier<(integer)>
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $ArmorMaterial$Type, arg1: $ArmorItem$Type$Type, arg2: $Item$Properties$Type, arg3: $Supplier$Type<(integer)>)

public "getTotalDamageResistance"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $ItemStack$Type): float
public "attachGem"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer): void
public "getGemSlots"(arg0: $ItemStack$Type): integer
public "getAttachedGems"(arg0: $ItemStack$Type): ($ItemStack)[]
public "canAttachGem"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public "clearGems"(arg0: $ItemStack$Type): void
public "detachGem"(arg0: $ItemStack$Type, arg1: integer): $ItemStack
public "getAttachedGemCount"(arg0: $ItemStack$Type): integer
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AshenArmorGemItem$Type = ($AshenArmorGemItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AshenArmorGemItem_ = $AshenArmorGemItem$Type;
}}
declare module "packages/com/rekindled/embers/$RegistryManager$ToolSet" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $RegistryManager$ToolSet {
 "name": string
readonly "SWORD": $RegistryObject<($Item)>
readonly "SHOVEL": $RegistryObject<($Item)>
readonly "PICKAXE": $RegistryObject<($Item)>
readonly "AXE": $RegistryObject<($Item)>
readonly "HOE": $RegistryObject<($Item)>

constructor(arg0: string, arg1: $Tier$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$ToolSet$Type = ($RegistryManager$ToolSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager$ToolSet_ = $RegistryManager$ToolSet$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoringContext" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $BoringContext implements $Container {
 "dimension": $ResourceLocation
 "biome": $ResourceLocation
 "height": integer
 "blocks": ($BlockState)[]

constructor(arg0: $ResourceLocation$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: ($BlockState$Type)[])

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
/**
 * 
 * @deprecated
 */
public "getItem"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
/**
 * 
 * @deprecated
 */
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoringContext$Type = ($BoringContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoringContext_ = $BoringContext$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MechanicalCoreBlockEntity$BlockEntityDirection" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export class $MechanicalCoreBlockEntity$BlockEntityDirection {
 "blockEntity": $BlockEntity
 "direction": $Direction

constructor(arg0: $BlockEntity$Type, arg1: $Direction$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCoreBlockEntity$BlockEntityDirection$Type = ($MechanicalCoreBlockEntity$BlockEntityDirection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalCoreBlockEntity$BlockEntityDirection_ = $MechanicalCoreBlockEntity$BlockEntityDirection$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageItemSound" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $MessageItemSound {

constructor(arg0: $Entity$Type, arg1: $Item$Type, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float)
constructor(arg0: integer, arg1: $Item$Type, arg2: $SoundEvent$Type, arg3: $SoundSource$Type, arg4: boolean, arg5: float, arg6: float)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageItemSound
public static "encode"(arg0: $MessageItemSound$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageItemSound$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageItemSound$Type = ($MessageItemSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageItemSound_ = $MessageItemSound$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AlchemyContext" {
import {$IAlchemyRecipe$PedestalContents, $IAlchemyRecipe$PedestalContents$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe$PedestalContents"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $AlchemyContext implements $Container {
 "tablet": $ItemStack
 "contents": $List<($IAlchemyRecipe$PedestalContents)>
 "seed": long

constructor(arg0: $ItemStack$Type, arg1: $List$Type<($IAlchemyRecipe$PedestalContents$Type)>, arg2: long)

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
/**
 * 
 * @deprecated
 */
public "getItem"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
/**
 * 
 * @deprecated
 */
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyContext$Type = ($AlchemyContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyContext_ = $AlchemyContext$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersConfiguredFeatures" {
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$List, $List$Type} from "packages/java/util/$List"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BootstapContext, $BootstapContext$Type} from "packages/net/minecraft/data/worldgen/$BootstapContext"

export class $EmbersConfiguredFeatures {
static readonly "STONE_ORE_REPLACEABLES": $RuleTest
static readonly "DEEPSLATE_ORE_REPLACEABLES": $RuleTest
static readonly "ORE_LEAD_TARGET_LIST": $Supplier<($List<($OreConfiguration$TargetBlockState)>)>
static readonly "ORE_LEAD_KEY": $ResourceKey<($ConfiguredFeature<(any), (any)>)>
static readonly "ORE_LEAD": $ConfiguredFeature<($OreConfiguration), (any)>
static readonly "ORE_SILVER_TARGET_LIST": $Supplier<($List<($OreConfiguration$TargetBlockState)>)>
static readonly "ORE_SILVER_KEY": $ResourceKey<($ConfiguredFeature<(any), (any)>)>
static readonly "ORE_SILVER": $ConfiguredFeature<($OreConfiguration), (any)>

constructor()

public static "generate"(arg0: $BootstapContext$Type<($ConfiguredFeature$Type<(any), (any)>)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersConfiguredFeatures$Type = ($EmbersConfiguredFeatures);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersConfiguredFeatures_ = $EmbersConfiguredFeatures$Type;
}}
declare module "packages/com/rekindled/embers/util/$EmbersTiers" {
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $EmbersTiers {
static readonly "LEAD": $Tier
static readonly "TYRFING": $Tier
static readonly "SILVER": $Tier
static readonly "DAWNSTONE": $Tier
static readonly "CLOCKWORK_PICK": $Tier
static readonly "CLOCKWORK_AXE": $Tier
static readonly "CLOCKWORK_HAMMER": $Tier

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersTiers$Type = ($EmbersTiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersTiers_ = $EmbersTiers$Type;
}}
declare module "packages/com/rekindled/embers/augment/$EldritchInsigniaAugment" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"
import {$LivingChangeTargetEvent, $LivingChangeTargetEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent"

export class $EldritchInsigniaAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onEntityTarget"(arg0: $LivingChangeTargetEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EldritchInsigniaAugment$Type = ($EldritchInsigniaAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EldritchInsigniaAugment_ = $EldritchInsigniaAugment$Type;
}}
declare module "packages/com/rekindled/embers/$EmbersClientEvents" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$MovementInputUpdateEvent, $MovementInputUpdateEvent$Type} from "packages/net/minecraftforge/client/event/$MovementInputUpdateEvent"
import {$RenderTooltipEvent$GatherComponents, $RenderTooltipEvent$GatherComponents$Type} from "packages/net/minecraftforge/client/event/$RenderTooltipEvent$GatherComponents"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RenderLevelStageEvent, $RenderLevelStageEvent$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$ModelEvent$BakingCompleted, $ModelEvent$BakingCompleted$Type} from "packages/net/minecraftforge/client/event/$ModelEvent$BakingCompleted"
import {$RenderHighlightEvent$Block, $RenderHighlightEvent$Block$Type} from "packages/net/minecraftforge/client/event/$RenderHighlightEvent$Block"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelBakery, $ModelBakery$Type} from "packages/net/minecraft/client/resources/model/$ModelBakery"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $EmbersClientEvents {
static readonly "INGAME_OVERLAY": $IGuiOverlay
static "ticks": integer
static "gaugeAngle": double
static "seed": long
static "lastTarget": $BlockPos
static "GAUGE": $ResourceLocation
static "GAUGE_POINTER": $ResourceLocation

constructor()

public static "getModel"(arg0: $ModelBakery$Type, arg1: string): $BakedModel
public static "onLevelRender"(arg0: $RenderLevelStageEvent$Type): void
public static "onMovementInput"(arg0: $MovementInputUpdateEvent$Type): void
public static "afterModelBake"(arg0: $ModelEvent$BakingCompleted$Type): void
public static "onBlockHighlight"(arg0: $RenderHighlightEvent$Block$Type): void
public static "renderAtmosphericGauge"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: $Player$Type, arg3: float, arg4: integer, arg5: integer): void
public static "addCapabilityItemDescription"(arg0: $List$Type<($Component$Type)>, arg1: $BlockEntity$Type, arg2: $Direction$Type): void
public static "addCapabilityEmberDescription"(arg0: $List$Type<($Component$Type)>, arg1: $BlockEntity$Type, arg2: $Direction$Type): void
public static "addCapabilityFluidDescription"(arg0: $List$Type<($Component$Type)>, arg1: $BlockEntity$Type, arg2: $Direction$Type): void
public static "getFormattedModifierLevel"(arg0: integer): string
public static "onTooltip"(arg0: $RenderTooltipEvent$GatherComponents$Type): void
public static "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
public static "renderIngameOverlay"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersClientEvents$Type = ($EmbersClientEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersClientEvents_ = $EmbersClientEvents$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$FluidVesselBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$FluidVesselBlockEntity, $FluidVesselBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidVesselBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $FluidVesselBlockEntityRenderer implements $BlockEntityRenderer<($FluidVesselBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $FluidVesselBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $FluidVesselBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $FluidVesselBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidVesselBlockEntityRenderer$Type = ($FluidVesselBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidVesselBlockEntityRenderer_ = $FluidVesselBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MnemonicInscriberBlockEntityRenderer" {
import {$MnemonicInscriberBlockEntity, $MnemonicInscriberBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MnemonicInscriberBlockEntity"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MnemonicInscriberBlockEntityRenderer implements $BlockEntityRenderer<($MnemonicInscriberBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MnemonicInscriberBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MnemonicInscriberBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MnemonicInscriberBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MnemonicInscriberBlockEntityRenderer$Type = ($MnemonicInscriberBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MnemonicInscriberBlockEntityRenderer_ = $MnemonicInscriberBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MelterBottomBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MelterBottomBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation {
 "capability": $IEmberCapability
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "isWorking": boolean
 "upgrades": $List<($UpgradeContext)>
 "cachedRecipe": $IMeltingRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MelterBottomBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MelterBottomBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MelterBottomBlockEntity$Type = ($MelterBottomBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MelterBottomBlockEntity_ = $MelterBottomBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/entity/render/$EmberPacketRenderer" {
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $EmberPacketRenderer extends $EntityRenderer<($EmberPacketEntity)> {
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "render"(arg0: $EmberPacketEntity$Type, arg1: float, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer): void
public "getTextureLocation"(arg0: $EmberPacketEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberPacketRenderer$Type = ($EmberPacketRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberPacketRenderer_ = $EmberPacketRenderer$Type;
}}
declare module "packages/com/rekindled/embers/apiimpl/$UpgradeUtilImpl" {
import {$IUpgradeUtil, $IUpgradeUtil$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeUtil"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $UpgradeUtilImpl implements $IUpgradeUtil {

constructor()

public "getTotalEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
public "getTotalEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
public "getTotalSpeedModifier"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): double
public "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
public "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>, arg4: integer): void
public "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>): void
public "verifyUpgrades"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): void
public "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
public "getWorkTime"(arg0: $BlockEntity$Type, arg1: integer, arg2: $List$Type<($UpgradeContext$Type)>): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $UpgradeEvent$Type, arg2: $List$Type<($UpgradeContext$Type)>): void
public "transformOutput"(arg0: $BlockEntity$Type, arg1: $FluidStack$Type, arg2: $List$Type<($UpgradeContext$Type)>): $FluidStack
public "transformOutput"(arg0: $BlockEntity$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: $List$Type<($UpgradeContext$Type)>): void
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: integer, arg3: $List$Type<($UpgradeContext$Type)>): integer
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: string, arg3: $List$Type<($UpgradeContext$Type)>): string
public "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: $List$Type<($UpgradeContext$Type)>): T
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: $List$Type<($UpgradeContext$Type)>): double
public "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: boolean, arg3: $List$Type<($UpgradeContext$Type)>): boolean
public "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[]): $List<($UpgradeContext)>
public "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[], arg3: $List$Type<($UpgradeContext$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeUtilImpl$Type = ($UpgradeUtilImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeUtilImpl_ = $UpgradeUtilImpl$Type;
}}
declare module "packages/com/rekindled/embers/block/$BeamCannonBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$EmberEmitterBlock, $EmberEmitterBlock$Type} from "packages/com/rekindled/embers/block/$EmberEmitterBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $BeamCannonBlock extends $EmberEmitterBlock {
static readonly "FACING": $DirectionProperty
static readonly "X_DIRECTIONS": ($Direction)[]
static readonly "Y_DIRECTIONS": ($Direction)[]
static readonly "Z_DIRECTIONS": ($Direction)[]
static readonly "DIRECTIONS": ($BooleanProperty)[]
static readonly "ALL_DIRECTIONS": ($BooleanProperty)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getBlockSupportShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): $VoxelShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeamCannonBlock$Type = ($BeamCannonBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeamCannonBlock_ = $BeamCannonBlock$Type;
}}
declare module "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType" {
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$EmbersFluidType$FluidInfo, $EmbersFluidType$FluidInfo$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"

export class $EmbersFluidType extends $FluidType {
readonly "RENDER_OVERLAY": $ResourceLocation
readonly "TEXTURE_STILL": $ResourceLocation
readonly "TEXTURE_FLOW": $ResourceLocation
readonly "TEXTURE_OVERLAY": $ResourceLocation
readonly "FOG_COLOR": $Vector3f
readonly "fogStart": float
readonly "fogEnd": float
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(arg0: $FluidType$Properties$Type, arg1: $EmbersFluidType$FluidInfo$Type)

public "initializeClient"(arg0: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersFluidType$Type = ($EmbersFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersFluidType_ = $EmbersFluidType$Type;
}}
declare module "packages/com/rekindled/embers/augment/$AugmentBase" {
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AugmentBase implements $IAugment {

constructor(arg0: $ResourceLocation$Type, arg1: double)

public "getName"(): $ResourceLocation
public "getCost"(): double
public "countTowardsTotalLevel"(): boolean
public "onApply"(arg0: $ItemStack$Type): void
public "canRemove"(): boolean
public "shouldRenderTooltip"(): boolean
public "onRemove"(arg0: $ItemStack$Type): void
get "name"(): $ResourceLocation
get "cost"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AugmentBase$Type = ($AugmentBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AugmentBase_ = $AugmentBase$Type;
}}
declare module "packages/com/rekindled/embers/block/$InfernoForgeBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $InfernoForgeBlock extends $DoubleTallMachineBlock implements $SimpleWaterloggedBlock {
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "TOP_AABB": $VoxelShape
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getCollisionShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfernoForgeBlock$Type = ($InfernoForgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfernoForgeBlock_ = $InfernoForgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$AtmosphericGaugeBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$DirectionalBlock, $DirectionalBlock$Type} from "packages/net/minecraft/world/level/block/$DirectionalBlock"

export class $AtmosphericGaugeBlock extends $DirectionalBlock implements $EntityBlock, $SimpleWaterloggedBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "hasAnalogOutputSignal"(arg0: $BlockState$Type): boolean
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): integer
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "canAttach"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericGaugeBlock$Type = ($AtmosphericGaugeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericGaugeBlock_ = $AtmosphericGaugeBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity$TabletItemStackHandler" {
import {$AlchemyTabletBlockEntity, $AlchemyTabletBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AlchemyTabletBlockEntity$TabletItemStackHandler extends $ItemStackHandler {

constructor(arg0: integer, arg1: $AlchemyTabletBlockEntity$Type)

public "getSlotLimit"(arg0: integer): integer
public "forceInsertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyTabletBlockEntity$TabletItemStackHandler$Type = ($AlchemyTabletBlockEntity$TabletItemStackHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyTabletBlockEntity$TabletItemStackHandler_ = $AlchemyTabletBlockEntity$TabletItemStackHandler$Type;
}}
declare module "packages/com/rekindled/embers/block/$ClockworkAttenuatorBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$DialBaseBlock, $DialBaseBlock$Type} from "packages/com/rekindled/embers/block/$DialBaseBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $ClockworkAttenuatorBlock extends $DialBaseBlock implements $EntityBlock {
static readonly "DIAL_TYPE": string
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getDialType"(): string
public "getDisplayInfo"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: integer): $List<($Component)>
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "dialType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkAttenuatorBlock$Type = ($ClockworkAttenuatorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkAttenuatorBlock_ = $ClockworkAttenuatorBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$DialBaseBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDial, $IDial$Type} from "packages/com/rekindled/embers/api/block/$IDial"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$DirectionalBlock, $DirectionalBlock$Type} from "packages/net/minecraft/world/level/block/$DirectionalBlock"

export class $DialBaseBlock extends $DirectionalBlock implements $IDial, $EntityBlock, $SimpleWaterloggedBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getDisplayInfo"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: integer): $List<($Component)>
public "updateBEData"(arg0: $BlockPos$Type, arg1: integer): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onNeighborChange"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "canAttach"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
public "getDialType"(): string
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "dialType"(): string
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DialBaseBlock$Type = ($DialBaseBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DialBaseBlock_ = $DialBaseBlock$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$BoilingCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBoilingRecipe, $IBoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoilingRecipe"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $BoilingCategory implements $IRecipeCategory<($IBoilingRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IBoilingRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IBoilingRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IBoilingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IBoilingRecipe$Type): boolean
public "handleInput"(arg0: $IBoilingRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IBoilingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IBoilingRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IBoilingRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilingCategory$Type = ($BoilingCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilingCategory_ = $BoilingCategory$Type;
}}
declare module "packages/com/rekindled/embers/util/$AugmentPredicate" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AugmentPredicate extends $ItemPredicate {
static readonly "ID": $ResourceLocation
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor(arg0: $IAugment$Type, arg1: integer)

public static "deserialize"(arg0: $JsonObject$Type): $AugmentPredicate
public "serializeToJson"(): $JsonElement
public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AugmentPredicate$Type = ($AugmentPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AugmentPredicate_ = $AugmentPredicate$Type;
}}
declare module "packages/com/rekindled/embers/block/$WildfireStirlingBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $WildfireStirlingBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WildfireStirlingBlock$Type = ($WildfireStirlingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WildfireStirlingBlock_ = $WildfireStirlingBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CatalysisCombustionContext, $CatalysisCombustionContext$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionContext"
import {$CatalysisCombustionRecipe$Serializer, $CatalysisCombustionRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe$Serializer"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $CatalysisCombustionRecipe implements $ICatalysisCombustionRecipe {
static readonly "SERIALIZER": $CatalysisCombustionRecipe$Serializer
readonly "id": $ResourceLocation
readonly "ingredient": $Ingredient
readonly "machine": $Ingredient
readonly "burnTime": integer
readonly "multiplier": double

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $Ingredient$Type, arg3: integer, arg4: double)

public "matches"(arg0: $CatalysisCombustionContext$Type, arg1: $Level$Type): boolean
public "process"(arg0: $CatalysisCombustionContext$Type): integer
public "getDisplayInput"(): $Ingredient
public "getmultiplier"(arg0: $CatalysisCombustionContext$Type): double
public "getDisplayTime"(): integer
public "getBurnTIme"(arg0: $CatalysisCombustionContext$Type): integer
public "getDisplayMachine"(): $Ingredient
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "getDisplayMultiplier"(): double
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $CatalysisCombustionContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $CatalysisCombustionContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayInput"(): $Ingredient
get "displayTime"(): integer
get "displayMachine"(): $Ingredient
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayMultiplier"(): double
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisCombustionRecipe$Type = ($CatalysisCombustionRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisCombustionRecipe_ = $CatalysisCombustionRecipe$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersBlockTags" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$BlockTagsProvider, $BlockTagsProvider$Type} from "packages/net/minecraftforge/common/data/$BlockTagsProvider"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"

export class $EmbersBlockTags extends $BlockTagsProvider {
static readonly "EMITTER_CONNECTION": $TagKey<($Block)>
static readonly "EMITTER_CONNECTION_FLOOR": $TagKey<($Block)>
static readonly "EMITTER_CONNECTION_CEILING": $TagKey<($Block)>
static readonly "ITEM_PIPE_CONNECTION": $TagKey<($Block)>
static readonly "ITEM_PIPE_CONNECTION_TOGGLEABLE": $TagKey<($Block)>
static readonly "FLUID_PIPE_CONNECTION": $TagKey<($Block)>
static readonly "FLUID_PIPE_CONNECTION_TOGGLEABLE": $TagKey<($Block)>
static readonly "RELOCATION_NOT_SUPPORTED": $TagKey<($Block)>
static readonly "MECH_CORE_PROXYABLE": $TagKey<($Block)>
static readonly "MECH_CORE_PROXYABLE_BOTTOM": $TagKey<($Block)>
static readonly "MECH_CORE_PROXYABLE_TOP": $TagKey<($Block)>
static readonly "HEAT_SOURCES": $TagKey<($Block)>
static readonly "RESERVOIR_EXPANSION": $TagKey<($Block)>
static readonly "CHAMBER_CONNECTION": $TagKey<($Block)>
static readonly "DIAL": $TagKey<($Block)>
static readonly "MINABLE_WITH_PICKAXE_SHOVEL": $TagKey<($Block)>
static readonly "MINABLE_WITH_HAMMER": $TagKey<($Block)>
static readonly "NEEDS_LEAD_TOOL": $TagKey<($Block)>
static readonly "NEEDS_TYRFING": $TagKey<($Block)>
static readonly "NEEDS_SILVER_TOOL": $TagKey<($Block)>
static readonly "NEEDS_DAWNSTONE_TOOL": $TagKey<($Block)>
static readonly "NEEDS_CLOCKWORK_TOOL": $TagKey<($Block)>
static readonly "NEEDS_CLOCKWORK_HAMMER": $TagKey<($Block)>
static readonly "WORLD_BOTTOM": $TagKey<($Block)>
static readonly "SNOW": $TagKey<($Block)>
static readonly "PRISTINE_COPPER": $TagKey<($Block)>
static readonly "EXPOSED_COPPER": $TagKey<($Block)>
static readonly "WEATHERED_COPPER": $TagKey<($Block)>
static readonly "OXIDIZED_COPPER": $TagKey<($Block)>
static readonly "LEAD_ORE": $TagKey<($Block)>
static readonly "RAW_LEAD_BLOCK": $TagKey<($Block)>
static readonly "SILVER_ORE": $TagKey<($Block)>
static readonly "RAW_SILVER_BLOCK": $TagKey<($Block)>
static readonly "LEAD_BLOCK": $TagKey<($Block)>
static readonly "SILVER_BLOCK": $TagKey<($Block)>
static readonly "DAWNSTONE_BLOCK": $TagKey<($Block)>
static readonly "CRYSTAL_SEEDS": $TagKey<($Block)>
static readonly "COPPER_SEED": $TagKey<($Block)>
static readonly "IRON_SEED": $TagKey<($Block)>
static readonly "GOLD_SEED": $TagKey<($Block)>
static readonly "LEAD_SEED": $TagKey<($Block)>
static readonly "SILVER_SEED": $TagKey<($Block)>
static readonly "NICKEL_SEED": $TagKey<($Block)>
static readonly "TIN_SEED": $TagKey<($Block)>
static readonly "ALUMINUM_SEED": $TagKey<($Block)>
static readonly "ZINC_SEED": $TagKey<($Block)>
static readonly "PLATINUM_SEED": $TagKey<($Block)>
static readonly "URANIUM_SEED": $TagKey<($Block)>
static readonly "DAWNSTONE_SEED": $TagKey<($Block)>
static readonly "BRONZE_BLOCK": $TagKey<($Block)>
static readonly "NICKEL_BLOCK": $TagKey<($Block)>
static readonly "TIN_BLOCK": $TagKey<($Block)>
static readonly "ALUMINUM_BLOCK": $TagKey<($Block)>
static readonly "ELECTRUM_BLOCK": $TagKey<($Block)>

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "woodDecoTags"(arg0: $RegistryManager$StoneDecoBlocks$Type): void
public "decoTags"(arg0: $RegistryManager$StoneDecoBlocks$Type): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersBlockTags$Type = ($EmbersBlockTags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersBlockTags_ = $EmbersBlockTags$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IAlchemyRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$AlchemyContext, $AlchemyContext$Type} from "packages/com/rekindled/embers/recipe/$AlchemyContext"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$AlchemyResult, $AlchemyResult$Type} from "packages/com/rekindled/embers/api/misc/$AlchemyResult"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IAlchemyRecipe extends $Recipe<($AlchemyContext)> {

 "getResult"(arg0: $AlchemyContext$Type): $AlchemyResult
 "getResultItem"(): $ItemStack
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getCode"(arg0: long): $ArrayList<($Ingredient)>
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getInputs"(): $List<($Ingredient)>
 "getfailureItem"(): $ItemStack
 "getAspects"(): $List<($Ingredient)>
 "matchesCorrect"(arg0: $AlchemyContext$Type, arg1: $Level$Type): boolean
 "getCenterInput"(): $Ingredient
 "getRemainingItems"(arg0: $AlchemyContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "assemble"(arg0: $AlchemyContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getId"(): $ResourceLocation
 "matches"(arg0: $AlchemyContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IAlchemyRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAlchemyRecipe$Type = ($IAlchemyRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAlchemyRecipe_ = $IAlchemyRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$ISparkable" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export interface $ISparkable {

 "sparkProgress"(arg0: $BlockEntity$Type, arg1: double): void

(arg0: $BlockEntity$Type, arg1: double): void
}

export namespace $ISparkable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISparkable$Type = ($ISparkable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISparkable_ = $ISparkable$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export interface $IVisuallySplitRecipe<R extends $Recipe<(any)>> {

 "getVisualRecipes"(): $List<(R)>

(): $List<(R)>
}

export namespace $IVisuallySplitRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IVisuallySplitRecipe$Type<R> = ($IVisuallySplitRecipe<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IVisuallySplitRecipe_<R> = $IVisuallySplitRecipe$Type<(R)>;
}}
declare module "packages/com/rekindled/embers/util/$DecimalFormats" {
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PreparableReloadListener$PreparationBarrier, $PreparableReloadListener$PreparationBarrier$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener$PreparationBarrier"
import {$ResourceManagerReloadListener, $ResourceManagerReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManagerReloadListener"
import {$DecimalFormat, $DecimalFormat$Type} from "packages/java/text/$DecimalFormat"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$ProfilerFiller, $ProfilerFiller$Type} from "packages/net/minecraft/util/profiling/$ProfilerFiller"

export class $DecimalFormats implements $ResourceManagerReloadListener {

constructor()

public static "getDecimalFormat"(arg0: string): $DecimalFormat
public "onResourceManagerReload"(arg0: $ResourceManager$Type): void
public "reload"(arg0: $PreparableReloadListener$PreparationBarrier$Type, arg1: $ResourceManager$Type, arg2: $ProfilerFiller$Type, arg3: $ProfilerFiller$Type, arg4: $Executor$Type, arg5: $Executor$Type): $CompletableFuture<(void)>
public "getName"(): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecimalFormats$Type = ($DecimalFormats);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DecimalFormats_ = $DecimalFormats$Type;
}}
declare module "packages/com/rekindled/embers/item/$TinkerHammerItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TinkerHammerItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getCraftingRemainingItem"(arg0: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(): boolean
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "onItemUseFirst"(arg0: $ItemStack$Type, arg1: $UseOnContext$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinkerHammerItem$Type = ($TinkerHammerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinkerHammerItem_ = $TinkerHammerItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$MnemonicInscriberBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $MnemonicInscriberBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "ACTIVE": $BooleanProperty
static readonly "UP_AABB": $VoxelShape
static readonly "DOWN_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MnemonicInscriberBlock$Type = ($MnemonicInscriberBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MnemonicInscriberBlock_ = $MnemonicInscriberBlock$Type;
}}
declare module "packages/com/rekindled/embers/item/$DawnstoneMailItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DawnstoneMailItem extends $Item implements $IEmbersCurioItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "equipSound"(): $SoundEvent
public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DawnstoneMailItem$Type = ($DawnstoneMailItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DawnstoneMailItem_ = $DawnstoneMailItem$Type;
}}
declare module "packages/com/rekindled/embers/entity/$EmberPacketEntity" {
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EmberPacketEntity extends $Entity {
 "pos": $BlockPos
 "dest": $BlockPos
 "value": double
 "lifetime": integer
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)

public "tick"(): void
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
public "initCustom"(arg0: $BlockPos$Type, arg1: $BlockPos$Type, arg2: double, arg3: double, arg4: double, arg5: double): void
public "affectTileEntity"(arg0: $BlockState$Type, arg1: $BlockEntity$Type): void
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberPacketEntity$Type = ($EmberPacketEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberPacketEntity_ = $EmberPacketEntity$Type;
}}
declare module "packages/com/rekindled/embers/particle/$XRayGlowParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $XRayGlowParticleOptions implements $ParticleOptions {
static readonly "MIN_SCALE": float
static readonly "MAX_SCALE": float
static readonly "EMBER": $XRayGlowParticleOptions
static readonly "EMBER_NOMOTION": $XRayGlowParticleOptions
static readonly "EMBER_BIG_NOMOTION": $XRayGlowParticleOptions
static readonly "CODEC": $Codec<($XRayGlowParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($XRayGlowParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float)
constructor(arg0: $Vector3f$Type, arg1: float, arg2: integer)
constructor(arg0: $Vector3f$Type, arg1: $Vec3$Type, arg2: float)
constructor(arg0: $Vector3f$Type, arg1: $Vec3$Type, arg2: float, arg3: integer)

public "getLifetime"(): integer
public "getMotion"(): $Vec3
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public static "readVec3"(arg0: $StringReader$Type): $Vec3
public static "readVec3"(arg0: $FriendlyByteBuf$Type): $Vec3
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "lifetime"(): integer
get "motion"(): $Vec3
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XRayGlowParticleOptions$Type = ($XRayGlowParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $XRayGlowParticleOptions_ = $XRayGlowParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/network/$PacketHandler" {
import {$SimpleChannel, $SimpleChannel$Type} from "packages/net/minecraftforge/network/simple/$SimpleChannel"

export class $PacketHandler {
static readonly "INSTANCE": $SimpleChannel

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketHandler$Type = ($PacketHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketHandler_ = $PacketHandler$Type;
}}
declare module "packages/com/rekindled/embers/block/$ArchaicLightBlock" {
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $ArchaicLightBlock extends $Block {
static readonly "EMBER": $GlowParticleOptions
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArchaicLightBlock$Type = ($ArchaicLightBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArchaicLightBlock_ = $ArchaicLightBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$HearthCoilEdgeBlock" {
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $HearthCoilEdgeBlock extends $MechEdgeBlockBase {
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HearthCoilEdgeBlock$Type = ($HearthCoilEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HearthCoilEdgeBlock_ = $HearthCoilEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MelterTopBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpenTankBlockEntity, $OpenTankBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MelterTopBlockEntity extends $OpenTankBlockEntity implements $IExtraCapabilityInformation {
 "angle": double
 "renderOffset": float
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MelterTopBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MelterTopBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MelterTopBlockEntity$Type = ($MelterTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MelterTopBlockEntity_ = $MelterTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/worldgen/$CrystalSeedStructureProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $CrystalSeedStructureProcessor extends $StructureProcessor {
static readonly "CODEC": $Codec<($CrystalSeedStructureProcessor)>
readonly "minXp": integer
readonly "maxXp": integer
readonly "size": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "processBlock"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type): $StructureTemplate$StructureBlockInfo
public "getXp"(arg0: $RandomSource$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalSeedStructureProcessor$Type = ($CrystalSeedStructureProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalSeedStructureProcessor_ = $CrystalSeedStructureProcessor$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersDamageTypeTags" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$TagsProvider, $TagsProvider$Type} from "packages/net/minecraft/data/tags/$TagsProvider"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $EmbersDamageTypeTags extends $TagsProvider<($DamageType)> {
static readonly "HOLY_DAMAGE": $TagKey<($DamageType)>

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersDamageTypeTags$Type = ($EmbersDamageTypeTags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersDamageTypeTags_ = $EmbersDamageTypeTags$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$DawnstoneAnvilBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$DawnstoneAnvilBlockEntity, $DawnstoneAnvilBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$DawnstoneAnvilBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $DawnstoneAnvilBlockEntityRenderer implements $BlockEntityRenderer<($DawnstoneAnvilBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $DawnstoneAnvilBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $DawnstoneAnvilBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $DawnstoneAnvilBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DawnstoneAnvilBlockEntityRenderer$Type = ($DawnstoneAnvilBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DawnstoneAnvilBlockEntityRenderer_ = $DawnstoneAnvilBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageCasterOrb" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageCasterOrb {

constructor(arg0: double, arg1: double, arg2: double)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageCasterOrb
public static "encode"(arg0: $MessageCasterOrb$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageCasterOrb$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageCasterOrb$Type = ($MessageCasterOrb);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageCasterOrb_ = $MessageCasterOrb$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersFluidTags" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$FluidTagsProvider, $FluidTagsProvider$Type} from "packages/net/minecraft/data/tags/$FluidTagsProvider"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $EmbersFluidTags extends $FluidTagsProvider {
static readonly "MOLTEN_IRON": $TagKey<($Fluid)>
static readonly "MOLTEN_GOLD": $TagKey<($Fluid)>
static readonly "MOLTEN_COPPER": $TagKey<($Fluid)>
static readonly "MOLTEN_LEAD": $TagKey<($Fluid)>
static readonly "MOLTEN_SILVER": $TagKey<($Fluid)>
static readonly "MOLTEN_DAWNSTONE": $TagKey<($Fluid)>
static readonly "STEAM": $TagKey<($Fluid)>
static readonly "WATERY": $TagKey<($Fluid)>
static readonly "MOLTEN_NICKEL": $TagKey<($Fluid)>
static readonly "MOLTEN_TIN": $TagKey<($Fluid)>
static readonly "MOLTEN_ALUMINUM": $TagKey<($Fluid)>
static readonly "MOLTEN_ZINC": $TagKey<($Fluid)>
static readonly "MOLTEN_PLATINUM": $TagKey<($Fluid)>
static readonly "MOLTEN_URANIUM": $TagKey<($Fluid)>
static readonly "MOLTEN_BRONZE": $TagKey<($Fluid)>
static readonly "MOLTEN_ELECTRUM": $TagKey<($Fluid)>
static readonly "MOLTEN_BRASS": $TagKey<($Fluid)>
static readonly "MOLTEN_CONSTANTAN": $TagKey<($Fluid)>
static readonly "MOLTEN_INVAR": $TagKey<($Fluid)>
static readonly "INGOT_TOOLTIP": $TagKey<($Fluid)>
static readonly "METAL_TOOLTIPS": $TagKey<($Fluid)>

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "m_6577_"(arg0: $HolderLookup$Provider$Type): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersFluidTags$Type = ($EmbersFluidTags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersFluidTags_ = $EmbersFluidTags$Type;
}}
declare module "packages/com/rekindled/embers/util/$GrandhammerLootModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootModifier, $LootModifier$Type} from "packages/net/minecraftforge/common/loot/$LootModifier"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"

export class $GrandhammerLootModifier extends $LootModifier {
static readonly "CODEC": $Codec<($GrandhammerLootModifier)>

constructor(arg0: ($LootItemCondition$Type)[])

public "doApply"(arg0: $ObjectArrayList$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $ObjectArrayList<($ItemStack)>
public "codec"(): $Codec<($GrandhammerLootModifier)>
public static "getJson"<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrandhammerLootModifier$Type = ($GrandhammerLootModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GrandhammerLootModifier_ = $GrandhammerLootModifier$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$InfernoForgeTopBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $InfernoForgeTopBlockEntity extends $BlockEntity {
 "lastToggle": long
 "open": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfernoForgeTopBlockEntity$Type = ($InfernoForgeTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfernoForgeTopBlockEntity_ = $InfernoForgeTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IAlchemyRecipe$PedestalContents, $IAlchemyRecipe$PedestalContents$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe$PedestalContents"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$AlchemyPedestalTopBlockEntity, $AlchemyPedestalTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalTopBlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$ISparkable, $ISparkable$Type} from "packages/com/rekindled/embers/api/tile/$ISparkable"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AlchemyTabletBlockEntity$TabletItemStackHandler, $AlchemyTabletBlockEntity$TabletItemStackHandler$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity$TabletItemStackHandler"

export class $AlchemyTabletBlockEntity extends $BlockEntity implements $ISparkable, $ISoundController, $IExtraCapabilityInformation {
static readonly "UPGRADE_SIDES": ($Direction)[]
static readonly "CONSUME_AMOUNT": integer
static readonly "SPARK_THRESHOLD": integer
static readonly "PROCESSING_TIME": integer
 "inventory": $AlchemyTabletBlockEntity$TabletItemStackHandler
 "outputHandler": $IItemHandler
 "holder": $LazyOptional<($IItemHandler)>
 "outputHolder": $LazyOptional<($IItemHandler)>
 "outputMode": boolean
 "progress": integer
 "process": integer
 "cachedRecipe": $IAlchemyRecipe
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AlchemyTabletBlockEntity$Type): void
public static "getPedestalContents"(arg0: $List$Type<($AlchemyPedestalTopBlockEntity$Type)>): $ArrayList<($IAlchemyRecipe$PedestalContents)>
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AlchemyTabletBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "sparkProgress"(arg0: $BlockEntity$Type, arg1: double): void
public static "getNearbyPedestals"(arg0: $Level$Type, arg1: $BlockPos$Type): $ArrayList<($AlchemyPedestalTopBlockEntity)>
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyTabletBlockEntity$Type = ($AlchemyTabletBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyTabletBlockEntity_ = $AlchemyTabletBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$IProjectileEffect" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IProjectileEffect {

 "onFizzle"(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $IProjectilePreset$Type): void
 "onBlockImpact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IProjectilePreset$Type): void
 "onEntityImpact"(arg0: $Entity$Type, arg1: $IProjectilePreset$Type): void
 "onHit"(arg0: $Level$Type, arg1: $HitResult$Type, arg2: $IProjectilePreset$Type): void
}

export namespace $IProjectileEffect {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProjectileEffect$Type = ($IProjectileEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProjectileEffect_ = $IProjectileEffect$Type;
}}
declare module "packages/com/rekindled/embers/api/block/$IDial" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IDial {

 "getDialType"(): string
 "getDisplayInfo"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: integer): $List<($Component)>
 "updateBEData"(arg0: $BlockPos$Type, arg1: integer): void
}

export namespace $IDial {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDial$Type = ($IDial);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDial_ = $IDial$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$EffectDamage" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EffectDamage implements $IProjectileEffect {

constructor(arg0: float, arg1: $Function$Type<($Entity$Type), ($DamageSource$Type)>, arg2: integer, arg3: double)

public "getSource"(): $Function<($Entity), ($DamageSource)>
public "onEntityImpact"(arg0: $Entity$Type, arg1: $IProjectilePreset$Type): void
public "setSource"(arg0: $Function$Type<($Entity$Type), ($DamageSource$Type)>): void
public "setFire"(arg0: integer): void
public "setInvinciblityMultiplier"(arg0: double): void
public "setDamage"(arg0: float): void
public "getDamage"(): float
public "getFire"(): integer
public "getInvinciblityMultiplier"(): double
public "onFizzle"(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $IProjectilePreset$Type): void
public "onBlockImpact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IProjectilePreset$Type): void
public "onHit"(arg0: $Level$Type, arg1: $HitResult$Type, arg2: $IProjectilePreset$Type): void
get "source"(): $Function<($Entity), ($DamageSource)>
set "source"(value: $Function$Type<($Entity$Type), ($DamageSource$Type)>)
set "fire"(value: integer)
set "invinciblityMultiplier"(value: double)
set "damage"(value: float)
get "damage"(): float
get "fire"(): integer
get "invinciblityMultiplier"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectDamage$Type = ($EffectDamage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectDamage_ = $EffectDamage$Type;
}}
declare module "packages/com/rekindled/embers/block/$MelterBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MelterBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MelterBlock$Type = ($MelterBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MelterBlock_ = $MelterBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberFunnelBlockEntity" {
import {$EmberReceiverBlockEntity, $EmberReceiverBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberReceiverBlockEntity"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export class $EmberFunnelBlockEntity extends $EmberReceiverBlockEntity {
static readonly "TRANSFER_RATE": integer
 "capability": $IEmberCapability
 "ticksExisted": long
 "random": $Random
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "onReceive"(arg0: $EmberPacketEntity$Type): boolean
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberFunnelBlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberFunnelBlockEntity$Type = ($EmberFunnelBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberFunnelBlockEntity_ = $EmberFunnelBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AlchemyPedestalBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $AlchemyPedestalBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)
constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "setChanged"(): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyPedestalBlockEntity$Type = ($AlchemyPedestalBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyPedestalBlockEntity_ = $AlchemyPedestalBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IEmberActivationRecipe extends $Recipe<($Container)> {

 "process"(arg0: $Container$Type): integer
 "getDisplayOutput"(): integer
 "getDisplayInput"(): $Ingredient
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getOutput"(arg0: $Container$Type): integer
 "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IEmberActivationRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberActivationRecipe$Type = ($IEmberActivationRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberActivationRecipe_ = $IEmberActivationRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MixingContext" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $MixingContext implements $Container {
 "fluids": ($IFluidHandler)[]

constructor(...arg0: ($IFluidHandler$Type)[])

/**
 * 
 * @deprecated
 */
public "setChanged"(): void
/**
 * 
 * @deprecated
 */
public "getItem"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "getContainerSize"(): integer
/**
 * 
 * @deprecated
 */
public "removeItemNoUpdate"(arg0: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
/**
 * 
 * @deprecated
 */
public "clearContent"(): void
/**
 * 
 * @deprecated
 */
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "stillValid"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stopOpen"(arg0: $Player$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixingContext$Type = ($MixingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixingContext_ = $MixingContext$Type;
}}
declare module "packages/com/rekindled/embers/block/$CrystalCellBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CrystalCellBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrystalCellBlock$Type = ($CrystalCellBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrystalCellBlock_ = $CrystalCellBlock$Type;
}}
declare module "packages/com/rekindled/embers/gui/$GuiCodex" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchCategory, $ResearchCategory$Type} from "packages/com/rekindled/embers/research/$ResearchCategory"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"

export class $GuiCodex extends $Screen {
 "mouseX": double
 "mouseY": double
 "smoothMouseX": double
 "smoothMouseY": double
 "selectedIndex": integer
 "selectedPageIndex": integer
 "researchCategory": $ResearchCategory
 "researchPage": $ResearchBase
 "ticks": float
 "showLeftArrow": boolean
 "showRightArrow": boolean
 "tooltipX": integer
 "tooltipY": integer
 "renderTooltip": boolean
 "framesExisted": integer
 "raise": (float)[]
 "raiseTargets": (float)[]
 "sentences": (string)[]
 "nextPageSelected": boolean
 "previousPageSelected": boolean
 "searchString": string
 "searchDelay": integer
 "searchResult": $ArrayList<($ResearchBase)>
static "INDEX": $ResourceLocation
static "PARTS": $ResourceLocation
static "instance": $GuiCodex
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor()

public static "drawCenteredText"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: $FormattedCharSequence$Type, arg3: integer, arg4: integer, arg5: integer): void
public static "drawText"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: $FormattedCharSequence$Type, arg3: integer, arg4: integer, arg5: integer): void
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "shouldCloseOnEsc"(): boolean
public "onClose"(): void
public static "drawTextGlowing"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: $FormattedCharSequence$Type, arg3: integer, arg4: integer): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "isPauseScreen"(): boolean
public "tick"(): void
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "peekLastCategory"(): $ResearchCategory
public "renderItemStackAt"(arg0: $GuiGraphics$Type, arg1: $ItemStack$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
public "popLastCategory"(): $ResearchCategory
public "pushLastCategory"(arg0: $ResearchCategory$Type): void
public "doRenderTooltip"(arg0: $GuiGraphics$Type): void
public "renderEmberTooltip"(arg0: $GuiGraphics$Type, arg1: $List$Type<($Component$Type)>, arg2: integer, arg3: integer): void
public "getVert"(arg0: float, arg1: float, arg2: float): float
public "renderItemStackMinusTooltipAt"(arg0: $GuiGraphics$Type, arg1: $ItemStack$Type, arg2: integer, arg3: integer): void
public "playSound"(arg0: $SoundEvent$Type, arg1: float): void
public "playSound"(arg0: $SoundEvent$Type): void
public "markTooltipForRender"(arg0: $ItemStack$Type, arg1: integer, arg2: integer): void
public static "drawCenteredTextGlowing"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: $FormattedCharSequence$Type, arg3: integer, arg4: integer): void
public static "drawHoveringTextGlowing"(arg0: $GuiGraphics$Type, arg1: $List$Type<($ClientTooltipComponent$Type)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: $Font$Type): void
public static "drawTextGlowingAura"(arg0: $Font$Type, arg1: $GuiGraphics$Type, arg2: $FormattedCharSequence$Type, arg3: integer, arg4: integer): void
public "drawModalRectGlowing"(arg0: $GuiGraphics$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): void
get "pauseScreen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiCodex$Type = ($GuiCodex);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiCodex_ = $GuiCodex$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$StampingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeWrapper, $RecipeWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RecipeWrapper"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IStampingRecipe, $IStampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IStampingRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$StampingContext, $StampingContext$Type} from "packages/com/rekindled/embers/recipe/$StampingContext"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$StampingRecipe$TagAmount, $StampingRecipe$TagAmount$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe$TagAmount"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$StampingRecipe$Serializer, $StampingRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$StampingRecipe$Serializer"

export class $StampingRecipe implements $IStampingRecipe {
static readonly "SERIALIZER": $StampingRecipe$Serializer
readonly "id": $ResourceLocation
readonly "stamp": $Ingredient
readonly "input": $Ingredient
readonly "fluid": $FluidIngredient
readonly "output": $Either<($ItemStack), ($StampingRecipe$TagAmount)>

constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $Ingredient$Type, arg3: $FluidIngredient$Type, arg4: $Either$Type<($ItemStack$Type), ($StampingRecipe$TagAmount$Type)>)
constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $Ingredient$Type, arg3: $FluidIngredient$Type, arg4: $ItemStack$Type)
constructor(arg0: $ResourceLocation$Type, arg1: $Ingredient$Type, arg2: $Ingredient$Type, arg3: $FluidIngredient$Type, arg4: $StampingRecipe$TagAmount$Type)

public "matches"(arg0: $StampingContext$Type, arg1: $Level$Type): boolean
public "getResultItem"(): $ItemStack
public "getDisplayInput"(): $Ingredient
public "getDisplayStamp"(): $Ingredient
public "getDisplayInputFluid"(): $FluidIngredient
public "getSerializer"(): $RecipeSerializer<(any)>
public "assemble"(arg0: $StampingContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getId"(): $ResourceLocation
public "getOutput"(arg0: $RecipeWrapper$Type): $ItemStack
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getRemainingItems"(arg0: $StampingContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "resultItem"(): $ItemStack
get "displayInput"(): $Ingredient
get "displayStamp"(): $Ingredient
get "displayInputFluid"(): $FluidIngredient
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingRecipe$Type = ($StampingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingRecipe_ = $StampingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MixingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$IMixingRecipe, $IMixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMixingRecipe"
import {$MixingRecipe$Serializer, $MixingRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$MixingRecipe$Serializer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$MixingContext, $MixingContext$Type} from "packages/com/rekindled/embers/recipe/$MixingContext"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $MixingRecipe implements $IMixingRecipe {
static readonly "SERIALIZER": $MixingRecipe$Serializer
readonly "id": $ResourceLocation
readonly "inputs": $ArrayList<($FluidIngredient)>
readonly "output": $FluidStack

constructor(arg0: $ResourceLocation$Type, arg1: $ArrayList$Type<($FluidIngredient$Type)>, arg2: $FluidStack$Type)

public "matches"(arg0: $MixingContext$Type, arg1: $Level$Type): boolean
public "process"(arg0: $MixingContext$Type): $FluidStack
public "getDisplayOutput"(): $FluidStack
public "getDisplayInputFluids"(): $ArrayList<($FluidIngredient)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "getOutput"(arg0: $MixingContext$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $MixingContext$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $MixingContext$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $FluidStack
get "displayInputFluids"(): $ArrayList<($FluidIngredient)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixingRecipe$Type = ($MixingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixingRecipe_ = $MixingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/particle/$TyrfingParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$TyrfingParticleOptions, $TyrfingParticleOptions$Type} from "packages/com/rekindled/embers/particle/$TyrfingParticleOptions"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $TyrfingParticle extends $TextureSheetParticle {
 "phase": integer
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $TyrfingParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TyrfingParticle$Type = ($TyrfingParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TyrfingParticle_ = $TyrfingParticle$Type;
}}
declare module "packages/com/rekindled/embers/block/$DawnstoneAnvilBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $DawnstoneAnvilBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "X_AXIS_AABB": $VoxelShape
static readonly "Z_AXIS_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DawnstoneAnvilBlock$Type = ($DawnstoneAnvilBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DawnstoneAnvilBlock_ = $DawnstoneAnvilBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$CinderPlinthBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$CinderPlinthBlockEntity, $CinderPlinthBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$CinderPlinthBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $CinderPlinthBlockEntityRenderer implements $BlockEntityRenderer<($CinderPlinthBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CinderPlinthBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $CinderPlinthBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CinderPlinthBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CinderPlinthBlockEntityRenderer$Type = ($CinderPlinthBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CinderPlinthBlockEntityRenderer_ = $CinderPlinthBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$MachineRecipeEvent" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $MachineRecipeEvent<T> extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: T)

public "getOriginalRecipe"(): T
public "setRecipe"(arg0: T): void
public "getRecipe"(): T
get "originalRecipe"(): T
set "recipe"(value: T)
get "recipe"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineRecipeEvent$Type<T> = ($MachineRecipeEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineRecipeEvent_<T> = $MachineRecipeEvent$Type<(T)>;
}}
declare module "packages/com/rekindled/embers/blockentity/$CaminiteValveBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ReservoirBlockEntity, $ReservoirBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ReservoirBlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CaminiteValveBlockEntity extends $BlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getReservoir"(): $ReservoirBlockEntity
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public static "commonTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CaminiteValveBlockEntity$Type): void
public "updateTank"(): void
get "reservoir"(): $ReservoirBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteValveBlockEntity$Type = ($CaminiteValveBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteValveBlockEntity_ = $CaminiteValveBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CatalysisCombustionContext, $CatalysisCombustionContext$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $ICatalysisCombustionRecipe extends $Recipe<($CatalysisCombustionContext)> {

 "process"(arg0: $CatalysisCombustionContext$Type): integer
 "getDisplayInput"(): $Ingredient
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getmultiplier"(arg0: $CatalysisCombustionContext$Type): double
 "getDisplayTime"(): integer
 "getBurnTIme"(arg0: $CatalysisCombustionContext$Type): integer
 "getDisplayMachine"(): $Ingredient
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $CatalysisCombustionContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getDisplayMultiplier"(): double
 "getRemainingItems"(arg0: $CatalysisCombustionContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $CatalysisCombustionContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $ICatalysisCombustionRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICatalysisCombustionRecipe$Type = ($ICatalysisCombustionRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICatalysisCombustionRecipe_ = $ICatalysisCombustionRecipe$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberFunnelBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EmberReceiverBlock, $EmberReceiverBlock$Type} from "packages/com/rekindled/embers/block/$EmberReceiverBlock"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $EmberFunnelBlock extends $EmberReceiverBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberFunnelBlock$Type = ($EmberFunnelBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberFunnelBlock_ = $EmberFunnelBlock$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberRecordItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RecordItem, $RecordItem$Type} from "packages/net/minecraft/world/item/$RecordItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberRecordItem extends $RecordItem {
/**
 * 
 * @deprecated
 */
static readonly "BY_NAME": $Map<($SoundEvent), ($RecordItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: integer, arg1: $Supplier$Type<($SoundEvent$Type)>, arg2: $Item$Properties$Type, arg3: integer)

public "getTooltipImage"(arg0: $ItemStack$Type): $Optional<($TooltipComponent)>
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberRecordItem$Type = ($EmberRecordItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberRecordItem_ = $EmberRecordItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$BeamSplitterBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $BeamSplitterBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "canAttach"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeamSplitterBlock$Type = ($BeamSplitterBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeamSplitterBlock_ = $BeamSplitterBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CatalysisCombustionRecipe, $CatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$CatalysisCombustionRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $CatalysisCombustionRecipe$Serializer implements $RecipeSerializer<($CatalysisCombustionRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $CatalysisCombustionRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $CatalysisCombustionRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $CatalysisCombustionRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $CatalysisCombustionRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisCombustionRecipe$Serializer$Type = ($CatalysisCombustionRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisCombustionRecipe$Serializer_ = $CatalysisCombustionRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberRelayBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberPacketProducer, $IEmberPacketProducer$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketProducer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IEmberPacketReceiver, $IEmberPacketReceiver$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketReceiver"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export class $EmberRelayBlockEntity extends $BlockEntity implements $IEmberPacketProducer, $IEmberPacketReceiver {
 "target": $BlockPos
 "random": $Random
 "polled": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setTargetPosition"(arg0: $BlockPos$Type, arg1: $Direction$Type): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEmittingDirection"(arg0: $Direction$Type): $Direction
public "onReceive"(arg0: $EmberPacketEntity$Type): boolean
public "hasRoomFor"(arg0: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberRelayBlockEntity$Type = ($EmberRelayBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberRelayBlockEntity_ = $EmberRelayBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MechanicalPumpTopBlockEntity" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$FluidHandlerBlockEntity, $FluidHandlerBlockEntity$Type} from "packages/net/minecraftforge/fluids/capability/$FluidHandlerBlockEntity"

export class $MechanicalPumpTopBlockEntity extends $FluidHandlerBlockEntity implements $IExtraCapabilityInformation {
static "capacity": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPumpTopBlockEntity$Type = ($MechanicalPumpTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPumpTopBlockEntity_ = $MechanicalPumpTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$GaseousFuelRecipe, $GaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $GaseousFuelRecipe$Serializer implements $RecipeSerializer<($GaseousFuelRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $GaseousFuelRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $GaseousFuelRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $GaseousFuelRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $GaseousFuelRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaseousFuelRecipe$Serializer$Type = ($GaseousFuelRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GaseousFuelRecipe$Serializer_ = $GaseousFuelRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/render/$AlchemicalNoteItemRenderer" {
import {$ItemRenderer, $ItemRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$ItemRenderer"
import {$BlockEntityWithoutLevelRenderer, $BlockEntityWithoutLevelRenderer$Type} from "packages/net/minecraft/client/renderer/$BlockEntityWithoutLevelRenderer"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityModelSet, $EntityModelSet$Type} from "packages/net/minecraft/client/model/geom/$EntityModelSet"
import {$ItemInHandRenderer, $ItemInHandRenderer$Type} from "packages/net/minecraft/client/renderer/$ItemInHandRenderer"
import {$BlockEntityRenderDispatcher, $BlockEntityRenderDispatcher$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderDispatcher"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AlchemicalNoteItemRenderer extends $BlockEntityWithoutLevelRenderer {
 "font": $Font
 "minecraft": $Minecraft
 "itemInHandRenderer": $ItemInHandRenderer
 "itemRenderer": $ItemRenderer

constructor(arg0: $BlockEntityRenderDispatcher$Type, arg1: $EntityModelSet$Type)

public "renderNote"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: integer, arg3: integer, arg4: $ItemStack$Type): void
public "renderPedestal"(arg0: $PoseStack$Type, arg1: integer, arg2: integer, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer, arg6: $ItemStack$Type, arg7: $ItemStack$Type): void
public "renderByItem"(arg0: $ItemStack$Type, arg1: $ItemDisplayContext$Type, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemicalNoteItemRenderer$Type = ($AlchemicalNoteItemRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemicalNoteItemRenderer_ = $AlchemicalNoteItemRenderer$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersRecipes" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$MeltingBonus, $MeltingBonus$Type} from "packages/com/rekindled/embers/util/$MeltingBonus"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RegistryManager$ToolSet, $RegistryManager$ToolSet$Type} from "packages/com/rekindled/embers/$RegistryManager$ToolSet"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$RecipeProvider, $RecipeProvider$Type} from "packages/net/minecraft/data/recipes/$RecipeProvider"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"
import {$IConditionBuilder, $IConditionBuilder$Type} from "packages/net/minecraftforge/common/crafting/conditions/$IConditionBuilder"

export class $EmbersRecipes extends $RecipeProvider implements $IConditionBuilder {
static "boringFolder": string
static "activationFolder": string
static "meltingFolder": string
static "stampingFolder": string
static "mixingFolder": string
static "coefficientFolder": string
static "alchemyFolder": string
static "boilingFolder": string
static "gaseousFuelFolder": string
static "catalysisFolder": string
static "combustionFolder": string
static "anvilFolder": string

constructor(arg0: $PackOutput$Type)

public static "getResource"(arg0: string): $ResourceLocation
public "itemTag"(arg0: string, arg1: string): $TagKey<($Item)>
public "m_245200_"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public "tagReal"(arg0: $TagKey$Type<(any)>): $ICondition
public "fullOreRecipes"(arg0: string, arg1: $ImmutableList$Type<($ItemLike$Type)>, arg2: $Fluid$Type, arg3: $Item$Type, arg4: $Item$Type, arg5: $Item$Type, arg6: $Item$Type, arg7: $Item$Type, arg8: $Item$Type, arg9: $Consumer$Type<($FinishedRecipe$Type)>, ...arg10: ($MeltingBonus$Type)[]): void
public "plateHammerRecipe"(arg0: string, arg1: $Item$Type, arg2: $Consumer$Type<($FinishedRecipe$Type)>): void
public "fullMetalRecipes"(arg0: string, arg1: $Fluid$Type, arg2: $Item$Type, arg3: $Item$Type, arg4: $Item$Type, arg5: $Item$Type, arg6: $Consumer$Type<($FinishedRecipe$Type)>): void
public "decoRecipes"(arg0: $RegistryManager$StoneDecoBlocks$Type, arg1: $Consumer$Type<($FinishedRecipe$Type)>): void
public "toolRecipes"(arg0: $RegistryManager$ToolSet$Type, arg1: $TagKey$Type<($Item$Type)>, arg2: $Item$Type, arg3: $Consumer$Type<($FinishedRecipe$Type)>): void
public "oreMeltingRecipes"(arg0: string, arg1: $Fluid$Type, arg2: $Consumer$Type<($FinishedRecipe$Type)>, ...arg3: ($MeltingBonus$Type)[]): void
public "bonusRecipe"(arg0: $BiConsumer$Type<($ICondition$Type), ($MeltingBonus$Type)>, arg1: $ICondition$Type, ...arg2: ($MeltingBonus$Type)[]): void
public "fluidTag"(arg0: string, arg1: string): $TagKey<($Fluid)>
public "fullOreMeltingStampingRecipes"(arg0: string, arg1: $Fluid$Type, arg2: $Consumer$Type<($FinishedRecipe$Type)>, ...arg3: ($MeltingBonus$Type)[]): void
public "fullMeltingStampingRecipes"(arg0: string, arg1: $Fluid$Type, arg2: $Consumer$Type<($FinishedRecipe$Type)>): void
public "blockIngotNuggetCompression"(arg0: string, arg1: $Item$Type, arg2: $Item$Type, arg3: $Item$Type, arg4: $Consumer$Type<($FinishedRecipe$Type)>): void
public "TRUE"(): $ICondition
public "FALSE"(): $ICondition
public "or"(...arg0: ($ICondition$Type)[]): $ICondition
public "and"(...arg0: ($ICondition$Type)[]): $ICondition
public "not"(arg0: $ICondition$Type): $ICondition
public "modLoaded"(arg0: string): $ICondition
public "itemExists"(arg0: string, arg1: string): $ICondition
public "tagEmpty"(arg0: $TagKey$Type<($Item$Type)>): $ICondition
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersRecipes$Type = ($EmbersRecipes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersRecipes_ = $EmbersRecipes$Type;
}}
declare module "packages/com/rekindled/embers/item/$ExplosionCharmItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ExplosionEvent$Start, $ExplosionEvent$Start$Type} from "packages/net/minecraftforge/event/level/$ExplosionEvent$Start"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ExplosionCharmItem extends $Item implements $IEmbersCurioItem {
static readonly "COOLDOWN": integer
static readonly "MERCY_TIME": integer
static "ITEM_COOLDOWN_KEY": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "onExplosion"(arg0: $ExplosionEvent$Start$Type): void
public static "hasItemCooledDown"(arg0: $ItemStack$Type, arg1: long, arg2: integer): boolean
public static "setItemCooldown"(arg0: $ItemStack$Type, arg1: long): $ItemStack
public static "hasItemMercy"(arg0: $ItemStack$Type, arg1: long, arg2: integer): boolean
public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
public "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionCharmItem$Type = ($ExplosionCharmItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionCharmItem_ = $ExplosionCharmItem$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersBiomeModifiers" {
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$BootstapContext, $BootstapContext$Type} from "packages/net/minecraft/data/worldgen/$BootstapContext"

export class $EmbersBiomeModifiers {
static readonly "ORE_LEAD_KEY": $ResourceKey<($BiomeModifier)>
static readonly "ORE_SILVER_KEY": $ResourceKey<($BiomeModifier)>
static readonly "GOLEM_SPAWN": $ResourceKey<($BiomeModifier)>
static readonly "NO_MONSTERS": $TagKey<($Biome)>

constructor()

public static "generate"(arg0: $BootstapContext$Type<($BiomeModifier$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersBiomeModifiers$Type = ($EmbersBiomeModifiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersBiomeModifiers_ = $EmbersBiomeModifiers$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoilingRecipeBuilder" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BoilingRecipe, $BoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoilingRecipe"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $BoilingRecipeBuilder {
 "id": $ResourceLocation
 "input": $FluidIngredient
 "output": $FluidStack

constructor()

public "id"(arg0: $ResourceLocation$Type): $BoilingRecipeBuilder
public "domain"(arg0: string): $BoilingRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $Fluid$Type, arg1: integer): $BoilingRecipeBuilder
public static "create"(arg0: $FluidStack$Type): $BoilingRecipeBuilder
public "input"(arg0: $TagKey$Type<($Fluid$Type)>, arg1: integer): $BoilingRecipeBuilder
public "input"(...arg0: ($FluidIngredient$Type)[]): $BoilingRecipeBuilder
public "input"(arg0: $Fluid$Type, arg1: integer): $BoilingRecipeBuilder
public "input"(arg0: $FluidStack$Type): $BoilingRecipeBuilder
public "input"(arg0: $FluidIngredient$Type): $BoilingRecipeBuilder
public "build"(): $BoilingRecipe
public "output"(arg0: $Fluid$Type, arg1: integer): $BoilingRecipeBuilder
public "output"(arg0: $FluidStack$Type): $BoilingRecipeBuilder
public "folder"(arg0: string): $BoilingRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilingRecipeBuilder$Type = ($BoilingRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilingRecipeBuilder_ = $BoilingRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$GeologicSeparatorBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpenTankBlockEntity, $OpenTankBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $GeologicSeparatorBlockEntity extends $OpenTankBlockEntity implements $IExtraCapabilityInformation {
 "renderOffset": float
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $GeologicSeparatorBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeologicSeparatorBlockEntity$Type = ($GeologicSeparatorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeologicSeparatorBlockEntity_ = $GeologicSeparatorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberCartridgeItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EmberStorageItem, $EmberStorageItem$Type} from "packages/com/rekindled/embers/item/$EmberStorageItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberCartridgeItem extends $EmberStorageItem {
static readonly "CAPACITY": double
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getCapacity"(): double
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
get "capacity"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberCartridgeItem$Type = ($EmberCartridgeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberCartridgeItem_ = $EmberCartridgeItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$CopperChargerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CopperChargerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperChargerBlock$Type = ($CopperChargerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperChargerBlock_ = $CopperChargerBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/capabilities/$EmbersCapabilities" {
import {$IUpgradeProvider, $IUpgradeProvider$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeProvider"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $EmbersCapabilities {
static readonly "UPGRADE_PROVIDER_CAPABILITY": $Capability<($IUpgradeProvider)>
static readonly "EMBER_CAPABILITY": $Capability<($IEmberCapability)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersCapabilities$Type = ($EmbersCapabilities);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersCapabilities_ = $EmbersCapabilities$Type;
}}
declare module "packages/com/rekindled/embers/augment/$BlastingCoreAugment" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEvent$BreakEvent, $BlockEvent$BreakEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent$BreakEvent"
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $BlastingCoreAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "getBlastAdjacent"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $Player$Type, arg3: double): $Iterable<($BlockPos)>
public "getBlastCube"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $Player$Type, arg3: double): $Iterable<($BlockPos)>
public "onHit"(arg0: $LivingHurtEvent$Type): void
public "onBreak"(arg0: $BlockEvent$BreakEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastingCoreAugment$Type = ($BlastingCoreAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlastingCoreAugment_ = $BlastingCoreAugment$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CopperCellBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CopperCellBlockEntity extends $BlockEntity {
 "capability": $IEmberCapability
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperCellBlockEntity$Type = ($CopperCellBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperCellBlockEntity_ = $CopperCellBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$InfoGogglesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $InfoGogglesEvent extends $Event {

constructor()
constructor(arg0: $Player$Type, arg1: boolean)

public "isCancelable"(): boolean
public "shouldDisplay"(): boolean
public "setShouldDisplay"(arg0: boolean): void
public "getPlayer"(): $Player
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "player"(): $Player
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfoGogglesEvent$Type = ($InfoGogglesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfoGogglesEvent_ = $InfoGogglesEvent$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IMixingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$MixingContext, $MixingContext$Type} from "packages/com/rekindled/embers/recipe/$MixingContext"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IMixingRecipe extends $Recipe<($MixingContext)> {

 "process"(arg0: $MixingContext$Type): $FluidStack
 "getDisplayOutput"(): $FluidStack
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getDisplayInputFluids"(): $ArrayList<($FluidIngredient)>
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $MixingContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getOutput"(arg0: $MixingContext$Type): $FluidStack
 "getRemainingItems"(arg0: $MixingContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $MixingContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IMixingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMixingRecipe$Type = ($IMixingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMixingRecipe_ = $IMixingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/block/$ChamberBlockBase" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ChamberBlockBase$ChamberConnection, $ChamberBlockBase$ChamberConnection$Type} from "packages/com/rekindled/embers/block/$ChamberBlockBase$ChamberConnection"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ChamberBlockBase extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
 "topSound": $SoundType
static readonly "CONNECTION": $EnumProperty<($ChamberBlockBase$ChamberConnection)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "getSoundType"(arg0: $BlockState$Type): $SoundType
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChamberBlockBase$Type = ($ChamberBlockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChamberBlockBase_ = $ChamberBlockBase$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$MeltingCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $MeltingCategory implements $IRecipeCategory<($IMeltingRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IMeltingRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IMeltingRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IMeltingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IMeltingRecipe$Type): boolean
public "handleInput"(arg0: $IMeltingRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IMeltingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IMeltingRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IMeltingRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeltingCategory$Type = ($MeltingCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeltingCategory_ = $MeltingCategory$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersBlockStates" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$RegistryManager$MetalCrystalSeed, $RegistryManager$MetalCrystalSeed$Type} from "packages/com/rekindled/embers/$RegistryManager$MetalCrystalSeed"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ConfiguredModel$Builder, $ConfiguredModel$Builder$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel$Builder"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$WallSide, $WallSide$Type} from "packages/net/minecraft/world/level/block/state/properties/$WallSide"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"
import {$BlockStateProvider, $BlockStateProvider$Type} from "packages/net/minecraftforge/client/model/generators/$BlockStateProvider"
import {$MultiPartBlockStateBuilder, $MultiPartBlockStateBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"

export class $EmbersBlockStates extends $BlockStateProvider {
static readonly "WALL_PROPS": $ImmutableMap<($Direction), ($Property<($WallSide)>)>

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type)

public "dial"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "fluid"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "decoBlocks"(arg0: $RegistryManager$StoneDecoBlocks$Type): void
public "blockWithItem"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "blockWithItem"(arg0: $RegistryObject$Type<(any)>): void
public "leverBlock"(arg0: $Block$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "metalSeed"(arg0: $RegistryManager$MetalCrystalSeed$Type): void
public "flatItem"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public static "addEmitterConnections"(arg0: $MultiPartBlockStateBuilder$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "pillarBlockWithItem"(arg0: $RegistryObject$Type<(any)>, arg1: string, arg2: string): $ModelFile
public "betterDirectionalBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>, arg2: integer): void
public "blockWithItemTexture"(arg0: $RegistryObject$Type<(any)>, arg1: string): void
public "columnBlockWithItem"(arg0: $RegistryObject$Type<(any)>, arg1: string, arg2: string): $ModelFile
public static "rotationsForDirection"<T>(arg0: $ConfiguredModel$Builder$Type<(T)>, arg1: $Direction$Type): $ConfiguredModel$Builder<(T)>
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersBlockStates$Type = ($EmbersBlockStates);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersBlockStates_ = $EmbersBlockStates$Type;
}}
declare module "packages/com/rekindled/embers/block/$AtmosphericBellowsBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $AtmosphericBellowsBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericBellowsBlock$Type = ($AtmosphericBellowsBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericBellowsBlock_ = $AtmosphericBellowsBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$EmberEvent" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$EmberEvent$EnumType, $EmberEvent$EnumType$Type} from "packages/com/rekindled/embers/api/event/$EmberEvent$EnumType"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $EmberEvent extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: $EmberEvent$EnumType$Type, arg2: double)

public "getType"(): $EmberEvent$EnumType
public "getAmount"(): double
get "type"(): $EmberEvent$EnumType
get "amount"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEvent$Type = ($EmberEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEvent_ = $EmberEvent$Type;
}}
declare module "packages/com/rekindled/embers/block/$CombustionChamberBlock" {
import {$ChamberBlockBase$ChamberConnection, $ChamberBlockBase$ChamberConnection$Type} from "packages/com/rekindled/embers/block/$ChamberBlockBase$ChamberConnection"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$ChamberBlockBase, $ChamberBlockBase$Type} from "packages/com/rekindled/embers/block/$ChamberBlockBase"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CombustionChamberBlock extends $ChamberBlockBase {
 "topSound": $SoundType
static readonly "CONNECTION": $EnumProperty<($ChamberBlockBase$ChamberConnection)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombustionChamberBlock$Type = ($CombustionChamberBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombustionChamberBlock_ = $CombustionChamberBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/augment/$IAugmentUtil" {
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $IAugmentUtil {

 "getLevel"(arg0: $ItemStack$Type): integer
 "setLevel"(arg0: $ItemStack$Type, arg1: integer): void
 "getTotalAugmentLevel"(arg0: $ItemStack$Type): integer
 "getArmorAugmentLevel"(arg0: $LivingEntity$Type, arg1: $IAugment$Type): integer
 "getAugment"(arg0: $ResourceLocation$Type): $IAugment
 "getAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type): integer
 "getAllAugments"(): $Collection<($IAugment)>
 "getAugments"(arg0: $ItemStack$Type): $List<($IAugment)>
 "addAugment"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $IAugment$Type): void
 "setAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
 "hasAugment"(arg0: $ItemStack$Type, arg1: $IAugment$Type): boolean
 "hasHeat"(arg0: $ItemStack$Type): boolean
 "addAugmentLevel"(arg0: $ItemStack$Type, arg1: $IAugment$Type, arg2: integer): void
 "registerAugment"(arg0: $IAugment$Type): $IAugment
 "getHeat"(arg0: $ItemStack$Type): float
 "removeAllAugments"(arg0: $ItemStack$Type): $List<($ItemStack)>
 "getMaxHeat"(arg0: $ItemStack$Type): float
 "addHeat"(arg0: $ItemStack$Type, arg1: float): void
 "setHeat"(arg0: $ItemStack$Type, arg1: float): void
}

export namespace $IAugmentUtil {
const HEAT_TAG: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAugmentUtil$Type = ($IAugmentUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAugmentUtil_ = $IAugmentUtil$Type;
}}
declare module "packages/com/rekindled/embers/block/$GlimmerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$GlowParticleOptions, $GlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$GlowParticleOptions"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$StarParticleOptions, $StarParticleOptions$Type} from "packages/com/rekindled/embers/particle/$StarParticleOptions"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $GlimmerBlock extends $Block implements $SimpleWaterloggedBlock {
static readonly "EMBER": $GlowParticleOptions
static readonly "GLIMMER": $StarParticleOptions
static readonly "GLIMMER_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlimmerBlock$Type = ($GlimmerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlimmerBlock_ = $GlimmerBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberEmitterBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EmberEmitterBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "FACING": $DirectionProperty
static readonly "X_DIRECTIONS": ($Direction)[]
static readonly "Y_DIRECTIONS": ($Direction)[]
static readonly "Z_DIRECTIONS": ($Direction)[]
static readonly "DIRECTIONS": ($BooleanProperty)[]
static readonly "ALL_DIRECTIONS": ($BooleanProperty)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getBlockSupportShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): $VoxelShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "getIndexForDirection"(arg0: $Direction$Axis$Type, arg1: $Direction$Type): integer
public static "getDirectionForIndex"(arg0: $Direction$Axis$Type, arg1: integer): $Direction
public static "canAttach"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEmitterBlock$Type = ($EmberEmitterBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEmitterBlock_ = $EmberEmitterBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$MiniBoilerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $MiniBoilerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiniBoilerBlock$Type = ($MiniBoilerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiniBoilerBlock_ = $MiniBoilerBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilRepairMateriaRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$AnvilRepairMateriaRecipe$Serializer, $AnvilRepairMateriaRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairMateriaRecipe$Serializer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IVisuallySplitRecipe, $IVisuallySplitRecipe$Type} from "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilRepairMateriaRecipe implements $IDawnstoneAnvilRecipe, $IVisuallySplitRecipe<($IDawnstoneAnvilRecipe)> {
static readonly "SERIALIZER": $AnvilRepairMateriaRecipe$Serializer
readonly "id": $ResourceLocation
static "visualRecipes": $List<($IDawnstoneAnvilRecipe)>

constructor(arg0: $ResourceLocation$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getVisualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "visualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilRepairMateriaRecipe$Type = ($AnvilRepairMateriaRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilRepairMateriaRecipe_ = $AnvilRepairMateriaRecipe$Type;
}}
declare module "packages/com/rekindled/embers/util/$PipePriorityMap" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"

export class $PipePriorityMap<K, V> {

constructor()

public "get"(arg0: K): $ArrayList<(V)>
public "put"(arg0: K, arg1: V): void
public "keySet"(): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipePriorityMap$Type<K, V> = ($PipePriorityMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipePriorityMap_<K, V> = $PipePriorityMap$Type<(K), (V)>;
}}
declare module "packages/com/rekindled/embers/compat/jei/$JEIPlugin" {
import {$IGuiHandlerRegistration, $IGuiHandlerRegistration$Type} from "packages/mezz/jei/api/registration/$IGuiHandlerRegistration"
import {$IAdvancedRegistration, $IAdvancedRegistration$Type} from "packages/mezz/jei/api/registration/$IAdvancedRegistration"
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$IMetalCoefficientRecipe, $IMetalCoefficientRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$IRecipeCatalystRegistration, $IRecipeCatalystRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCatalystRegistration"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$IRuntimeRegistration, $IRuntimeRegistration$Type} from "packages/mezz/jei/api/registration/$IRuntimeRegistration"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IModIngredientRegistration, $IModIngredientRegistration$Type} from "packages/mezz/jei/api/registration/$IModIngredientRegistration"
import {$IMixingRecipe, $IMixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMixingRecipe"
import {$IJeiConfigManager, $IJeiConfigManager$Type} from "packages/mezz/jei/api/runtime/config/$IJeiConfigManager"
import {$IStampingRecipe, $IStampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IStampingRecipe"
import {$IVanillaCategoryExtensionRegistration, $IVanillaCategoryExtensionRegistration$Type} from "packages/mezz/jei/api/registration/$IVanillaCategoryExtensionRegistration"
import {$RecipeType as $RecipeType$0, $RecipeType$Type as $RecipeType$0$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$IRecipeRegistration, $IRecipeRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeRegistration"
import {$IRecipeTransferRegistration, $IRecipeTransferRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeTransferRegistration"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"
import {$IMeltingRecipe, $IMeltingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMeltingRecipe"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$IModPlugin, $IModPlugin$Type} from "packages/mezz/jei/api/$IModPlugin"
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$IBoringRecipe, $IBoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoringRecipe"
import {$IBoilingRecipe, $IBoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoilingRecipe"
import {$IRecipeCategoryRegistration, $IRecipeCategoryRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCategoryRegistration"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ISubtypeRegistration, $ISubtypeRegistration$Type} from "packages/mezz/jei/api/registration/$ISubtypeRegistration"
import {$IPlatformFluidHelper, $IPlatformFluidHelper$Type} from "packages/mezz/jei/api/helpers/$IPlatformFluidHelper"

export class $JEIPlugin implements $IModPlugin {
static "pluginID": $ResourceLocation
static readonly "BORING": $RecipeType$0<($IBoringRecipe)>
static readonly "EXCAVATION": $RecipeType$0<($IBoringRecipe)>
static readonly "EMBER_ACTIVATION": $RecipeType$0<($IEmberActivationRecipe)>
static readonly "MELTING": $RecipeType$0<($IMeltingRecipe)>
static readonly "MELTING_BONUS": $RecipeType$0<($IMeltingRecipe)>
static readonly "STAMPING": $RecipeType$0<($IStampingRecipe)>
static readonly "MIXING": $RecipeType$0<($IMixingRecipe)>
static readonly "METAL_COEFFICIENT": $RecipeType$0<($IMetalCoefficientRecipe)>
static readonly "ALCHEMY": $RecipeType$0<($IAlchemyRecipe)>
static readonly "BOILING": $RecipeType$0<($IBoilingRecipe)>
static readonly "GASEOUS_FUEL": $RecipeType$0<($IGaseousFuelRecipe)>
static readonly "CATALYSIS_COMBUSTION": $RecipeType$0<($ICatalysisCombustionRecipe)>
static readonly "DAWNSTONE_ANVIL": $RecipeType$0<($IDawnstoneAnvilRecipe)>

constructor()

public "registerRecipeCatalysts"(arg0: $IRecipeCatalystRegistration$Type): void
public static "addRecipes"<C extends $Container, T extends $Recipe<(C)>>(arg0: $IRecipeRegistration$Type, arg1: $RecipeManager$Type, arg2: $RecipeType$0$Type<(T)>, arg3: $RecipeType$Type<(T)>): void
public "getPluginUid"(): $ResourceLocation
public "registerRecipes"(arg0: $IRecipeRegistration$Type): void
public "registerCategories"(arg0: $IRecipeCategoryRegistration$Type): void
public "registerItemSubtypes"(arg0: $ISubtypeRegistration$Type): void
public "registerVanillaCategoryExtensions"(arg0: $IVanillaCategoryExtensionRegistration$Type): void
public "registerFluidSubtypes"<T>(arg0: $ISubtypeRegistration$Type, arg1: $IPlatformFluidHelper$Type<(T)>): void
public "onConfigManagerAvailable"(arg0: $IJeiConfigManager$Type): void
public "registerGuiHandlers"(arg0: $IGuiHandlerRegistration$Type): void
public "onRuntimeUnavailable"(): void
public "registerIngredients"(arg0: $IModIngredientRegistration$Type): void
public "registerRecipeTransferHandlers"(arg0: $IRecipeTransferRegistration$Type): void
public "registerAdvanced"(arg0: $IAdvancedRegistration$Type): void
public "onRuntimeAvailable"(arg0: $IJeiRuntime$Type): void
public "registerRuntime"(arg0: $IRuntimeRegistration$Type): void
get "pluginUid"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEIPlugin$Type = ($JEIPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEIPlugin_ = $JEIPlugin$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AlchemyRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$AlchemyRecipe, $AlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$AlchemyRecipe"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $AlchemyRecipeBuilder {
 "id": $ResourceLocation
 "output": $ItemStack
 "failure": $ItemStack
 "tablet": $Ingredient
 "aspects": $ArrayList<($Ingredient)>
 "inputs": $ArrayList<($Ingredient)>

constructor()

public "id"(arg0: $ResourceLocation$Type): $AlchemyRecipeBuilder
public "domain"(arg0: string): $AlchemyRecipeBuilder
public "failure"(arg0: $Item$Type): $AlchemyRecipeBuilder
public "failure"(arg0: $ItemStack$Type): $AlchemyRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $ItemLike$Type): $AlchemyRecipeBuilder
public static "create"(arg0: $ItemStack$Type): $AlchemyRecipeBuilder
public "build"(): $AlchemyRecipe
public "output"(arg0: $Item$Type): $AlchemyRecipeBuilder
public "output"(arg0: $ItemStack$Type): $AlchemyRecipeBuilder
public "inputs"(arg0: $ArrayList$Type<($Ingredient$Type)>): $AlchemyRecipeBuilder
public "inputs"(...arg0: ($Ingredient$Type)[]): $AlchemyRecipeBuilder
public "inputs"(...arg0: ($TagKey$Type<($Item$Type)>)[]): $AlchemyRecipeBuilder
public "inputs"(...arg0: ($ItemLike$Type)[]): $AlchemyRecipeBuilder
public "folder"(arg0: string): $AlchemyRecipeBuilder
public "aspects"(...arg0: ($Ingredient$Type)[]): $AlchemyRecipeBuilder
public "aspects"(...arg0: ($TagKey$Type<($Item$Type)>)[]): $AlchemyRecipeBuilder
public "aspects"(arg0: $ArrayList$Type<($Ingredient$Type)>): $AlchemyRecipeBuilder
public "aspects"(...arg0: ($ItemLike$Type)[]): $AlchemyRecipeBuilder
public "tablet"(arg0: $Ingredient$Type): $AlchemyRecipeBuilder
public "tablet"(arg0: $TagKey$Type<($Item$Type)>): $AlchemyRecipeBuilder
public "tablet"(...arg0: ($ItemLike$Type)[]): $AlchemyRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyRecipeBuilder$Type = ($AlchemyRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyRecipeBuilder_ = $AlchemyRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$EmberSiphonUpgrade" {
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export class $EmberSiphonUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "getLimit"(arg0: $BlockEntity$Type): integer
public "getSpeed"(arg0: $BlockEntity$Type, arg1: double, arg2: integer, arg3: integer): double
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberSiphonUpgrade$Type = ($EmberSiphonUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberSiphonUpgrade_ = $EmberSiphonUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidHandlerBlockEntity, $FluidHandlerBlockEntity$Type} from "packages/net/minecraftforge/fluids/capability/$FluidHandlerBlockEntity"

export class $OpenTankBlockEntity extends $FluidHandlerBlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "setChanged"(): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "setEscapedFluid"(arg0: $FluidStack$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
set "escapedFluid"(value: $FluidStack$Type)
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpenTankBlockEntity$Type = ($OpenTankBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpenTankBlockEntity_ = $OpenTankBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$WaterloggableButtonBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$AttachFace, $AttachFace$Type} from "packages/net/minecraft/world/level/block/state/properties/$AttachFace"
import {$ButtonBlock, $ButtonBlock$Type} from "packages/net/minecraft/world/level/block/$ButtonBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockSetType, $BlockSetType$Type} from "packages/net/minecraft/world/level/block/state/properties/$BlockSetType"

export class $WaterloggableButtonBlock extends $ButtonBlock {
static readonly "POWERED": $BooleanProperty
static readonly "FACE": $EnumProperty<($AttachFace)>
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $BlockSetType$Type, arg2: integer, arg3: boolean)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterloggableButtonBlock$Type = ($WaterloggableButtonBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WaterloggableButtonBlock_ = $WaterloggableButtonBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$AlchemyTabletBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$AlchemyTabletBlockEntity, $AlchemyTabletBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyTabletBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $AlchemyTabletBlockEntityRenderer implements $BlockEntityRenderer<($AlchemyTabletBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $AlchemyTabletBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $AlchemyTabletBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $AlchemyTabletBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyTabletBlockEntityRenderer$Type = ($AlchemyTabletBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyTabletBlockEntityRenderer_ = $AlchemyTabletBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberStorageItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberStorageItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getCapacity"(): double
public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "getBarColor"(arg0: $ItemStack$Type): integer
public "isBarVisible"(arg0: $ItemStack$Type): boolean
public "getBarWidth"(arg0: $ItemStack$Type): integer
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public static "withFill"(arg0: $Item$Type, arg1: double): $ItemStack
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
get "capacity"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberStorageItem$Type = ($EmberStorageItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberStorageItem_ = $EmberStorageItem$Type;
}}
declare module "packages/com/rekindled/embers/util/$FluidAmounts" {
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $FluidAmounts {
static readonly "NUGGET_AMOUNT": integer
static readonly "INGOT_AMOUNT": integer
static readonly "BLOCK_AMOUNT": integer
static readonly "RAW_AMOUNT": integer
static readonly "ORE_AMOUNT": integer
static readonly "RAW_BLOCK_AMOUNT": integer
static readonly "PLATE_AMOUNT": integer
static readonly "GEAR_AMOUNT": integer

constructor()

public static "getIngotTooltip"(arg0: integer): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$Type = ($FluidAmounts);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidAmounts_ = $FluidAmounts$Type;
}}
declare module "packages/com/rekindled/embers/particle/$AlchemyCircleParticleOptions" {
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $AlchemyCircleParticleOptions implements $ParticleOptions {
static readonly "DEFAULT": $AlchemyCircleParticleOptions
static readonly "CODEC": $Codec<($AlchemyCircleParticleOptions)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($AlchemyCircleParticleOptions)>

constructor(arg0: $Vector3f$Type, arg1: float, arg2: integer)

public "getLifetime"(): integer
public static "readVector3f"(arg0: $FriendlyByteBuf$Type): $Vector3f
public static "readVector3f"(arg0: $StringReader$Type): $Vector3f
public "getScale"(): float
public "getColor"(): $Vector3f
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "lifetime"(): integer
get "scale"(): float
get "color"(): $Vector3f
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyCircleParticleOptions$Type = ($AlchemyCircleParticleOptions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyCircleParticleOptions_ = $AlchemyCircleParticleOptions$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GaseousFuelRecipeBuilder" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GaseousFuelRecipe, $GaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$GaseousFuelRecipe"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $GaseousFuelRecipeBuilder {
 "id": $ResourceLocation
 "input": $FluidIngredient
 "burnTime": integer
 "powerMultiplier": double

constructor()

public "id"(arg0: $ResourceLocation$Type): $GaseousFuelRecipeBuilder
public "domain"(arg0: string): $GaseousFuelRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $ResourceLocation$Type): $GaseousFuelRecipeBuilder
public static "create"(arg0: $FluidStack$Type): $GaseousFuelRecipeBuilder
public static "create"(arg0: $Fluid$Type, arg1: integer): $GaseousFuelRecipeBuilder
public "input"(arg0: $TagKey$Type<($Fluid$Type)>, arg1: integer): $GaseousFuelRecipeBuilder
public "input"(...arg0: ($FluidIngredient$Type)[]): $GaseousFuelRecipeBuilder
public "input"(arg0: $Fluid$Type, arg1: integer): $GaseousFuelRecipeBuilder
public "input"(arg0: $FluidStack$Type): $GaseousFuelRecipeBuilder
public "input"(arg0: $FluidIngredient$Type): $GaseousFuelRecipeBuilder
public "build"(): $GaseousFuelRecipe
public "burnTime"(arg0: integer): $GaseousFuelRecipeBuilder
public "folder"(arg0: string): $GaseousFuelRecipeBuilder
public "powerMultiplier"(arg0: double): $GaseousFuelRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaseousFuelRecipeBuilder$Type = ($GaseousFuelRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GaseousFuelRecipeBuilder_ = $GaseousFuelRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersEntityLootTables" {
import {$EntityLootSubProvider, $EntityLootSubProvider$Type} from "packages/net/minecraft/data/loot/$EntityLootSubProvider"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $EmbersEntityLootTables extends $EntityLootSubProvider {

constructor()

public "generate"(): void
public "getKnownEntityTypes"(): $Stream<($EntityType<(any)>)>
get "knownEntityTypes"(): $Stream<($EntityType<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersEntityLootTables$Type = ($EmbersEntityLootTables);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersEntityLootTables_ = $EmbersEntityLootTables$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MirrorRelayBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberPacketProducer, $IEmberPacketProducer$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketProducer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IEmberPacketReceiver, $IEmberPacketReceiver$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketReceiver"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export class $MirrorRelayBlockEntity extends $BlockEntity implements $IEmberPacketProducer, $IEmberPacketReceiver {
 "target": $BlockPos
 "random": $Random
 "polled": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setTargetPosition"(arg0: $BlockPos$Type, arg1: $Direction$Type): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEmittingDirection"(arg0: $Direction$Type): $Direction
public "onReceive"(arg0: $EmberPacketEntity$Type): boolean
public "hasRoomFor"(arg0: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MirrorRelayBlockEntity$Type = ($MirrorRelayBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MirrorRelayBlockEntity_ = $MirrorRelayBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$BeamCannonBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $BeamCannonBlockEntity extends $BlockEntity {
 "capability": $IEmberCapability
static readonly "PULL_RATE": double
static readonly "FIRE_THRESHOLD": integer
static readonly "DAMAGE": float
static readonly "MAX_DISTANCE": integer
 "ticksExisted": long
 "lastPowered": boolean
 "random": $Random
 "offset": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)
constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "fire"(arg0: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BeamCannonBlockEntity$Type): void
public "sparkTarget"(arg0: $BlockEntity$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeamCannonBlockEntity$Type = ($BeamCannonBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeamCannonBlockEntity_ = $BeamCannonBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$FuelItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FuelItem extends $Item {
readonly "burnTime": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type, arg1: integer)

public "getBurnTime"(arg0: $ItemStack$Type, arg1: $RecipeType$Type<(any)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelItem$Type = ($FuelItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelItem_ = $FuelItem$Type;
}}
declare module "packages/com/rekindled/embers/api/$IEmbersAPI" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IEmbersAPI {

 "registerWearableLens"(arg0: $Ingredient$Type): void
 "registerHammerTargetGetter"(arg0: $Item$Type): void
 "registerHammerTargetGetter"(arg0: $Function$Type<($Player$Type), ($Pair$Type<($BlockPos$Type), ($Direction$Type)>)>): void
 "getEmberCapacityTotal"(arg0: $Player$Type): double
 "registerEmberResonance"(arg0: $Ingredient$Type, arg1: double): void
 "registerLinkingHammer"(arg0: $Item$Type): void
 "registerLinkingHammer"(arg0: $BiPredicate$Type<($Player$Type), ($InteractionHand$Type)>): void
 "getHammerTarget"(arg0: $Player$Type): $Pair<($BlockPos), ($Direction)>
 "getEmberDensity"(arg0: long, arg1: integer, arg2: integer): float
 "isHoldingHammer"(arg0: $Player$Type, arg1: $InteractionHand$Type): boolean
 "getEmberStability"(arg0: long, arg1: integer, arg2: integer): float
 "registerLens"(arg0: $Ingredient$Type): void
 "registerLens"(arg0: $Predicate$Type<($Player$Type)>): void
 "isWearingLens"(arg0: $Player$Type): boolean
 "setScales"(arg0: $LivingEntity$Type, arg1: double): void
 "getScales"(arg0: $LivingEntity$Type): double
 "getEmberTotal"(arg0: $Player$Type): double
 "getTaggedItem"(arg0: $TagKey$Type<($Item$Type)>): $Item
 "removeEmber"(arg0: $Player$Type, arg1: double): void
 "getEmberResonance"(arg0: $ItemStack$Type): double
}

export namespace $IEmbersAPI {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmbersAPI$Type = ($IEmbersAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmbersAPI_ = $IEmbersAPI$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AlchemyPedestalTopBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IAlchemyRecipe$PedestalContents, $IAlchemyRecipe$PedestalContents$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe$PedestalContents"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$AlchemyPedestalBlockEntity, $AlchemyPedestalBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AlchemyPedestalBlockEntity"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $AlchemyPedestalTopBlockEntity extends $AlchemyPedestalBlockEntity implements $ISoundController {
 "active": integer
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "isActive"(): boolean
public "isValid"(): boolean
public "getContents"(): $IAlchemyRecipe$PedestalContents
public "setActive"(arg0: integer): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AlchemyPedestalTopBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "playSound"(arg0: integer): void
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
get "active"(): boolean
get "valid"(): boolean
get "contents"(): $IAlchemyRecipe$PedestalContents
set "active"(value: integer)
get "soundIDs"(): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyPedestalTopBlockEntity$Type = ($AlchemyPedestalTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyPedestalTopBlockEntity_ = $AlchemyPedestalTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/render/$BakedPipeModel" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ChunkRenderTypeSet, $ChunkRenderTypeSet$Type} from "packages/net/minecraftforge/client/$ChunkRenderTypeSet"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $BakedPipeModel implements $BakedModel {
static readonly "EMPTY": $List<($BakedQuad)>
readonly "QUAD_CACHE": ($List<($BakedQuad)>)[]

constructor(arg0: $BakedModel$Type, arg1: ($BakedModel$Type)[], arg2: ($BakedModel$Type)[])

public "usesBlockLight"(): boolean
public "isGui3d"(): boolean
public "getParticleIcon"(): $TextureAtlasSprite
public static "getCacheIndex"(arg0: (integer)[]): integer
public "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type): $List<($BakedQuad)>
public "isCustomRenderer"(): boolean
public "getOverrides"(): $ItemOverrides
public "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type, arg3: $ModelData$Type, arg4: $RenderType$Type): $List<($BakedQuad)>
public "useAmbientOcclusion"(): boolean
/**
 * 
 * @deprecated
 */
public "getTransforms"(): $ItemTransforms
public "useAmbientOcclusion"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
public "useAmbientOcclusion"(arg0: $BlockState$Type): boolean
public "getRenderTypes"(arg0: $ItemStack$Type, arg1: boolean): $List<($RenderType)>
public "getRenderTypes"(arg0: $BlockState$Type, arg1: $RandomSource$Type, arg2: $ModelData$Type): $ChunkRenderTypeSet
public "getRenderPasses"(arg0: $ItemStack$Type, arg1: boolean): $List<($BakedModel)>
public "applyTransform"(arg0: $ItemDisplayContext$Type, arg1: $PoseStack$Type, arg2: boolean): $BakedModel
public "getParticleIcon"(arg0: $ModelData$Type): $TextureAtlasSprite
public "getModelData"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ModelData$Type): $ModelData
public "useAmbientOcclusionWithLightEmission"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
get "gui3d"(): boolean
get "particleIcon"(): $TextureAtlasSprite
get "customRenderer"(): boolean
get "overrides"(): $ItemOverrides
get "transforms"(): $ItemTransforms
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BakedPipeModel$Type = ($BakedPipeModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BakedPipeModel_ = $BakedPipeModel$Type;
}}
declare module "packages/com/rekindled/embers/item/$BlazingRayItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IProjectileWeapon, $IProjectileWeapon$Type} from "packages/com/rekindled/embers/api/item/$IProjectileWeapon"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlazingRayItem extends $Item implements $IProjectileWeapon {
static "rand": $Random
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "getUseDuration"(arg0: $ItemStack$Type): integer
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "getUseAnimation"(arg0: $ItemStack$Type): $UseAnim
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazingRayItem$Type = ($BlazingRayItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlazingRayItem_ = $BlazingRayItem$Type;
}}
declare module "packages/com/rekindled/embers/block/$WaterloggableLeverBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$AttachFace, $AttachFace$Type} from "packages/net/minecraft/world/level/block/state/properties/$AttachFace"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$LeverBlock, $LeverBlock$Type} from "packages/net/minecraft/world/level/block/$LeverBlock"

export class $WaterloggableLeverBlock extends $LeverBlock {
static readonly "POWERED": $BooleanProperty
static readonly "FACE": $EnumProperty<($AttachFace)>
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterloggableLeverBlock$Type = ($WaterloggableLeverBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WaterloggableLeverBlock_ = $WaterloggableLeverBlock$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$EmberActivationCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$IEmberActivationRecipe, $IEmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$IEmberActivationRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $EmberActivationCategory implements $IRecipeCategory<($IEmberActivationRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IEmberActivationRecipe)>
public "draw"(arg0: $IEmberActivationRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IEmberActivationRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IEmberActivationRecipe$Type): boolean
public "handleInput"(arg0: $IEmberActivationRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IEmberActivationRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IEmberActivationRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IEmberActivationRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivationCategory$Type = ($EmberActivationCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivationCategory_ = $EmberActivationCategory$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$HeatIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HeatIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(arg0: $Ingredient$Type, arg1: boolean)

public "test"(arg0: $ItemStack$Type): boolean
public static "of"(arg0: $Ingredient$Type): $HeatIngredient
public static "of"(arg0: $Ingredient$Type, arg1: boolean): $HeatIngredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getStackingIds"(): $IntList
public "isEmpty"(): boolean
public "getSerializer"(): $IIngredientSerializer<($HeatIngredient)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "stackingIds"(): $IntList
get "empty"(): boolean
get "serializer"(): $IIngredientSerializer<($HeatIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatIngredient$Type = ($HeatIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatIngredient_ = $HeatIngredient$Type;
}}
declare module "packages/com/rekindled/embers/block/$MithrilBlock" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MithrilBlock extends $BaseEntityBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MithrilBlock$Type = ($MithrilBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MithrilBlock_ = $MithrilBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilRepairRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$AnvilRepairRecipe$Serializer, $AnvilRepairRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AnvilRepairRecipe$Serializer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IVisuallySplitRecipe, $IVisuallySplitRecipe$Type} from "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilRepairRecipe implements $IDawnstoneAnvilRecipe, $IVisuallySplitRecipe<($IDawnstoneAnvilRecipe)> {
static readonly "SERIALIZER": $AnvilRepairRecipe$Serializer
readonly "id": $ResourceLocation
static "visualRecipes": $List<($IDawnstoneAnvilRecipe)>

constructor(arg0: $ResourceLocation$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getVisualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "visualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilRepairRecipe$Type = ($AnvilRepairRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilRepairRecipe_ = $AnvilRepairRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilAugmentRemoveRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$AnvilAugmentRemoveRecipe, $AnvilAugmentRemoveRecipe$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRemoveRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $AnvilAugmentRemoveRecipe$Serializer implements $RecipeSerializer<($AnvilAugmentRemoveRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $AnvilAugmentRemoveRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $AnvilAugmentRemoveRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $AnvilAugmentRemoveRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $AnvilAugmentRemoveRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilAugmentRemoveRecipe$Serializer$Type = ($AnvilAugmentRemoveRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilAugmentRemoveRecipe$Serializer_ = $AnvilAugmentRemoveRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/particle/$VaporParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$VaporParticleOptions, $VaporParticleOptions$Type} from "packages/com/rekindled/embers/particle/$VaporParticleOptions"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $VaporParticle extends $TextureSheetParticle {
 "minScale": float
 "maxScale": float
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $VaporParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaporParticle$Type = ($VaporParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VaporParticle_ = $VaporParticle$Type;
}}
declare module "packages/com/rekindled/embers/augment/$TinkerLensAugment" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $TinkerLensAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type, arg1: boolean)

public "countTowardsTotalLevel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinkerLensAugment$Type = ($TinkerLensAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinkerLensAugment_ = $TinkerLensAugment$Type;
}}
declare module "packages/com/rekindled/embers/render/$FluidCuboid" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$FluidCuboid$FluidFace, $FluidCuboid$FluidFace$Type} from "packages/com/rekindled/embers/render/$FluidCuboid$FluidFace"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FluidCuboid {
static readonly "DEFAULT_FACES": $Map<($Direction), ($FluidCuboid$FluidFace)>
static readonly "FLOWING_DOWN_FACES": $Map<($Direction), ($FluidCuboid$FluidFace)>

constructor(arg0: $Vector3f$Type, arg1: $Vector3f$Type, arg2: $Map$Type<($Direction$Type), ($FluidCuboid$FluidFace$Type)>)

public "getFrom"(): $Vector3f
public static "fromJson"(arg0: $JsonObject$Type): $FluidCuboid
public static "parseList"<T>(arg0: $JsonArray$Type, arg1: string, arg2: $Function$Type<($JsonObject$Type), (T)>): $List<(T)>
public static "parseList"<T>(arg0: $JsonArray$Type, arg1: string, arg2: $BiFunction$Type<($JsonElement$Type), (string), (T)>): $List<(T)>
public static "getRotation"(arg0: $JsonObject$Type, arg1: string): integer
public "getFace"(arg0: $Direction$Type): $FluidCuboid$FluidFace
public "getFaces"(): $Map<($Direction), ($FluidCuboid$FluidFace)>
public "getTo"(): $Vector3f
public "getToScaled"(): $Vector3f
public "getFromScaled"(): $Vector3f
public static "arrayToVector"(arg0: $JsonObject$Type, arg1: string): $Vector3f
public static "arrayToObject"<T>(arg0: $JsonObject$Type, arg1: string, arg2: integer, arg3: $Function$Type<((float)[]), (T)>): T
public static "listFromJson"(arg0: $JsonObject$Type, arg1: string): $List<($FluidCuboid)>
get "from"(): $Vector3f
get "faces"(): $Map<($Direction), ($FluidCuboid$FluidFace)>
get "to"(): $Vector3f
get "toScaled"(): $Vector3f
get "fromScaled"(): $Vector3f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidCuboid$Type = ($FluidCuboid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidCuboid_ = $FluidCuboid$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$MixingCategory" {
import {$IMixingRecipe, $IMixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IMixingRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $MixingCategory implements $IRecipeCategory<($IMixingRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IMixingRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IMixingRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IMixingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IMixingRecipe$Type): boolean
public "handleInput"(arg0: $IMixingRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IMixingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IMixingRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IMixingRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixingCategory$Type = ($MixingCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixingCategory_ = $MixingCategory$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$BeamSplitterBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISparkable, $ISparkable$Type} from "packages/com/rekindled/embers/api/tile/$ISparkable"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IEmberPacketProducer, $IEmberPacketProducer$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketProducer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IEmberPacketReceiver, $IEmberPacketReceiver$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketReceiver"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EmberPacketEntity, $EmberPacketEntity$Type} from "packages/com/rekindled/embers/entity/$EmberPacketEntity"

export class $BeamSplitterBlockEntity extends $BlockEntity implements $IEmberPacketProducer, $IEmberPacketReceiver, $ISparkable {
 "target1": $BlockPos
 "target2": $BlockPos
 "random": $Random
 "polled": boolean
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "split"(arg0: double): void
public "setTargetPosition"(arg0: $BlockPos$Type, arg1: $Direction$Type): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEmittingDirection"(arg0: $Direction$Type): $Direction
public "onReceive"(arg0: $EmberPacketEntity$Type): boolean
public "hasRoomFor"(arg0: double): boolean
public "sparkProgress"(arg0: $BlockEntity$Type, arg1: double): void
public "hasRoomTarget"(arg0: $BlockPos$Type, arg1: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeamSplitterBlockEntity$Type = ($BeamSplitterBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeamSplitterBlockEntity_ = $BeamSplitterBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberDiscountBaubleItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$EmberRemoveEvent, $EmberRemoveEvent$Type} from "packages/com/rekindled/embers/api/event/$EmberRemoveEvent"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberDiscountBaubleItem extends $Item implements $IEmbersCurioItem {
 "reduction": double
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type, arg1: double)

public "onTake"(arg0: $EmberRemoveEvent$Type): void
public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
public "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberDiscountBaubleItem$Type = ($EmberDiscountBaubleItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberDiscountBaubleItem_ = $EmberDiscountBaubleItem$Type;
}}
declare module "packages/com/rekindled/embers/research/capability/$DefaultResearchCapability" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IResearchCapability, $IResearchCapability$Type} from "packages/com/rekindled/embers/research/capability/$IResearchCapability"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DefaultResearchCapability implements $IResearchCapability {

constructor()

public "readFromNBT"(arg0: $CompoundTag$Type): void
public "isChecked"(arg0: string): boolean
public "setCheckmark"(arg0: string, arg1: boolean): void
public "getCheckmarks"(): $Map<(string), (boolean)>
public "writeToNBT"(arg0: $CompoundTag$Type): void
get "checkmarks"(): $Map<(string), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultResearchCapability$Type = ($DefaultResearchCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultResearchCapability_ = $DefaultResearchCapability$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersLootTables" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$LootTableProvider, $LootTableProvider$Type} from "packages/net/minecraft/data/loot/$LootTableProvider"

export class $EmbersLootTables extends $LootTableProvider {

constructor(arg0: $PackOutput$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersLootTables$Type = ($EmbersLootTables);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersLootTables_ = $EmbersLootTables$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberEjectorBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$EmberEmitterBlock, $EmberEmitterBlock$Type} from "packages/com/rekindled/embers/block/$EmberEmitterBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $EmberEjectorBlock extends $EmberEmitterBlock {
static readonly "FACING": $DirectionProperty
static readonly "X_DIRECTIONS": ($Direction)[]
static readonly "Y_DIRECTIONS": ($Direction)[]
static readonly "Z_DIRECTIONS": ($Direction)[]
static readonly "DIRECTIONS": ($BooleanProperty)[]
static readonly "ALL_DIRECTIONS": ($BooleanProperty)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEjectorBlock$Type = ($EmberEjectorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEjectorBlock_ = $EmberEjectorBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$EffectPotion" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EffectPotion implements $IProjectileEffect {

constructor(arg0: $MobEffectInstance$Type)

public "onEntityImpact"(arg0: $Entity$Type, arg1: $IProjectilePreset$Type): void
public "setEffect"(arg0: $MobEffectInstance$Type): void
public "getEffect"(): $MobEffectInstance
public "onFizzle"(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $IProjectilePreset$Type): void
public "onBlockImpact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IProjectilePreset$Type): void
public "onHit"(arg0: $Level$Type, arg1: $HitResult$Type, arg2: $IProjectilePreset$Type): void
set "effect"(value: $MobEffectInstance$Type)
get "effect"(): $MobEffectInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectPotion$Type = ($EffectPotion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectPotion_ = $EffectPotion$Type;
}}
declare module "packages/com/rekindled/embers/damage/$DamageEmber" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $DamageEmber extends $DamageSource {

constructor(arg0: $Holder$Type<($DamageType$Type)>)
constructor(arg0: $Holder$Type<($DamageType$Type)>, arg1: $Entity$Type, arg2: boolean)
constructor(arg0: $Holder$Type<($DamageType$Type)>, arg1: $Entity$Type)
constructor(arg0: $Holder$Type<($DamageType$Type)>, arg1: $Entity$Type, arg2: $Entity$Type, arg3: $Vec3$Type)
constructor(arg0: $Holder$Type<($DamageType$Type)>, arg1: $Entity$Type, arg2: $Entity$Type)
constructor(arg0: $Holder$Type<($DamageType$Type)>, arg1: $Vec3$Type)

public "isIndirect"(): boolean
public "getLocalizedDeathMessage"(arg0: $LivingEntity$Type): $Component
get "indirect"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DamageEmber$Type = ($DamageEmber);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DamageEmber_ = $DamageEmber$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberInjectorBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberInjectorBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation {
 "capability": $IEmberCapability
static readonly "EMBER_COST": double
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "upgrades": $List<($UpgradeContext)>
 "isWorking": boolean
 "distance": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberInjectorBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberInjectorBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberInjectorBlockEntity$Type = ($EmberInjectorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberInjectorBlockEntity_ = $EmberInjectorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/worldgen/$EntityMobilizerStructureProcessor" {
import {$StructureTemplate$StructureEntityInfo, $StructureTemplate$StructureEntityInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureEntityInfo"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $EntityMobilizerStructureProcessor extends $StructureProcessor {
static readonly "CODEC": $Codec<($EntityMobilizerStructureProcessor)>
static readonly "INSTANCE": $EntityMobilizerStructureProcessor

constructor()

public "processEntity"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $StructureTemplate$StructureEntityInfo$Type, arg3: $StructureTemplate$StructureEntityInfo$Type, arg4: $StructurePlaceSettings$Type, arg5: $StructureTemplate$Type): $StructureTemplate$StructureEntityInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityMobilizerStructureProcessor$Type = ($EntityMobilizerStructureProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityMobilizerStructureProcessor_ = $EntityMobilizerStructureProcessor$Type;
}}
declare module "packages/com/rekindled/embers/item/$EmberJarItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EmberStorageItem, $EmberStorageItem$Type} from "packages/com/rekindled/embers/item/$EmberStorageItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EmberJarItem extends $EmberStorageItem {
static readonly "CAPACITY": double
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getCapacity"(): double
public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
get "capacity"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberJarItem$Type = ($EmberJarItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberJarItem_ = $EmberJarItem$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$ProjectileFireball" {
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ProjectileFireball implements $IProjectilePreset {

constructor(arg0: $Entity$Type, arg1: $Vec3$Type, arg2: $Vec3$Type, arg3: double, arg4: integer, arg5: $IProjectileEffect$Type)

public "getSize"(): double
public "setColor"(arg0: $Color$Type): void
public "setSize"(arg0: double): void
public "shoot"(arg0: $Level$Type): void
public "setPos"(arg0: $Vec3$Type): void
public "getVelocity"(): $Vec3
public "getLifetime"(): integer
public "setVelocity"(arg0: $Vec3$Type): void
public "setGravity"(arg0: double): void
public "getGravity"(): double
public "setEffect"(arg0: $IProjectileEffect$Type): void
public "getEntity"(): $Entity
public "getColor"(): $Color
public "getShooter"(): $Entity
public "getPos"(): $Vec3
public "setHoming"(arg0: integer, arg1: double, arg2: integer, arg3: integer, arg4: $Predicate$Type<($Entity$Type)>): void
public "setLifetime"(arg0: integer): void
public "getEffect"(): $IProjectileEffect
get "size"(): double
set "color"(value: $Color$Type)
set "size"(value: double)
set "pos"(value: $Vec3$Type)
get "velocity"(): $Vec3
get "lifetime"(): integer
set "velocity"(value: $Vec3$Type)
set "gravity"(value: double)
get "gravity"(): double
set "effect"(value: $IProjectileEffect$Type)
get "entity"(): $Entity
get "color"(): $Color
get "shooter"(): $Entity
get "pos"(): $Vec3
set "lifetime"(value: integer)
get "effect"(): $IProjectileEffect
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProjectileFireball$Type = ($ProjectileFireball);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProjectileFireball_ = $ProjectileFireball$Type;
}}
declare module "packages/com/rekindled/embers/compat/curios/$CuriosCompat" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RegisterColorHandlersEvent$Item, $RegisterColorHandlersEvent$Item$Type} from "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent$Item"
import {$ExplosionPedestalBlockEntity, $ExplosionPedestalBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ExplosionPedestalBlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $CuriosCompat {
static readonly "EXPLOSION_PEDESTAL": $RegistryObject<($Block)>
static readonly "EMBER_RING": $RegistryObject<($Item)>
static readonly "EMBER_BELT": $RegistryObject<($Item)>
static readonly "EMBER_AMULET": $RegistryObject<($Item)>
static readonly "EMBER_BULB": $RegistryObject<($Item)>
static readonly "DAWNSTONE_MAIL": $RegistryObject<($Item)>
static readonly "ASHEN_AMULET": $RegistryObject<($Item)>
static readonly "NONBELEIVER_AMULET": $RegistryObject<($Item)>
static readonly "EXPLOSION_CHARM": $RegistryObject<($Item)>
static readonly "EXPLOSION_PEDESTAL_ITEM": $RegistryObject<($Item)>
static readonly "EXPLOSION_PEDESTAL_ENTITY": $RegistryObject<($BlockEntityType<($ExplosionPedestalBlockEntity)>)>

constructor()

public static "init"(): void
public static "getEmberCapacityTotal"(arg0: $LivingEntity$Type): double
public static "registerColorHandler"(arg0: $RegisterColorHandlersEvent$Item$Type, arg1: $ItemColor$Type): void
public static "getEmberTotal"(arg0: $LivingEntity$Type): double
public static "removeEmber"(arg0: $LivingEntity$Type, arg1: double): double
public static "checkForCurios"(arg0: $LivingEntity$Type, arg1: $Predicate$Type<($ItemStack$Type)>): boolean
public static "initCuriosCategory"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuriosCompat$Type = ($CuriosCompat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CuriosCompat_ = $CuriosCompat$Type;
}}
declare module "packages/com/rekindled/embers/util/$WeightedItemStack" {
import {$WeightedEntry$IntrusiveBase, $WeightedEntry$IntrusiveBase$Type} from "packages/net/minecraft/util/random/$WeightedEntry$IntrusiveBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$WeightedEntry$Wrapper, $WeightedEntry$Wrapper$Type} from "packages/net/minecraft/util/random/$WeightedEntry$Wrapper"

export class $WeightedItemStack extends $WeightedEntry$IntrusiveBase {
static "EMPTY": $WeightedItemStack

constructor(arg0: $ItemStack$Type, arg1: integer)

public "getStack"(): $ItemStack
public static "wrap"<T>(arg0: T, arg1: integer): $WeightedEntry$Wrapper<(T)>
get "stack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedItemStack$Type = ($WeightedItemStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeightedItemStack_ = $WeightedItemStack$Type;
}}
declare module "packages/com/rekindled/embers/particle/$AlchemyCircleParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$AlchemyCircleParticleOptions, $AlchemyCircleParticleOptions$Type} from "packages/com/rekindled/embers/particle/$AlchemyCircleParticleOptions"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $AlchemyCircleParticle extends $TextureSheetParticle {
 "rotScale": float
static readonly "QUAT": $Quaternionf
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $AlchemyCircleParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
public "render"(arg0: $VertexConsumer$Type, arg1: $Camera$Type, arg2: float): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyCircleParticle$Type = ($AlchemyCircleParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyCircleParticle_ = $AlchemyCircleParticle$Type;
}}
declare module "packages/com/rekindled/embers/util/$SuperHeaterLootModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootModifier, $LootModifier$Type} from "packages/net/minecraftforge/common/loot/$LootModifier"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$SmeltingRecipe, $SmeltingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$SmeltingRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"

export class $SuperHeaterLootModifier extends $LootModifier {
static readonly "CODEC": $Codec<($SuperHeaterLootModifier)>
 "cachedRecipe": $SmeltingRecipe

constructor(arg0: ($LootItemCondition$Type)[])

public "doApply"(arg0: $ObjectArrayList$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $ObjectArrayList<($ItemStack)>
public "codec"(): $Codec<($SuperHeaterLootModifier)>
public static "getJson"<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuperHeaterLootModifier$Type = ($SuperHeaterLootModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuperHeaterLootModifier_ = $SuperHeaterLootModifier$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$IInventoryEmberCell" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IInventoryEmberCell {

}

export namespace $IInventoryEmberCell {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInventoryEmberCell$Type = ($IInventoryEmberCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInventoryEmberCell_ = $IInventoryEmberCell$Type;
}}
declare module "packages/com/rekindled/embers/block/$AlchemyPedestalBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $AlchemyPedestalBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyPedestalBlock$Type = ($AlchemyPedestalBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyPedestalBlock_ = $AlchemyPedestalBlock$Type;
}}
declare module "packages/com/rekindled/embers/augment/$DiffractionBarrelAugment" {
import {$EmberProjectileEvent, $EmberProjectileEvent$Type} from "packages/com/rekindled/embers/api/event/$EmberProjectileEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $DiffractionBarrelAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onProjectileFire"(arg0: $EmberProjectileEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiffractionBarrelAugment$Type = ($DiffractionBarrelAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiffractionBarrelAugment_ = $DiffractionBarrelAugment$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemPipeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PipeBlockBase, $PipeBlockBase$Type} from "packages/com/rekindled/embers/block/$PipeBlockBase"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ItemPipeBlock extends $PipeBlockBase {
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "connected"(arg0: $Direction$Type, arg1: $BlockState$Type): boolean
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "connectToTile"(arg0: $BlockEntity$Type, arg1: $Direction$Type): boolean
public "unclog"(arg0: $BlockEntity$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getConnectionTag"(): $TagKey<($Block)>
public "getToggleConnectionTag"(): $TagKey<($Block)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "connectionTag"(): $TagKey<($Block)>
get "toggleConnectionTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeBlock$Type = ($ItemPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeBlock_ = $ItemPipeBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$ExplosionPedestalBlock" {
import {$AlchemyPedestalBlock, $AlchemyPedestalBlock$Type} from "packages/com/rekindled/embers/block/$AlchemyPedestalBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ExplosionPedestalBlock extends $AlchemyPedestalBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionPedestalBlock$Type = ($ExplosionPedestalBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionPedestalBlock_ = $ExplosionPedestalBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GemUnsocketRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GemUnsocketRecipe, $GemUnsocketRecipe$Type} from "packages/com/rekindled/embers/recipe/$GemUnsocketRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $GemUnsocketRecipe$Serializer implements $RecipeSerializer<($GemUnsocketRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $GemUnsocketRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $GemUnsocketRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $GemUnsocketRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $GemUnsocketRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemUnsocketRecipe$Serializer$Type = ($GemUnsocketRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemUnsocketRecipe$Serializer_ = $GemUnsocketRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$StampBaseBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpenTankBlockEntity, $OpenTankBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $StampBaseBlockEntity extends $OpenTankBlockEntity implements $IExtraCapabilityInformation {
 "renderOffset": float
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $StampBaseBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampBaseBlockEntity$Type = ($StampBaseBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampBaseBlockEntity_ = $StampBaseBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/item/$ITyrfingWeapon" {
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"

export interface $ITyrfingWeapon {

 "attack"(arg0: $LivingHurtEvent$Type, arg1: double): void

(arg0: $LivingHurtEvent$Type, arg1: double): void
}

export namespace $ITyrfingWeapon {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITyrfingWeapon$Type = ($ITyrfingWeapon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITyrfingWeapon_ = $ITyrfingWeapon$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$WildfireStirlingBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IGaseousFuelRecipe, $IGaseousFuelRecipe$Type} from "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$WildfireStirlingUpgrade, $WildfireStirlingUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$WildfireStirlingUpgrade"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $WildfireStirlingBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
 "activeTicks": integer
 "burnTime": integer
 "upgrade": $WildfireStirlingUpgrade
 "tank": $FluidTank
 "cachedRecipe": $IGaseousFuelRecipe
 "holder": $LazyOptional<($IFluidHandler)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "setActive"(arg0: integer): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $WildfireStirlingBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $WildfireStirlingBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
set "active"(value: integer)
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WildfireStirlingBlockEntity$Type = ($WildfireStirlingBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WildfireStirlingBlockEntity_ = $WildfireStirlingBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/util/$EmberGenUtil" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EmberGenUtil {
static "offX": integer
static "offZ": integer

constructor()

public static "getEmberDensity"(arg0: long, arg1: integer, arg2: integer): float
public static "getEmberStability"(arg0: long, arg1: integer, arg2: integer): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberGenUtil$Type = ($EmberGenUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberGenUtil_ = $EmberGenUtil$Type;
}}
declare module "packages/com/rekindled/embers/render/$EmbersRenderTypes" {
import {$RenderStateShard$OverlayStateShard, $RenderStateShard$OverlayStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$OverlayStateShard"
import {$RenderStateShard$LineStateShard, $RenderStateShard$LineStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LineStateShard"
import {$RenderStateShard$EmptyTextureStateShard, $RenderStateShard$EmptyTextureStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$EmptyTextureStateShard"
import {$RenderStateShard$LayeringStateShard, $RenderStateShard$LayeringStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LayeringStateShard"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$RenderStateShard$OutputStateShard, $RenderStateShard$OutputStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$OutputStateShard"
import {$RenderStateShard$ColorLogicStateShard, $RenderStateShard$ColorLogicStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$ColorLogicStateShard"
import {$VertexFormat$Mode, $VertexFormat$Mode$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat$Mode"
import {$RenderStateShard$ShaderStateShard, $RenderStateShard$ShaderStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$ShaderStateShard"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RenderStateShard$DepthTestStateShard, $RenderStateShard$DepthTestStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$DepthTestStateShard"
import {$DrawBuffer, $DrawBuffer$Type} from "packages/com/jozufozu/flywheel/backend/instancing/$DrawBuffer"
import {$ShaderInstance, $ShaderInstance$Type} from "packages/net/minecraft/client/renderer/$ShaderInstance"
import {$RenderStateShard$TransparencyStateShard, $RenderStateShard$TransparencyStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TransparencyStateShard"
import {$RenderStateShard$CullStateShard, $RenderStateShard$CullStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$CullStateShard"
import {$RenderStateShard$TexturingStateShard, $RenderStateShard$TexturingStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TexturingStateShard"
import {$RenderStateShard$TextureStateShard, $RenderStateShard$TextureStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TextureStateShard"
import {$RenderStateShard$LightmapStateShard, $RenderStateShard$LightmapStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LightmapStateShard"
import {$RenderStateShard$WriteMaskStateShard, $RenderStateShard$WriteMaskStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$WriteMaskStateShard"
import {$RenderType$CompositeRenderType, $RenderType$CompositeRenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType$CompositeRenderType"
import {$VertexFormat, $VertexFormat$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"

export class $EmbersRenderTypes extends $RenderType {
static "additiveShader": $ShaderInstance
static readonly "ADDITIVE_SHADER": $RenderStateShard$ShaderStateShard
static "mithrilShader": $ShaderInstance
static readonly "MITHRIL_SHADER": $RenderStateShard$ShaderStateShard
static "PARTICLE_SHEET_ADDITIVE": $ParticleRenderType
static "PARTICLE_SHEET_ADDITIVE_XRAY": $ParticleRenderType
static "PARTICLE_SHEET_TRANSLUCENT_NODEPTH": $ParticleRenderType
static readonly "FLUID": $RenderType
static readonly "PTLC_SHADER": $RenderStateShard$ShaderStateShard
static readonly "PTCN_SHADER": $RenderStateShard$ShaderStateShard
static readonly "PTC_SHADER": $RenderStateShard$ShaderStateShard
static readonly "CRYSTAL": $RenderType
static readonly "CRYSTAL_FALLBACK": $RenderType
static readonly "FIELD_CHART": $RenderType
static readonly "FIELD_CHART_FALLBACK": $RenderType
static "CRYSTAL_SEED": $Function<($ResourceLocation), ($RenderType)>
static readonly "BEAM": $RenderType
static readonly "GLOW_LINES": $RenderType
static readonly "GLOW_GUI": $RenderType
static readonly "HEAT_BAR_ENDS": $RenderType
static "GLOW_TEXT": $Function<($RenderStateShard$EmptyTextureStateShard), ($RenderType)>
static readonly "NOTE_BACKGROUND": $RenderType
static readonly "NOTE_PEDESTAL": $RenderType
static "MITHRIL_REFLECTION": $ResourceLocation
static "MITHRIL": $RenderType
static readonly "BIG_BUFFER_SIZE": integer
static readonly "MEDIUM_BUFFER_SIZE": integer
static readonly "SMALL_BUFFER_SIZE": integer
static readonly "TRANSIENT_BUFFER_SIZE": integer
static readonly "LINES": $RenderType$CompositeRenderType
static readonly "LINE_STRIP": $RenderType$CompositeRenderType
 "sortOnUpload": boolean
static readonly "VIEW_SCALE_Z_EPSILON": float
static readonly "MAX_ENCHANTMENT_GLINT_SPEED_MILLIS": double
readonly "name": string
 "setupState": $Runnable
static readonly "NO_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "ADDITIVE_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "LIGHTNING_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "GLINT_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "CRUMBLING_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "TRANSLUCENT_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "NO_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_LIGHTMAP_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_TEX_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_TEX_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_TEX_LIGHTMAP_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_SOLID_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CUTOUT_MIPPED_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_MOVING_BLOCK_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_NO_CRUMBLING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_CUTOUT_NO_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SOLID_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_Z_OFFSET_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_EMISSIVE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SMOOTH_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_BEACON_BEAM_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_DECAL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_NO_OUTLINE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SHADOW_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_ALPHA_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_EYES_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENERGY_SWIRL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LEASH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_WATER_MASK_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_OUTLINE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_ENTITY_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_DIRECT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_GLINT_DIRECT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CRUMBLING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_BACKGROUND_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_INTENSITY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_BACKGROUND_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_INTENSITY_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LIGHTNING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRIPWIRE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_END_PORTAL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_END_GATEWAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LINES_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_OVERLAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_TEXT_HIGHLIGHT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_GHOST_RECIPE_OVERLAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "BLOCK_SHEET_MIPPED": $RenderStateShard$TextureStateShard
static readonly "BLOCK_SHEET": $RenderStateShard$TextureStateShard
static readonly "NO_TEXTURE": $RenderStateShard$EmptyTextureStateShard
static readonly "DEFAULT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "GLINT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "ENTITY_GLINT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "LIGHTMAP": $RenderStateShard$LightmapStateShard
static readonly "NO_LIGHTMAP": $RenderStateShard$LightmapStateShard
static readonly "OVERLAY": $RenderStateShard$OverlayStateShard
static readonly "NO_OVERLAY": $RenderStateShard$OverlayStateShard
static readonly "CULL": $RenderStateShard$CullStateShard
static readonly "NO_CULL": $RenderStateShard$CullStateShard
static readonly "NO_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "EQUAL_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "LEQUAL_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "GREATER_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "COLOR_DEPTH_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "COLOR_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "DEPTH_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "NO_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "POLYGON_OFFSET_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "VIEW_OFFSET_Z_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "MAIN_TARGET": $RenderStateShard$OutputStateShard
static readonly "OUTLINE_TARGET": $RenderStateShard$OutputStateShard
static readonly "TRANSLUCENT_TARGET": $RenderStateShard$OutputStateShard
static readonly "PARTICLES_TARGET": $RenderStateShard$OutputStateShard
static readonly "WEATHER_TARGET": $RenderStateShard$OutputStateShard
static readonly "CLOUDS_TARGET": $RenderStateShard$OutputStateShard
static readonly "ITEM_ENTITY_TARGET": $RenderStateShard$OutputStateShard
static readonly "DEFAULT_LINE": $RenderStateShard$LineStateShard
static readonly "NO_COLOR_LOGIC": $RenderStateShard$ColorLogicStateShard
static readonly "OR_REVERSE_COLOR_LOGIC": $RenderStateShard$ColorLogicStateShard

constructor(arg0: string, arg1: $VertexFormat$Type, arg2: $VertexFormat$Mode$Type, arg3: integer, arg4: boolean, arg5: boolean, arg6: $Runnable$Type, arg7: $Runnable$Type)

public static "getNote"(arg0: $ResourceLocation$Type): $RenderType
public static "getDrawBuffer"(arg0: $RenderType$Type): $DrawBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersRenderTypes$Type = ($EmbersRenderTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersRenderTypes_ = $EmbersRenderTypes$Type;
}}
declare module "packages/com/rekindled/embers/block/$GeologicSeparatorBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $GeologicSeparatorBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeologicSeparatorBlock$Type = ($GeologicSeparatorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeologicSeparatorBlock_ = $GeologicSeparatorBlock$Type;
}}
declare module "packages/com/rekindled/embers/research/subtypes/$ResearchFakePage" {
import {$GuiCodex, $GuiCodex$Type} from "packages/com/rekindled/embers/gui/$GuiCodex"
import {$Vec2i, $Vec2i$Type} from "packages/com/rekindled/embers/util/$Vec2i"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResearchBase, $ResearchBase$Type} from "packages/com/rekindled/embers/research/$ResearchBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ResearchFakePage extends $ResearchBase {
 "name": string
 "u": double
 "v": double
 "icon": $ItemStack
 "x": integer
 "y": integer
 "ancestors": $List<($ResearchBase)>
 "subCategory": $ResearchBase
 "iconBackground": $ResourceLocation
 "background": $ResourceLocation
 "firstPage": $ResearchBase
 "pageNumber": integer
 "selectedAmount": float
 "selectionTarget": float
 "shownAmount": float
 "shownTarget": float
 "checked": boolean

constructor(arg0: $ResearchBase$Type, arg1: double, arg2: double)
constructor(arg0: $ResearchBase$Type, arg1: $Vec2i$Type)

public "getName"(): string
public "getIcon"(): $ItemStack
public "getIconBackground"(): $ResourceLocation
public "getIconBackgroundV"(): double
public "getIconBackgroundU"(): double
public "onOpen"(arg0: $GuiCodex$Type): boolean
public "getTitle"(): string
get "name"(): string
get "icon"(): $ItemStack
get "iconBackground"(): $ResourceLocation
get "iconBackgroundV"(): double
get "iconBackgroundU"(): double
get "title"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchFakePage$Type = ($ResearchFakePage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchFakePage_ = $ResearchFakePage$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MelterTopBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MelterTopBlockEntity, $MelterTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MelterTopBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MelterTopBlockEntityRenderer implements $BlockEntityRenderer<($MelterTopBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MelterTopBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MelterTopBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MelterTopBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MelterTopBlockEntityRenderer$Type = ($MelterTopBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MelterTopBlockEntityRenderer_ = $MelterTopBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IExtraDialInformation" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"

export interface $IExtraDialInformation {

 "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
 "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer

(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
}

export namespace $IExtraDialInformation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtraDialInformation$Type = ($IExtraDialInformation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtraDialInformation_ = $IExtraDialInformation$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$ProjectileRay" {
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ProjectileRay implements $IProjectilePreset {

constructor(arg0: $Entity$Type, arg1: $Vec3$Type, arg2: $Vec3$Type, arg3: boolean, arg4: $IProjectileEffect$Type)

public "setColor"(arg0: $Color$Type): void
public "shoot"(arg0: $Level$Type): void
public "setPos"(arg0: $Vec3$Type): void
public "getVelocity"(): $Vec3
public "setPierceEntities"(arg0: boolean): void
public "setVelocity"(arg0: $Vec3$Type): void
public "setEffect"(arg0: $IProjectileEffect$Type): void
public "getEntity"(): $Entity
public "getColor"(): $Color
public "getShooter"(): $Entity
public "getPos"(): $Vec3
public "getEffect"(): $IProjectileEffect
public "canPierceEntities"(): boolean
set "color"(value: $Color$Type)
set "pos"(value: $Vec3$Type)
get "velocity"(): $Vec3
set "pierceEntities"(value: boolean)
set "velocity"(value: $Vec3$Type)
set "effect"(value: $IProjectileEffect$Type)
get "entity"(): $Entity
get "color"(): $Color
get "shooter"(): $Entity
get "pos"(): $Vec3
get "effect"(): $IProjectileEffect
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProjectileRay$Type = ($ProjectileRay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProjectileRay_ = $ProjectileRay$Type;
}}
declare module "packages/com/rekindled/embers/apiimpl/$EmbersAPIImpl" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IEmbersAPI, $IEmbersAPI$Type} from "packages/com/rekindled/embers/api/$IEmbersAPI"

export class $EmbersAPIImpl implements $IEmbersAPI {

constructor()

public static "init"(): void
public "registerWearableLens"(arg0: $Ingredient$Type): void
public "registerHammerTargetGetter"(arg0: $Item$Type): void
public "registerHammerTargetGetter"(arg0: $Function$Type<($Player$Type), ($Pair$Type<($BlockPos$Type), ($Direction$Type)>)>): void
public "getEmberCapacityTotal"(arg0: $Player$Type): double
public "registerEmberResonance"(arg0: $Ingredient$Type, arg1: double): void
public "registerLinkingHammer"(arg0: $BiPredicate$Type<($Player$Type), ($InteractionHand$Type)>): void
public "registerLinkingHammer"(arg0: $Item$Type): void
public "getHammerTarget"(arg0: $Player$Type): $Pair<($BlockPos), ($Direction)>
public "getEmberDensity"(arg0: long, arg1: integer, arg2: integer): float
public "isHoldingHammer"(arg0: $Player$Type, arg1: $InteractionHand$Type): boolean
public "getEmberStability"(arg0: long, arg1: integer, arg2: integer): float
public "registerLens"(arg0: $Ingredient$Type): void
public "registerLens"(arg0: $Predicate$Type<($Player$Type)>): void
public "isWearingLens"(arg0: $Player$Type): boolean
public "setScales"(arg0: $LivingEntity$Type, arg1: double): void
public "getScales"(arg0: $LivingEntity$Type): double
public "getEmberTotal"(arg0: $Player$Type): double
public "getTaggedItem"(arg0: $TagKey$Type<($Item$Type)>): $Item
public "removeEmber"(arg0: $Player$Type, arg1: double): void
public "getEmberResonance"(arg0: $ItemStack$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersAPIImpl$Type = ($EmbersAPIImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersAPIImpl_ = $EmbersAPIImpl$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IExtraCapabilityInformation {

 "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
 "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
 "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
}

export namespace $IExtraCapabilityInformation {
function formatCapability(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtraCapabilityInformation$Type = ($IExtraCapabilityInformation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtraCapabilityInformation_ = $IExtraCapabilityInformation$Type;
}}
declare module "packages/com/rekindled/embers/block/$CinderPlinthBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CinderPlinthBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CinderPlinthBlock$Type = ($CinderPlinthBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CinderPlinthBlock_ = $CinderPlinthBlock$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersBlockLootTables" {
import {$BlockLootSubProvider, $BlockLootSubProvider$Type} from "packages/net/minecraft/data/loot/$BlockLootSubProvider"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"

export class $EmbersBlockLootTables extends $BlockLootSubProvider {

constructor()

public "decoDrops"(arg0: $RegistryManager$StoneDecoBlocks$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersBlockLootTables$Type = ($EmbersBlockLootTables);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersBlockLootTables_ = $EmbersBlockLootTables$Type;
}}
declare module "packages/com/rekindled/embers/render/$PipeModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $PipeModel implements $IUnbakedGeometry<($PipeModel)> {

constructor(arg0: $BlockModel$Type, arg1: $BlockModel$Type, arg2: $BlockModel$Type, arg3: $BlockModel$Type, arg4: $BlockModel$Type)

public static "getRotatedModels"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ResourceLocation$Type, arg4: $BlockModel$Type, arg5: $BlockModel$Type): ($BakedModel)[]
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeModel$Type = ($PipeModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeModel_ = $PipeModel$Type;
}}
declare module "packages/com/rekindled/embers/item/$ClockworkPickaxeItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ClockworkToolItem, $ClockworkToolItem$Type} from "packages/com/rekindled/embers/item/$ClockworkToolItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ClockworkPickaxeItem extends $ClockworkToolItem {
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "canPerformAction"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
public "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkPickaxeItem$Type = ($ClockworkPickaxeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClockworkPickaxeItem_ = $ClockworkPickaxeItem$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$CatalysisCombustionCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $CatalysisCombustionCategory implements $IRecipeCategory<($ICatalysisCombustionRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($ICatalysisCombustionRecipe)>
public "draw"(arg0: $ICatalysisCombustionRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $ICatalysisCombustionRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $ICatalysisCombustionRecipe$Type): boolean
public "handleInput"(arg0: $ICatalysisCombustionRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $ICatalysisCombustionRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $ICatalysisCombustionRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($ICatalysisCombustionRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisCombustionCategory$Type = ($CatalysisCombustionCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisCombustionCategory_ = $CatalysisCombustionCategory$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$ItemTransferBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ItemTransferBlockEntity, $ItemTransferBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ItemTransferBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $ItemTransferBlockEntityRenderer implements $BlockEntityRenderer<($ItemTransferBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $ItemTransferBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $ItemTransferBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $ItemTransferBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransferBlockEntityRenderer$Type = ($ItemTransferBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransferBlockEntityRenderer_ = $ItemTransferBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AugmentIngredient" {
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AugmentIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(arg0: $Ingredient$Type, arg1: $IAugment$Type, arg2: integer, arg3: boolean)

public "test"(arg0: $ItemStack$Type): boolean
public static "of"(arg0: $Ingredient$Type, arg1: $IAugment$Type, arg2: integer, arg3: boolean): $AugmentIngredient
public static "of"(arg0: $Ingredient$Type, arg1: $IAugment$Type, arg2: boolean): $AugmentIngredient
public static "of"(arg0: $Ingredient$Type, arg1: $IAugment$Type): $AugmentIngredient
public static "of"(arg0: $Ingredient$Type, arg1: $IAugment$Type, arg2: integer): $AugmentIngredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getStackingIds"(): $IntList
public "isEmpty"(): boolean
public "getSerializer"(): $IIngredientSerializer<($AugmentIngredient)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "stackingIds"(): $IntList
get "empty"(): boolean
get "serializer"(): $IIngredientSerializer<($AugmentIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AugmentIngredient$Type = ($AugmentIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AugmentIngredient_ = $AugmentIngredient$Type;
}}
declare module "packages/com/rekindled/embers/item/$CaminiteRingBlockItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CaminiteRingBlockItem extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type, arg1: $Item$Properties$Type)

public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaminiteRingBlockItem$Type = ($CaminiteRingBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CaminiteRingBlockItem_ = $CaminiteRingBlockItem$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$CatalysisCombustionContext" {
import {$RecipeWrapper, $RecipeWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RecipeWrapper"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"

export class $CatalysisCombustionContext extends $RecipeWrapper {
 "machine": $ItemStack

constructor(arg0: $IItemHandlerModifiable$Type, arg1: $ItemStack$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatalysisCombustionContext$Type = ($CatalysisCombustionContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatalysisCombustionContext_ = $CatalysisCombustionContext$Type;
}}
declare module "packages/com/rekindled/embers/block/$EntropicEnumeratorBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EntropicEnumeratorBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "CUBE_AABB": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorBlock$Type = ($EntropicEnumeratorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorBlock_ = $EntropicEnumeratorBlock$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageWorldSeed" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageWorldSeed {

constructor(arg0: long)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageWorldSeed
public static "encode"(arg0: $MessageWorldSeed$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageWorldSeed$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageWorldSeed$Type = ($MessageWorldSeed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageWorldSeed_ = $MessageWorldSeed$Type;
}}
declare module "packages/com/rekindled/embers/block/$StampBaseBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $StampBaseBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampBaseBlock$Type = ($StampBaseBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampBaseBlock_ = $StampBaseBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$MixingRecipeBuilder" {
import {$MixingRecipe, $MixingRecipe$Type} from "packages/com/rekindled/embers/recipe/$MixingRecipe"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $MixingRecipeBuilder {
 "id": $ResourceLocation
 "inputs": $ArrayList<($FluidIngredient)>
 "output": $FluidStack

constructor()

public "id"(arg0: $ResourceLocation$Type): $MixingRecipeBuilder
public "domain"(arg0: string): $MixingRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $Fluid$Type, arg1: integer): $MixingRecipeBuilder
public static "create"(arg0: $FluidStack$Type): $MixingRecipeBuilder
public "input"(arg0: $TagKey$Type<($Fluid$Type)>, arg1: integer): $MixingRecipeBuilder
public "input"(...arg0: ($FluidIngredient$Type)[]): $MixingRecipeBuilder
public "input"(arg0: $Fluid$Type, arg1: integer): $MixingRecipeBuilder
public "input"(arg0: $FluidStack$Type): $MixingRecipeBuilder
public "input"(arg0: $FluidIngredient$Type): $MixingRecipeBuilder
public "build"(): $MixingRecipe
public "output"(arg0: $Fluid$Type, arg1: integer): $MixingRecipeBuilder
public "output"(arg0: $FluidStack$Type): $MixingRecipeBuilder
public "folder"(arg0: string): $MixingRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixingRecipeBuilder$Type = ($MixingRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixingRecipeBuilder_ = $MixingRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/particle/$XRayGlowParticle" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$XRayGlowParticleOptions, $XRayGlowParticleOptions$Type} from "packages/com/rekindled/embers/particle/$XRayGlowParticleOptions"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $XRayGlowParticle extends $TextureSheetParticle {
 "rBase": float
 "gBase": float
 "bBase": float
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float

constructor(arg0: $ClientLevel$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $XRayGlowParticleOptions$Type)

public "getQuadSize"(arg0: float): float
public "getRenderType"(): $ParticleRenderType
public "tick"(): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XRayGlowParticle$Type = ($XRayGlowParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $XRayGlowParticle_ = $XRayGlowParticle$Type;
}}
declare module "packages/com/rekindled/embers/api/upgrades/$UpgradeUtil" {
import {$IUpgradeUtil, $IUpgradeUtil$Type} from "packages/com/rekindled/embers/api/upgrades/$IUpgradeUtil"
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $UpgradeUtil {
static "IMPL": $IUpgradeUtil

constructor()

public static "getTotalEmberConsumption"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
public static "getTotalEmberProduction"(arg0: $BlockEntity$Type, arg1: double, arg2: $List$Type<($UpgradeContext$Type)>): double
public static "getTotalSpeedModifier"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): double
public static "doWork"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
public static "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>, arg4: integer): void
public static "collectUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $List$Type<($UpgradeContext$Type)>): void
public static "verifyUpgrades"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): void
public static "doTick"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>): boolean
public static "getWorkTime"(arg0: $BlockEntity$Type, arg1: integer, arg2: $List$Type<($UpgradeContext$Type)>): integer
public static "throwEvent"(arg0: $BlockEntity$Type, arg1: $UpgradeEvent$Type, arg2: $List$Type<($UpgradeContext$Type)>): void
public static "transformOutput"(arg0: $BlockEntity$Type, arg1: $FluidStack$Type, arg2: $List$Type<($UpgradeContext$Type)>): $FluidStack
public static "transformOutput"(arg0: $BlockEntity$Type, arg1: $List$Type<($ItemStack$Type)>, arg2: $List$Type<($UpgradeContext$Type)>): void
public static "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: integer, arg3: $List$Type<($UpgradeContext$Type)>): integer
public static "getOtherParameter"<T>(arg0: $BlockEntity$Type, arg1: string, arg2: T, arg3: $List$Type<($UpgradeContext$Type)>): T
public static "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: string, arg3: $List$Type<($UpgradeContext$Type)>): string
public static "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: boolean, arg3: $List$Type<($UpgradeContext$Type)>): boolean
public static "getOtherParameter"(arg0: $BlockEntity$Type, arg1: string, arg2: double, arg3: $List$Type<($UpgradeContext$Type)>): double
public static "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[], arg3: $List$Type<($UpgradeContext$Type)>): void
public static "getUpgrades"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: ($Direction$Type)[]): $List<($UpgradeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeUtil$Type = ($UpgradeUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeUtil_ = $UpgradeUtil$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$IngotTooltipCallback" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeSlotTooltipCallback, $IRecipeSlotTooltipCallback$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotTooltipCallback"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IRecipeSlotView, $IRecipeSlotView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotView"

export class $IngotTooltipCallback implements $IRecipeSlotTooltipCallback {
static "INSTANCE": $IngotTooltipCallback

constructor()

public "onTooltip"(arg0: $IRecipeSlotView$Type, arg1: $List$Type<($Component$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngotTooltipCallback$Type = ($IngotTooltipCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngotTooltipCallback_ = $IngotTooltipCallback$Type;
}}
declare module "packages/com/rekindled/embers/block/$FluidPipeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PipeBlockBase, $PipeBlockBase$Type} from "packages/com/rekindled/embers/block/$PipeBlockBase"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidPipeBlock extends $PipeBlockBase {
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "connected"(arg0: $Direction$Type, arg1: $BlockState$Type): boolean
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "connectToTile"(arg0: $BlockEntity$Type, arg1: $Direction$Type): boolean
public "unclog"(arg0: $BlockEntity$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getConnectionTag"(): $TagKey<($Block)>
public "getToggleConnectionTag"(): $TagKey<($Block)>
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
get "connectionTag"(): $TagKey<($Block)>
get "toggleConnectionTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlock$Type = ($FluidPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeBlock_ = $FluidPipeBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/misc/$AlchemyResult" {
import {$IAlchemyRecipe$PedestalContents, $IAlchemyRecipe$PedestalContents$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe$PedestalContents"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AlchemyResult {
 "contents": $List<($IAlchemyRecipe$PedestalContents)>
 "result": $ItemStack
 "blackPins": integer
 "whitePins": integer

constructor(arg0: $List$Type<($IAlchemyRecipe$PedestalContents$Type)>, arg1: $ItemStack$Type, arg2: integer, arg3: integer)

public "createResultStack"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyResult$Type = ($AlchemyResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyResult_ = $AlchemyResult$Type;
}}
declare module "packages/com/rekindled/embers/api/power/$IEmberCapability" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilitySerializable, $ICapabilitySerializable$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilitySerializable"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IEmberCapability extends $ICapabilitySerializable<($CompoundTag)> {

 "invalidate"(): void
 "getEmber"(): double
 "getEmberCapacity"(): double
 "setEmber"(arg0: double): void
 "onContentsChanged"(): void
 "removeAmount"(arg0: double, arg1: boolean): double
 "acceptsVolatile"(): boolean
 "addAmount"(arg0: double, arg1: boolean): double
 "setEmberCapacity"(arg0: double): void
 "writeToNBT"(arg0: $CompoundTag$Type): void
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
 "deserializeNBT"(arg0: $CompoundTag$Type): void
 "serializeNBT"(): $CompoundTag
}

export namespace $IEmberCapability {
const EMBER_CAPACITY: string
const EMBER: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEmberCapability$Type = ($IEmberCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEmberCapability_ = $IEmberCapability$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberSiphonBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EmberSiphonBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberSiphonBlock$Type = ($EmberSiphonBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberSiphonBlock_ = $EmberSiphonBlock$Type;
}}
declare module "packages/com/rekindled/embers/util/$HeatBarTooltip" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"

export class $HeatBarTooltip implements $TooltipComponent {
 "normalText": $FormattedCharSequence
 "heat": float
 "maxHeat": float
 "barWidth": integer

constructor(arg0: $FormattedCharSequence$Type, arg1: float, arg2: float, arg3: integer)
constructor(arg0: $FormattedCharSequence$Type, arg1: float, arg2: float)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatBarTooltip$Type = ($HeatBarTooltip);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatBarTooltip_ = $HeatBarTooltip$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MiniBoilerBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$PipeBlockEntityBase, $PipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBoilingRecipe, $IBoilingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoilingRecipe"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $MiniBoilerBlockEntity extends $PipeBlockEntityBase implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "SOUND_SLOW": integer
static readonly "SOUND_MEDIUM": integer
static readonly "SOUND_FAST": integer
static readonly "SOUND_PRESSURE_LOW": integer
static readonly "SOUND_PRESSURE_MEDIUM": integer
static readonly "SOUND_PRESSURE_HIGH": integer
static readonly "SOUND_IDS": (integer)[]
 "fluidHolder": $LazyOptional<($IFluidHandler)>
 "gasHolder": $LazyOptional<($IFluidHandler)>
 "cachedRecipe": $IBoilingRecipe
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MiniBoilerBlockEntity$Type): void
public "spawnParticles"(): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getFluidStack"(): $FluidStack
public "getFluidAmount"(): integer
public "getFluidTank"(): $FluidTank
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MiniBoilerBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getFluid"(): $Fluid
public "initConnections"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public "boil"(arg0: double): void
public "getGas"(): $Fluid
public "getGasStack"(): $FluidStack
public "getGasTank"(): $FluidTank
public "getGasAmount"(): integer
public "explode"(): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "handleSound"(): void
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "soundIDs"(): (integer)[]
get "fluidStack"(): $FluidStack
get "fluidAmount"(): integer
get "fluidTank"(): $FluidTank
get "fluid"(): $Fluid
get "gas"(): $Fluid
get "gasStack"(): $FluidStack
get "gasTank"(): $FluidTank
get "gasAmount"(): integer
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiniBoilerBlockEntity$Type = ($MiniBoilerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiniBoilerBlockEntity_ = $MiniBoilerBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageBeamCannonFX" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $MessageBeamCannonFX {
static "random": $Random

constructor()
constructor(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: integer)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageBeamCannonFX
public static "encode"(arg0: $MessageBeamCannonFX$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageBeamCannonFX$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
public static "spawnParticles"(arg0: $MessageBeamCannonFX$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageBeamCannonFX$Type = ($MessageBeamCannonFX);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageBeamCannonFX_ = $MessageBeamCannonFX$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$HeatExchangerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$HeatExchangerUpgrade, $HeatExchangerUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$HeatExchangerUpgrade"

export class $HeatExchangerBlockEntity extends $BlockEntity {
 "upgrade": $HeatExchangerUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatExchangerBlockEntity$Type = ($HeatExchangerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatExchangerBlockEntity_ = $HeatExchangerBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/$EmbersEvents" {
import {$EmberProjectileEvent, $EmberProjectileEvent$Type} from "packages/com/rekindled/embers/api/event/$EmberProjectileEvent"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$BlockEvent$BreakEvent, $BlockEvent$BreakEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent$BreakEvent"
import {$MissingMappingsEvent, $MissingMappingsEvent$Type} from "packages/net/minecraftforge/registries/$MissingMappingsEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LevelEvent$Load, $LevelEvent$Load$Type} from "packages/net/minecraftforge/event/level/$LevelEvent$Load"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ArrowLooseEvent, $ArrowLooseEvent$Type} from "packages/net/minecraftforge/event/entity/player/$ArrowLooseEvent"
import {$AnvilUpdateEvent, $AnvilUpdateEvent$Type} from "packages/net/minecraftforge/event/$AnvilUpdateEvent"
import {$EntityJoinLevelEvent, $EntityJoinLevelEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityJoinLevelEvent"
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$ExplosionEvent$Start, $ExplosionEvent$Start$Type} from "packages/net/minecraftforge/event/level/$ExplosionEvent$Start"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TickEvent$LevelTickEvent, $TickEvent$LevelTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$LevelTickEvent"
import {$ExplosionCharmWorldInfo, $ExplosionCharmWorldInfo$Type} from "packages/com/rekindled/embers/util/$ExplosionCharmWorldInfo"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EmbersEvents {
static "explosionCharmData": $HashMap<($ResourceLocation), ($ExplosionCharmWorldInfo)>

constructor()

public static "onAnvilUpdate"(arg0: $AnvilUpdateEvent$Type): void
public static "onServerTick"(arg0: $TickEvent$LevelTickEvent$Type): void
public static "onBlockBreak"(arg0: $BlockEvent$BreakEvent$Type): void
public static "onEntityDamaged"(arg0: $LivingHurtEvent$Type): void
public static "fixMappings"(arg0: $MissingMappingsEvent$Type): void
public static "onJoin"(arg0: $EntityJoinLevelEvent$Type): void
public static "onProjectileFired"(arg0: $EmberProjectileEvent$Type): void
public static "onExplosion"(arg0: $ExplosionEvent$Start$Type): void
public static "onLevelLoad"(arg0: $LevelEvent$Load$Type): void
public static "attuneInflictorGem"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $ItemStack$Type): void
public static "getInflictorGemResistance"(arg0: $LivingHurtEvent$Type, arg1: $ItemStack$Type): float
public static "addHeat"(arg0: $Entity$Type, arg1: $ItemStack$Type, arg2: float): void
public static "putExplosionCharm"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public static "onArrowLoose"(arg0: $ArrowLooseEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersEvents$Type = ($EmbersEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersEvents_ = $EmbersEvents$Type;
}}
declare module "packages/com/rekindled/embers/render/$FluidRenderer" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$FluidCuboid, $FluidCuboid$Type} from "packages/com/rekindled/embers/render/$FluidCuboid"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $FluidRenderer {

constructor()

public static "renderScaledCuboid"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: $FluidCuboid$Type, arg3: $FluidStack$Type, arg4: float, arg5: integer, arg6: integer, arg7: integer, arg8: boolean): void
public static "putTexturedQuad"(arg0: $VertexConsumer$Type, arg1: $PoseStack$Type, arg2: $TextureAtlasSprite$Type, arg3: $Vector3f$Type, arg4: $Vector3f$Type, arg5: $Direction$Type, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: boolean): void
public static "withBlockLight"(arg0: integer, arg1: integer): integer
public static "getBlockSprite"(arg0: $ResourceLocation$Type): $TextureAtlasSprite
public static "renderCuboids"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: $List$Type<($FluidCuboid$Type)>, arg3: $FluidStack$Type, arg4: integer, arg5: integer): void
public static "renderCuboid"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: $FluidCuboid$Type, arg3: float, arg4: $TextureAtlasSprite$Type, arg5: $TextureAtlasSprite$Type, arg6: integer, arg7: integer, arg8: integer, arg9: boolean): void
public static "renderCuboid"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: $FluidCuboid$Type, arg3: $TextureAtlasSprite$Type, arg4: $TextureAtlasSprite$Type, arg5: $Vector3f$Type, arg6: $Vector3f$Type, arg7: integer, arg8: integer, arg9: integer, arg10: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidRenderer$Type = ($FluidRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidRenderer_ = $FluidRenderer$Type;
}}
declare module "packages/com/rekindled/embers/block/$InfernoForgeEdgeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MechEdgeBlockBase, $MechEdgeBlockBase$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MechEdgeBlockBase$MechEdge, $MechEdgeBlockBase$MechEdge$Type} from "packages/com/rekindled/embers/block/$MechEdgeBlockBase$MechEdge"

export class $InfernoForgeEdgeBlock extends $MechEdgeBlockBase {
static readonly "NORTH_AABB": $VoxelShape
static readonly "NORTHEAST_AABB": $VoxelShape
static readonly "EAST_AABB": $VoxelShape
static readonly "SOUTHEAST_AABB": $VoxelShape
static readonly "SOUTH_AABB": $VoxelShape
static readonly "SOUTHWEST_AABB": $VoxelShape
static readonly "WEST_AABB": $VoxelShape
static readonly "NORTHWEST_AABB": $VoxelShape
static readonly "SHAPES_TOP": ($VoxelShape)[]
static readonly "CORNER_CENTER_AABB": $VoxelShape
static readonly "NORTHEAST_BOTTOM_AABB": $VoxelShape
static readonly "SOUTHEAST_BOTTOM_AABB": $VoxelShape
static readonly "SOUTHWEST_BOTTOM_AABB": $VoxelShape
static readonly "NORTHWEST_BOTTOM_AABB": $VoxelShape
static readonly "SHAPES_BOTTOM": ($VoxelShape)[]
static readonly "EDGE": $EnumProperty<($MechEdgeBlockBase$MechEdge)>
static readonly "TOP_AABB": $VoxelShape
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getCenterBlock"(): $Block
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
get "centerBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfernoForgeEdgeBlock$Type = ($InfernoForgeEdgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfernoForgeEdgeBlock_ = $InfernoForgeEdgeBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IStampingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeWrapper, $RecipeWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RecipeWrapper"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$StampingContext, $StampingContext$Type} from "packages/com/rekindled/embers/recipe/$StampingContext"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IStampingRecipe extends $Recipe<($StampingContext)> {

 "getResultItem"(): $ItemStack
 "getDisplayInput"(): $Ingredient
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getDisplayStamp"(): $Ingredient
 "getDisplayInputFluid"(): $FluidIngredient
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getOutput"(arg0: $RecipeWrapper$Type): $ItemStack
 "getRemainingItems"(arg0: $StampingContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "assemble"(arg0: $StampingContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getId"(): $ResourceLocation
 "matches"(arg0: $StampingContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IStampingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStampingRecipe$Type = ($IStampingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStampingRecipe_ = $IStampingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/block/$PipeBlockBase" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $PipeBlockBase extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "CENTER_AABB": $VoxelShape
static readonly "PIPE_DOWN_AABB": $VoxelShape
static readonly "END_DOWN_AABB": $VoxelShape
static readonly "PIPE_UP_AABB": $VoxelShape
static readonly "END_UP_AABB": $VoxelShape
static readonly "PIPE_NORTH_AABB": $VoxelShape
static readonly "END_NORTH_AABB": $VoxelShape
static readonly "PIPE_SOUTH_AABB": $VoxelShape
static readonly "END_SOUTH_AABB": $VoxelShape
static readonly "PIPE_WEST_AABB": $VoxelShape
static readonly "END_WEST_AABB": $VoxelShape
static readonly "PIPE_EAST_AABB": $VoxelShape
static readonly "END_EAST_AABB": $VoxelShape
static readonly "PIPE_AABBS": ($VoxelShape)[]
static readonly "END_AABBS": ($VoxelShape)[]
static readonly "SHAPES": ($VoxelShape)[]
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "connected"(arg0: $Direction$Type, arg1: $BlockState$Type): boolean
public "connectToTile"(arg0: $BlockEntity$Type, arg1: $Direction$Type): boolean
public "getCenterShape"(): $VoxelShape
public "unclog"(arg0: $BlockEntity$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getConnectionTag"(): $TagKey<($Block)>
public static "facingConnected"(arg0: $Direction$Type, arg1: $BlockState$Type, arg2: $DirectionProperty$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public static "getShapeIndex"(arg0: $PipeBlockEntityBase$PipeConnection$Type, arg1: $PipeBlockEntityBase$PipeConnection$Type, arg2: $PipeBlockEntityBase$PipeConnection$Type, arg3: $PipeBlockEntityBase$PipeConnection$Type, arg4: $PipeBlockEntityBase$PipeConnection$Type, arg5: $PipeBlockEntityBase$PipeConnection$Type): integer
public static "makeShapes"(arg0: $VoxelShape$Type, arg1: ($VoxelShape$Type)[]): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getToggleConnectionTag"(): $TagKey<($Block)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "centerShape"(): $VoxelShape
get "connectionTag"(): $TagKey<($Block)>
get "toggleConnectionTag"(): $TagKey<($Block)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockBase$Type = ($PipeBlockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockBase_ = $PipeBlockBase$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IMetalCoefficientRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockStateContext, $BlockStateContext$Type} from "packages/com/rekindled/embers/recipe/$BlockStateContext"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IMetalCoefficientRecipe extends $Recipe<($BlockStateContext)> {

 "getDisplayInput"(): $List<($ItemStack)>
 "getCoefficient"(arg0: $BlockStateContext$Type): double
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getDisplayCoefficient"(): double
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $BlockStateContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getRemainingItems"(arg0: $BlockStateContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $BlockStateContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IMetalCoefficientRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMetalCoefficientRecipe$Type = ($IMetalCoefficientRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMetalCoefficientRecipe_ = $IMetalCoefficientRecipe$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$GenericRecipeBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $GenericRecipeBuilder {
 "recipe": $Recipe<(any)>

constructor()

public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $Recipe$Type<(any)>): $GenericRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericRecipeBuilder$Type = ($GenericRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericRecipeBuilder_ = $GenericRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/item/$NonbeleiverAmuletItem" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmbersCurioItem, $IEmbersCurioItem$Type} from "packages/com/rekindled/embers/item/$IEmbersCurioItem"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ICurio$SoundInfo, $ICurio$SoundInfo$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$SoundInfo"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotContext, $SlotContext$Type} from "packages/top/theillusivec4/curios/api/$SlotContext"
import {$ICurio$DropRule, $ICurio$DropRule$Type} from "packages/top/theillusivec4/curios/api/type/capability/$ICurio$DropRule"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NonbeleiverAmuletItem extends $Item implements $IEmbersCurioItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "onDamage"(arg0: $LivingDamageEvent$Type): void
public "onEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "canEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "getEquipSound"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $ICurio$SoundInfo
public "onUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): void
public "unequipSound"(): $SoundEvent
public "playEquipSound"(arg0: $SlotContext$Type, arg1: boolean): void
public "equipSound"(): $SoundEvent
/**
 * 
 * @deprecated
 */
public "onEquip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "getAttributesTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "showAttributesTooltip"(arg0: string, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "playRightClickEquipSound"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): void
public "makesPiglinsNeutral"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getAttributeModifiers"(arg0: string, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getAttributeModifiers"(arg0: $SlotContext$Type, arg1: $UUID$Type, arg2: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "hasCurioCapability"(arg0: $ItemStack$Type): boolean
public "curioTick"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioTick"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "canUnequip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canUnequip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "curioBreak"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "curioBreak"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): void
/**
 * 
 * @deprecated
 */
public "getDropRule"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type): $ICurio$DropRule
public "getDropRule"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: integer, arg3: boolean, arg4: $ItemStack$Type): $ICurio$DropRule
/**
 * 
 * @deprecated
 */
public "getFortuneBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
/**
 * 
 * @deprecated
 */
public "getLootingBonus"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): integer
public "onEquipFromUse"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): void
public "getSlotsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "readSyncData"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "readSyncData"(arg0: $SlotContext$Type, arg1: $CompoundTag$Type, arg2: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "onUnequip"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
/**
 * 
 * @deprecated
 */
public "canRightClickEquip"(arg0: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "getTagsTooltip"(arg0: $List$Type<($Component$Type)>, arg1: $ItemStack$Type): $List<($Component)>
/**
 * 
 * @deprecated
 */
public "curioAnimate"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): void
public "writeSyncData"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "writeSyncData"(arg0: $ItemStack$Type): $CompoundTag
public "canSync"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
/**
 * 
 * @deprecated
 */
public "canSync"(arg0: string, arg1: integer, arg2: $LivingEntity$Type, arg3: $ItemStack$Type): boolean
public "getLootingLevel"(arg0: $SlotContext$Type, arg1: $DamageSource$Type, arg2: $LivingEntity$Type, arg3: integer, arg4: $ItemStack$Type): integer
/**
 * 
 * @deprecated
 */
public "canEquip"(arg0: string, arg1: $LivingEntity$Type, arg2: $ItemStack$Type): boolean
public "canEquip"(arg0: $SlotContext$Type, arg1: $ItemStack$Type): boolean
public "isEnderMask"(arg0: $SlotContext$Type, arg1: $EnderMan$Type, arg2: $ItemStack$Type): boolean
public "getFortuneLevel"(arg0: $SlotContext$Type, arg1: $LootContext$Type, arg2: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonbeleiverAmuletItem$Type = ($NonbeleiverAmuletItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonbeleiverAmuletItem_ = $NonbeleiverAmuletItem$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$FieldChartBlockEntityRenderer" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$FieldChartBlockEntity, $FieldChartBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FieldChartBlockEntity"
import {$FieldChartBlockEntityRenderer$IChartSource, $FieldChartBlockEntityRenderer$IChartSource$Type} from "packages/com/rekindled/embers/blockentity/render/$FieldChartBlockEntityRenderer$IChartSource"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $FieldChartBlockEntityRenderer implements $BlockEntityRenderer<($FieldChartBlockEntity)> {
static "baseHeight": float
static "height": float

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $FieldChartBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "renderChart"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: float, arg3: float, arg4: float, arg5: $VertexConsumer$Type, arg6: $Matrix4f$Type, arg7: $FieldChartBlockEntityRenderer$IChartSource$Type, arg8: $Color$Type, arg9: $Color$Type, arg10: $Color$Type): void
public "shouldRender"(arg0: $FieldChartBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $FieldChartBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldChartBlockEntityRenderer$Type = ($FieldChartBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldChartBlockEntityRenderer_ = $FieldChartBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$ExcavationBucketsBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ExcavationBucketsBlockEntity, $ExcavationBucketsBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$ExcavationBucketsBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $ExcavationBucketsBlockEntityRenderer implements $BlockEntityRenderer<($ExcavationBucketsBlockEntity)> {
static "wheel": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $ExcavationBucketsBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $ExcavationBucketsBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $ExcavationBucketsBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationBucketsBlockEntityRenderer$Type = ($ExcavationBucketsBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationBucketsBlockEntityRenderer_ = $ExcavationBucketsBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MnemonicInscriberBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$MnemonicInscriberUpgrade, $MnemonicInscriberUpgrade$Type} from "packages/com/rekindled/embers/upgrade/$MnemonicInscriberUpgrade"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MnemonicInscriberBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "upgrade": $MnemonicInscriberUpgrade
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MnemonicInscriberBlockEntity$Type = ($MnemonicInscriberBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MnemonicInscriberBlockEntity_ = $MnemonicInscriberBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/item/$TyrfingItem" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ITyrfingWeapon, $ITyrfingWeapon$Type} from "packages/com/rekindled/embers/api/item/$ITyrfingWeapon"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$SwordItem, $SwordItem$Type} from "packages/net/minecraft/world/item/$SwordItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TyrfingItem extends $SwordItem implements $ITyrfingWeapon {
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Tier$Type, arg1: integer, arg2: float, arg3: $Item$Properties$Type)

public "attack"(arg0: $LivingHurtEvent$Type, arg1: double): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TyrfingItem$Type = ($TyrfingItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TyrfingItem_ = $TyrfingItem$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$HearthCoilBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$AbstractCookingRecipe, $AbstractCookingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$AbstractCookingRecipe"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $HearthCoilBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
static readonly "DEFAULT_COLOR": $Color
 "capability": $IEmberCapability
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "heat": double
static readonly "SOUND_LOW_LOOP": integer
static readonly "SOUND_MID_LOOP": integer
static readonly "SOUND_HIGH_LOOP": integer
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_IDS": (integer)[]
 "cachedRecipes": $HashMap<($RecipeType<(any)>), ($AbstractCookingRecipe)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $HearthCoilBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"<T extends $AbstractCookingRecipe>(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $HearthCoilBlockEntity$Type): void
public "playSound"(arg0: integer): void
public static "depleteItem"(arg0: $ItemEntity$Type, arg1: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HearthCoilBlockEntity$Type = ($HearthCoilBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HearthCoilBlockEntity_ = $HearthCoilBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$IFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export interface $IFilter {

 "getType"(): $ResourceLocation
 "readFromNBT"(arg0: $CompoundTag$Type): void
 "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
 "formatFilter"(): string
 "acceptsItem"(arg0: $ItemStack$Type): boolean
 "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
}

export namespace $IFilter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilter$Type = ($IFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilter_ = $IFilter$Type;
}}
declare module "packages/com/rekindled/embers/block/$MechanicalPumpBlock" {
import {$DoubleTallMachineBlock, $DoubleTallMachineBlock$Type} from "packages/com/rekindled/embers/block/$DoubleTallMachineBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $MechanicalPumpBlock extends $DoubleTallMachineBlock {
 "topSound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $SoundType$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPumpBlock$Type = ($MechanicalPumpBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPumpBlock_ = $MechanicalPumpBlock$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$FluidTransferBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$FluidTransferBlockEntity, $FluidTransferBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$FluidTransferBlockEntity"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $FluidTransferBlockEntityRenderer implements $BlockEntityRenderer<($FluidTransferBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $FluidTransferBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $FluidTransferBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $FluidTransferBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTransferBlockEntityRenderer$Type = ($FluidTransferBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTransferBlockEntityRenderer_ = $FluidTransferBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/augment/$ResonatingBellAugment" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"
import {$PlayerInteractEvent$RightClickBlock, $PlayerInteractEvent$RightClickBlock$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $ResonatingBellAugment extends $AugmentBase {
static "cooldownTicksServer": $HashMap<($UUID), (float)>

constructor(arg0: $ResourceLocation$Type)

public static "setCooldown"(arg0: $UUID$Type, arg1: float): void
public static "hasCooldown"(arg0: $UUID$Type): boolean
public "onClick"(arg0: $PlayerInteractEvent$RightClickBlock$Type): void
public "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResonatingBellAugment$Type = ($ResonatingBellAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResonatingBellAugment_ = $ResonatingBellAugment$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidTransferBlockEntity" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$FluidPipeBlockEntityBase, $FluidPipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$FluidPipeBlockEntityBase"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $FluidTransferBlockEntity extends $FluidPipeBlockEntityBase {
static readonly "PRIORITY_TRANSFER": integer
 "filterFluid": $FluidStack
 "syncFilter": boolean
 "outputHolder": $LazyOptional<($IFluidHandler)>
static readonly "MAX_PUSH": integer
 "tank": $FluidTank
 "holder": $LazyOptional<($IFluidHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getPriority"(arg0: $Direction$Type): integer
public "getConnection"(arg0: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getCapacity"(): integer
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidTransferBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
get "capacity"(): integer
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTransferBlockEntity$Type = ($FluidTransferBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTransferBlockEntity_ = $FluidTransferBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/fluidtypes/$MoltenMetalFluidType" {
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$EmbersFluidType$FluidInfo, $EmbersFluidType$FluidInfo$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$EmbersFluidType, $EmbersFluidType$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $MoltenMetalFluidType extends $EmbersFluidType {
readonly "RENDER_OVERLAY": $ResourceLocation
readonly "TEXTURE_STILL": $ResourceLocation
readonly "TEXTURE_FLOW": $ResourceLocation
readonly "TEXTURE_OVERLAY": $ResourceLocation
readonly "FOG_COLOR": $Vector3f
readonly "fogStart": float
readonly "fogEnd": float
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(arg0: $FluidType$Properties$Type, arg1: $EmbersFluidType$FluidInfo$Type)

public "move"(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
public "initializeClient"(arg0: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
public "setItemMovement"(arg0: $ItemEntity$Type): void
set "itemMovement"(value: $ItemEntity$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MoltenMetalFluidType$Type = ($MoltenMetalFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MoltenMetalFluidType_ = $MoltenMetalFluidType$Type;
}}
declare module "packages/com/rekindled/embers/block/$FluidTransferBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $FluidTransferBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
static readonly "FILTER": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTransferBlock$Type = ($FluidTransferBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTransferBlock_ = $FluidTransferBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IBoringRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BoringContext, $BoringContext$Type} from "packages/com/rekindled/embers/recipe/$BoringContext"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$WeightedItemStack, $WeightedItemStack$Type} from "packages/com/rekindled/embers/util/$WeightedItemStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IBoringRecipe extends $Recipe<($BoringContext)> {

 "getDimensions"(): $Collection<($ResourceLocation)>
 "getBiomes"(): $Collection<($ResourceLocation)>
 "getMinHeight"(): integer
 "getMaxHeight"(): integer
 "getDisplayOutput"(): $WeightedItemStack
 "getDisplayInput"(): $List<($ItemStack)>
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $BoringContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getChance"(): double
 "getOutput"(arg0: $BoringContext$Type): $WeightedItemStack
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getRemainingItems"(arg0: $BoringContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $BoringContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IBoringRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBoringRecipe$Type = ($IBoringRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBoringRecipe_ = $IBoringRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$AlchemyStartEvent" {
import {$IAlchemyRecipe, $IAlchemyRecipe$Type} from "packages/com/rekindled/embers/recipe/$IAlchemyRecipe"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$AlchemyContext, $AlchemyContext$Type} from "packages/com/rekindled/embers/recipe/$AlchemyContext"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $AlchemyStartEvent extends $UpgradeEvent {
 "context": $AlchemyContext

constructor(arg0: $BlockEntity$Type, arg1: $AlchemyContext$Type, arg2: $IAlchemyRecipe$Type)

public "getContext"(): $AlchemyContext
public "setRecipe"(arg0: $IAlchemyRecipe$Type): void
public "getRecipe"(): $IAlchemyRecipe
get "context"(): $AlchemyContext
set "recipe"(value: $IAlchemyRecipe$Type)
get "recipe"(): $IAlchemyRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyStartEvent$Type = ($AlchemyStartEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyStartEvent_ = $AlchemyStartEvent$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$AtmosphericGaugeBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $AtmosphericGaugeBlockEntity extends $BlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $AtmosphericGaugeBlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericGaugeBlockEntity$Type = ($AtmosphericGaugeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericGaugeBlockEntity_ = $AtmosphericGaugeBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$MixerCentrifugeTopBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidHandlerBlockEntity, $FluidHandlerBlockEntity$Type} from "packages/net/minecraftforge/fluids/capability/$FluidHandlerBlockEntity"

export class $MixerCentrifugeTopBlockEntity extends $FluidHandlerBlockEntity implements $IExtraCapabilityInformation {
static "capacity": integer
 "loaded": boolean
 "renderOffset": float
 "capability": $IEmberCapability
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public "setChanged"(): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $MixerCentrifugeTopBlockEntity$Type): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixerCentrifugeTopBlockEntity$Type = ($MixerCentrifugeTopBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixerCentrifugeTopBlockEntity_ = $MixerCentrifugeTopBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$InfernoForgeTopBlockEntityRenderer" {
import {$InfernoForgeTopBlockEntity, $InfernoForgeTopBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$InfernoForgeTopBlockEntity"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $InfernoForgeTopBlockEntityRenderer implements $BlockEntityRenderer<($InfernoForgeTopBlockEntity)> {
static "hatch": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $InfernoForgeTopBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $InfernoForgeTopBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $InfernoForgeTopBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfernoForgeTopBlockEntityRenderer$Type = ($InfernoForgeTopBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfernoForgeTopBlockEntityRenderer_ = $InfernoForgeTopBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/item/$InflictorGemItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IInflictorGem, $IInflictorGem$Type} from "packages/com/rekindled/embers/api/item/$IInflictorGem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $InflictorGemItem extends $Item implements $IInflictorGem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "getDamageResistance"(arg0: $ItemStack$Type, arg1: float): float
public "getAttunedSource"(arg0: $ItemStack$Type): string
public "attuneSource"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $DamageSource$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InflictorGemItem$Type = ($InflictorGemItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InflictorGemItem_ = $InflictorGemItem$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$IProjectilePreset" {
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IProjectilePreset {

 "setColor"(arg0: $Color$Type): void
 "shoot"(arg0: $Level$Type): void
 "setPos"(arg0: $Vec3$Type): void
 "getVelocity"(): $Vec3
 "setVelocity"(arg0: $Vec3$Type): void
 "setEffect"(arg0: $IProjectileEffect$Type): void
 "getEntity"(): $Entity
 "getColor"(): $Color
 "getShooter"(): $Entity
 "getPos"(): $Vec3
 "getEffect"(): $IProjectileEffect
}

export namespace $IProjectilePreset {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProjectilePreset$Type = ($IProjectilePreset);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProjectilePreset_ = $IProjectilePreset$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$EntropicEnumeratorUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $EntropicEnumeratorUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorUpgrade$Type = ($EntropicEnumeratorUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorUpgrade_ = $EntropicEnumeratorUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberEjectorBlockEntity" {
import {$EmberEmitterBlockEntity, $EmberEmitterBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EmberEmitterBlockEntity"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberEjectorBlockEntity extends $EmberEmitterBlockEntity {
static readonly "TRANSFER_RATE": double
static readonly "PULL_RATE": double
 "capability": $IEmberCapability
 "target": $BlockPos
 "ticksExisted": long
 "random": $Random
 "offset": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberEjectorBlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEjectorBlockEntity$Type = ($EmberEjectorBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEjectorBlockEntity_ = $EmberEjectorBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$EntropicEnumeratorBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$EntropicEnumeratorBlockEntity, $EntropicEnumeratorBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$EntropicEnumeratorBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $EntropicEnumeratorBlockEntityRenderer implements $BlockEntityRenderer<($EntropicEnumeratorBlockEntity)> {
static "cubies": ((($BakedModel)[])[])[]
static "quat": $Quaternionf

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $EntropicEnumeratorBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $EntropicEnumeratorBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $EntropicEnumeratorBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntropicEnumeratorBlockEntityRenderer$Type = ($EntropicEnumeratorBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntropicEnumeratorBlockEntityRenderer_ = $EntropicEnumeratorBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/util/$RenderUtil" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Color, $Color$Type} from "packages/java/awt/$Color"
import {$MultiBufferSource$BufferSource, $MultiBufferSource$BufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource$BufferSource"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BufferBuilder, $BufferBuilder$Type} from "packages/com/mojang/blaze3d/vertex/$BufferBuilder"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"

export class $RenderUtil {

constructor()

public static "drawColorRectBatched"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$BufferSource$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: float, arg17: float, arg18: float, arg19: float, arg20: float, arg21: float, arg22: float): void
public static "drawHeatBarEnd"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$BufferSource$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float): void
public static "renderWavyEmberLine"(arg0: $BufferBuilder$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): void
public static "renderWavyEmberLine"(arg0: $BufferBuilder$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $Color$Type): void
public static "renderHighlightCircle"(arg0: $BufferBuilder$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: $Color$Type): void
public static "renderHighlightCircle"(arg0: $BufferBuilder$Type, arg1: double, arg2: double, arg3: double): void
public static "renderAlchemyCircle"(arg0: $VertexConsumer$Type, arg1: $Matrix4f$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderUtil$Type = ($RenderUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderUtil_ = $RenderUtil$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$AtmosphericBellowsBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$AtmosphericBellowsBlockEntity, $AtmosphericBellowsBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$AtmosphericBellowsBlockEntity"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $AtmosphericBellowsBlockEntityRenderer implements $BlockEntityRenderer<($AtmosphericBellowsBlockEntity)> {
static "length": float
static "blowLength": float
static "suckLength": float
static "top": $BakedModel
static "leather": $BakedModel
static "random": $Random

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $AtmosphericBellowsBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $AtmosphericBellowsBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $AtmosphericBellowsBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtmosphericBellowsBlockEntityRenderer$Type = ($AtmosphericBellowsBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtmosphericBellowsBlockEntityRenderer_ = $AtmosphericBellowsBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$ExcavationCategory" {
import {$BoringCategory, $BoringCategory$Type} from "packages/com/rekindled/embers/compat/jei/$BoringCategory"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$IBoringRecipe, $IBoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$IBoringRecipe"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $ExcavationCategory extends $BoringCategory {
static "title": $Component
 "icon": $IDrawable
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IBoringRecipe)>
public "getTitle"(): $Component
get "recipeType"(): $RecipeType<($IBoringRecipe)>
get "title"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationCategory$Type = ($ExcavationCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationCategory_ = $ExcavationCategory$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FieldChartBlockEntity" {
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $FieldChartBlockEntity extends $BlockEntity implements $ISoundController {
static readonly "SOUND_LOOP": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FieldChartBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "getRenderBoundingBox"(): $AABB
public "playSound"(arg0: integer): void
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
get "soundIDs"(): (integer)[]
get "renderBoundingBox"(): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldChartBlockEntity$Type = ($FieldChartBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldChartBlockEntity_ = $FieldChartBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$MirrorRelayBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EmberReceiverBlock, $EmberReceiverBlock$Type} from "packages/com/rekindled/embers/block/$EmberReceiverBlock"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $MirrorRelayBlock extends $EmberReceiverBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MirrorRelayBlock$Type = ($MirrorRelayBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MirrorRelayBlock_ = $MirrorRelayBlock$Type;
}}
declare module "packages/com/rekindled/embers/entity/render/$AncientGolemEyeLayer" {
import {$EyesLayer, $EyesLayer$Type} from "packages/net/minecraft/client/renderer/entity/layers/$EyesLayer"
import {$RenderLayerParent, $RenderLayerParent$Type} from "packages/net/minecraft/client/renderer/entity/$RenderLayerParent"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$AncientGolemModel, $AncientGolemModel$Type} from "packages/com/rekindled/embers/model/$AncientGolemModel"

export class $AncientGolemEyeLayer<T extends $Entity, M extends $AncientGolemModel<(T)>> extends $EyesLayer<(T), (M)> {

constructor(arg0: $RenderLayerParent$Type<(T), (M)>)

public "renderType"(): $RenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AncientGolemEyeLayer$Type<T, M> = ($AncientGolemEyeLayer<(T), (M)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AncientGolemEyeLayer_<T, M> = $AncientGolemEyeLayer$Type<(T), (M)>;
}}
declare module "packages/com/rekindled/embers/recipe/$StampingRecipe$TagAmount" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $StampingRecipe$TagAmount {
 "tag": $TagKey<($Item)>
 "amount": integer

constructor(arg0: $TagKey$Type<($Item$Type)>, arg1: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingRecipe$TagAmount$Type = ($StampingRecipe$TagAmount);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingRecipe$TagAmount_ = $StampingRecipe$TagAmount$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$EmberBoreBladeRenderEvent" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $EmberBoreBladeRenderEvent extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: $PoseStack$Type, arg2: $BlockState$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer)

public "getBuffer"(): $MultiBufferSource
public "getLight"(): integer
public "getBlockState"(): $BlockState
public "getPose"(): $PoseStack
public "getOverlay"(): integer
get "buffer"(): $MultiBufferSource
get "light"(): integer
get "blockState"(): $BlockState
get "pose"(): $PoseStack
get "overlay"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreBladeRenderEvent$Type = ($EmberBoreBladeRenderEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreBladeRenderEvent_ = $EmberBoreBladeRenderEvent$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$EmberEmitterBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IEmberPacketProducer, $IEmberPacketProducer$Type} from "packages/com/rekindled/embers/api/power/$IEmberPacketProducer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EmberEmitterBlockEntity extends $BlockEntity implements $IEmberPacketProducer {
 "capability": $IEmberCapability
static readonly "TRANSFER_RATE": double
static readonly "PULL_RATE": double
 "target": $BlockPos
 "ticksExisted": long
 "random": $Random
 "offset": integer
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)
constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "setTargetPosition"(arg0: $BlockPos$Type, arg1: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEmittingDirection"(arg0: $Direction$Type): $Direction
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EmberEmitterBlockEntity$Type): void
public static "getBurstVelocity"(arg0: $Direction$Type): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEmitterBlockEntity$Type = ($EmberEmitterBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEmitterBlockEntity_ = $EmberEmitterBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberBoreBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EmberBoreBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberBoreBlock$Type = ($EmberBoreBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberBoreBlock_ = $EmberBoreBlock$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberReceiverBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $EmberReceiverBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "canAttach"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberReceiverBlock$Type = ($EmberReceiverBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberReceiverBlock_ = $EmberReceiverBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IBoilingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidHandlerContext, $FluidHandlerContext$Type} from "packages/com/rekindled/embers/recipe/$FluidHandlerContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IBoilingRecipe extends $Recipe<($FluidHandlerContext)> {

 "process"(arg0: $FluidHandlerContext$Type, arg1: integer): $FluidStack
 "getDisplayOutput"(): $FluidStack
 "getDisplayInput"(): $FluidIngredient
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $FluidHandlerContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getOutput"(arg0: $FluidHandlerContext$Type): $FluidStack
 "getRemainingItems"(arg0: $FluidHandlerContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $FluidHandlerContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IBoilingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBoilingRecipe$Type = ($IBoilingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBoilingRecipe_ = $IBoilingRecipe$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CombustionChamberBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ICatalysisCombustionRecipe, $ICatalysisCombustionRecipe$Type} from "packages/com/rekindled/embers/recipe/$ICatalysisCombustionRecipe"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CombustionChamberBlockEntity extends $BlockEntity implements $IExtraCapabilityInformation {
static "machine": $ItemStack
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "cachedRecipe": $ICatalysisCombustionRecipe
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CombustionChamberBlockEntity$Type): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombustionChamberBlockEntity$Type = ($CombustionChamberBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombustionChamberBlockEntity_ = $CombustionChamberBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$BoringRecipeBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$BoringRecipe, $BoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoringRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"

export class $BoringRecipeBuilder {
 "id": $ResourceLocation
 "result": $ItemStack
 "weight": integer
 "minHeight": integer
 "maxHeight": integer
 "dimensions": $HashSet<($ResourceLocation)>
 "biomes": $HashSet<($ResourceLocation)>
 "requiredBlock": $TagKey<($Block)>
 "amountRequired": integer
 "chance": double
 "type": $RecipeSerializer<(any)>

constructor()

public "type"(arg0: $RecipeSerializer$Type<(any)>): $BoringRecipeBuilder
public "dimensions"(arg0: $HashSet$Type<($ResourceLocation$Type)>): $BoringRecipeBuilder
public "id"(arg0: $ResourceLocation$Type): $BoringRecipeBuilder
public "domain"(arg0: string): $BoringRecipeBuilder
public "save"(arg0: $Consumer$Type<($FinishedRecipe$Type)>): void
public static "create"(arg0: $ItemStack$Type): $BoringRecipeBuilder
public static "create"(arg0: $Item$Type): $BoringRecipeBuilder
public "build"(): $BoringRecipe
public "dimension"(...arg0: ($ResourceLocation$Type)[]): $BoringRecipeBuilder
public "biomes"(arg0: $HashSet$Type<($ResourceLocation$Type)>): $BoringRecipeBuilder
public "maxHeight"(arg0: integer): $BoringRecipeBuilder
public "folder"(arg0: string): $BoringRecipeBuilder
public "require"(arg0: $TagKey$Type<($Block$Type)>, arg1: integer): $BoringRecipeBuilder
public "minHeight"(arg0: integer): $BoringRecipeBuilder
public "biome"(...arg0: ($ResourceLocation$Type)[]): $BoringRecipeBuilder
public "weight"(arg0: integer): $BoringRecipeBuilder
public "chance"(arg0: double): $BoringRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoringRecipeBuilder$Type = ($BoringRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoringRecipeBuilder_ = $BoringRecipeBuilder$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IDawnstoneAnvilRecipe extends $Recipe<($Container)> {

 "getDisplayOutput"(): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getDisplayInputTop"(): $List<($ItemStack)>
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getDisplayInputBottom"(): $List<($ItemStack)>
 "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
 "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IDawnstoneAnvilRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDawnstoneAnvilRecipe$Type = ($IDawnstoneAnvilRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDawnstoneAnvilRecipe_ = $IDawnstoneAnvilRecipe$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$CopperChargerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISoundController, $ISoundController$Type} from "packages/com/rekindled/embers/util/sound/$ISoundController"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$IEmberCapability, $IEmberCapability$Type} from "packages/com/rekindled/embers/api/power/$IEmberCapability"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IExtraCapabilityInformation$EnumIOType, $IExtraCapabilityInformation$EnumIOType$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation$EnumIOType"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$IExtraDialInformation, $IExtraDialInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraDialInformation"
import {$IExtraCapabilityInformation, $IExtraCapabilityInformation$Type} from "packages/com/rekindled/embers/api/tile/$IExtraCapabilityInformation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CopperChargerBlockEntity extends $BlockEntity implements $ISoundController, $IExtraDialInformation, $IExtraCapabilityInformation {
 "capability": $IEmberCapability
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
 "angle": integer
 "turnRate": integer
 "isWorking": boolean
 "wasWorking": boolean
 "reverse": boolean
static readonly "SOUND_PROCESS": integer
static readonly "SOUND_REVERSE": integer
static readonly "SOUND_IDS": (integer)[]
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "setChanged"(): void
public "addDialInformation"(arg0: $Direction$Type, arg1: $List$Type<($Component$Type)>, arg2: string): void
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CopperChargerBlockEntity$Type): void
public "shouldPlaySound"(arg0: integer): boolean
public "getSoundIDs"(): (integer)[]
public "stopSound"(arg0: integer): void
public "isSoundPlaying"(arg0: integer): boolean
public "hasCapabilityDescription"(arg0: $Capability$Type<(any)>): boolean
public "addCapabilityDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Capability$Type<(any)>, arg2: $Direction$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $CopperChargerBlockEntity$Type): void
public "playSound"(arg0: integer): void
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getCurrentVolume"(arg0: integer, arg1: float): float
public "getCurrentPitch"(arg0: integer, arg1: float): float
public "handleSound"(): void
public "getComparatorData"(arg0: $Direction$Type, arg1: integer, arg2: string): integer
public static "formatCapability"(arg0: $IExtraCapabilityInformation$EnumIOType$Type, arg1: string, arg2: $Component$Type): $Component
public "addOtherDescription"(arg0: $List$Type<($Component$Type)>, arg1: $Direction$Type): void
get "soundIDs"(): (integer)[]
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperChargerBlockEntity$Type = ($CopperChargerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CopperChargerBlockEntity_ = $CopperChargerBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/network/message/$MessageResearchData" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MessageResearchData {
static readonly "NAME_MAX_LENGTH": integer

constructor()
constructor(arg0: $Map$Type<(string), (boolean)>)

public static "decode"(arg0: $FriendlyByteBuf$Type): $MessageResearchData
public static "encode"(arg0: $MessageResearchData$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $MessageResearchData$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageResearchData$Type = ($MessageResearchData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageResearchData_ = $MessageResearchData$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$ExcavationRecipe" {
import {$WeightedItemStack, $WeightedItemStack$Type} from "packages/com/rekindled/embers/util/$WeightedItemStack"
import {$HashSet, $HashSet$Type} from "packages/java/util/$HashSet"
import {$ExcavationRecipe$Serializer, $ExcavationRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$ExcavationRecipe$Serializer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$BoringRecipe, $BoringRecipe$Type} from "packages/com/rekindled/embers/recipe/$BoringRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $ExcavationRecipe extends $BoringRecipe {
static readonly "SERIALIZER": $ExcavationRecipe$Serializer
readonly "id": $ResourceLocation
readonly "result": $WeightedItemStack
readonly "minHeight": integer
readonly "maxHeight": integer
readonly "dimensions": $HashSet<($ResourceLocation)>
readonly "biomes": $HashSet<($ResourceLocation)>
readonly "requiredBlock": $TagKey<($Block)>
readonly "amountRequired": integer
readonly "chance": double

constructor(arg0: $BoringRecipe$Type)
constructor(arg0: $ResourceLocation$Type, arg1: $WeightedItemStack$Type, arg2: integer, arg3: integer, arg4: $HashSet$Type<($ResourceLocation$Type)>, arg5: $HashSet$Type<($ResourceLocation$Type)>, arg6: $TagKey$Type<($Block$Type)>, arg7: integer, arg8: double)

public "getSerializer"(): $RecipeSerializer<(any)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcavationRecipe$Type = ($ExcavationRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcavationRecipe_ = $ExcavationRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$EmberEvent$EnumType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $EmberEvent$EnumType extends $Enum<($EmberEvent$EnumType)> {
static readonly "PRODUCE": $EmberEvent$EnumType
static readonly "CONSUME": $EmberEvent$EnumType
static readonly "TRANSFER": $EmberEvent$EnumType


public static "values"(): ($EmberEvent$EnumType)[]
public static "valueOf"(arg0: string): $EmberEvent$EnumType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberEvent$EnumType$Type = (("transfer") | ("consume") | ("produce")) | ($EmberEvent$EnumType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberEvent$EnumType_ = $EmberEvent$EnumType$Type;
}}
declare module "packages/com/rekindled/embers/upgrade/$MnemonicInscriberUpgrade" {
import {$UpgradeContext, $UpgradeContext$Type} from "packages/com/rekindled/embers/api/upgrades/$UpgradeContext"
import {$DefaultUpgradeProvider, $DefaultUpgradeProvider$Type} from "packages/com/rekindled/embers/upgrade/$DefaultUpgradeProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $MnemonicInscriberUpgrade extends $DefaultUpgradeProvider {

constructor(arg0: $BlockEntity$Type)

public "getPriority"(): integer
public "throwEvent"(arg0: $BlockEntity$Type, arg1: $List$Type<($UpgradeContext$Type)>, arg2: $UpgradeEvent$Type, arg3: integer, arg4: integer): void
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MnemonicInscriberUpgrade$Type = ($MnemonicInscriberUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MnemonicInscriberUpgrade_ = $MnemonicInscriberUpgrade$Type;
}}
declare module "packages/com/rekindled/embers/block/$ItemTransferBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeConnection, $IPipeConnection$Type} from "packages/com/rekindled/embers/api/block/$IPipeConnection"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ItemTransferBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock, $IPipeConnection {
static readonly "FILTER": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getPipeConnection"(arg0: $BlockState$Type, arg1: $Direction$Type): $PipeBlockEntityBase$PipeConnection
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransferBlock$Type = ($ItemTransferBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransferBlock_ = $ItemTransferBlock$Type;
}}
declare module "packages/com/rekindled/embers/api/event/$DialInformationEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UpgradeEvent, $UpgradeEvent$Type} from "packages/com/rekindled/embers/api/event/$UpgradeEvent"

export class $DialInformationEvent extends $UpgradeEvent {

constructor(arg0: $BlockEntity$Type, arg1: $List$Type<($Component$Type)>, arg2: string)

public "getDialType"(): string
public "getInformation"(): $List<($Component)>
get "dialType"(): string
get "information"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DialInformationEvent$Type = ($DialInformationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DialInformationEvent_ = $DialInformationEvent$Type;
}}
declare module "packages/com/rekindled/embers/item/$GlimmerLampItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $GlimmerLampItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "getBarColor"(arg0: $ItemStack$Type): integer
public "isBarVisible"(arg0: $ItemStack$Type): boolean
public "inventoryTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Entity$Type, arg3: integer, arg4: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlimmerLampItem$Type = ($GlimmerLampItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlimmerLampItem_ = $GlimmerLampItem$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IAlchemyRecipe$PedestalContents" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $IAlchemyRecipe$PedestalContents {
 "aspect": $ItemStack
 "input": $ItemStack

constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAlchemyRecipe$PedestalContents$Type = ($IAlchemyRecipe$PedestalContents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAlchemyRecipe$PedestalContents_ = $IAlchemyRecipe$PedestalContents$Type;
}}
declare module "packages/com/rekindled/embers/compat/jei/$StampingCategory" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$IStampingRecipe, $IStampingRecipe$Type} from "packages/com/rekindled/embers/recipe/$IStampingRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"
import {$IGuiHelper, $IGuiHelper$Type} from "packages/mezz/jei/api/helpers/$IGuiHelper"

export class $StampingCategory implements $IRecipeCategory<($IStampingRecipe)> {
static "title": $Component
static "texture": $ResourceLocation

constructor(arg0: $IGuiHelper$Type)

public "getRecipeType"(): $RecipeType<($IStampingRecipe)>
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "setRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: $IStampingRecipe$Type, arg2: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "draw"(arg0: $IStampingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: $GuiGraphics$Type, arg3: double, arg4: double): void
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: $IStampingRecipe$Type): boolean
public "handleInput"(arg0: $IStampingRecipe$Type, arg1: double, arg2: double, arg3: $InputConstants$Key$Type): boolean
public "getTooltipStrings"(arg0: $IStampingRecipe$Type, arg1: $IRecipeSlotsView$Type, arg2: double, arg3: double): $List<($Component)>
public "getRegistryName"(arg0: $IStampingRecipe$Type): $ResourceLocation
get "recipeType"(): $RecipeType<($IStampingRecipe)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StampingCategory$Type = ($StampingCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StampingCategory_ = $StampingCategory$Type;
}}
declare module "packages/com/rekindled/embers/research/capability/$IResearchCapability" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IResearchCapability {

 "readFromNBT"(arg0: $CompoundTag$Type): void
 "isChecked"(arg0: string): boolean
 "setCheckmark"(arg0: string, arg1: boolean): void
 "getCheckmarks"(): $Map<(string), (boolean)>
 "writeToNBT"(arg0: $CompoundTag$Type): void
}

export namespace $IResearchCapability {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IResearchCapability$Type = ($IResearchCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IResearchCapability_ = $IResearchCapability$Type;
}}
declare module "packages/com/rekindled/embers/fluidtypes/$SteamFluidType" {
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$EmbersFluidType$FluidInfo, $EmbersFluidType$FluidInfo$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType$FluidInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$EmbersFluidType, $EmbersFluidType$Type} from "packages/com/rekindled/embers/fluidtypes/$EmbersFluidType"

export class $SteamFluidType extends $EmbersFluidType {
readonly "RENDER_OVERLAY": $ResourceLocation
readonly "TEXTURE_STILL": $ResourceLocation
readonly "TEXTURE_FLOW": $ResourceLocation
readonly "TEXTURE_OVERLAY": $ResourceLocation
readonly "FOG_COLOR": $Vector3f
readonly "fogStart": float
readonly "fogEnd": float
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(arg0: $FluidType$Properties$Type, arg1: $EmbersFluidType$FluidInfo$Type)

public "move"(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
public "initializeClient"(arg0: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SteamFluidType$Type = ($SteamFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SteamFluidType_ = $SteamFluidType$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$FilterExisting" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IFilter, $IFilter$Type} from "packages/com/rekindled/embers/api/filter/$IFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $FilterExisting implements $IFilter {
static readonly "RESOURCE_LOCATION": $ResourceLocation

constructor()

public "getType"(): $ResourceLocation
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "formatFilter"(): string
public "acceptsItem"(arg0: $ItemStack$Type, arg1: $IItemHandler$Type): boolean
public "acceptsItem"(arg0: $ItemStack$Type): boolean
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterExisting$Type = ($FilterExisting);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterExisting_ = $FilterExisting$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilBreakdownRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$AnvilBreakdownRecipe$Serializer, $AnvilBreakdownRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AnvilBreakdownRecipe$Serializer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IVisuallySplitRecipe, $IVisuallySplitRecipe$Type} from "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilBreakdownRecipe implements $IDawnstoneAnvilRecipe, $IVisuallySplitRecipe<($IDawnstoneAnvilRecipe)> {
static readonly "SERIALIZER": $AnvilBreakdownRecipe$Serializer
readonly "id": $ResourceLocation
static "visualRecipes": $List<($IDawnstoneAnvilRecipe)>

constructor(arg0: $ResourceLocation$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getVisualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "visualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilBreakdownRecipe$Type = ($AnvilBreakdownRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilBreakdownRecipe_ = $AnvilBreakdownRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/tile/$IBin" {
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export interface $IBin {

 "getInventory"(): $IItemHandler

(): $IItemHandler
}

export namespace $IBin {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBin$Type = ($IBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBin_ = $IBin$Type;
}}
declare module "packages/com/rekindled/embers/datagen/$EmbersLang" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$LanguageProvider, $LanguageProvider$Type} from "packages/net/minecraftforge/common/data/$LanguageProvider"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$IAugment, $IAugment$Type} from "packages/com/rekindled/embers/api/augment/$IAugment"
import {$RegistryManager$ToolSet, $RegistryManager$ToolSet$Type} from "packages/com/rekindled/embers/$RegistryManager$ToolSet"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RegistryManager$StoneDecoBlocks, $RegistryManager$StoneDecoBlocks$Type} from "packages/com/rekindled/embers/$RegistryManager$StoneDecoBlocks"

export class $EmbersLang extends $LanguageProvider {

constructor(arg0: $PackOutput$Type)

public "addDeco"(arg0: $RegistryManager$StoneDecoBlocks$Type, arg1: string): void
public "addTools"(arg0: $RegistryManager$ToolSet$Type, arg1: string): void
public "addSubtitle"(arg0: $RegistryObject$Type<($SoundEvent$Type)>, arg1: string): void
public "addLore"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "addFluid"(arg0: string, arg1: string): void
public "addAugment"(arg0: $IAugment$Type, arg1: string, arg2: boolean): void
public "addAugment"(arg0: $IAugment$Type, arg1: string): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbersLang$Type = ($EmbersLang);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbersLang_ = $EmbersLang$Type;
}}
declare module "packages/com/rekindled/embers/api/filter/$EnumFilterSetting" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $EnumFilterSetting extends $Enum<($EnumFilterSetting)> {
static readonly "STRICT": $EnumFilterSetting
static readonly "FUZZY": $EnumFilterSetting


public static "get"(arg0: integer): $EnumFilterSetting
public static "values"(): ($EnumFilterSetting)[]
public static "valueOf"(arg0: string): $EnumFilterSetting
public "rotate"(arg0: integer): $EnumFilterSetting
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumFilterSetting$Type = (("strict") | ("fuzzy")) | ($EnumFilterSetting);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumFilterSetting_ = $EnumFilterSetting$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$StamperBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$StamperBlockEntity, $StamperBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$StamperBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $StamperBlockEntityRenderer implements $BlockEntityRenderer<($StamperBlockEntity)> {
static "arm": $BakedModel

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $StamperBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $StamperBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $StamperBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StamperBlockEntityRenderer$Type = ($StamperBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StamperBlockEntityRenderer_ = $StamperBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$IGaseousFuelRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidHandlerContext, $FluidHandlerContext$Type} from "packages/com/rekindled/embers/recipe/$FluidHandlerContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/rekindled/embers/recipe/$FluidIngredient"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IGaseousFuelRecipe extends $Recipe<($FluidHandlerContext)> {

 "process"(arg0: $FluidHandlerContext$Type, arg1: integer): integer
 "getDisplayInput"(): $FluidIngredient
/**
 * 
 * @deprecated
 */
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getPowerMultiplier"(arg0: $FluidHandlerContext$Type): double
 "getDisplayBurnTime"(): integer
 "getBurnTime"(arg0: $FluidHandlerContext$Type): integer
 "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "assemble"(arg0: $FluidHandlerContext$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getDisplayMultiplier"(): double
 "getRemainingItems"(arg0: $FluidHandlerContext$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "isIncomplete"(): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getId"(): $ResourceLocation
 "matches"(arg0: $FluidHandlerContext$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IGaseousFuelRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGaseousFuelRecipe$Type = ($IGaseousFuelRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGaseousFuelRecipe_ = $IGaseousFuelRecipe$Type;
}}
declare module "packages/com/rekindled/embers/api/projectile/$EffectMulti" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$IProjectileEffect, $IProjectileEffect$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectileEffect"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IProjectilePreset, $IProjectilePreset$Type} from "packages/com/rekindled/embers/api/projectile/$IProjectilePreset"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EffectMulti implements $IProjectileEffect {

constructor(arg0: $List$Type<($IProjectileEffect$Type)>)

public "onFizzle"(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $IProjectilePreset$Type): void
public "onBlockImpact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IProjectilePreset$Type): void
public "onEntityImpact"(arg0: $Entity$Type, arg1: $IProjectilePreset$Type): void
public "addEffect"(arg0: $IProjectileEffect$Type): void
public "onHit"(arg0: $Level$Type, arg1: $HitResult$Type, arg2: $IProjectilePreset$Type): void
public "getEffects"(): $List<($IProjectileEffect)>
get "effects"(): $List<($IProjectileEffect)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectMulti$Type = ($EffectMulti);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectMulti_ = $EffectMulti$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$AnvilAugmentRemoveRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AnvilAugmentRemoveRecipe$Serializer, $AnvilAugmentRemoveRecipe$Serializer$Type} from "packages/com/rekindled/embers/recipe/$AnvilAugmentRemoveRecipe$Serializer"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IVisuallySplitRecipe, $IVisuallySplitRecipe$Type} from "packages/com/rekindled/embers/recipe/$IVisuallySplitRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IDawnstoneAnvilRecipe, $IDawnstoneAnvilRecipe$Type} from "packages/com/rekindled/embers/recipe/$IDawnstoneAnvilRecipe"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $AnvilAugmentRemoveRecipe implements $IDawnstoneAnvilRecipe, $IVisuallySplitRecipe<($IDawnstoneAnvilRecipe)> {
static readonly "SERIALIZER": $AnvilAugmentRemoveRecipe$Serializer
readonly "id": $ResourceLocation

constructor(arg0: $ResourceLocation$Type)

public "getDisplayOutput"(): $List<($ItemStack)>
public "getDisplayInputTop"(): $List<($ItemStack)>
public "getVisualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "getId"(): $ResourceLocation
public "matches"(arg0: $Container$Type, arg1: $Level$Type): boolean
public "getDisplayInputBottom"(): $List<($ItemStack)>
public "getOutput"(arg0: $Container$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
public "getToastSymbol"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "assemble"(arg0: $Container$Type, arg1: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "displayOutput"(): $List<($ItemStack)>
get "displayInputTop"(): $List<($ItemStack)>
get "visualRecipes"(): $List<($IDawnstoneAnvilRecipe)>
get "serializer"(): $RecipeSerializer<(any)>
get "id"(): $ResourceLocation
get "displayInputBottom"(): $List<($ItemStack)>
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "incomplete"(): boolean
get "special"(): boolean
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilAugmentRemoveRecipe$Type = ($AnvilAugmentRemoveRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilAugmentRemoveRecipe_ = $AnvilAugmentRemoveRecipe$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$ItemPipeBlockEntityBase" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeBlockEntityBase$PipeConnection, $PipeBlockEntityBase$PipeConnection$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase$PipeConnection"
import {$ItemStackHandler, $ItemStackHandler$Type} from "packages/net/minecraftforge/items/$ItemStackHandler"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PipeBlockEntityBase, $PipeBlockEntityBase$Type} from "packages/com/rekindled/embers/blockentity/$PipeBlockEntityBase"
import {$IItemPipePriority, $IItemPipePriority$Type} from "packages/com/rekindled/embers/blockentity/$IItemPipePriority"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $ItemPipeBlockEntityBase extends $PipeBlockEntityBase implements $IItemPipePriority {
 "inventory": $ItemStackHandler
 "holder": $LazyOptional<($IItemHandler)>
static readonly "PRIORITY_BLOCK": integer
static readonly "PRIORITY_PIPE": integer
 "connections": ($PipeBlockEntityBase$PipeConnection)[]
 "from": (boolean)[]
 "clogged": boolean
 "lastTransfer": $Direction
 "ticksExisted": integer
 "lastRobin": integer
 "loaded": boolean
 "saveConnections": boolean
 "syncConnections": boolean
 "syncCloggedFlag": boolean
 "syncTransfer": boolean
static readonly "DATA_TYPE": $ModelProperty<((integer)[])>
 "blockState": $BlockState

constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "getPriority"(arg0: $Direction$Type): integer
public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemPipeBlockEntityBase$Type): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public static "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemPipeBlockEntityBase$Type): void
public "writeInventory"(arg0: $CompoundTag$Type): void
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeBlockEntityBase$Type = ($ItemPipeBlockEntityBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeBlockEntityBase_ = $ItemPipeBlockEntityBase$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/$FluidVesselBlockEntity" {
import {$OpenTankBlockEntity, $OpenTankBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$OpenTankBlockEntity"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidTank, $FluidTank$Type} from "packages/net/minecraftforge/fluids/capability/templates/$FluidTank"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidVesselBlockEntity extends $OpenTankBlockEntity {
 "renderOffset": float
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getCapacity"(): integer
public static "clientTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidVesselBlockEntity$Type): void
public "getFluidStack"(): $FluidStack
public "getTank"(): $FluidTank
get "capacity"(): integer
get "fluidStack"(): $FluidStack
get "tank"(): $FluidTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidVesselBlockEntity$Type = ($FluidVesselBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidVesselBlockEntity_ = $FluidVesselBlockEntity$Type;
}}
declare module "packages/com/rekindled/embers/$Embers" {
import {$SpawnPlacementRegisterEvent, $SpawnPlacementRegisterEvent$Type} from "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent"
import {$GatherDataEvent, $GatherDataEvent$Type} from "packages/net/minecraftforge/data/event/$GatherDataEvent"
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$Type} from "packages/net/minecraftforge/common/capabilities/$RegisterCapabilitiesEvent"
import {$EntityAttributeCreationEvent, $EntityAttributeCreationEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityAttributeCreationEvent"
import {$RegisterEvent, $RegisterEvent$Type} from "packages/net/minecraftforge/registries/$RegisterEvent"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"

export class $Embers {
static readonly "MODID_OLD": string
static readonly "MODID": string
static readonly "LOGGER": $Logger

constructor()

public "registerCaps"(arg0: $RegisterCapabilitiesEvent$Type): void
public "gatherData"(arg0: $GatherDataEvent$Type): void
public "spawnPlacements"(arg0: $SpawnPlacementRegisterEvent$Type): void
public "entityAttributes"(arg0: $EntityAttributeCreationEvent$Type): void
public "commonSetup"(arg0: $FMLCommonSetupEvent$Type): void
public "registerRecipeSerializers"(arg0: $RegisterEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Embers$Type = ($Embers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Embers_ = $Embers$Type;
}}
declare module "packages/com/rekindled/embers/block/$CreativeEmberBlock" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CreativeEmberBlock extends $BaseEntityBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeEmberBlock$Type = ($CreativeEmberBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeEmberBlock_ = $CreativeEmberBlock$Type;
}}
declare module "packages/com/rekindled/embers/recipe/$EmberActivationRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$EmberActivationRecipe, $EmberActivationRecipe$Type} from "packages/com/rekindled/embers/recipe/$EmberActivationRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $EmberActivationRecipe$Serializer implements $RecipeSerializer<($EmberActivationRecipe)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): $EmberActivationRecipe
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $EmberActivationRecipe
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: $EmberActivationRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $EmberActivationRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberActivationRecipe$Serializer$Type = ($EmberActivationRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberActivationRecipe$Serializer_ = $EmberActivationRecipe$Serializer$Type;
}}
declare module "packages/com/rekindled/embers/augment/$FlameBarrierAugment" {
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"

export class $FlameBarrierAugment extends $AugmentBase {

constructor(arg0: $ResourceLocation$Type)

public "onHit"(arg0: $LivingHurtEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlameBarrierAugment$Type = ($FlameBarrierAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlameBarrierAugment_ = $FlameBarrierAugment$Type;
}}
declare module "packages/com/rekindled/embers/block/$EmberDialBlock" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$DialBaseBlock, $DialBaseBlock$Type} from "packages/com/rekindled/embers/block/$DialBaseBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $EmberDialBlock extends $DialBaseBlock {
static readonly "DIAL_TYPE": string
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getDialType"(): string
public "hasAnalogOutputSignal"(arg0: $BlockState$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): integer
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public static "formatEmber"(arg0: double, arg1: double): $MutableComponent
get "dialType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmberDialBlock$Type = ($EmberDialBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmberDialBlock_ = $EmberDialBlock$Type;
}}
declare module "packages/com/rekindled/embers/augment/$WindingGearsAugment" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$BlockEvent$BreakEvent, $BlockEvent$BreakEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent$BreakEvent"
import {$LivingEvent$LivingJumpEvent, $LivingEvent$LivingJumpEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingJumpEvent"
import {$LivingFallEvent, $LivingFallEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingFallEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$PlayerEvent$BreakSpeed, $PlayerEvent$BreakSpeed$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed"
import {$AugmentBase, $AugmentBase$Type} from "packages/com/rekindled/embers/augment/$AugmentBase"
import {$PlayerInteractEvent$RightClickItem, $PlayerInteractEvent$RightClickItem$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickItem"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"
import {$LivingEvent$LivingTickEvent, $LivingEvent$LivingTickEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingTickEvent"

export class $WindingGearsAugment extends $AugmentBase {
static readonly "TEXTURE_HUD": $ResourceLocation
static readonly "BAR_U": integer
static readonly "BAR_V": integer
static readonly "BAR_WIDTH": integer
static readonly "BAR_HEIGHT": integer
static readonly "TAG_CHARGE": string
static readonly "TAG_CHARGE_TIME": string
static readonly "MAX_CHARGE": double
static readonly "CHARGE_DECAY_DELAY": integer
static readonly "CHARGE_DECAY": double

constructor(arg0: $ResourceLocation$Type)

public "onRightClickItem"(arg0: $PlayerInteractEvent$RightClickItem$Type): void
public static "isClockworkTool"(arg0: $ItemStack$Type): boolean
public static "getSpeedBonus"(arg0: $Level$Type, arg1: $ItemStack$Type): float
public static "depleteCharge"(arg0: $Level$Type, arg1: $ItemStack$Type, arg2: double): void
public static "getChargeDecay"(arg0: $Level$Type, arg1: $ItemStack$Type): double
public static "addCharge"(arg0: $Level$Type, arg1: $ItemStack$Type, arg2: double): void
public "onClientUpdate"(arg0: $TickEvent$ClientTickEvent$Type): void
public static "getMaxCharge"(arg0: $Level$Type, arg1: $ItemStack$Type): double
public static "getCharge"(arg0: $Level$Type, arg1: $ItemStack$Type): double
public "getBreakSpeed"(arg0: $PlayerEvent$BreakSpeed$Type): void
public static "renderSpringUnderlay"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public static "renderSpringOverlay"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public static "getHeldClockworkTool"(arg0: $LivingEntity$Type): $ItemStack
public "onJump"(arg0: $LivingEvent$LivingJumpEvent$Type): void
public static "setCharge"(arg0: $Level$Type, arg1: $ItemStack$Type, arg2: double): void
public "onAttack"(arg0: $LivingDamageEvent$Type): void
public static "getRotationSpeed"(arg0: $Level$Type, arg1: $ItemStack$Type): double
public "onTick"(arg0: $LivingEvent$LivingTickEvent$Type): void
public "onFall"(arg0: $LivingFallEvent$Type): void
public "onBreak"(arg0: $BlockEvent$BreakEvent$Type): void
public static "getDamageBonus"(arg0: $Level$Type, arg1: $ItemStack$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindingGearsAugment$Type = ($WindingGearsAugment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindingGearsAugment_ = $WindingGearsAugment$Type;
}}
declare module "packages/com/rekindled/embers/blockentity/render/$MithrilBlockEntityRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$MithrilBlockEntity, $MithrilBlockEntity$Type} from "packages/com/rekindled/embers/blockentity/$MithrilBlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $MithrilBlockEntityRenderer implements $BlockEntityRenderer<($MithrilBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $MithrilBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $MithrilBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $MithrilBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MithrilBlockEntityRenderer$Type = ($MithrilBlockEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MithrilBlockEntityRenderer_ = $MithrilBlockEntityRenderer$Type;
}}
declare module "packages/com/rekindled/embers/block/$AlchemyTabletBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BaseEntityBlock, $BaseEntityBlock$Type} from "packages/net/minecraft/world/level/block/$BaseEntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $AlchemyTabletBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlchemyTabletBlock$Type = ($AlchemyTabletBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlchemyTabletBlock_ = $AlchemyTabletBlock$Type;
}}
