declare module "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $HolosphereBlock extends $TetraWaterloggedBlock implements $EntityBlock {
static readonly "identifier": string
static "instance": $RegistryObject<($HolosphereBlock)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "clientInit"(): void
public static "place"(arg0: $BlockPlaceContext$Type): $InteractionResult
public "playerWillDestroy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type): void
public "commonInit"(arg0: $PacketHandler$Type): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereBlock$Type = ($HolosphereBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereBlock_ = $HolosphereBlock$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterFierySelf" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterFierySelf implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterFierySelf$Type = ($TooltipGetterFierySelf);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterFierySelf_ = $TooltipGetterFierySelf$Type;
}}
declare module "packages/se/mickelus/mutil/util/$ParticleHelper" {
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ParticleHelper {

constructor()

public static "spawnArmorParticles"(arg0: $LivingEntity$Type): void
public static "spawnArmorParticles"(arg0: $LivingEntity$Type, arg1: $EquipmentSlot$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleHelper$Type = ($ParticleHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleHelper_ = $ParticleHelper$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$PunctureEffect" {
import {$AbilityUseResult, $AbilityUseResult$Type} from "packages/se/mickelus/tetra/effect/$AbilityUseResult"
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $PunctureEffect extends $ChargedAbilityEffect {
static readonly "instance": $PunctureEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
public "performDefensive"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type): $AbilityUseResult
public "performRegular"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: $LivingEntity$Type, arg4: integer, arg5: boolean, arg6: integer): $AbilityUseResult
public "performEcho"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: $LivingEntity$Type, arg4: integer, arg5: boolean, arg6: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PunctureEffect$Type = ($PunctureEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PunctureEffect_ = $PunctureEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBarTool" {
import {$GuiStatBar, $GuiStatBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBar"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiStatBarTool extends $GuiStatBar {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $ToolAction$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $ToolAction$Type, arg4: boolean, arg5: boolean)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): void
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatBarTool$Type = ($GuiStatBarTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatBarTool_ = $GuiStatBarTool$Type;
}}
declare module "packages/se/mickelus/tetra/trades/$ItemsForScrapTrade" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ItemsForScrapTrade implements $VillagerTrades$ItemListing {

constructor(arg0: $ItemStack$Type, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: $Item$Type, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: $Item$Type, arg1: integer, arg2: integer)
constructor(arg0: $Block$Type, arg1: integer, arg2: integer, arg3: integer)

public "getOffer"(arg0: $Entity$Type, arg1: $RandomSource$Type): $MerchantOffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemsForScrapTrade$Type = ($ItemsForScrapTrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemsForScrapTrade_ = $ItemsForScrapTrade$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/holo/$ScanHelper" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $ScanHelper {

constructor()

public static "hasStructure"(arg0: string, arg1: $ServerLevel$Type, arg2: $ChunkPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScanHelper$Type = ($ScanHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScanHelper_ = $ScanHelper$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$InitializableItem, $InitializableItem$Type} from "packages/se/mickelus/tetra/items/$InitializableItem"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ScrollItem extends $BlockItem implements $InitializableItem {
static readonly "identifier": string
static "instance": $ScrollItem
static "gemExpertise": $ItemStack
static "metalExpertise": $ItemStack
static "woodExpertise": $ItemStack
static "stoneExpertise": $ItemStack
static "fibreExpertise": $ItemStack
static "skinExpertise": $ItemStack
static "boneExpertise": $ItemStack
static "fabricExpertise": $ItemStack
static "scaleExpertise": $ItemStack
static "hammerEfficiency": $ItemStack
static "axeEfficiency": $ItemStack
static "cutEfficiency": $ItemStack
static "sturdyGuard": $ItemStack
static "throwingKnife": $ItemStack
static "howlingBlade": $ItemStack
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type)

public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "getName"(arg0: $ItemStack$Type): $Component
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "getCreativeTabItems"(): $Collection<($ItemStack)>
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
get "creativeTabItems"(): $Collection<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollItem$Type = ($ScrollItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollItem_ = $ScrollItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$PuncturedPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $PuncturedPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $PuncturedPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PuncturedPotionEffect$Type = ($PuncturedPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PuncturedPotionEffect_ = $PuncturedPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/sorting/$BasicStatSorter" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$StatFormat, $StatFormat$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatFormat"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $BasicStatSorter implements $IStatSorter {

constructor(arg0: $IStatGetter$Type, arg1: string, arg2: $StatFormat$Type)

public "getName"(): string
public "compare"<T>(arg0: $Player$Type, arg1: $Function$Type<(any), ($ItemStack$Type)>): $Comparator<(T)>
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getWeight"(arg0: $Player$Type, arg1: $ItemStack$Type): integer
public "setInverted"(): $BasicStatSorter
public "setSuffix"(arg0: string): $BasicStatSorter
get "name"(): string
set "suffix"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicStatSorter$Type = ($BasicStatSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicStatSorter_ = $BasicStatSorter$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$CrushingEffect" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"

export class $CrushingEffect {

constructor()

public static "onLivingDamage"(arg0: $LivingDamageEvent$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrushingEffect$Type = ($CrushingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrushingEffect_ = $CrushingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiKeybinding" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"

export class $GuiKeybinding extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: string, arg4: string, arg5: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: string, arg4: string)
constructor(arg0: integer, arg1: integer, arg2: string)
constructor(arg0: integer, arg1: integer, arg2: $KeyMapping$Type)
constructor(arg0: integer, arg1: integer, arg2: $KeyMapping$Type, arg3: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiKeybinding$Type = ($GuiKeybinding);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiKeybinding_ = $GuiKeybinding$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$ZOffsetGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $ZOffsetGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: double)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ZOffsetGui$Type = ($ZOffsetGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ZOffsetGui_ = $ZOffsetGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterToolLevel" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterToolLevel implements $IStatGetter {

constructor(arg0: $ToolAction$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterToolLevel$Type = ($StatGetterToolLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterToolLevel_ = $StatGetterToolLevel$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteractionGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$SecondaryInteraction, $SecondaryInteraction$Type} from "packages/se/mickelus/tetra/interactions/$SecondaryInteraction"

export class $SecondaryInteractionGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $SecondaryInteraction$Type)

public "hide"(): void
public "show"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteractionGui$Type = ($SecondaryInteractionGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteractionGui_ = $SecondaryInteractionGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$BasicWorkbenchBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractWorkbenchBlock, $AbstractWorkbenchBlock$Type} from "packages/se/mickelus/tetra/blocks/workbench/$AbstractWorkbenchBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BasicWorkbenchBlock extends $AbstractWorkbenchBlock {
static readonly "identifier": string
static "instance": $AbstractWorkbenchBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public static "upgradeWorkbench"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $InteractionHand$Type, arg4: $Direction$Type): $InteractionResult
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicWorkbenchBlock$Type = ($BasicWorkbenchBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicWorkbenchBlock_ = $BasicWorkbenchBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedVentBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"

export class $ForgedVentBlock extends $TetraWaterloggedBlock implements $IInteractiveBlock {
static readonly "propRotation": $IntegerProperty
static readonly "propX": $BooleanProperty
static readonly "propBroken": $BooleanProperty
static readonly "identifier": string
static readonly "interactions": ($BlockInteraction)[]
static "instance": $ForgedVentBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "getLightBlock"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): integer
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedVentBlock$Type = ($ForgedVentBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedVentBlock_ = $ForgedVentBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerHeadRenderer" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$HammerHeadBlockEntity, $HammerHeadBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerHeadBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $HammerHeadRenderer implements $BlockEntityRenderer<($HammerHeadBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $HammerHeadBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $HammerHeadBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $HammerHeadBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerHeadRenderer$Type = ($HammerHeadRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerHeadRenderer_ = $HammerHeadRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$SchematicType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SchematicType extends $Enum<($SchematicType)> {
static readonly "other": $SchematicType
static readonly "improvement": $SchematicType
static readonly "minor": $SchematicType
static readonly "major": $SchematicType


public static "values"(): ($SchematicType)[]
public static "valueOf"(arg0: string): $SchematicType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicType$Type = (("other") | ("minor") | ("major") | ("improvement")) | ($SchematicType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicType_ = $SchematicType$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterDrawStrength" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterDrawStrength implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterDrawStrength$Type = ($TooltipGetterDrawStrength);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterDrawStrength_ = $TooltipGetterDrawStrength$Type;
}}
declare module "packages/se/mickelus/mutil/gui/animation/$VisibilityFilter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $VisibilityFilter {

constructor(arg0: float, arg1: float)

public "get"(): float
public "apply"(arg0: float): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VisibilityFilter$Type = ($VisibilityFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VisibilityFilter_ = $VisibilityFilter$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ChargedAbilityPacket" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ChargedAbilityPacket extends $BlockPosPacket {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $BlockPos$Type, arg2: $Vec3$Type, arg3: $InteractionHand$Type, arg4: integer)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChargedAbilityPacket$Type = ($ChargedAbilityPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChargedAbilityPacket_ = $ChargedAbilityPacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicScrollPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $MultiblockSchematicScrollPacket extends $AbstractPacket {

constructor()
constructor(arg0: boolean)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicScrollPacket$Type = ($MultiblockSchematicScrollPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicScrollPacket_ = $MultiblockSchematicScrollPacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiSchematicList" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"

export class $GuiSchematicList extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<($UpgradeSchematic$Type)>)

public "setSchematics"(arg0: ($UpgradeSchematic$Type)[]): void
public "flash"(): void
set "schematics"(value: ($UpgradeSchematic$Type)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSchematicList$Type = ($GuiSchematicList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSchematicList_ = $GuiSchematicList$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $WorkbenchAction {

 "getKey"(): string
 "canPerformOn"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
 "perform"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $WorkbenchTile$Type): void
 "allowInWorldInteraction"(): boolean
 "getRequiredToolActions"(arg0: $ItemStack$Type): $Collection<($ToolAction)>
 "getRequiredTools"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
 "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
}

export namespace $WorkbenchAction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchAction$Type = ($WorkbenchAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchAction_ = $WorkbenchAction$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/$GuiStats" {
import {$GuiStatBar, $GuiStatBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBar"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$GuiStatBarIntegrity, $GuiStatBarIntegrity$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBarIntegrity"

export class $GuiStats {
static readonly "sharpnessGetter": $IStatGetter
static readonly "attackDamageGetter": $IStatGetter
static readonly "attackDamage": $GuiStatBar
static readonly "attackDamageNormalizedGetter": $IStatGetter
static readonly "attackDamageNormalized": $GuiStatBar
static readonly "counterweightGetter": $IStatGetter
static readonly "attackSpeedGetter": $IStatGetter
static readonly "attackSpeed": $GuiStatBar
static readonly "attackSpeedGetterNormalized": $IStatGetter
static readonly "attackSpeedNormalized": $GuiStatBar
static readonly "powerGetter": $IStatGetter
static readonly "drawStrengthGetter": $IStatGetter
static readonly "drawStrength": $GuiStatBar
static readonly "quickChargeGetter": $IStatGetter
static readonly "quickChargeGetterInverted": $IStatGetter
static readonly "drawSpeedGetter": $IStatGetter
static readonly "drawSpeed": $GuiStatBar
static readonly "drawSpeedNormalized": $GuiStatBar
static readonly "abilityDamageGetter": $IStatGetter
static readonly "abilityDamage": $GuiStatBar
static readonly "abilityCooldownGetter": $IStatGetter
static readonly "abilityCooldown": $GuiStatBar
static readonly "abilityCooldownNormalized": $GuiStatBar
static readonly "reachGetter": $IStatGetter
static readonly "reach": $GuiStatBar
static readonly "attackRangeGetter": $IStatGetter
static readonly "attackRange": $GuiStatBar
static readonly "durabilityGetter": $IStatGetter
static readonly "durability": $GuiStatBar
static readonly "armorGetter": $IStatGetter
static readonly "armor": $GuiStatBar
static readonly "toughnessGetter": $IStatGetter
static readonly "toughness": $GuiStatBar
static readonly "shieldbreakerGetter": $IStatGetter
static readonly "shieldbreaker": $GuiStatBar
static readonly "blocking": $GuiStatBar
static readonly "blockingReflectGetter": $IStatGetter
static readonly "blockingReflect": $GuiStatBar
static readonly "bashingGetter": $IStatGetter
static readonly "bashing": $GuiStatBar
static readonly "throwableGetter": $IStatGetter
static readonly "throwable": $GuiStatBar
static readonly "ricochetGetter": $IStatGetter
static readonly "ricochet": $GuiStatBar
static readonly "piercingGetter": $IStatGetter
static readonly "piercing": $GuiStatBar
static readonly "jabGetter": $IStatGetter
static readonly "jab": $GuiStatBar
static readonly "quickslotGetter": $IStatGetter
static readonly "quickslot": $GuiStatBar
static readonly "potionStorageGetter": $IStatGetter
static readonly "potionStorage": $GuiStatBar
static readonly "storageGetter": $IStatGetter
static readonly "storage": $GuiStatBar
static readonly "quiverGetter": $IStatGetter
static readonly "quiver": $GuiStatBar
static readonly "boosterGetter": $IStatGetter
static readonly "booster": $GuiStatBar
static readonly "suspendSelfGetter": $IStatGetter
static readonly "suspendSelf": $GuiStatBar
static readonly "sweepingGetter": $IStatGetter
static readonly "sweeping": $GuiStatBar
static readonly "sweepingRangeGetter": $IStatGetter
static readonly "sweepingRange": $GuiStatBar
static readonly "bleedingGetter": $IStatGetter
static readonly "bleeding": $GuiStatBar
static readonly "backstabGetter": $IStatGetter
static readonly "backstab": $GuiStatBar
static readonly "armorPenetrationGetter": $IStatGetter
static readonly "armorPenetration": $GuiStatBar
static readonly "crushingGetter": $IStatGetter
static readonly "crushing": $GuiStatBar
static readonly "skeweringGetter": $IStatGetter
static readonly "skewering": $GuiStatBar
static readonly "severingGetter": $IStatGetter
static readonly "severing": $GuiStatBar
static readonly "stunGetter": $IStatGetter
static readonly "stun": $GuiStatBar
static readonly "howlingGetter": $IStatGetter
static readonly "howling": $GuiStatBar
static readonly "knockbackGetter": $IStatGetter
static readonly "knockback": $GuiStatBar
static readonly "lootingGetter": $IStatGetter
static readonly "looting": $GuiStatBar
static readonly "fieryGetter": $IStatGetter
static readonly "fiery": $GuiStatBar
static readonly "smiteGetter": $IStatGetter
static readonly "smite": $GuiStatBar
static readonly "arthropodGetter": $IStatGetter
static readonly "arthropod": $GuiStatBar
static readonly "unbreakingGetter": $IStatGetter
static readonly "unbreaking": $GuiStatBar
static readonly "mendingGetter": $IStatGetter
static readonly "mending": $GuiStatBar
static readonly "silkTouchGetter": $IStatGetter
static readonly "replantGetter": $IStatGetter
static readonly "silkTouch": $GuiStatBar
static readonly "fortuneGetter": $IStatGetter
static readonly "fortune": $GuiStatBar
static readonly "infinityGetter": $IStatGetter
static readonly "infinity": $GuiStatBar
static readonly "flameGetter": $IStatGetter
static readonly "flame": $GuiStatBar
static readonly "punchGetter": $IStatGetter
static readonly "punch": $GuiStatBar
static readonly "quickStrikeGetter": $IStatGetter
static readonly "quickStrike": $GuiStatBar
static readonly "softStrikeGetter": $IStatGetter
static readonly "softStrike": $GuiStatBar
static readonly "fierySelfGetter": $IStatGetter
static readonly "fierySelf": $GuiStatBar
static readonly "enderReverbGetter": $IStatGetter
static readonly "enderReverb": $GuiStatBar
static readonly "sculkTaintGetter": $IStatGetter
static readonly "sculkTaint": $GuiStatBar
static readonly "medialLimitGetter": $IStatGetter
static readonly "medialLimit": $GuiStatBar
static readonly "lateralLimitGetter": $IStatGetter
static readonly "lateralLimit": $GuiStatBar
static readonly "axialLimitGetter": $IStatGetter
static readonly "axialLimit": $GuiStatBar
static readonly "criticalGetter": $IStatGetter
static readonly "criticalStrike": $GuiStatBar
static readonly "intuitGetter": $IStatGetter
static readonly "intuit": $GuiStatBar
static readonly "earthbindGetter": $IStatGetter
static readonly "earthbind": $GuiStatBar
static readonly "reachingGetter": $IStatGetter
static readonly "reaching": $GuiStatBar
static readonly "jankingGetter": $IStatGetter
static readonly "janking": $GuiStatBar
static readonly "releaseLatchGetter": $IStatGetter
static readonly "releaseLatch": $GuiStatBar
static readonly "overbowedGetter": $IStatGetter
static readonly "overbowed": $GuiStatBar
static readonly "multishotGetter": $IStatGetter
static readonly "multishot": $GuiStatBar
static readonly "focusEchoGetter": $IStatGetter
static readonly "focusGetter": $IStatGetter
static readonly "focus": $GuiStatBar
static readonly "spreadGetter": $IStatGetter
static readonly "spread": $GuiStatBar
static readonly "zoomGetter": $IStatGetter
static readonly "zoom": $GuiStatBar
static readonly "velocityGetter": $IStatGetter
static readonly "suspendGetter": $IStatGetter
static readonly "velocity": $GuiStatBar
static readonly "magicCapacityGetter": $IStatGetter
static readonly "magicCapacity": $GuiStatBar
static readonly "stabilityGetter": $IStatGetter
static readonly "stability": $GuiStatBar
static readonly "workableGetter": $IStatGetter
static readonly "workable": $GuiStatBar
static readonly "sweeperRangeGetter": $IStatGetter
static readonly "sweeperRange": $GuiStatBar
static readonly "sweeperHorizontalSpreadGetter": $IStatGetter
static readonly "sweeperHorizontalSpread": $GuiStatBar
static readonly "sweeperVerticalSpreadGetter": $IStatGetter
static readonly "sweeperVerticalSpread": $GuiStatBar
static readonly "integrity": $GuiStatBarIntegrity
static readonly "percussionScannerGetter": $IStatGetter
static readonly "percussionScanner": $GuiStatBar
static readonly "counterweight": $GuiStatBar

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStats$Type = ($GuiStats);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStats_ = $GuiStats$Type;
}}
declare module "packages/se/mickelus/mutil/data/deserializer/$BlockDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BlockDeserializer implements $JsonDeserializer<($Block)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDeserializer$Type = ($BlockDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockDeserializer_ = $BlockDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedWallBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ForgedWallBlock extends $TetraBlock {
static readonly "identifier": string
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedWallBlock$Type = ($ForgedWallBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedWallBlock_ = $ForgedWallBlock$Type;
}}
declare module "packages/se/mickelus/tetra/trades/$ItemsForEmeraldsAndScrapTrade" {
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ItemsForEmeraldsAndScrapTrade implements $VillagerTrades$ItemListing {

constructor(arg0: $ItemLike$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer)

public "getOffer"(arg0: $Entity$Type, arg1: $RandomSource$Type): $MerchantOffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemsForEmeraldsAndScrapTrade$Type = ($ItemsForEmeraldsAndScrapTrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemsForEmeraldsAndScrapTrade_ = $ItemsForEmeraldsAndScrapTrade$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiItemRolling" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiItem$CountMode, $GuiItem$CountMode$Type} from "packages/se/mickelus/mutil/gui/$GuiItem$CountMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiItemRolling extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "setTooltip"(arg0: boolean): $GuiItemRolling
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "getTooltipLines"(): $List<($Component)>
public "setItems"(arg0: ($ItemStack$Type)[]): $GuiItemRolling
public "setCountVisibility"(arg0: $GuiItem$CountMode$Type): $GuiItemRolling
set "tooltip"(value: boolean)
get "tooltipLines"(): $List<($Component)>
set "items"(value: ($ItemStack$Type)[])
set "countVisibility"(value: $GuiItem$CountMode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiItemRolling$Type = ($GuiItemRolling);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiItemRolling_ = $GuiItemRolling$Type;
}}
declare module "packages/se/mickelus/tetra/util/$StreamHelper" {
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Random, $Random$Type} from "packages/java/util/$Random"

export class $StreamHelper {

constructor()

public static "toShuffledList"<T>(arg0: $Random$Type): $Collector<(T), (any), ($List<(T)>)>
public static "toShuffledList"<T>(): $Collector<(T), (any), ($List<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StreamHelper$Type = ($StreamHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StreamHelper_ = $StreamHelper$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $CraftingEffectOutcome {

 "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean

(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}

export namespace $CraftingEffectOutcome {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingEffectOutcome$Type = ($CraftingEffectOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingEffectOutcome_ = $CraftingEffectOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiBar" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"

export class $GuiBar extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: double, arg4: double)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: double, arg4: double, arg5: boolean)

public "setValue"(arg0: double, arg1: double): void
public "setColor"(arg0: integer): $GuiBar
public "setMin"(arg0: double): void
public "setAlignment"(arg0: $GuiAlignment$Type): $GuiBar
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setMax"(arg0: double): void
set "color"(value: integer)
set "min"(value: double)
set "alignment"(value: $GuiAlignment$Type)
set "max"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiBar$Type = ($GuiBar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiBar_ = $GuiBar$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/dynamic/$DynamicModularItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DynamicModularItem extends $ItemModularHandheld {
static readonly "identifier": string
static readonly "typeKey": string
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "canGainHoneProgress"(arg0: $ItemStack$Type): boolean
public "getHoneIntegrityMultiplier"(arg0: $ItemStack$Type): integer
public "getRequiredModules"(arg0: $ItemStack$Type): (string)[]
public "getHoneBase"(arg0: $ItemStack$Type): integer
public "getMinorModuleKeys"(arg0: $ItemStack$Type): (string)[]
public "getMajorModuleKeys"(arg0: $ItemStack$Type): (string)[]
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicModularItem$Type = ($DynamicModularItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicModularItem_ = $DynamicModularItem$Type;
}}
declare module "packages/se/mickelus/tetra/$TetraSounds" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"

export class $TetraSounds {
static readonly "scannerLoop": $SoundEvent
static readonly "scanMiss": $SoundEvent
static readonly "scanHit": $SoundEvent
static readonly "honeGain": $SoundEvent
static readonly "settle": $SoundEvent

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraSounds$Type = ($TetraSounds);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraSounds_ = $TetraSounds$Type;
}}
declare module "packages/se/mickelus/tetra/properties/$AttributeHelper" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"

export class $AttributeHelper {
static readonly "emptyMap": $Multimap<($Attribute), ($AttributeModifier)>

constructor()

public static "merge"(arg0: $Collection$Type<($Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "merge"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>, arg1: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "round"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "collapse"(arg0: $Collection$Type<($AttributeModifier$Type)>): $Collection<($AttributeModifier)>
public static "getMultiplyAmount"(arg0: $Collection$Type<($AttributeModifier$Type)>): double
public static "getAdditionAmount"(arg0: $Collection$Type<($AttributeModifier$Type)>): double
public static "multiplyModifiers"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>, arg1: double): $Multimap<($Attribute), ($AttributeModifier)>
public static "overwrite"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>, arg1: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "fixIdentifiers"(arg0: $Attribute$Type, arg1: $AttributeModifier$Type): $AttributeModifier
public static "fixIdentifiers"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "getMergedAmount"(arg0: $Collection$Type<($AttributeModifier$Type)>): double
public static "getMergedAmount"(arg0: $Collection$Type<($AttributeModifier$Type)>, arg1: double): double
public static "retainMax"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>, ...arg1: ($Attribute$Type)[]): $Multimap<($Attribute), ($AttributeModifier)>
public static "retainMax"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>, arg1: $Collection$Type<($Attribute$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "retainMax"(arg0: $Collection$Type<($AttributeModifier$Type)>): $Collection<($AttributeModifier)>
public static "collapseRound"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "multiplyModifier"(arg0: $AttributeModifier$Type, arg1: double): $AttributeModifier
public static "getAttributeKey"(arg0: $Attribute$Type, arg1: $AttributeModifier$Operation$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeHelper$Type = ($AttributeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributeHelper_ = $AttributeHelper$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$UnresolvedItemModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $UnresolvedItemModel implements $IUnbakedGeometry<($UnresolvedItemModel)> {

constructor(arg0: $ItemTransforms$Type, arg1: $Map$Type<(string), ($ItemTransforms$Type)>)
constructor(arg0: $ItemTransforms$Type)

public "clearCache"(): void
public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnresolvedItemModel$Type = ($UnresolvedItemModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnresolvedItemModel_ = $UnresolvedItemModel$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$AndRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $AndRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndRequirement$Type = ($AndRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndRequirement_ = $AndRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$InitializableBlock" {
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"

export interface $InitializableBlock {

 "clientInit"(): void
 "commonInit"(arg0: $PacketHandler$Type): void
}

export namespace $InitializableBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InitializableBlock$Type = ($InitializableBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InitializableBlock_ = $InitializableBlock$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$PotionBackdropGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"

export class $PotionBackdropGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBackdropGui$Type = ($PotionBackdropGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionBackdropGui_ = $PotionBackdropGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$BeamItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BeamItem extends $TetraItem {
static readonly "identifier": string
static "instance": $BeamItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeamItem$Type = ($BeamItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeamItem_ = $BeamItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$ExtractorProjectileRenderer" {
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ExtractorProjectileEntity, $ExtractorProjectileEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/chthonic/$ExtractorProjectileEntity"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ExtractorProjectileRenderer extends $EntityRenderer<($ExtractorProjectileEntity)> {
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "render"(arg0: $ExtractorProjectileEntity$Type, arg1: float, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer): void
public "getTextureLocation"(arg0: $ExtractorProjectileEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtractorProjectileRenderer$Type = ($ExtractorProjectileRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtractorProjectileRenderer_ = $ExtractorProjectileRenderer$Type;
}}
declare module "packages/se/mickelus/mutil/network/$AbstractPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export class $AbstractPacket {

constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractPacket$Type = ($AbstractPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractPacket_ = $AbstractPacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$StateOutcome" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $StateOutcome<T extends $Comparable<(T)>, V extends T> implements $InteractionOutcome {

constructor(arg0: $Property$Type<(T)>, arg1: V)

public "apply"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateOutcome$Type<T, V> = ($StateOutcome<(T), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StateOutcome_<T, V> = $StateOutcome$Type<(T), (V)>;
}}
declare module "packages/se/mickelus/tetra/data/provider/$TetraLootTableProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LootTableProvider$SubProviderEntry, $LootTableProvider$SubProviderEntry$Type} from "packages/net/minecraft/data/loot/$LootTableProvider$SubProviderEntry"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$LootTableProvider, $LootTableProvider$Type} from "packages/net/minecraft/data/loot/$LootTableProvider"

export class $TetraLootTableProvider extends $LootTableProvider {

constructor(arg0: $PackOutput$Type)

public "getTables"(): $List<($LootTableProvider$SubProviderEntry)>
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "tables"(): $List<($LootTableProvider$SubProviderEntry)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraLootTableProvider$Type = ($TetraLootTableProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraLootTableProvider_ = $TetraLootTableProvider$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SkeweringEffect" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $SkeweringEffect {

constructor()

public static "onLivingDamage"(arg0: $LivingDamageEvent$Type, arg1: integer, arg2: $ItemStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkeweringEffect$Type = ($SkeweringEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SkeweringEffect_ = $SkeweringEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterMultiply" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterMultiply implements $IStatGetter {

constructor(...arg0: ($IStatGetter$Type)[])
constructor(arg0: double, ...arg1: ($IStatGetter$Type)[])

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterMultiply$Type = ($StatGetterMultiply);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterMultiply_ = $StatGetterMultiply$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloImprovementGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OutcomeStack, $OutcomeStack$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$OutcomeStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloImprovementGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $UpgradeSchematic$Type, arg3: $ItemStack$Type, arg4: string, arg5: $Consumer$Type<($OutcomePreview$Type)>, arg6: $Consumer$Type<($OutcomePreview$Type)>, arg7: $Consumer$Type<($OutcomeStack$Type)>)

public "updateSelection"(arg0: $ItemStack$Type, arg1: $List$Type<($OutcomeStack$Type)>): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "updateVariants"(arg0: ($OutcomePreview$Type)[], arg1: $List$Type<($OutcomeStack$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloImprovementGui$Type = ($HoloImprovementGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloImprovementGui_ = $HoloImprovementGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiBarSegmented" {
import {$GuiBar, $GuiBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiBar"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiBarSegmented extends $GuiBar {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: double, arg4: double)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: double, arg4: double, arg5: boolean)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiBarSegmented$Type = ($GuiBarSegmented);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiBarSegmented_ = $GuiBarSegmented$Type;
}}
declare module "packages/se/mickelus/tetra/aspect/$TetraEnchantmentHelper" {
import {$ItemAspect, $ItemAspect$Type} from "packages/se/mickelus/tetra/aspect/$ItemAspect"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$TetraEnchantmentHelper$EnchantmentRules, $TetraEnchantmentHelper$EnchantmentRules$Type} from "packages/se/mickelus/tetra/aspect/$TetraEnchantmentHelper$EnchantmentRules"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TetraEnchantmentHelper {

constructor()

public static "init"(): void
public static "removeEnchantment"(arg0: $ItemStack$Type, arg1: string): void
public static "removeEnchantment"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): void
public static "mapEnchantment"(arg0: $ItemStack$Type, arg1: string, arg2: $Enchantment$Type): void
public static "applyEnchantment"(arg0: $ItemStack$Type, arg1: string, arg2: $Enchantment$Type, arg3: integer): void
public static "getEnchantmentName"(arg0: $Enchantment$Type, arg1: integer): string
public static "getEnchantment"(arg0: $CompoundTag$Type): $Pair<($Enchantment), (integer)>
public static "mapEnchantments"(arg0: $ItemStack$Type): void
public static "getEnchantmentCategories"(arg0: $ItemAspect$Type): ($EnchantmentCategory)[]
public static "getEnchantmentPrimitive"(arg0: $CompoundTag$Type): $Pair<(string), (integer)>
public static "getEnchantmentCapacityCost"(arg0: $Enchantment$Type, arg1: integer): integer
public static "getEnchantmentTooltip"(arg0: $Enchantment$Type, arg1: integer, arg2: boolean): string
public static "isApplicableForAspects"(arg0: $Enchantment$Type, arg1: boolean, arg2: $Map$Type<($ItemAspect$Type), (integer)>): boolean
public static "removeEnchantments"(arg0: $ItemStack$Type, arg1: string): void
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
public static "registerMapping"(arg0: $ItemAspect$Type, arg1: $TetraEnchantmentHelper$EnchantmentRules$Type): void
public static "registerMapping"(arg0: $ItemAspect$Type, arg1: $EnchantmentCategory$Type, arg2: string, arg3: string): void
public static "transferReplacementEnchantments"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $ItemStack
public static "getEnchantmentDescription"(arg0: $Enchantment$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraEnchantmentHelper$Type = ($TetraEnchantmentHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraEnchantmentHelper_ = $TetraEnchantmentHelper$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$HauntedEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $HauntedEffect {

constructor()

public static "perform"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HauntedEffect$Type = ($HauntedEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HauntedEffect_ = $HauntedEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$GuiSlotEffect" {
import {$SlotType, $SlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$SlotType"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$List, $List$Type} from "packages/java/util/$List"

export class $GuiSlotEffect extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $SlotType$Type, arg3: $ItemEffect$Type)

public static "getEffectsForSlot"(arg0: $SlotType$Type, arg1: $Collection$Type<($ItemEffect$Type)>): $Collection<($GuiSlotEffect)>
public static "getEffectsForInventory"(arg0: $SlotType$Type, arg1: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>, arg2: integer): $Collection<($GuiElement)>
public static "getEffectsForInventory"(arg0: $SlotType$Type, arg1: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>): $Collection<($GuiElement)>
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSlotEffect$Type = ($GuiSlotEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSlotEffect_ = $GuiSlotEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterHowling" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterHowling implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterHowling$Type = ($TooltipGetterHowling);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterHowling_ = $TooltipGetterHowling$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialEffectGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HoloMaterialEffectGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: boolean, arg4: boolean)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialEffectGui$Type = ($HoloMaterialEffectGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialEffectGui_ = $HoloMaterialEffectGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAttributeMultiply" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAttributeMultiply implements $IStatGetter {

constructor(arg0: $Attribute$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAttributeMultiply$Type = ($StatGetterAttributeMultiply);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAttributeMultiply_ = $StatGetterAttributeMultiply$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiButtonOutlined" {
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"

export class $GuiButtonOutlined extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: $Runnable$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $GuiAlignment$Type, arg4: $Runnable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiButtonOutlined$Type = ($GuiButtonOutlined);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiButtonOutlined_ = $GuiButtonOutlined$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleImprovement" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $GuiModuleImprovement extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: integer, arg5: $Runnable$Type, arg6: $Runnable$Type)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleImprovement$Type = ($GuiModuleImprovement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleImprovement_ = $GuiModuleImprovement$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ModularShieldModel" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Model, $Model$Type} from "packages/net/minecraft/client/model/$Model"
import {$ModelPart, $ModelPart$Type} from "packages/net/minecraft/client/model/geom/$ModelPart"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"

export class $ModularShieldModel extends $Model {

constructor(arg0: $ModelPart$Type)

public static "createLayer"(): $LayerDefinition
public "getModel"(arg0: string): $ModelPart
public "renderToBuffer"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: integer, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularShieldModel$Type = ($ModularShieldModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularShieldModel_ = $ModularShieldModel$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$MiningSpeedPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$PlayerEvent$BreakSpeed, $PlayerEvent$BreakSpeed$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $MiningSpeedPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $MiningSpeedPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public static "onBreakSpeed"(arg0: $PlayerEvent$BreakSpeed$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiningSpeedPotionEffect$Type = ($MiningSpeedPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiningSpeedPotionEffect_ = $MiningSpeedPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterNone" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterNone implements $ITooltipGetter {

constructor(arg0: string)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterNone$Type = ($TooltipGetterNone);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterNone_ = $TooltipGetterNone$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiSettleProgress" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiSettleProgress extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "update"(arg0: $ItemStack$Type, arg1: $ItemModuleMajor$Type): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSettleProgress$Type = ($GuiSettleProgress);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSettleProgress_ = $GuiSettleProgress$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $InteractionOutcome {

 "apply"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean

(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
}

export namespace $InteractionOutcome {
const EMPTY: $InteractionOutcome
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractionOutcome$Type = ($InteractionOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractionOutcome_ = $InteractionOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$PerkRequrement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$IntegerPredicate, $IntegerPredicate$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$IntegerPredicate"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $PerkRequrement implements $CraftingRequirement {

constructor(arg0: string, arg1: $IntegerPredicate$Type)

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerkRequrement$Type = ($PerkRequrement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PerkRequrement_ = $PerkRequrement$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $ForgedContainerBlockEntity extends $BlockEntity implements $MenuProvider {
static "type": $RegistryObject<($BlockEntityType<($ForgedContainerBlockEntity)>)>
static "lockIntegrityMax": integer
static "lockCount": integer
static "lidIntegrityMax": integer
static "compartmentCount": integer
static "compartmentSize": integer
 "openTime": long
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "isOpen"(): boolean
public "open"(arg0: $Player$Type): void
public "isLocked"(arg0: integer): boolean
public "isLocked"(): (boolean)[]
public "getDisplayName"(): $Component
public "getFacing"(): $Direction
public "breakLock"(arg0: $Player$Type, arg1: integer, arg2: $InteractionHand$Type): void
public "getOrDelegate"(): $ForgedContainerBlockEntity
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$Type, arg2: $Player$Type): $AbstractContainerMenu
public "isFlipped"(): boolean
public static "writeLockData"(arg0: $CompoundTag$Type, arg1: (integer)[]): void
public static "writeLidData"(arg0: $CompoundTag$Type, arg1: integer): void
public static "getUpdatedBlockState"(arg0: $BlockState$Type, arg1: (integer)[], arg2: integer): $BlockState
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
get "locked"(): boolean
get "displayName"(): $Component
get "facing"(): $Direction
get "orDelegate"(): $ForgedContainerBlockEntity
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "flipped"(): boolean
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerBlockEntity$Type = ($ForgedContainerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerBlockEntity_ = $ForgedContainerBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatIndicator" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiTexture, $GuiTexture$Type} from "packages/se/mickelus/mutil/gui/$GuiTexture"

export class $GuiStatIndicator extends $GuiTexture {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $IStatGetter$Type, arg5: $ITooltipGetter$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: integer, arg5: $ResourceLocation$Type, arg6: $IStatGetter$Type, arg7: $ITooltipGetter$Type)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
public "isActive"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "withShowRequirements"(...arg0: ($IStatGetter$Type)[]): $GuiStatIndicator
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getLabel"(): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
get "label"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatIndicator$Type = ($GuiStatIndicator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatIndicator_ = $GuiStatIndicator$Type;
}}
declare module "packages/se/mickelus/mutil/data/deserializer/$ItemDeserializer" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $ItemDeserializer implements $JsonDeserializer<($Item)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDeserializer$Type = ($ItemDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDeserializer_ = $ItemDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$EffectUnRenderer" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Gui, $Gui$Type} from "packages/net/minecraft/client/gui/$Gui"
import {$EffectRenderingInventoryScreen, $EffectRenderingInventoryScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$EffectRenderingInventoryScreen"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $EffectUnRenderer implements $IClientMobEffectExtensions {
static readonly "INSTANCE": $IClientMobEffectExtensions

constructor()

public "renderGuiIcon"(arg0: $MobEffectInstance$Type, arg1: $Gui$Type, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: float, arg6: float): boolean
public "isVisibleInGui"(arg0: $MobEffectInstance$Type): boolean
public "isVisibleInInventory"(arg0: $MobEffectInstance$Type): boolean
public "renderInventoryIcon"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
public static "of"(arg0: $MobEffectInstance$Type): $IClientMobEffectExtensions
public static "of"(arg0: $MobEffect$Type): $IClientMobEffectExtensions
public "renderInventoryText"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectUnRenderer$Type = ($EffectUnRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectUnRenderer_ = $EffectUnRenderer$Type;
}}
declare module "packages/se/mickelus/mutil/util/$TileEntityOptional" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $TileEntityOptional {

constructor()

public static "from"<T>(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Class$Type<(T)>): $Optional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityOptional$Type = ($TileEntityOptional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityOptional_ = $TileEntityOptional$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$HasImprovementRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $HasImprovementRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HasImprovementRequirement$Type = ($HasImprovementRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HasImprovementRequirement_ = $HasImprovementRequirement$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$DisabledSlot" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $DisabledSlot extends $Slot {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(arg0: $Container$Type, arg1: integer, arg2: integer, arg3: integer)

public "mayPlace"(arg0: $ItemStack$Type): boolean
public "mayPickup"(arg0: $Player$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisabledSlot$Type = ($DisabledSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisabledSlot_ = $DisabledSlot$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$LootOutcome" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $LootOutcome implements $InteractionOutcome {

constructor()

public "apply"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootOutcome$Type = ($LootOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootOutcome_ = $LootOutcome$Type;
}}
declare module "packages/se/mickelus/mutil/gui/impl/$GuiHorizontalScrollable" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $GuiHorizontalScrollable extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "getOffset"(): double
public "setOffset"(arg0: double): void
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "addChild"(arg0: $GuiElement$Type): void
public "markDirty"(): void
public "setGlobal"(arg0: boolean): $GuiHorizontalScrollable
public "onMouseScroll"(arg0: double, arg1: double, arg2: double): boolean
public "clearChildren"(): void
public "getOffsetMax"(): integer
public "forceRefreshBounds"(): void
get "offset"(): double
set "offset"(value: double)
set "global"(value: boolean)
get "offsetMax"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiHorizontalScrollable$Type = ($GuiHorizontalScrollable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiHorizontalScrollable_ = $GuiHorizontalScrollable$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$GenericTrigger" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$Type} from "packages/net/minecraft/advancements/critereon/$SimpleCriterionTrigger"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$AbstractCriterionTriggerInstance, $AbstractCriterionTriggerInstance$Type} from "packages/net/minecraft/advancements/critereon/$AbstractCriterionTriggerInstance"
import {$GenericTrigger$TriggerDeserializer, $GenericTrigger$TriggerDeserializer$Type} from "packages/se/mickelus/tetra/advancements/$GenericTrigger$TriggerDeserializer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GenericTrigger<T extends $AbstractCriterionTriggerInstance> extends $SimpleCriterionTrigger<(T)> {

constructor(arg0: string, arg1: $GenericTrigger$TriggerDeserializer$Type<(T)>)

public "fulfillCriterion"(arg0: $ServerPlayer$Type, arg1: $Predicate$Type<(T)>): void
public "getId"(): $ResourceLocation
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericTrigger$Type<T> = ($GenericTrigger<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericTrigger_<T> = $GenericTrigger$Type<(T)>;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloCrossGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $HoloCrossGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: float)

public "animateOpen"(): void
public "animateReopen"(): void
public "stopAnimations"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloCrossGui$Type = ($HoloCrossGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloCrossGui_ = $HoloCrossGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$GuiBarBooster" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiBarBooster extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setFuel"(arg0: float): void
set "fuel"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiBarBooster$Type = ($GuiBarBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiBarBooster_ = $GuiBarBooster$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$EquipToolbeltItemPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$ToolbeltSlotType, $ToolbeltSlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltSlotType"

export class $EquipToolbeltItemPacket extends $AbstractPacket {

constructor()
constructor(arg0: $ToolbeltSlotType$Type, arg1: integer, arg2: $InteractionHand$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EquipToolbeltItemPacket$Type = ($EquipToolbeltItemPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EquipToolbeltItemPacket_ = $EquipToolbeltItemPacket$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteraction" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PerformSide, $PerformSide$Type} from "packages/se/mickelus/tetra/interactions/$PerformSide"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $SecondaryInteraction {

 "getKey"(): string
 "perform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): void
 "canPerform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
 "getPerformSide"(): $PerformSide
 "getLabel"(): string
}

export namespace $SecondaryInteraction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteraction$Type = ($SecondaryInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteraction_ = $SecondaryInteraction$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$EarthboundPotionEffect" {
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $EarthboundPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $EarthboundPotionEffect

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EarthboundPotionEffect$Type = ($EarthboundPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EarthboundPotionEffect_ = $EarthboundPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorBaseBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$IHeatTransfer, $IHeatTransfer$Type} from "packages/se/mickelus/tetra/blocks/$IHeatTransfer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CoreExtractorBaseBlockEntity extends $BlockEntity implements $IHeatTransfer {
static "type": $BlockEntityType<($CoreExtractorBaseBlockEntity)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "fill"(arg0: integer): integer
public "transfer"(): void
public "tick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "drain"(arg0: integer): integer
public "canRefill"(): boolean
public "isSending"(): boolean
public "setSending"(arg0: boolean): void
public "getCharge"(): integer
public "getFacing"(): $Direction
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "updateTransferState"(): void
public "setReceiving"(arg0: boolean): void
public "isReceiving"(): boolean
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEfficiency"(): float
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
public "canSend"(): boolean
public "canRecieve"(): boolean
public "getReceiveLimit"(): integer
public "getSendLimit"(): integer
get "sending"(): boolean
set "sending"(value: boolean)
get "charge"(): integer
get "facing"(): $Direction
get "updatePacket"(): $ClientboundBlockEntityDataPacket
set "receiving"(value: boolean)
get "receiving"(): boolean
get "efficiency"(): float
get "updateTag"(): $CompoundTag
get "receiveLimit"(): integer
get "sendLimit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorBaseBlockEntity$Type = ($CoreExtractorBaseBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorBaseBlockEntity_ = $CoreExtractorBaseBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterStability" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterStability implements $IStatGetter {

constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterStability$Type = ($StatGetterStability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterStability_ = $StatGetterStability$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterFocus" {
import {$StatGetterSpread, $StatGetterSpread$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterSpread"

export class $StatGetterFocus extends $StatGetterSpread {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterFocus$Type = ($StatGetterFocus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterFocus_ = $StatGetterFocus$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$PristineLapisItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PristineLapisItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PristineLapisItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PristineLapisItem$Type = ($PristineLapisItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PristineLapisItem_ = $PristineLapisItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$ExtractorProjectileEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$IEntityAdditionalSpawnData, $IEntityAdditionalSpawnData$Type} from "packages/net/minecraftforge/entity/$IEntityAdditionalSpawnData"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractArrow, $AbstractArrow$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow"
import {$IntOpenHashSet, $IntOpenHashSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntOpenHashSet"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AbstractArrow$Pickup, $AbstractArrow$Pickup$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow$Pickup"
import {$PlayMessages$SpawnEntity, $PlayMessages$SpawnEntity$Type} from "packages/net/minecraftforge/network/$PlayMessages$SpawnEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"

export class $ExtractorProjectileEntity extends $AbstractArrow implements $IEntityAdditionalSpawnData {
static readonly "unlocalizedName": string
static readonly "damageKey": string
static readonly "heatKey": string
static "type": $EntityType<($ExtractorProjectileEntity)>
 "pickup": $AbstractArrow$Pickup
 "shakeTime": integer
 "piercingIgnoreEntityIds": $IntOpenHashSet
 "ownerUUID": $UUID
 "cachedOwner": $Entity
 "leftOwner": boolean
 "hasBeenShot": boolean
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $PlayMessages$SpawnEntity$Type, arg1: $Level$Type)
constructor(arg0: $Level$Type, arg1: double, arg2: double, arg3: double)
constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)
constructor(arg0: $Level$Type, arg1: $LivingEntity$Type, arg2: $ItemStack$Type)

public "isPickable"(): boolean
public "tick"(): void
public "onGround"(): boolean
public "playerTouch"(arg0: $Player$Type): void
public "readAdditionalSaveData"(arg0: $CompoundTag$Type): void
public "addAdditionalSaveData"(arg0: $CompoundTag$Type): void
public "m_6901_"(): void
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
public "writeSpawnData"(arg0: $FriendlyByteBuf$Type): void
public "readSpawnData"(arg0: $FriendlyByteBuf$Type): void
public "interactAt"(arg0: $Player$Type, arg1: $Vec3$Type, arg2: $InteractionHand$Type): $InteractionResult
get "pickable"(): boolean
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtractorProjectileEntity$Type = ($ExtractorProjectileEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtractorProjectileEntity_ = $ExtractorProjectileEntity$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ExecuteEffect" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ExecuteEffect extends $ChargedAbilityEffect {
static readonly "instance": $ExecuteEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExecuteEffect$Type = ($ExecuteEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExecuteEffect_ = $ExecuteEffect$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$ImprovementCraftCriterion" {
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$AbstractCriterionTriggerInstance, $AbstractCriterionTriggerInstance$Type} from "packages/net/minecraft/advancements/critereon/$AbstractCriterionTriggerInstance"
import {$MinMaxBounds$Ints, $MinMaxBounds$Ints$Type} from "packages/net/minecraft/advancements/critereon/$MinMaxBounds$Ints"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GenericTrigger, $GenericTrigger$Type} from "packages/se/mickelus/tetra/advancements/$GenericTrigger"
import {$ContextAwarePredicate, $ContextAwarePredicate$Type} from "packages/net/minecraft/advancements/critereon/$ContextAwarePredicate"

export class $ImprovementCraftCriterion extends $AbstractCriterionTriggerInstance {
static readonly "trigger": $GenericTrigger<($ImprovementCraftCriterion)>

constructor(arg0: $ContextAwarePredicate$Type, arg1: $ItemPredicate$Type, arg2: $ItemPredicate$Type, arg3: string, arg4: string, arg5: string, arg6: integer, arg7: $ToolAction$Type, arg8: $MinMaxBounds$Ints$Type)

public "test"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string, arg3: string, arg4: string, arg5: integer, arg6: $ToolAction$Type, arg7: integer): boolean
public static "trigger"(arg0: $ServerPlayer$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string, arg5: string, arg6: integer, arg7: $ToolAction$Type, arg8: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImprovementCraftCriterion$Type = ($ImprovementCraftCriterion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImprovementCraftCriterion_ = $ImprovementCraftCriterion$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$UtilBooster" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $UtilBooster {
static readonly "activeKey": string
static readonly "chargedKey": string
static readonly "fuelKey": string
static readonly "bufferKey": string
static readonly "cooldownKey": string
static readonly "fuelCapacity": integer
static readonly "fuelCost": integer
static readonly "fuelCostCharged": integer
static readonly "fuelRecharge": integer
static readonly "cooldownTicks": integer
static readonly "gunpowderGain": integer
static readonly "boostStrength": float
static readonly "chargedBoostStrength": float
static readonly "boostLevelMultiplier": float

constructor()

public static "isActive"(arg0: $CompoundTag$Type): boolean
public static "setActive"(arg0: $CompoundTag$Type, arg1: boolean, arg2: boolean): void
public static "rechargeFuel"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public static "getBoosterLevel"(arg0: $ItemStack$Type): integer
public static "hasFuel"(arg0: $CompoundTag$Type, arg1: boolean): boolean
public static "boostPlayerCharged"(arg0: $Player$Type, arg1: $CompoundTag$Type, arg2: integer): void
public static "boostPlayer"(arg0: $Player$Type, arg1: $CompoundTag$Type, arg2: integer): void
public static "getFuel"(arg0: $CompoundTag$Type): integer
public static "hasBooster"(arg0: $Player$Type): boolean
public static "boostHorizontal"(arg0: $Player$Type): void
public static "consumeFuel"(arg0: $CompoundTag$Type, arg1: integer): void
public static "consumeFuel"(arg0: $CompoundTag$Type, arg1: boolean): void
public static "canBoost"(arg0: $ItemStack$Type): boolean
public static "getFuelPercent"(arg0: $CompoundTag$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilBooster$Type = ($UtilBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UtilBooster_ = $UtilBooster$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$PropertyMatcherDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$PropertyMatcher, $PropertyMatcher$Type} from "packages/se/mickelus/tetra/blocks/$PropertyMatcher"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $PropertyMatcherDeserializer implements $JsonDeserializer<($PropertyMatcher)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $PropertyMatcher
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyMatcherDeserializer$Type = ($PropertyMatcherDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyMatcherDeserializer_ = $PropertyMatcherDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/util/$ToolActionHelper" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BiMap, $BiMap$Type} from "packages/com/google/common/collect/$BiMap"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $ToolActionHelper {
static readonly "appropriateTools": $BiMap<($ToolAction), ($TagKey<($Block)>)>
static readonly "hoeExtraTag": $TagKey<($Block)>
static readonly "cuttingDestroyTags": $Set<($TagKey<($Block)>)>
static readonly "cuttingHarvestBlocks": $Set<($Block)>
static readonly "hammerMineable": $TagKey<($Block)>

constructor()

public static "init"(): void
public static "playerCanDestroyBlock"(arg0: $Player$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $ItemStack$Type): boolean
public static "playerCanDestroyBlock"(arg0: $Player$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $ItemStack$Type, arg4: $ToolAction$Type): boolean
public static "getAppropriateTools"(arg0: $BlockState$Type): $Set<($ToolAction)>
public static "isEffectiveOn"(arg0: $ToolAction$Type, arg1: $BlockState$Type): boolean
public static "isEffectiveOn"(arg0: $ItemStack$Type, arg1: $BlockState$Type): boolean
public static "getAppropriateTool"(arg0: $BlockState$Type): $ToolAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolActionHelper$Type = ($ToolActionHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolActionHelper_ = $ToolActionHelper$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$StonecutterItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StonecutterItem extends $TetraItem {
static readonly "identifier": string
static "instance": $StonecutterItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StonecutterItem$Type = ($StonecutterItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StonecutterItem_ = $StonecutterItem$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$ApplyListOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ApplyListOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyListOutcome$Type = ($ApplyListOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyListOutcome_ = $ApplyListOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/crossbow/$ModularCrossbowItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ModularItem, $ModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$ModularItem"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularCrossbowItem extends $ModularItem {
static readonly "staveKey": string
static readonly "stockKey": string
static readonly "stringKey": string
static readonly "attachmentAKey": string
static readonly "attachmentBKey": string
static readonly "identifier": string
static readonly "velocityFactor": double
static "instance": $ModularCrossbowItem
static "multishotDefaultSpread": double
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Type)

public "isLoaded"(arg0: $ItemStack$Type): boolean
public "clientInit"(): void
public "getModels"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): $ImmutableList<($ModuleModel)>
public static "getProjectileVelocity"(arg0: double, arg1: float): float
public "updateConfig"(arg0: integer, arg1: integer): void
public "setLoaded"(arg0: $ItemStack$Type, arg1: boolean): void
public "getReloadDuration"(arg0: $ItemStack$Type): integer
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getProgress"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): float
public "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "getUseDuration"(arg0: $ItemStack$Type): integer
public "hasProjectiles"(arg0: $ItemStack$Type, arg1: $Item$Type): boolean
public "onUseTick"(arg0: $Level$Type, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): void
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "canBeDepleted"(): boolean
public "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "getUseAnimation"(arg0: $ItemStack$Type): $UseAnim
public "useOnRelease"(arg0: $ItemStack$Type): boolean
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularCrossbowItem$Type = ($ModularCrossbowItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularCrossbowItem_ = $ModularCrossbowItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSlotMajorGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"

export class $HoloSlotMajorGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $GuiAttachment$Type, arg3: string, arg4: string, arg5: $Consumer$Type<(string)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSlotMajorGui$Type = ($HoloSlotMajorGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSlotMajorGui_ = $HoloSlotMajorGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$ICraftingEffectProviderBlock" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ICraftingEffectProviderBlock {

 "canUnlockCraftingEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
 "getCraftingEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
}

export namespace $ICraftingEffectProviderBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICraftingEffectProviderBlock$Type = ($ICraftingEffectProviderBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICraftingEffectProviderBlock_ = $ICraftingEffectProviderBlock$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SeveringEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $SeveringEffect {

constructor()

public static "perform"(arg0: $ItemStack$Type, arg1: integer, arg2: $LivingEntity$Type, arg3: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeveringEffect$Type = ($SeveringEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeveringEffect_ = $SeveringEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$PryEffect" {
import {$AbilityUseResult, $AbilityUseResult$Type} from "packages/se/mickelus/tetra/effect/$AbilityUseResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $PryEffect {
static readonly "flatCooldown": double
static readonly "cooldownSpeedMultiplier": double
static readonly "damageMultiplier": double

constructor()

public static "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: integer, arg5: $LivingEntity$Type): void
public static "performDefensive"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: $LivingEntity$Type): $AbilityUseResult
public static "performRegular"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: double, arg4: integer, arg5: $LivingEntity$Type, arg6: boolean, arg7: integer): $AbilityUseResult
public static "performEcho"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: double, arg4: integer, arg5: $LivingEntity$Type, arg6: boolean, arg7: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PryEffect$Type = ($PryEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PryEffect_ = $PryEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$StrikingEffect" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"

export class $StrikingEffect {
static readonly "effectActionMap": $List<($Pair<($ItemEffect), ($ToolAction)>)>

constructor()

public static "causeEffect"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemModularHandheld$Type, arg3: $Level$Type, arg4: $BlockPos$Type, arg5: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrikingEffect$Type = ($StrikingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StrikingEffect_ = $StrikingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$RepairInstance" {
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $RepairInstance extends $Record {

constructor(definitions: $Collection$Type<($RepairDefinition$Type)>, module: $ItemModule$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "module"(): $ItemModule
public "definitions"(): $Collection<($RepairDefinition)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairInstance$Type = ($RepairInstance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairInstance_ = $RepairInstance$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiActionButton" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$WorkbenchAction, $WorkbenchAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GuiActionButton extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $WorkbenchAction$Type, arg3: $ItemStack$Type, arg4: $Consumer$Type<($WorkbenchAction$Type)>)
constructor(arg0: integer, arg1: integer, arg2: $WorkbenchAction$Type, arg3: $ItemStack$Type, arg4: $GuiAlignment$Type, arg5: $Consumer$Type<($WorkbenchAction$Type)>)

public "update"(arg0: $Map$Type<($ToolAction$Type), (integer)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiActionButton$Type = ($GuiActionButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiActionButton_ = $GuiActionButton$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerMenu" {
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ForgedContainerBlockEntity, $ForgedContainerBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerBlockEntity"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $ForgedContainerMenu extends $AbstractContainerMenu {
static "type": $RegistryObject<($MenuType<($ForgedContainerMenu)>)>
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(arg0: integer, arg1: $ForgedContainerBlockEntity$Type, arg2: $Container$Type, arg3: $Player$Type)

public static "create"(arg0: integer, arg1: $BlockPos$Type, arg2: $Inventory$Type): $ForgedContainerMenu
public "changeCompartment"(arg0: integer): void
public "stillValid"(arg0: $Player$Type): boolean
public "getTile"(): $ForgedContainerBlockEntity
public "quickMoveStack"(arg0: $Player$Type, arg1: integer): $ItemStack
get "tile"(): $ForgedContainerBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerMenu$Type = ($ForgedContainerMenu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerMenu_ = $ForgedContainerMenu$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$OrRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $OrRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrRequirement$Type = ($OrRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrRequirement_ = $OrRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedPlatformSlabBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InitializableBlock, $InitializableBlock$Type} from "packages/se/mickelus/tetra/blocks/$InitializableBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$SlabType, $SlabType$Type} from "packages/net/minecraft/world/level/block/state/properties/$SlabType"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SlabBlock, $SlabBlock$Type} from "packages/net/minecraft/world/level/block/$SlabBlock"

export class $ForgedPlatformSlabBlock extends $SlabBlock implements $InitializableBlock {
static readonly "identifier": string
static readonly "TYPE": $EnumProperty<($SlabType)>
static readonly "WATERLOGGED": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedPlatformSlabBlock$Type = ($ForgedPlatformSlabBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedPlatformSlabBlock_ = $ForgedPlatformSlabBlock$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$HoloScanRootGui" {
import {$HoloRootBaseGui, $HoloRootBaseGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloRootBaseGui"

export class $HoloScanRootGui extends $HoloRootBaseGui {

constructor(arg0: integer, arg1: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloScanRootGui$Type = ($HoloScanRootGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloScanRootGui_ = $HoloScanRootGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$OutcomeStack" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $OutcomeStack {

constructor(arg0: $UpgradeSchematic$Type, arg1: $OutcomePreview$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "previewEquals"(arg0: $OutcomePreview$Type): boolean
public "schematicEquals"(arg0: $UpgradeSchematic$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutcomeStack$Type = ($OutcomeStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutcomeStack_ = $OutcomeStack$Type;
}}
declare module "packages/se/mickelus/tetra/properties/$IToolProvider" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IToolProvider {

 "onActionConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
 "getToolLevels"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
 "getToolEfficiency"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): float
 "getToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
 "getTools"(arg0: $ItemStack$Type): $Set<($ToolAction)>
 "getToolData"(arg0: $ItemStack$Type): $ToolData
 "onCraftConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
 "canProvideTools"(arg0: $ItemStack$Type): boolean
}

export namespace $IToolProvider {
const logger: $Logger
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IToolProvider$Type = ($IToolProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IToolProvider_ = $IToolProvider$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiItem$CountMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $GuiItem$CountMode extends $Enum<($GuiItem$CountMode)> {
static readonly "normal": $GuiItem$CountMode
static readonly "always": $GuiItem$CountMode
static readonly "never": $GuiItem$CountMode


public static "values"(): ($GuiItem$CountMode)[]
public static "valueOf"(arg0: string): $GuiItem$CountMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiItem$CountMode$Type = (("always") | ("normal") | ("never")) | ($GuiItem$CountMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiItem$CountMode_ = $GuiItem$CountMode$Type;
}}
declare module "packages/se/mickelus/tetra/$TetraMod" {
import {$RegisterCommandsEvent, $RegisterCommandsEvent$Type} from "packages/net/minecraftforge/event/$RegisterCommandsEvent"
import {$GatherDataEvent, $GatherDataEvent$Type} from "packages/net/minecraftforge/data/event/$GatherDataEvent"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"

export class $TetraMod {
static readonly "MOD_ID": string
static "instance": $TetraMod
static "packetHandler": $PacketHandler

constructor()

public "setup"(arg0: $FMLCommonSetupEvent$Type): void
public static "onGatherData"(arg0: $GatherDataEvent$Type): void
public "registerCommands"(arg0: $RegisterCommandsEvent$Type): void
set "up"(value: $FMLCommonSetupEvent$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraMod$Type = ($TetraMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraMod_ = $TetraMod$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$BaseSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BaseSchematic implements $UpgradeSchematic {

constructor()

public "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "checkTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
public "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getSeverity"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): float
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "getRequiredTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Collection<($ToolAction)>
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "isHoning"(): boolean
public "getRarity"(): $SchematicRarity
public "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "getNumMaterialSlots"(): integer
public "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
public "getApplicableMaterials"(): (string)[]
public "matchesRequirements"(arg0: $CraftingContext$Type): boolean
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "getMaterialTranslation"(): $MaterialMultiplier
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "honing"(): boolean
get "rarity"(): $SchematicRarity
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
get "applicableMaterials"(): (string)[]
get "materialTranslation"(): $MaterialMultiplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseSchematic$Type = ($BaseSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseSchematic_ = $BaseSchematic$Type;
}}
declare module "packages/se/mickelus/mutil/gui/impl/$GuiColors" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GuiColors {
static readonly "normal": integer
static readonly "add": integer
static readonly "remove": integer
static readonly "change": integer
static readonly "hover": integer
static readonly "selected": integer
static readonly "muted": integer
static readonly "hoverMuted": integer
static readonly "warning": integer
static readonly "negative": integer
static readonly "positive": integer
static readonly "separator": integer

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiColors$Type = ($GuiColors);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiColors_ = $GuiColors$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$UpdateBoosterPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $UpdateBoosterPacket extends $AbstractPacket {

constructor(arg0: boolean, arg1: boolean)
constructor(arg0: boolean)
constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpdateBoosterPacket$Type = ($UpdateBoosterPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpdateBoosterPacket_ = $UpdateBoosterPacket$Type;
}}
declare module "packages/se/mickelus/tetra/util/$Lherper" {
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"

export class $Lherper {

constructor()

public static "easeIn"(arg0: float): float
public static "easeOut"(arg0: float): float
public static "lerpColors"(arg0: float, ...arg1: ($Vector3f$Type)[]): $Vector3f
public static "lerpColors"(arg0: float, ...arg1: (integer)[]): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lherper$Type = ($Lherper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lherper_ = $Lherper$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBarIntegrity" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiStatBase, $GuiStatBase$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"

export class $GuiStatBarIntegrity extends $GuiStatBase {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): void
public "setAlignment"(arg0: $GuiAlignment$Type): void
public "getTooltipLines"(): $List<($Component)>
public "updateValue"(arg0: double, arg1: double): void
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
set "alignment"(value: $GuiAlignment$Type)
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatBarIntegrity$Type = ($GuiStatBarIntegrity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatBarIntegrity_ = $GuiStatBarIntegrity$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$ModularModelLoader" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$UnresolvedItemModel, $UnresolvedItemModel$Type} from "packages/se/mickelus/tetra/client/model/$UnresolvedItemModel"
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"

export class $ModularModelLoader implements $IGeometryLoader<($UnresolvedItemModel)> {

constructor()

public static "init"(): void
public "read"(arg0: $JsonObject$Type, arg1: $JsonDeserializationContext$Type): $UnresolvedItemModel
public static "clearCaches"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularModelLoader$Type = ($ModularModelLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularModelLoader_ = $ModularModelLoader$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$IHeatTransfer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHeatTransfer {

 "fill"(arg0: integer): integer
 "drain"(arg0: integer): integer
 "isSending"(): boolean
 "setSending"(arg0: boolean): void
 "getCharge"(): integer
 "updateTransferState"(): void
 "setReceiving"(arg0: boolean): void
 "isReceiving"(): boolean
 "getEfficiency"(): float
 "canSend"(): boolean
 "canRecieve"(): boolean
 "getReceiveLimit"(): integer
 "getSendLimit"(): integer
}

export namespace $IHeatTransfer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHeatTransfer$Type = ($IHeatTransfer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHeatTransfer_ = $IHeatTransfer$Type;
}}
declare module "packages/se/mickelus/tetra/levelgen/$MultiblockSchematicProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $MultiblockSchematicProcessor extends $StructureProcessor {
static readonly "INSTANCE": $MultiblockSchematicProcessor
static readonly "codec": $Codec<($MultiblockSchematicProcessor)>
static "type": $RegistryObject<($StructureProcessorType<(any)>)>

constructor()

public "process"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type, arg6: $StructureTemplate$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicProcessor$Type = ($MultiblockSchematicProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicProcessor_ = $MultiblockSchematicProcessor$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$ToolData" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$TierData, $TierData$Type} from "packages/se/mickelus/tetra/module/data/$TierData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ToolData extends $TierData<($ToolAction)> {
 "levelMap": $Map<(T), (float)>
 "efficiencyMap": $Map<(T), (float)>

constructor()

public static "merge"(arg0: $ToolData$Type, arg1: $ToolData$Type): $ToolData
public static "merge"(arg0: $Collection$Type<($ToolData$Type)>): $ToolData
public static "multiply"(arg0: $ToolData$Type, arg1: float, arg2: float): $ToolData
public static "offsetLevel"(arg0: $ToolData$Type, arg1: float, arg2: integer): $ToolData
public static "overwrite"(arg0: $ToolData$Type, arg1: $ToolData$Type): $ToolData
public static "retainMax"(arg0: $Collection$Type<($ToolData$Type)>): $ToolData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolData$Type = ($ToolData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolData_ = $ToolData$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollTile" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$ScrollData, $ScrollData$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollData"

export class $ScrollTile extends $BlockEntity {
static readonly "identifier": string
static "type": $BlockEntityType<($ScrollTile)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "addScroll"(arg0: $ItemStack$Type): boolean
public "isIntricate"(): boolean
public "getItemTags"(): ($CompoundTag)[]
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public "getCraftingEffects"(): ($ResourceLocation)[]
public "getSchematics"(): ($ResourceLocation)[]
public "getScrolls"(): ($ScrollData)[]
public "getUpdateTag"(): $CompoundTag
get "intricate"(): boolean
get "itemTags"(): ($CompoundTag)[]
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "renderBoundingBox"(): $AABB
get "craftingEffects"(): ($ResourceLocation)[]
get "schematics"(): ($ResourceLocation)[]
get "scrolls"(): ($ScrollData)[]
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollTile$Type = ($ScrollTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollTile_ = $ScrollTile$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/$GuiBlockProgress" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"

export class $GuiBlockProgress extends $GuiRoot {

constructor(arg0: $Minecraft$Type)

public "draw"(arg0: $GuiGraphics$Type): void
public "setProgress"(arg0: float): void
set "progress"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiBlockProgress$Type = ($GuiBlockProgress);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiBlockProgress_ = $GuiBlockProgress$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchContainer" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $WorkbenchContainer extends $AbstractContainerMenu {
static "containerType": $RegistryObject<($MenuType<($WorkbenchContainer)>)>
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(arg0: integer, arg1: $WorkbenchTile$Type, arg2: $Container$Type, arg3: $Player$Type)

public static "create"(arg0: integer, arg1: $BlockPos$Type, arg2: $Inventory$Type): $WorkbenchContainer
public "updateSlots"(): void
public "getTileEntity"(): $WorkbenchTile
public static "getSlotOffsetY"(arg0: integer, arg1: integer): integer
public "stillValid"(arg0: $Player$Type): boolean
public "quickMoveStack"(arg0: $Player$Type, arg1: integer): $ItemStack
get "tileEntity"(): $WorkbenchTile
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchContainer$Type = ($WorkbenchContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchContainer_ = $WorkbenchContainer$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$PlanarStabilizerItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PlanarStabilizerItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PlanarStabilizerItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlanarStabilizerItem$Type = ($PlanarStabilizerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlanarStabilizerItem_ = $PlanarStabilizerItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$FracturedBedrockBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $FracturedBedrockBlock extends $TetraBlock implements $EntityBlock {
static readonly "identifier": string
static "instance": $FracturedBedrockBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public static "pierce"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: integer): void
public static "canPierce"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FracturedBedrockBlock$Type = ($FracturedBedrockBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FracturedBedrockBlock_ = $FracturedBedrockBlock$Type;
}}
declare module "packages/se/mickelus/tetra/effect/revenge/$RemoveRevengePacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $RemoveRevengePacket extends $AbstractPacket {

constructor(arg0: $Entity$Type)
constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveRevengePacket$Type = ($RemoveRevengePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveRevengePacket_ = $RemoveRevengePacket$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$MeshItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MeshItem extends $TetraItem {
static readonly "identifier": string
static "instance": $MeshItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MeshItem$Type = ($MeshItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MeshItem_ = $MeshItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$LungeEffect" {
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LungeEffect$LungeData, $LungeEffect$LungeData$Type} from "packages/se/mickelus/tetra/effect/$LungeEffect$LungeData"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LungeEffect extends $ChargedAbilityEffect {
static readonly "instance": $LungeEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $BlockPos$Type, arg6: $Vec3$Type, arg7: integer): void
public static "onPlayerTick"(arg0: $Player$Type): void
public static "echo"(arg0: $Player$Type, arg1: $LungeEffect$LungeData$Type, arg2: boolean): void
public "getChargeTime"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type): integer
public static "receiveEchoPacket"(arg0: $Player$Type, arg1: boolean): void
public static "onJump"(arg0: $LocalPlayer$Type): void
public static "onRightClick"(arg0: $LocalPlayer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LungeEffect$Type = ($LungeEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LungeEffect_ = $LungeEffect$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$GenericTrigger$TriggerDeserializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$DeserializationContext, $DeserializationContext$Type} from "packages/net/minecraft/advancements/critereon/$DeserializationContext"
import {$ContextAwarePredicate, $ContextAwarePredicate$Type} from "packages/net/minecraft/advancements/critereon/$ContextAwarePredicate"

export interface $GenericTrigger$TriggerDeserializer<T> {

 "apply"(arg0: $JsonObject$Type, arg1: $ContextAwarePredicate$Type, arg2: $DeserializationContext$Type): T

(arg0: $JsonObject$Type, arg1: $ContextAwarePredicate$Type, arg2: $DeserializationContext$Type): T
}

export namespace $GenericTrigger$TriggerDeserializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericTrigger$TriggerDeserializer$Type<T> = ($GenericTrigger$TriggerDeserializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericTrigger$TriggerDeserializer_<T> = $GenericTrigger$TriggerDeserializer$Type<(T)>;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $UpgradeSchematic {

 "getName"(): string
 "getKey"(): string
 "getType"(): $SchematicType
 "getSeverity"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): float
 "getDescription"(arg0: $ItemStack$Type): string
 "getSources"(): (string)[]
 "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
 "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
 "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
 "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
 "isRelevant"(arg0: $ItemStack$Type): boolean
 "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
 "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
 "checkTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $Map$Type<($ToolAction$Type), (integer)>): boolean
 "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
 "getRequiredTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Collection<($ToolAction)>
 "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
 "isHoning"(): boolean
 "getRarity"(): $SchematicRarity
 "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
 "getGlyph"(): $GlyphData
 "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
 "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
 "getNumMaterialSlots"(): integer
 "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
 "getApplicableMaterials"(): (string)[]
 "matchesRequirements"(arg0: $CraftingContext$Type): boolean
 "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
 "getMaterialTranslation"(): $MaterialMultiplier
 "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
 "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
}

export namespace $UpgradeSchematic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeSchematic$Type = ($UpgradeSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeSchematic_ = $UpgradeSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/transfer/$TransferUnitBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$IHeatTransfer, $IHeatTransfer$Type} from "packages/se/mickelus/tetra/blocks/$IHeatTransfer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $TransferUnitBlockEntity extends $BlockEntity implements $IHeatTransfer {
static "type": $RegistryObject<($BlockEntityType<($TransferUnitBlockEntity)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "fill"(arg0: integer): integer
public "transfer"(): void
public "drain"(arg0: integer): integer
public "putCell"(arg0: $ItemStack$Type): boolean
public "hasCell"(): boolean
public "removeCell"(): $ItemStack
public "isSending"(): boolean
public "setSending"(arg0: boolean): void
public "getCharge"(): integer
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "updateTransferState"(): void
public "setReceiving"(arg0: boolean): void
public "isReceiving"(): boolean
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "serverTick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "getEfficiency"(): float
public "getCell"(): $ItemStack
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
public "canSend"(): boolean
public static "writeCell"(arg0: $CompoundTag$Type, arg1: $ItemStack$Type): void
public "canRecieve"(): boolean
public "getReceiveLimit"(): integer
public "getSendLimit"(): integer
get "sending"(): boolean
set "sending"(value: boolean)
get "charge"(): integer
get "updatePacket"(): $ClientboundBlockEntityDataPacket
set "receiving"(value: boolean)
get "receiving"(): boolean
get "efficiency"(): float
get "cell"(): $ItemStack
get "updateTag"(): $CompoundTag
get "receiveLimit"(): integer
get "sendLimit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransferUnitBlockEntity$Type = ($TransferUnitBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransferUnitBlockEntity_ = $TransferUnitBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IStatSorter {

 "getName"(): string
 "compare"<T>(arg0: $Player$Type, arg1: $Function$Type<(any), ($ItemStack$Type)>): $Comparator<(T)>
 "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): string
 "getWeight"(arg0: $Player$Type, arg1: $ItemStack$Type): integer
}

export namespace $IStatSorter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStatSorter$Type = ($IStatSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStatSorter_ = $IStatSorter$Type;
}}
declare module "packages/se/mickelus/mutil/data/$DataStore" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SimplePreparableReloadListener, $SimplePreparableReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$SimplePreparableReloadListener"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DataStore<V> extends $SimplePreparableReloadListener<($Map<($ResourceLocation), ($JsonElement)>)> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $Class$Type<(V)>, arg4: $DataDistributor$Type)

public "getData"(): $Map<($ResourceLocation), (V)>
public "getData"(arg0: $ResourceLocation$Type): V
public "sendToPlayer"(arg0: $ServerPlayer$Type): void
public "onReload"(arg0: $Runnable$Type): void
public "parseData"(arg0: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
public "getRawData"(): $Map<($ResourceLocation), ($JsonElement)>
public "getDirectory"(): string
public "loadFromPacket"(arg0: $Map$Type<($ResourceLocation$Type), (string)>): void
public "getDataIn"(arg0: $ResourceLocation$Type): $Collection<(V)>
get "data"(): $Map<($ResourceLocation), (V)>
get "rawData"(): $Map<($ResourceLocation), ($JsonElement)>
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataStore$Type<V> = ($DataStore<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataStore_<V> = $DataStore$Type<(V)>;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterPercentageDecimal" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterPercentageDecimal implements $ITooltipGetter {

constructor(arg0: string, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterPercentageDecimal$Type = ($TooltipGetterPercentageDecimal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterPercentageDecimal_ = $TooltipGetterPercentageDecimal$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$VerticalTabButtonGui" {
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $VerticalTabButtonGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: string, arg4: $Runnable$Type, arg5: boolean)

public "setActive"(arg0: boolean): void
public "setHasContent"(arg0: boolean): void
set "active"(value: boolean)
set "hasContent"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalTabButtonGui$Type = ($VerticalTabButtonGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VerticalTabButtonGui_ = $VerticalTabButtonGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$RepairSchematic" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$BaseSchematic, $BaseSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$BaseSchematic"

export class $RepairSchematic extends $BaseSchematic {

constructor(arg0: $IModularItem$Type, arg1: string)

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getSlot"(arg0: $ItemStack$Type): string
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
public "getNumMaterialSlots"(): integer
public "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairSchematic$Type = ($RepairSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairSchematic_ = $RepairSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ModularItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Cache, $Cache$Type} from "packages/com/google/common/cache/$Cache"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IToolProvider, $IToolProvider$Type} from "packages/se/mickelus/tetra/properties/$IToolProvider"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$SynergyData, $SynergyData$Type} from "packages/se/mickelus/tetra/module/data/$SynergyData"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularItem extends $TetraItem implements $IModularItem, $IToolProvider {
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "getItem"(): $Item
public "clearCaches"(): void
public "getAttributeModifierCache"(): $Cache<(string), ($Multimap<($Attribute), ($AttributeModifier)>)>
public "canGainHoneProgress"(arg0: $ItemStack$Type): boolean
public "getHoneIntegrityMultiplier"(arg0: $ItemStack$Type): integer
public "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
public "getEnchantmentValue"(arg0: $ItemStack$Type): integer
public "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
public "getBarColor"(arg0: $ItemStack$Type): integer
public "getBarWidth"(arg0: $ItemStack$Type): integer
public "onCraftedBy"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Player$Type): void
public "getName"(arg0: $ItemStack$Type): $Component
public "isFoil"(arg0: $ItemStack$Type): boolean
public "getRarity"(arg0: $ItemStack$Type): $Rarity
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "getMaxDamage"(arg0: $ItemStack$Type): integer
public "isBookEnchantable"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public "setDamage"(arg0: $ItemStack$Type, arg1: integer): void
public "damageItem"<T extends $LivingEntity>(arg0: $ItemStack$Type, arg1: integer, arg2: T, arg3: $Consumer$Type<(T)>): integer
public "getEffectDataCache"(): $Cache<(string), ($EffectData)>
public "getRequiredModules"(arg0: $ItemStack$Type): (string)[]
public "getToolDataCache"(): $Cache<(string), ($ToolData)>
public "getToolData"(arg0: $ItemStack$Type): $ToolData
public "getPropertyCache"(): $Cache<(string), ($ItemProperties)>
public "getHoneBase"(arg0: $ItemStack$Type): integer
public "getMinorModuleKeys"(arg0: $ItemStack$Type): (string)[]
public "getMajorModuleKeys"(arg0: $ItemStack$Type): (string)[]
public "getAllSynergyData"(arg0: $ItemStack$Type): ($SynergyData)[]
public "canProvideTools"(arg0: $ItemStack$Type): boolean
public "getProperties"(arg0: $ItemStack$Type): $ItemProperties
public "getIdentifier"(arg0: $ItemStack$Type): string
public "getAttributeValue"(arg0: $ItemStack$Type, arg1: $Attribute$Type, arg2: double): double
public "getAttributeValue"(arg0: $ItemStack$Type, arg1: $Attribute$Type): double
public "getModels"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): $ImmutableList<($ModuleModel)>
public "hasVariantSynergy"(arg0: $SynergyData$Type, arg1: (string)[]): boolean
public "hasModuleSynergy"(arg0: $ItemStack$Type, arg1: $SynergyData$Type, arg2: ($ItemModule$Type)[]): boolean
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "tickProgression"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): void
public "applyDamage"(arg0: integer, arg1: $ItemStack$Type, arg2: $LivingEntity$Type): void
public "isBroken"(arg0: integer, arg1: integer): boolean
public "isBroken"(arg0: $ItemStack$Type): boolean
public "applyUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
public "getTransformVariant"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public "getAttributeModifiersCached"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getEffectDataCached"(arg0: $ItemStack$Type): $EffectData
public "hasImprovementSynergy"(arg0: $SynergyData$Type, arg1: (string)[]): boolean
public "getAttributeModifiersCollapsed"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getEffectAttributes"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getEffectEfficiency"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): float
public "getModuleAttributes"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getDisplayNamePrefixes"(arg0: $ItemStack$Type): string
public "getMajorModuleNames"(arg0: $ItemStack$Type): (string)[]
public static "getImprovementDescription"(arg0: string): string
public "getRepairRequiredExperience"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): integer
public "tickHoningProgression"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): void
public "getRepairMaterialCount"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): integer
public "getRepairModuleName"(arg0: $ItemStack$Type): string
public "getRepairRequiredTools"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Collection<($ToolAction)>
public "getRepairRequiredToolLevels"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getRepairDefinitions"(arg0: $ItemStack$Type): $Collection<($RepairDefinition)>
public "getStabilityModifier"(arg0: $ItemStack$Type): float
public "applyNegativeUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
public "applyPositiveUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
public "applyDestabilizationEffects"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: float): void
public "incrementRepairCount"(arg0: $ItemStack$Type): void
public "getHoningIntegrityPenalty"(arg0: $ItemStack$Type): integer
public "getImprovementTooltip"(arg0: string, arg1: integer, arg2: boolean): string
public "getRepairRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ToolAction$Type): integer
public "getMinorModuleNames"(arg0: $ItemStack$Type): (string)[]
public "getAttributeModifiers"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getTooltip"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $TooltipFlag$Type): $List<($Component)>
public "assemble"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: float): void
public "getAllModules"(arg0: $ItemStack$Type): $Collection<($ItemModule)>
public "getDataCacheKey"(arg0: $ItemStack$Type): string
public "getSynergyData"(arg0: $ItemStack$Type): ($SynergyData)[]
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public "getEnchantability"(arg0: $ItemStack$Type): integer
public "acceptsEnchantment"(arg0: $ItemStack$Type, arg1: $Enchantment$Type, arg2: boolean): boolean
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public "getDefaultStack"(): $ItemStack
public "getNumMajorModules"(arg0: $ItemStack$Type): integer
public "getNumMinorModules"(arg0: $ItemStack$Type): integer
public "isModuleRequired"(arg0: $ItemStack$Type, arg1: string): boolean
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public "hasModule"(arg0: $ItemStack$Type, arg1: $ItemModule$Type): boolean
public "getMinorModules"(arg0: $ItemStack$Type): ($ItemModule)[]
public static "getImprovementName"(arg0: string, arg1: integer): string
public "getMajorModules"(arg0: $ItemStack$Type): ($ItemModuleMajor)[]
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public "getHonedCount"(arg0: $ItemStack$Type): integer
public "getReducedDamage"(arg0: integer, arg1: $ItemStack$Type, arg2: $LivingEntity$Type): integer
public "getModuleFromSlot"(arg0: $ItemStack$Type, arg1: string): $ItemModule
public "getRepairModule"(arg0: $ItemStack$Type): $Optional<($ItemModule)>
public "getRepairCount"(arg0: $ItemStack$Type): integer
public "getRepairCycle"(arg0: $ItemStack$Type): ($ItemModule)[]
public "getRepairAmount"(arg0: $ItemStack$Type): integer
public "fixIdentifiers"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public "getImprovements"(arg0: $ItemStack$Type): ($ImprovementData)[]
public "getPropertiesCached"(arg0: $ItemStack$Type): $ItemProperties
public "getItemName"(arg0: $ItemStack$Type): string
public "setHoningProgress"(arg0: $ItemStack$Type, arg1: integer): void
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public "getHoningLimit"(arg0: $ItemStack$Type): integer
public "getHoningProgress"(arg0: $ItemStack$Type): integer
public "getRepairSlot"(arg0: $ItemStack$Type): string
public "repair"(arg0: $ItemStack$Type): void
public "tweak"(arg0: $ItemStack$Type, arg1: string, arg2: $Map$Type<(string), (integer)>): void
public "getEffectData"(arg0: $ItemStack$Type): $EffectData
public "getEffects"(arg0: $ItemStack$Type): $Collection<($ItemEffect)>
public "getEffectLevel"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): integer
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
public "getTags"(arg0: $ItemStack$Type): $Set<($TagKey<($Item)>)>
public "onActionConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public "getToolLevels"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getToolEfficiency"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): float
public "getToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
public "getTools"(arg0: $ItemStack$Type): $Set<($ToolAction)>
public "onCraftConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
get "item"(): $Item
get "attributeModifierCache"(): $Cache<(string), ($Multimap<($Attribute), ($AttributeModifier)>)>
get "effectDataCache"(): $Cache<(string), ($EffectData)>
get "toolDataCache"(): $Cache<(string), ($ToolData)>
get "propertyCache"(): $Cache<(string), ($ItemProperties)>
get "defaultStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularItem$Type = ($ModularItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularItem_ = $ModularItem$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatFormat" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $StatFormat {
static readonly "noDecimal": $StatFormat
static readonly "oneDecimal": $StatFormat
static readonly "twoDecimal": $StatFormat
static readonly "abbreviate": $StatFormat

constructor(arg0: string)

public "get"(arg0: double): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatFormat$Type = ($StatFormat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatFormat_ = $StatFormat$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$HolosphereActionGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HolosphereActionGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: string, arg5: $Runnable$Type)

public "perform"(): void
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereActionGui$Type = ($HolosphereActionGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereActionGui_ = $HolosphereActionGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleMinorBackdrop" {
import {$GuiModuleBackdrop, $GuiModuleBackdrop$Type} from "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleBackdrop"

export class $GuiModuleMinorBackdrop extends $GuiModuleBackdrop {

constructor(arg0: integer, arg1: integer, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleMinorBackdrop$Type = ($GuiModuleMinorBackdrop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleMinorBackdrop_ = $GuiModuleMinorBackdrop$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$FocusEffect" {
import {$TickEvent$PlayerTickEvent, $TickEvent$PlayerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$PlayerTickEvent"
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $FocusEffect {

constructor()

public static "onPlayerTick"(arg0: $TickEvent$PlayerTickEvent$Type): void
public static "isDrawing"(arg0: $Player$Type): boolean
public static "onLivingDamage"(arg0: $LivingDamageEvent$Type): void
public static "getSpreadReduction"(arg0: $Player$Type, arg1: $ItemStack$Type): float
public static "onFireArrow"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public static "hasApplicableItem"(arg0: $LivingEntity$Type): boolean
public static "isApplicableItem"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FocusEffect$Type = ($FocusEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FocusEffect_ = $FocusEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiTweakSlider" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TweakData, $TweakData$Type} from "packages/se/mickelus/tetra/module/data/$TweakData"

export class $GuiTweakSlider extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $TweakData$Type, arg4: $Consumer$Type<(integer)>)

public "setValue"(arg0: integer): void
public "getTooltipLines"(): $List<($Component)>
set "value"(value: integer)
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTweakSlider$Type = ($GuiTweakSlider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTweakSlider_ = $GuiTweakSlider$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$UniqueOutcomeDefinition" {
import {$OutcomeDefinition, $OutcomeDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeDefinition"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$OutcomeMaterial, $OutcomeMaterial$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UniqueOutcomeDefinition extends $OutcomeDefinition {
 "material": $OutcomeMaterial
 "hidden": boolean
 "materialSlot": integer
 "experienceCost": integer
 "requiredTools": $ToolData
 "moduleKey": string
 "moduleVariant": string
 "improvements": $Map<(string), (integer)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueOutcomeDefinition$Type = ($UniqueOutcomeDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniqueOutcomeDefinition_ = $UniqueOutcomeDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ApplyUsageEffectsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ApplyUsageEffectsEvent extends $Event {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double)

public "getUsingEntity"(): $LivingEntity
public "isCancelable"(): boolean
public "getNegativeMultiplier"(): double
public "getPositiveMultiplier"(): double
public "getItemStack"(): $ItemStack
public "setPositiveMultiplier"(arg0: double): void
public "setNegativeMultiplier"(arg0: double): void
public "getOriginalPositiveMultiplier"(): double
public "getOriginalNegativeMultiplier"(): double
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "usingEntity"(): $LivingEntity
get "cancelable"(): boolean
get "negativeMultiplier"(): double
get "positiveMultiplier"(): double
get "itemStack"(): $ItemStack
set "positiveMultiplier"(value: double)
set "negativeMultiplier"(value: double)
get "originalPositiveMultiplier"(): double
get "originalNegativeMultiplier"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyUsageEffectsEvent$Type = ($ApplyUsageEffectsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyUsageEffectsEvent_ = $ApplyUsageEffectsEvent$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/$CraftingProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CraftingProperties {
 "stabilityOffset": integer
 "stabilityMultiplier": float
 "destabilizationOffset": float
 "xpOffset": integer
 "xpMultiplier": float

constructor()

public static "merge"(arg0: $CraftingProperties$Type, arg1: $CraftingProperties$Type): $CraftingProperties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingProperties$Type = ($CraftingProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingProperties_ = $CraftingProperties$Type;
}}
declare module "packages/se/mickelus/mutil/util/$HexCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$MapCodec, $MapCodec$Type} from "packages/com/mojang/serialization/$MapCodec"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/com/mojang/serialization/codecs/$UnboundedMapCodec"
import {$MapEncoder, $MapEncoder$Type} from "packages/com/mojang/serialization/$MapEncoder"
import {$PrimitiveCodec, $PrimitiveCodec$Type} from "packages/com/mojang/serialization/codecs/$PrimitiveCodec"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Encoder, $Encoder$Type} from "packages/com/mojang/serialization/$Encoder"
import {$Codec$ResultFunction, $Codec$ResultFunction$Type} from "packages/com/mojang/serialization/$Codec$ResultFunction"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Decoder, $Decoder$Type} from "packages/com/mojang/serialization/$Decoder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Lifecycle, $Lifecycle$Type} from "packages/com/mojang/serialization/$Lifecycle"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Decoder$Boxed, $Decoder$Boxed$Type} from "packages/com/mojang/serialization/$Decoder$Boxed"
import {$MapDecoder, $MapDecoder$Type} from "packages/com/mojang/serialization/$MapDecoder"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Decoder$Simple, $Decoder$Simple$Type} from "packages/com/mojang/serialization/$Decoder$Simple"
import {$SimpleMapCodec, $SimpleMapCodec$Type} from "packages/com/mojang/serialization/codecs/$SimpleMapCodec"
import {$Decoder$Terminal, $Decoder$Terminal$Type} from "packages/com/mojang/serialization/$Decoder$Terminal"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"

export class $HexCodec implements $PrimitiveCodec<(integer)> {
static readonly "instance": $HexCodec

constructor()

public "toString"(): string
public "write"<T>(arg0: $DynamicOps$Type<(T)>, arg1: integer): T
public "read"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<(integer)>
public "decode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<($Pair<(integer), (T)>)>
public "encode"<T>(arg0: integer, arg1: $DynamicOps$Type<(T)>, arg2: T): $DataResult<(T)>
public "dispatch"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $Codec<(E)>
public "dispatch"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(E)>
public static "of"<A>(arg0: $MapEncoder$Type<(integer)>, arg1: $MapDecoder$Type<(integer)>, arg2: $Supplier$Type<(string)>): $MapCodec<(integer)>
public static "of"<A>(arg0: $MapEncoder$Type<(integer)>, arg1: $MapDecoder$Type<(integer)>): $MapCodec<(integer)>
public static "of"<A>(arg0: $Encoder$Type<(integer)>, arg1: $Decoder$Type<(integer)>, arg2: string): $Codec<(integer)>
public static "of"<A>(arg0: $Encoder$Type<(integer)>, arg1: $Decoder$Type<(integer)>): $Codec<(integer)>
public static "list"<E>(arg0: $Codec$Type<(E)>): $Codec<($List<(E)>)>
public "orElse"(arg0: integer): $Codec<(integer)>
public "orElse"(arg0: $UnaryOperator$Type<(string)>, arg1: integer): $Codec<(integer)>
public "orElse"(arg0: $Consumer$Type<(string)>, arg1: integer): $Codec<(integer)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(arg0: N, arg1: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(arg0: integer): $Codec<(integer)>
public static "unit"<A>(arg0: $Supplier$Type<(integer)>): $Codec<(integer)>
public "orElseGet"(arg0: $Supplier$Type<(any)>): $Codec<(integer)>
public "orElseGet"(arg0: $Consumer$Type<(string)>, arg1: $Supplier$Type<(any)>): $Codec<(integer)>
public "orElseGet"(arg0: $UnaryOperator$Type<(string)>, arg1: $Supplier$Type<(any)>): $Codec<(integer)>
public static "pair"<F, S>(arg0: $Codec$Type<(F)>, arg1: $Codec$Type<(S)>): $Codec<($Pair<(F), (S)>)>
public "xmap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "optionalField"<F>(arg0: string, arg1: $Codec$Type<(F)>): $MapCodec<($Optional<(F)>)>
public "deprecated"(arg0: integer): $Codec<(integer)>
public "withLifecycle"(arg0: $Lifecycle$Type): $Codec<(integer)>
public "optionalFieldOf"(arg0: string): $MapCodec<($Optional<(integer)>)>
public "optionalFieldOf"(arg0: string, arg1: integer, arg2: $Lifecycle$Type): $MapCodec<(integer)>
public "optionalFieldOf"(arg0: string, arg1: $Lifecycle$Type, arg2: integer, arg3: $Lifecycle$Type): $MapCodec<(integer)>
public "optionalFieldOf"(arg0: string, arg1: integer): $MapCodec<(integer)>
public "mapResult"(arg0: $Codec$ResultFunction$Type<(integer)>): $Codec<(integer)>
public "flatXmap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public "promotePartial"(arg0: $Consumer$Type<(string)>): $Codec<(integer)>
public "partialDispatch"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $Codec<(E)>
public "dispatchMap"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $MapCodec<(E)>
public "dispatchMap"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $MapCodec<(E)>
public static "compoundList"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>): $Codec<($List<($Pair<(K), (V)>)>)>
public static "either"<F, S>(arg0: $Codec$Type<(F)>, arg1: $Codec$Type<(S)>): $Codec<($Either<(F), (S)>)>
public static "mapPair"<F, S>(arg0: $MapCodec$Type<(F)>, arg1: $MapCodec$Type<(S)>): $MapCodec<($Pair<(F), (S)>)>
public static "mapEither"<F, S>(arg0: $MapCodec$Type<(F)>, arg1: $MapCodec$Type<(S)>): $MapCodec<($Either<(F), (S)>)>
public "dispatchStable"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(E)>
public "comapFlatMap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "unboundedMap"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "simpleMap"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>, arg2: $Keyable$Type): $SimpleMapCodec<(K), (V)>
public static "doubleRange"(arg0: double, arg1: double): $Codec<(double)>
public static "floatRange"(arg0: float, arg1: float): $Codec<(float)>
public static "intRange"(arg0: integer, arg1: integer): $Codec<(integer)>
public "listOf"(): $Codec<($List<(integer)>)>
public "stable"(): $Codec<(integer)>
public static "empty"<A>(): $MapEncoder<(integer)>
public static "error"<A>(arg0: string): $Encoder<(integer)>
public "flatComap"<B>(arg0: $Function$Type<(any), (any)>): $Encoder<(B)>
public "comap"<B>(arg0: $Function$Type<(any), (any)>): $Encoder<(B)>
public "encodeStart"<T>(arg0: $DynamicOps$Type<(T)>, arg1: integer): $DataResult<(T)>
public "decode"<T>(arg0: $Dynamic$Type<(T)>): $DataResult<($Pair<(integer), (T)>)>
public "map"<B>(arg0: $Function$Type<(any), (any)>): $Decoder<(B)>
public "flatMap"<B>(arg0: $Function$Type<(any), (any)>): $Decoder<(B)>
public "parse"<T>(arg0: $Dynamic$Type<(T)>): $DataResult<(integer)>
public "parse"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<(integer)>
public "boxed"(): $Decoder$Boxed<(integer)>
public "simple"(): $Decoder$Simple<(integer)>
public static "ofBoxed"<A>(arg0: $Decoder$Boxed$Type<(any)>): $Decoder<(integer)>
public static "ofTerminal"<A>(arg0: $Decoder$Terminal$Type<(any)>): $Decoder<(integer)>
public static "ofSimple"<A>(arg0: $Decoder$Simple$Type<(any)>): $Decoder<(integer)>
public "terminal"(): $Decoder$Terminal<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HexCodec$Type = ($HexCodec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HexCodec_ = $HexCodec$Type;
}}
declare module "packages/se/mickelus/mutil/scheduling/$ServerScheduler" {
import {$AbstractScheduler, $AbstractScheduler$Type} from "packages/se/mickelus/mutil/scheduling/$AbstractScheduler"
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"

export class $ServerScheduler extends $AbstractScheduler {

constructor()

public "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScheduler$Type = ($ServerScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerScheduler_ = $ServerScheduler$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiAlignment" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"

export class $GuiAlignment extends $Enum<($GuiAlignment)> {
static readonly "left": $GuiAlignment
static readonly "center": $GuiAlignment
static readonly "right": $GuiAlignment


public static "values"(): ($GuiAlignment)[]
public static "valueOf"(arg0: string): $GuiAlignment
public "flip"(): $GuiAlignment
public "toAttachment"(): $GuiAttachment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiAlignment$Type = (("left") | ("center") | ("right")) | ($GuiAlignment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiAlignment_ = $GuiAlignment$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPistonUpdatePacket" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $CoreExtractorPistonUpdatePacket extends $BlockPosPacket {

constructor()
constructor(arg0: $BlockPos$Type, arg1: long)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorPistonUpdatePacket$Type = ($CoreExtractorPistonUpdatePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorPistonUpdatePacket_ = $CoreExtractorPistonUpdatePacket$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$ItemProperties" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"

export class $ItemProperties {
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

public static "merge"(arg0: $ItemProperties$Type, arg1: $ItemProperties$Type): $ItemProperties
public "multiply"(arg0: float): $ItemProperties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemProperties$Type = ($ItemProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemProperties_ = $ItemProperties$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/$HoloPage" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HoloPage extends $Enum<($HoloPage)> {
static readonly "craft": $HoloPage
static readonly "structures": $HoloPage
static readonly "system": $HoloPage
 "label": string


public static "values"(): ($HoloPage)[]
public static "valueOf"(arg0: string): $HoloPage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloPage$Type = (("system") | ("craft") | ("structures")) | ($HoloPage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloPage_ = $HoloPage$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterReaching" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$StatGetterEffectLevel, $StatGetterEffectLevel$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectLevel"

export class $StatGetterReaching extends $StatGetterEffectLevel {

constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterReaching$Type = ($StatGetterReaching);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterReaching_ = $StatGetterReaching$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleGlyph" {
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiTexture, $GuiTexture$Type} from "packages/se/mickelus/mutil/gui/$GuiTexture"

export class $GuiModuleGlyph extends $GuiTexture {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $GlyphData$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $GlyphData$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: $ResourceLocation$Type)

public "setShift"(arg0: boolean): $GuiModuleGlyph
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
set "shift"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleGlyph$Type = ($GuiModuleGlyph);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleGlyph_ = $GuiModuleGlyph$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialDetailGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"

export class $HoloMaterialDetailGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "update"(arg0: $MaterialData$Type, arg1: $MaterialData$Type): void
public "hide"(): void
public "animateOpen"(): void
public "show"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialDetailGui$Type = ($HoloMaterialDetailGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialDetailGui_ = $HoloMaterialDetailGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/particle/$SparkleParticle" {
import {$SimpleAnimatedParticle, $SimpleAnimatedParticle$Type} from "packages/net/minecraft/client/particle/$SimpleAnimatedParticle"

export class $SparkleParticle extends $SimpleAnimatedParticle {
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float


public "move"(arg0: double, arg1: double, arg2: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkleParticle$Type = ($SparkleParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkleParticle_ = $SparkleParticle$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/unlocks/$UnlockData" {
import {$PropertyMatcher, $PropertyMatcher$Type} from "packages/se/mickelus/tetra/blocks/$PropertyMatcher"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $UnlockData {
 "schematics": ($ResourceLocation)[]
 "effects": ($ResourceLocation)[]
 "block": $PropertyMatcher
 "bounds": $AABB

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnlockData$Type = ($UnlockData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnlockData_ = $UnlockData$Type;
}}
declare module "packages/se/mickelus/tetra/$ConfigHandler" {
import {$ForgeConfigSpec$BooleanValue, $ForgeConfigSpec$BooleanValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue"
import {$ForgeConfigSpec$DoubleValue, $ForgeConfigSpec$DoubleValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$DoubleValue"
import {$ForgeConfigSpec$IntValue, $ForgeConfigSpec$IntValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$IntValue"
import {$ModConfigEvent$Reloading, $ModConfigEvent$Reloading$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Reloading"
import {$ForgeConfigSpec, $ForgeConfigSpec$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$ModConfigEvent$Loading, $ModConfigEvent$Loading$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Loading"

export class $ConfigHandler {
static "spec": $ForgeConfigSpec
static "development": $ForgeConfigSpec$BooleanValue
static "toolbeltCurioOnly": $ForgeConfigSpec$BooleanValue
static "experimentalFeatures": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "disabledFeatures": $ForgeConfigSpec$ConfigValue<($List<(any)>)>
static "moduleProgression": $ForgeConfigSpec$BooleanValue
static "settleLimitBase": $ForgeConfigSpec$IntValue
static "settleLimitLevelMultiplier": $ForgeConfigSpec$DoubleValue
static "settleLimitDurabilityMultiplier": $ForgeConfigSpec$DoubleValue
static "magicCapacityMultiplier": $ForgeConfigSpec$DoubleValue
static "honeSwordBase": $ForgeConfigSpec$IntValue
static "honeSwordIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "honedoubleBase": $ForgeConfigSpec$IntValue
static "honedoubleIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "honeSingleBase": $ForgeConfigSpec$IntValue
static "honeSingleIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "honeBowBase": $ForgeConfigSpec$IntValue
static "honeBowIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "honeCrossbowBase": $ForgeConfigSpec$IntValue
static "honeCrossbowIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "honeShieldBase": $ForgeConfigSpec$IntValue
static "honeShieldIntegrityMultiplier": $ForgeConfigSpec$IntValue
static "enableBow": $ForgeConfigSpec$BooleanValue
static "enableCrossbow": $ForgeConfigSpec$BooleanValue
static "enableSingle": $ForgeConfigSpec$BooleanValue
static "enableShield": $ForgeConfigSpec$BooleanValue
static "enableGlint": $ForgeConfigSpec$BooleanValue
static "enableExtractor": $ForgeConfigSpec$BooleanValue

constructor()

public static "setup"(): void
public static "onReload"(arg0: $ModConfigEvent$Reloading$Type): void
public static "onLoad"(arg0: $ModConfigEvent$Loading$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigHandler$Type = ($ConfigHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigHandler_ = $ConfigHandler$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$ModuleCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModuleCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleCondition$Type = ($ModuleCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleCondition_ = $ModuleCondition$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloCraftRootGui" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$HoloRootBaseGui, $HoloRootBaseGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloRootBaseGui"

export class $HoloCraftRootGui extends $HoloRootBaseGui {
static readonly "backBinding": character

constructor(arg0: integer, arg1: integer)

public "onReload"(): void
public "updateState"(arg0: $IModularItem$Type, arg1: $ItemStack$Type, arg2: string, arg3: $UpgradeSchematic$Type): void
public "animateOpen"(): void
public "onCharType"(arg0: character, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloCraftRootGui$Type = ($HoloCraftRootGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloCraftRootGui_ = $HoloCraftRootGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/$ModularBladedItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularBladedItem extends $ItemModularHandheld {
static readonly "bladeKey": string
static readonly "hiltKey": string
static readonly "guardKey": string
static readonly "pommelKey": string
static readonly "fullerKey": string
static readonly "identifier": string
static "instance": $ModularBladedItem
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "updateConfig"(arg0: integer, arg1: integer): void
public static "createItemStack"(arg0: string, arg1: string, arg2: string): $ItemStack
public "getTransformVariant"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public "commonInit"(arg0: $PacketHandler$Type): void
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public static "getCreativeTabItemStacks"(): $Collection<($ItemStack)>
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
get "creativeTabItemStacks"(): $Collection<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularBladedItem$Type = ($ModularBladedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularBladedItem_ = $ModularBladedItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SweepingStrikeEffect" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SweepingStrikeEffect {

constructor()

public static "causeTruesweepEffect"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public static "causeEffect"(arg0: $Level$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $BlockPos$Type, arg4: $ToolAction$Type): void
public static "breakBlocksAround"(arg0: $Level$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $BlockPos$Type, arg4: $ToolAction$Type, arg5: boolean): $List<($Pair<(integer), ($BlockPos)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweepingStrikeEffect$Type = ($SweepingStrikeEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SweepingStrikeEffect_ = $SweepingStrikeEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/$BlockProgressOverlay" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $BlockProgressOverlay implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockProgressOverlay$Type = ($BlockProgressOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockProgressOverlay_ = $BlockProgressOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/aspect/$TetraEnchantmentHelper$EnchantmentRules" {
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"

export class $TetraEnchantmentHelper$EnchantmentRules {

constructor(arg0: string, arg1: string, ...arg2: ($EnchantmentCategory$Type)[])

public "isApplicable"(arg0: $Enchantment$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraEnchantmentHelper$EnchantmentRules$Type = ($TetraEnchantmentHelper$EnchantmentRules);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraEnchantmentHelper$EnchantmentRules_ = $TetraEnchantmentHelper$EnchantmentRules$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloBreadcrumbsGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export class $HoloBreadcrumbsGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Consumer$Type<(integer)>)

public "animateOpen"(arg0: boolean): void
public "setItems"(arg0: (string)[]): void
set "items"(value: (string)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloBreadcrumbsGui$Type = ($HoloBreadcrumbsGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloBreadcrumbsGui_ = $HoloBreadcrumbsGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/$TetraItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$InitializableItem, $InitializableItem$Type} from "packages/se/mickelus/tetra/items/$InitializableItem"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TetraItem extends $Item implements $InitializableItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraItem$Type = ($TetraItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraItem_ = $TetraItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$ComboPointGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $ComboPointGui extends $GuiElement {

constructor()

public "update"(arg0: integer): void
public "update"(arg0: $Player$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComboPointGui$Type = ($ComboPointGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComboPointGui_ = $ComboPointGui$Type;
}}
declare module "packages/se/mickelus/mutil/util/$ItemHandlerWrapper" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $ItemHandlerWrapper implements $Container {

constructor(arg0: $IItemHandler$Type)

public "setChanged"(): void
public "getItem"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "clearContent"(): void
public "isEmpty"(): boolean
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stillValid"(arg0: $Player$Type): boolean
public "stopOpen"(arg0: $Player$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHandlerWrapper$Type = ($ItemHandlerWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHandlerWrapper_ = $ItemHandlerWrapper$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$EnumTierData" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnumTierData<T extends $Enum<(any)>> {
 "levelMap": $Map<(T), (integer)>
 "efficiencyMap": $Map<(T), (float)>

constructor()

public "contains"(arg0: T): boolean
public "getLevel"(arg0: T): integer
public "getEfficiency"(arg0: T): float
public "getValues"(): $Set<(T)>
get "values"(): $Set<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumTierData$Type<T> = ($EnumTierData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumTierData_<T> = $EnumTierData$Type<(T)>;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiStringOutline" {
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiString, $GuiString$Type} from "packages/se/mickelus/mutil/gui/$GuiString"

export class $GuiStringOutline extends $GuiString {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string)
constructor(arg0: integer, arg1: integer, arg2: string)

public "setString"(arg0: string): void
set "string"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStringOutline$Type = ($GuiStringOutline);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStringOutline_ = $GuiStringOutline$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/crossbow/$CrossbowOverlay" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $CrossbowOverlay implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrossbowOverlay$Type = ($CrossbowOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrossbowOverlay_ = $CrossbowOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$ModuleModelDeserializer" {
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"

export class $ModuleModelDeserializer implements $JsonDeserializer<($ModuleModel)> {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleModelDeserializer$Type = ($ModuleModelDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleModelDeserializer_ = $ModuleModelDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialListGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $HoloMaterialListGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "reload"(): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "animateOpen"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialListGui$Type = ($HoloMaterialListGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialListGui_ = $HoloMaterialListGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ModuleDevCommand" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $ModuleDevCommand {

constructor()

public static "register"(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>, arg1: $CommandBuildContext$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleDevCommand$Type = ($ModuleDevCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleDevCommand_ = $ModuleDevCommand$Type;
}}
declare module "packages/se/mickelus/mutil/util/$InventoryStream" {
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $InventoryStream {

constructor()

public static "of"(arg0: $Container$Type): $Stream<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryStream$Type = ($InventoryStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryStream_ = $InventoryStream$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ReachingEffect" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$PlayerEvent$BreakSpeed, $PlayerEvent$BreakSpeed$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed"

export class $ReachingEffect {

constructor()

public static "getOffset"(arg0: integer, arg1: double): float
public static "getMultiplier"(arg0: integer, arg1: double, arg2: float): float
public static "onLivingDamage"(arg0: $LivingDamageEvent$Type, arg1: integer, arg2: float): void
public static "onBreakSpeed"(arg0: $PlayerEvent$BreakSpeed$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReachingEffect$Type = ($ReachingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReachingEffect_ = $ReachingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"

export class $HoloMaterialGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: $List$Type<($MaterialData$Type)>, arg4: integer, arg5: $Consumer$Type<($MaterialData$Type)>, arg6: $Consumer$Type<($MaterialData$Type)>, arg7: $Consumer$Type<($MaterialData$Type)>)

public "updateSelection"(arg0: $MaterialData$Type): void
public "animateIn"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialGroupGui$Type = ($HoloMaterialGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialGroupGui_ = $HoloMaterialGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerEffect" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $HammerEffect extends $Enum<($HammerEffect)> implements $StringRepresentable {
static readonly "efficient": $HammerEffect
static readonly "power": $HammerEffect
static readonly "precise": $HammerEffect
static readonly "reliable": $HammerEffect


public static "values"(): ($HammerEffect)[]
public static "valueOf"(arg0: string): $HammerEffect
public "getItem"(): $Item
public "getSerializedName"(): string
public static "fromItem"(arg0: $Item$Type): $HammerEffect
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "item"(): $Item
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerEffect$Type = (("reliable") | ("efficient") | ("power") | ("precise")) | ($HammerEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerEffect_ = $HammerEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$StackedMultiblockSchematicItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BaseMultiblockSchematicItem, $BaseMultiblockSchematicItem$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$BaseMultiblockSchematicItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MultiblockSchematicBlock, $MultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicBlock"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StackedMultiblockSchematicItem extends $BaseMultiblockSchematicItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $MultiblockSchematicBlock$Type, arg1: $Block$Type)

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackedMultiblockSchematicItem$Type = ($StackedMultiblockSchematicItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackedMultiblockSchematicItem_ = $StackedMultiblockSchematicItem$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$RepairDefinition" {
import {$OutcomeDefinition, $OutcomeDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeDefinition"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$OutcomeMaterial, $OutcomeMaterial$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial"

export class $RepairDefinition {
 "material": $OutcomeMaterial
 "requiredTools": $ToolData
 "moduleKey": string
 "moduleVariant": string
 "experienceCost": integer
 "replace": boolean

constructor(arg0: $OutcomeDefinition$Type)

public static "validateOutcome"(arg0: $OutcomeDefinition$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairDefinition$Type = ($RepairDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairDefinition_ = $RepairDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSortButton" {
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloSortButton extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<($IStatSorter$Type)>)

public "update"(arg0: ($OutcomePreview$Type)[]): void
public "reset"(): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onCharType"(arg0: character, arg1: integer): boolean
public "getTooltipLines"(): $List<($Component)>
public "hasFocus"(): boolean
public "isBlockingFocus"(): boolean
get "tooltipLines"(): $List<($Component)>
get "blockingFocus"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSortButton$Type = ($HoloSortButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSortButton_ = $HoloSortButton$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/bow/$ModularBowItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ModularItem, $ModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$ModularItem"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractArrow, $AbstractArrow$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ArrowItem, $ArrowItem$Type} from "packages/net/minecraft/world/item/$ArrowItem"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularBowItem extends $ModularItem {
static readonly "staveKey": string
static readonly "stringKey": string
static readonly "riserKey": string
static readonly "identifier": string
static readonly "velocityFactor": double
static "instance": $ModularBowItem
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "clientInit"(): void
public "getModels"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): $ImmutableList<($ModuleModel)>
public "updateConfig"(arg0: integer, arg1: integer): void
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getProgress"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): float
public static "fireProjectile"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $ArrowItem$Type, arg3: $ItemStack$Type, arg4: $ImmutableList$Type<($Function$Type<($AbstractArrow$Type), ($AbstractArrow$Type)>)>, arg5: $Player$Type, arg6: float, arg7: float, arg8: float, arg9: float, arg10: integer, arg11: double, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: boolean, arg17: boolean): void
public static "getArrowVelocity"(arg0: integer, arg1: double, arg2: float, arg3: boolean): float
public "getOverbowProgress"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): float
public "getDrawDuration"(arg0: $ItemStack$Type): integer
public "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "getUseDuration"(arg0: $ItemStack$Type): integer
public "onUseTick"(arg0: $Level$Type, arg1: $LivingEntity$Type, arg2: $ItemStack$Type, arg3: integer): void
public "finishUsingItem"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type): $ItemStack
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "canBeDepleted"(): boolean
public "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "getUseAnimation"(arg0: $ItemStack$Type): $UseAnim
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularBowItem$Type = ($ModularBowItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularBowItem_ = $ModularBowItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$SteeledPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SteeledPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SteeledPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SteeledPotionEffect$Type = ($SteeledPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SteeledPotionEffect_ = $SteeledPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$HolosphereBlockEntity$ScanResult, $HolosphereBlockEntity$ScanResult$Type} from "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlockEntity$ScanResult"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $HolosphereBlockEntity extends $BlockEntity {
static readonly "maxRange": integer
static "type": $RegistryObject<($BlockEntityType<($HolosphereBlockEntity)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "use"(arg0: integer, arg1: float, arg2: float): void
public "inScanMode"(): boolean
public "setItemTag"(arg0: $CompoundTag$Type): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getItemStack"(): $ItemStack
public "getScanModeTimestamp"(): long
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public "getScanResults"(): $List<($HolosphereBlockEntity$ScanResult)>
public "canScan"(): boolean
public "toggleScanMode"(arg0: boolean): void
public "getItemTag"(): $CompoundTag
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
set "itemTag"(value: $CompoundTag$Type)
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "itemStack"(): $ItemStack
get "scanModeTimestamp"(): long
get "renderBoundingBox"(): $AABB
get "scanResults"(): $List<($HolosphereBlockEntity$ScanResult)>
get "itemTag"(): $CompoundTag
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereBlockEntity$Type = ($HolosphereBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereBlockEntity_ = $HolosphereBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $TetraWaterloggedBlock extends $TetraBlock implements $SimpleWaterloggedBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraWaterloggedBlock$Type = ($TetraWaterloggedBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraWaterloggedBlock_ = $TetraWaterloggedBlock$Type;
}}
declare module "packages/se/mickelus/mutil/data/deserializer/$BlockPosDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPosDeserializer implements $JsonDeserializer<($BlockPos)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPosDeserializer$Type = ($BlockPosDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPosDeserializer_ = $BlockPosDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/transfer/$EnumTransferState" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $EnumTransferState extends $Enum<($EnumTransferState)> implements $StringRepresentable {
static readonly "sending": $EnumTransferState
static readonly "receiving": $EnumTransferState
static readonly "none": $EnumTransferState


public static "values"(): ($EnumTransferState)[]
public static "valueOf"(arg0: string): $EnumTransferState
public "getSerializedName"(): string
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumTransferState$Type = (("receiving") | ("sending") | ("none")) | ($EnumTransferState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumTransferState_ = $EnumTransferState$Type;
}}
declare module "packages/se/mickelus/tetra/effect/revenge/$AddRevengePacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AddRevengePacket extends $AbstractPacket {

constructor(arg0: $Entity$Type)
constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddRevengePacket$Type = ($AddRevengePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddRevengePacket_ = $AddRevengePacket$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ModularShieldItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularShieldItem extends $ItemModularHandheld {
static readonly "plateKey": string
static readonly "gripKey": string
static readonly "bossKey": string
static readonly "identifier": string
static readonly "bannerImprovementKey": string
static "instance": $ModularShieldItem
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "clientInit"(): void
public "updateConfig"(arg0: integer, arg1: integer): void
public "getCooldownBase"(arg0: $ItemStack$Type): double
public "initializeClient"(arg0: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "getAbilityBaseDamage"(arg0: $ItemStack$Type): double
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularShieldItem$Type = ($ModularShieldItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularShieldItem_ = $ModularShieldItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/dynamic/$ArchetypeSlotDefinition" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $ArchetypeSlotDefinition extends $Record {

constructor(key: string, major: boolean, required: boolean, x: integer, y: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "x"(): integer
public "key"(): string
public "y"(): integer
public "major"(): boolean
public "required"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArchetypeSlotDefinition$Type = ($ArchetypeSlotDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArchetypeSlotDefinition_ = $ArchetypeSlotDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$OverlayGuiBooster" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"

export class $OverlayGuiBooster extends $GuiRoot {

constructor(arg0: $Minecraft$Type)

public "setFuel"(arg0: float): void
set "fuel"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverlayGuiBooster$Type = ($OverlayGuiBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverlayGuiBooster_ = $OverlayGuiBooster$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/bow/$ProjectileMotionPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $ProjectileMotionPacket extends $AbstractPacket {

constructor()
constructor(arg0: $Projectile$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProjectileMotionPacket$Type = ($ProjectileMotionPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProjectileMotionPacket_ = $ProjectileMotionPacket$Type;
}}
declare module "packages/se/mickelus/mutil/effect/$EffectTooltipRenderer" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Gui, $Gui$Type} from "packages/net/minecraft/client/gui/$Gui"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$EffectRenderingInventoryScreen, $EffectRenderingInventoryScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$EffectRenderingInventoryScreen"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $EffectTooltipRenderer implements $IClientMobEffectExtensions {

constructor(arg0: $Function$Type<($MobEffectInstance$Type), (string)>)

public static "renderInventoryEffectTooltip"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: $Supplier$Type<($Component$Type)>): void
public "renderInventoryIcon"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
public static "of"(arg0: $MobEffectInstance$Type): $IClientMobEffectExtensions
public static "of"(arg0: $MobEffect$Type): $IClientMobEffectExtensions
public "renderGuiIcon"(arg0: $MobEffectInstance$Type, arg1: $Gui$Type, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: float, arg6: float): boolean
public "isVisibleInGui"(arg0: $MobEffectInstance$Type): boolean
public "isVisibleInInventory"(arg0: $MobEffectInstance$Type): boolean
public "renderInventoryText"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectTooltipRenderer$Type = ($EffectTooltipRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectTooltipRenderer_ = $EffectTooltipRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterCriticalStrike" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterCriticalStrike implements $ITooltipGetter {

constructor()

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterCriticalStrike$Type = ($TooltipGetterCriticalStrike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterCriticalStrike_ = $TooltipGetterCriticalStrike$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterMultiValue" {
import {$StatFormat, $StatFormat$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatFormat"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterMultiValue implements $ITooltipGetter {

constructor(arg0: string, arg1: ($IStatGetter$Type)[], arg2: ($StatFormat$Type)[])

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterMultiValue$Type = ($TooltipGetterMultiValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterMultiValue_ = $TooltipGetterMultiValue$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$StrikingStatIndicatorGui" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$GuiStatIndicator, $GuiStatIndicator$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatIndicator"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $StrikingStatIndicatorGui extends $GuiStatIndicator {

constructor(arg0: $ToolAction$Type)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
public "isActive"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getLabel"(): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
get "label"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrikingStatIndicatorGui$Type = ($StrikingStatIndicatorGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StrikingStatIndicatorGui_ = $StrikingStatIndicatorGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$PristineAmethystItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PristineAmethystItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PristineAmethystItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PristineAmethystItem$Type = ($PristineAmethystItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PristineAmethystItem_ = $PristineAmethystItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$PryChargedEffect" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $PryChargedEffect extends $ChargedAbilityEffect {
static readonly "instance": $PryChargedEffect


public "isAvailable"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): boolean
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PryChargedEffect$Type = ($PryChargedEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PryChargedEffect_ = $PryChargedEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAbilityCooldown" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAbilityCooldown implements $IStatGetter {

constructor(arg0: $ChargedAbilityEffect$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAbilityCooldown$Type = ($StatGetterAbilityCooldown);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAbilityCooldown_ = $StatGetterAbilityCooldown$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterReaching" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterReaching implements $ITooltipGetter {

constructor()

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterReaching$Type = ($TooltipGetterReaching);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterReaching_ = $TooltipGetterReaching$Type;
}}
declare module "packages/se/mickelus/tetra/items/cell/$ThermalCellItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ThermalCellItem extends $TetraItem {
static readonly "maxCharge": integer
static readonly "identifier": string
static "instance": $RegistryObject<($ThermalCellItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "clientInit"(): void
public "showDurabilityBar"(arg0: $ItemStack$Type): boolean
public static "getCharge"(arg0: $ItemStack$Type): integer
public static "drainCharge"(arg0: $ItemStack$Type, arg1: integer): integer
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public static "recharge"(arg0: $ItemStack$Type, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThermalCellItem$Type = ($ThermalCellItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThermalCellItem_ = $ThermalCellItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$RolledScrollBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$ScrollBlock, $ScrollBlock$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $RolledScrollBlock extends $ScrollBlock {
static readonly "identifier": string
static "instance": $ScrollBlock
static readonly "sound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RolledScrollBlock$Type = ($RolledScrollBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RolledScrollBlock_ = $RolledScrollBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/rack/$RackTESR" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$RackTile, $RackTile$Type} from "packages/se/mickelus/tetra/blocks/rack/$RackTile"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $RackTESR implements $BlockEntityRenderer<($RackTile)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $RackTile$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $RackTile$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $RackTile$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RackTESR$Type = ($RackTESR);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RackTESR_ = $RackTESR$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$HoneToast" {
import {$Toast, $Toast$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ToastComponent, $ToastComponent$Type} from "packages/net/minecraft/client/gui/components/toasts/$ToastComponent"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Toast$Visibility, $Toast$Visibility$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast$Visibility"

export class $HoneToast implements $Toast {

constructor(arg0: $ItemStack$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: $ToastComponent$Type, arg2: long): $Toast$Visibility
public "getToken"(): any
public "slotCount"(): integer
public "width"(): integer
public "height"(): integer
get "token"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoneToast$Type = ($HoneToast);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoneToast_ = $HoneToast$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiSpinner" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiSpinner extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSpinner$Type = ($GuiSpinner);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSpinner_ = $GuiSpinner$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/suspend/$SuspendEffect" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $SuspendEffect {

constructor()

public static "toggleSuspend"(arg0: $Player$Type, arg1: boolean): void
public static "canSuspend"(arg0: $Player$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuspendEffect$Type = ($SuspendEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuspendEffect_ = $SuspendEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$ModuleModel" {
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"

export class $ModuleModel {
 "type": string
 "location": $ResourceLocation
 "renderType": $ResourceLocation
 "transform": $Transformation
 "emission": integer
 "tint": integer
 "overlayTint": integer
 "renderLayer": $Priority
 "invertPerspectives": boolean
 "contexts": ($ItemDisplayContext)[]

constructor(arg0: string, arg1: $ResourceLocation$Type)
constructor(arg0: $ResourceLocation$Type)
constructor()

public "copy"(): $ModuleModel
public "getRenderLayer"(): $Priority
get "renderLayer"(): $Priority
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleModel$Type = ($ModuleModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleModel_ = $ModuleModel$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$QuickslotGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$QuickslotInventory, $QuickslotInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuickslotInventory"

export class $QuickslotGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "clear"(): void
public "getHand"(): $InteractionHand
public "setInventory"(arg0: $QuickslotInventory$Type): void
public "getFocus"(): integer
get "hand"(): $InteractionHand
set "inventory"(value: $QuickslotInventory$Type)
get "focus"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuickslotGroupGui$Type = ($QuickslotGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuickslotGroupGui_ = $QuickslotGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/$BasicModule" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BasicModule extends $ItemModule {
static readonly "repairLevelFactor": float

constructor(arg0: $ResourceLocation$Type, arg1: $ModuleData$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicModule$Type = ($BasicModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicModule_ = $BasicModule$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$EffectItemPredicate" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $EffectItemPredicate extends $ItemPredicate {
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor()
constructor(arg0: $JsonObject$Type)

public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectItemPredicate$Type = ($EffectItemPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectItemPredicate_ = $EffectItemPredicate$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$EchoHelper" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $EchoHelper {

constructor()

public static "echo"(arg0: $Player$Type, arg1: integer, arg2: $Runnable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EchoHelper$Type = ($EchoHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EchoHelper_ = $EchoHelper$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$ReplacementDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$ReplacementDefinition, $ReplacementDefinition$Type} from "packages/se/mickelus/tetra/module/$ReplacementDefinition"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $ReplacementDeserializer implements $JsonDeserializer<($ReplacementDefinition)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $ReplacementDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementDeserializer$Type = ($ReplacementDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplacementDeserializer_ = $ReplacementDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect$TargetRequirement" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ChargedAbilityEffect$TargetRequirement extends $Enum<($ChargedAbilityEffect$TargetRequirement)> {
static readonly "entity": $ChargedAbilityEffect$TargetRequirement
static readonly "block": $ChargedAbilityEffect$TargetRequirement
static readonly "either": $ChargedAbilityEffect$TargetRequirement
static readonly "none": $ChargedAbilityEffect$TargetRequirement


public static "values"(): ($ChargedAbilityEffect$TargetRequirement)[]
public static "valueOf"(arg0: string): $ChargedAbilityEffect$TargetRequirement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChargedAbilityEffect$TargetRequirement$Type = (("either") | ("block") | ("none") | ("entity")) | ($ChargedAbilityEffect$TargetRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChargedAbilityEffect$TargetRequirement_ = $ChargedAbilityEffect$TargetRequirement$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiRect" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiRect extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean)

public "setColor"(arg0: integer): $GuiRect
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
set "color"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiRect$Type = ($GuiRect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiRect_ = $GuiRect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectLevel" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterEffectLevel implements $IStatGetter {

constructor(arg0: $ItemEffect$Type, arg1: double)
constructor(arg0: $ItemEffect$Type, arg1: double, arg2: double)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterEffectLevel$Type = ($StatGetterEffectLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterEffectLevel_ = $StatGetterEffectLevel$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ItemUpgradeRegistry" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $ItemUpgradeRegistry {
static "instance": $ItemUpgradeRegistry

constructor()

public "getModule"(arg0: string): $ItemModule
public "getAllModules"(): $Collection<($ItemModule)>
public "getReplacement"(arg0: $ItemStack$Type): $ItemStack
public "registerReplacementHook"(arg0: $BiFunction$Type<($ItemStack$Type), ($ItemStack$Type), ($ItemStack$Type)>): void
get "allModules"(): $Collection<($ItemModule)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemUpgradeRegistry$Type = ($ItemUpgradeRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemUpgradeRegistry_ = $ItemUpgradeRegistry$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$LockedCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LockedCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LockedCondition$Type = ($LockedCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LockedCondition_ = $LockedCondition$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterIntegrity" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterIntegrity implements $IStatGetter {

constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterIntegrity$Type = ($StatGetterIntegrity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterIntegrity_ = $StatGetterIntegrity$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $HowlingPacket extends $AbstractPacket {

constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingPacket$Type = ($HowlingPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingPacket_ = $HowlingPacket$Type;
}}
declare module "packages/se/mickelus/mutil/gui/animation/$KeyframeAnimation" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiAnimation, $GuiAnimation$Type} from "packages/se/mickelus/mutil/gui/animation/$GuiAnimation"
import {$Applier, $Applier$Type} from "packages/se/mickelus/mutil/gui/animation/$Applier"

export class $KeyframeAnimation implements $GuiAnimation {

constructor(arg0: integer, arg1: $GuiElement$Type)

public "start"(): void
public "stop"(): void
public "isActive"(): boolean
public "onStop"(arg0: $Consumer$Type<(boolean)>): $KeyframeAnimation
public "preDraw"(): void
public "applyTo"(...arg0: ($Applier$Type)[]): $KeyframeAnimation
public "withDelay"(arg0: integer): $KeyframeAnimation
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyframeAnimation$Type = ($KeyframeAnimation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyframeAnimation_ = $KeyframeAnimation$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$AbilityData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AbilityData {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbilityData$Type = ($AbilityData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbilityData_ = $AbilityData$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterAttackSpeed" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterAttackSpeed implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterAttackSpeed$Type = ($TooltipGetterAttackSpeed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterAttackSpeed_ = $TooltipGetterAttackSpeed$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$QuadRenderer$Vertex" {
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"

export class $QuadRenderer$Vertex {

constructor(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float)
constructor(arg0: $Vector3f$Type, arg1: float, arg2: float)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadRenderer$Vertex$Type = ($QuadRenderer$Vertex);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadRenderer$Vertex_ = $QuadRenderer$Vertex$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/$ModularDoubleHeadedItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularDoubleHeadedItem extends $ItemModularHandheld {
static readonly "headLeftKey": string
static readonly "headRightKey": string
static readonly "handleKey": string
static readonly "bindingKey": string
static readonly "accessoryKey": string
static readonly "leftSuffix": string
static readonly "rightSuffix": string
static readonly "identifier": string
static "instance": $ModularDoubleHeadedItem
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "updateConfig"(arg0: integer, arg1: integer): void
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getTransformVariant"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public "getDisplayNamePrefixes"(arg0: $ItemStack$Type): string
public "getAttributeModifiers"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "onItemUseFirst"(arg0: $ItemStack$Type, arg1: $UseOnContext$Type): $InteractionResult
public "getToolDataRaw"(arg0: $ItemStack$Type): $ToolData
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public static "setupHammerStack"(arg0: string, arg1: string): $ItemStack
public static "getCreativeTabItemStacks"(): $Collection<($ItemStack)>
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
get "creativeTabItemStacks"(): $Collection<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularDoubleHeadedItem$Type = ($ModularDoubleHeadedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularDoubleHeadedItem_ = $ModularDoubleHeadedItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$InteractiveOutlineGui" {
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $InteractiveOutlineGui extends $GuiElement {

constructor(arg0: $BlockInteraction$Type, arg1: $Player$Type)

public "getBlockInteraction"(): $BlockInteraction
public "transitionOut"(arg0: $Runnable$Type): void
get "blockInteraction"(): $BlockInteraction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractiveOutlineGui$Type = ($InteractiveOutlineGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractiveOutlineGui_ = $InteractiveOutlineGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiIntegrityBar" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiIntegrityBar extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "setItemStack"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "getTooltipLines"(): $List<($Component)>
public "showAnimation"(): void
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiIntegrityBar$Type = ($GuiIntegrityBar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiIntegrityBar_ = $GuiIntegrityBar$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiSchematicListItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $GuiSchematicListItem extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $UpgradeSchematic$Type, arg3: $Runnable$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $UpgradeSchematic$Type, arg4: $Runnable$Type)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSchematicListItem$Type = ($GuiSchematicListItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSchematicListItem_ = $GuiSchematicListItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$GuiQuickSlotBackdrop" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"

export class $GuiQuickSlotBackdrop extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiQuickSlotBackdrop$Type = ($GuiQuickSlotBackdrop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiQuickSlotBackdrop_ = $GuiQuickSlotBackdrop$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$SynergyData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $SynergyData extends $VariantData {
 "improvements": (string)[]
 "moduleVariants": (string)[]
 "modules": (string)[]
 "sameVariant": boolean
 "matchSuffixed": boolean
 "name": string
 "visibilityKey": string
 "obscured": boolean
 "hidden": boolean
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SynergyData$Type = ($SynergyData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SynergyData_ = $SynergyData$Type;
}}
declare module "packages/se/mickelus/mutil/scheduling/$ClientScheduler" {
import {$AbstractScheduler, $AbstractScheduler$Type} from "packages/se/mickelus/mutil/scheduling/$AbstractScheduler"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"

export class $ClientScheduler extends $AbstractScheduler {

constructor()

public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientScheduler$Type = ($ClientScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientScheduler_ = $ClientScheduler$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$BakingContextWrapper" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"

export class $BakingContextWrapper implements $IGeometryBakingContext {

constructor(arg0: $IGeometryBakingContext$Type, arg1: $ItemTransforms$Type)

public "getTransforms"(): $ItemTransforms
public "useAmbientOcclusion"(): boolean
public "isGui3d"(): boolean
public "useBlockLight"(): boolean
public "getMaterial"(arg0: string): $Material
public "getRootTransform"(): $Transformation
public "getModelName"(): string
public "hasMaterial"(arg0: string): boolean
public "getRenderTypeHint"(): $ResourceLocation
public "isComponentVisible"(arg0: string, arg1: boolean): boolean
public "getRenderType"(arg0: $ResourceLocation$Type): $RenderTypeGroup
get "transforms"(): $ItemTransforms
get "gui3d"(): boolean
get "rootTransform"(): $Transformation
get "modelName"(): string
get "renderTypeHint"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BakingContextWrapper$Type = ($BakingContextWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BakingContextWrapper_ = $BakingContextWrapper$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantMajorItemGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$HoloVariantItemGui, $HoloVariantItemGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantItemGui"

export class $HoloVariantMajorItemGui extends $HoloVariantItemGui {

constructor(arg0: integer, arg1: integer, arg2: $OutcomePreview$Type, arg3: string, arg4: $Consumer$Type<($OutcomePreview$Type)>, arg5: $Consumer$Type<($OutcomePreview$Type)>, arg6: $Consumer$Type<($OutcomePreview$Type)>)

public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloVariantMajorItemGui$Type = ($HoloVariantMajorItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloVariantMajorItemGui_ = $HoloVariantMajorItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTESR" {
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $WorkbenchTESR implements $BlockEntityRenderer<($WorkbenchTile)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $WorkbenchTile$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $WorkbenchTile$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $WorkbenchTile$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchTESR$Type = ($WorkbenchTESR);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchTESR_ = $WorkbenchTESR$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$InsulatedPlateItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $InsulatedPlateItem extends $TetraItem {
static readonly "identifier": string
static "instance": $InsulatedPlateItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InsulatedPlateItem$Type = ($InsulatedPlateItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InsulatedPlateItem_ = $InsulatedPlateItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$QuickslotItemGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $QuickslotItemGui extends $GuiElement {
static readonly "height": integer

constructor(arg0: integer, arg1: integer, arg2: $ItemStack$Type, arg3: integer)

public "getSlot"(): integer
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "getHand"(): $InteractionHand
get "slot"(): integer
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuickslotItemGui$Type = ($QuickslotItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuickslotItemGui_ = $QuickslotItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ItemEffectHandler" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$InputEvent$Key, $InputEvent$Key$Type} from "packages/net/minecraftforge/client/event/$InputEvent$Key"
import {$ProjectileImpactEvent, $ProjectileImpactEvent$Type} from "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent"
import {$LivingDeathEvent, $LivingDeathEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDeathEvent"
import {$InputEvent$InteractionKeyMappingTriggered, $InputEvent$InteractionKeyMappingTriggered$Type} from "packages/net/minecraftforge/client/event/$InputEvent$InteractionKeyMappingTriggered"
import {$ArrowNockEvent, $ArrowNockEvent$Type} from "packages/net/minecraftforge/event/entity/player/$ArrowNockEvent"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$LivingAttackEvent, $LivingAttackEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingAttackEvent"
import {$LivingEvent$LivingJumpEvent, $LivingEvent$LivingJumpEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingJumpEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CriticalHitEvent, $CriticalHitEvent$Type} from "packages/net/minecraftforge/event/entity/player/$CriticalHitEvent"
import {$LivingExperienceDropEvent, $LivingExperienceDropEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingExperienceDropEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TickEvent$PlayerTickEvent, $TickEvent$PlayerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$PlayerTickEvent"
import {$AttackEntityEvent, $AttackEntityEvent$Type} from "packages/net/minecraftforge/event/entity/player/$AttackEntityEvent"
import {$PlayerInteractEvent$LeftClickBlock, $PlayerInteractEvent$LeftClickBlock$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock"
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"
import {$PlayerEvent$BreakSpeed, $PlayerEvent$BreakSpeed$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed"

export class $ItemEffectHandler {
static "instance": $ItemEffectHandler

constructor()

public "onPlayerTick"(arg0: $TickEvent$PlayerTickEvent$Type): void
public static "applyHitEffects"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type): void
public "onLivingDamage"(arg0: $LivingDamageEvent$Type): void
public "onEnderTeleport"(arg0: $EntityTeleportEvent$Type): void
public "onAttackEntity"(arg0: $AttackEntityEvent$Type): void
public "onLivingDeath"(arg0: $LivingDeathEvent$Type): void
public "onLivingHurt"(arg0: $LivingHurtEvent$Type): void
public "onLivingAttack"(arg0: $LivingAttackEvent$Type): void
public "onLivingJump"(arg0: $LivingEvent$LivingJumpEvent$Type): void
public "onClickInput"(arg0: $InputEvent$InteractionKeyMappingTriggered$Type): void
public "onBreakSpeed"(arg0: $PlayerEvent$BreakSpeed$Type): void
public "onLeftClickBlock"(arg0: $PlayerInteractEvent$LeftClickBlock$Type): void
public "onKeyInput"(arg0: $InputEvent$Key$Type): void
public "onCriticalHit"(arg0: $CriticalHitEvent$Type): void
public "onArrowNock"(arg0: $ArrowNockEvent$Type): void
public "onExperienceDrop"(arg0: $LivingExperienceDropEvent$Type): void
public "onProjectileImpact"(arg0: $ProjectileImpactEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEffectHandler$Type = ($ItemEffectHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEffectHandler_ = $ItemEffectHandler$Type;
}}
declare module "packages/se/mickelus/tetra/items/$ItemPredicateComposite" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemPredicateComposite extends $ItemPredicate {
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor(arg0: ($ItemPredicate$Type)[])

public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicateComposite$Type = ($ItemPredicateComposite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPredicateComposite_ = $ItemPredicateComposite$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloItemsGui" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HoloItemsGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $BiConsumer$Type<($IModularItem$Type), ($ItemStack$Type)>, arg5: $Consumer$Type<(string)>, arg6: $Runnable$Type)

public "animateOpen"(): void
public "changeItem"(arg0: $IModularItem$Type): void
public "animateBack"(): void
public "animateOpenAll"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloItemsGui$Type = ($HoloItemsGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloItemsGui_ = $HoloItemsGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$ToolbeltScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ToolbeltContainer, $ToolbeltContainer$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$ToolbeltContainer"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $ToolbeltScreen extends $AbstractContainerScreen<($ToolbeltContainer)> {
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $ToolbeltContainer$Type, arg1: $Inventory$Type, arg2: $Component$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltScreen$Type = ($ToolbeltScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltScreen_ = $ToolbeltScreen$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterCounterweight" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterCounterweight implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterCounterweight$Type = ($TooltipGetterCounterweight);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterCounterweight_ = $TooltipGetterCounterweight$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialApplicable" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $HoloMaterialApplicable extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $WorkbenchTile$Type, arg3: $ItemStack$Type, arg4: string, arg5: $UpgradeSchematic$Type, arg6: $Player$Type): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialApplicable$Type = ($HoloMaterialApplicable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialApplicable_ = $HoloMaterialApplicable$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterTool" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterTool implements $ITooltipGetter {

constructor(arg0: $ToolAction$Type, arg1: boolean)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterTool$Type = ($TooltipGetterTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterTool_ = $TooltipGetterTool$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteractionBase" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PerformSide, $PerformSide$Type} from "packages/se/mickelus/tetra/interactions/$PerformSide"
import {$SecondaryInteraction, $SecondaryInteraction$Type} from "packages/se/mickelus/tetra/interactions/$SecondaryInteraction"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SecondaryInteractionBase implements $SecondaryInteraction {

constructor(arg0: string, arg1: $PerformSide$Type)

public "getKey"(): string
public "getPerformSide"(): $PerformSide
public "getLabel"(): string
public "perform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): void
public "canPerform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
get "key"(): string
get "performSide"(): $PerformSide
get "label"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteractionBase$Type = ($SecondaryInteractionBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteractionBase_ = $SecondaryInteractionBase$Type;
}}
declare module "packages/se/mickelus/tetra/event/$ModularLooseProjectilesEvent" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractArrow, $AbstractArrow$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ModularLooseProjectilesEvent extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $Level$Type, arg4: integer, arg5: double, arg6: boolean, arg7: float, arg8: double, arg9: float, arg10: boolean, arg11: integer, arg12: double, arg13: double)

public "getCount"(): integer
public "getLevel"(): $Level
public "getProjectileVelocity"(): float
public "getProjectileRemappers"(): $ImmutableList<($Function<($AbstractArrow), ($AbstractArrow)>)>
public "isCancelable"(): boolean
public "getInitialAmmoStack"(): $ItemStack
public "setProjectileVelocity"(arg0: float): void
public "getInitialDrawProgress"(): integer
public "getInitialProjectileVelocity"(): float
public "addProjectileRemapper"(arg0: $Function$Type<($AbstractArrow$Type), ($AbstractArrow$Type)>): void
public "isInitialInfiniteAmmo"(): boolean
public "getInitialBasePitch"(): double
public "isInitialHasSuspend"(): boolean
public "getInitialMultishotSpread"(): double
public "getBaseYaw"(): double
public "getBasePitch"(): double
public "getAmmoStack"(): $ItemStack
public "isHasSuspend"(): boolean
public "getMultishotSpread"(): double
public "getAccuracy"(): float
public "isInfiniteAmmo"(): boolean
public "getStrength"(): double
public "getFiringStack"(): $ItemStack
public "getShooter"(): $Player
public "getDrawProgress"(): integer
public "setStrength"(arg0: double): void
public "setHasSuspend"(arg0: boolean): void
public "getInitialBaseYaw"(): double
public "setAmmoStack"(arg0: $ItemStack$Type): void
public "setInfiniteAmmo"(arg0: boolean): void
public "getInitialAccuracy"(): float
public "setDrawProgress"(arg0: integer): void
public "getInitialCount"(): integer
public "setBasePitch"(arg0: double): void
public "getInitialStrength"(): double
public "setBaseYaw"(arg0: double): void
public "setAccuracy"(arg0: float): void
public "setMultishotSpread"(arg0: double): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "setCount"(arg0: integer): void
get "count"(): integer
get "level"(): $Level
get "projectileVelocity"(): float
get "projectileRemappers"(): $ImmutableList<($Function<($AbstractArrow), ($AbstractArrow)>)>
get "cancelable"(): boolean
get "initialAmmoStack"(): $ItemStack
set "projectileVelocity"(value: float)
get "initialDrawProgress"(): integer
get "initialProjectileVelocity"(): float
get "initialInfiniteAmmo"(): boolean
get "initialBasePitch"(): double
get "initialHasSuspend"(): boolean
get "initialMultishotSpread"(): double
get "baseYaw"(): double
get "basePitch"(): double
get "ammoStack"(): $ItemStack
get "hasSuspend"(): boolean
get "multishotSpread"(): double
get "accuracy"(): float
get "infiniteAmmo"(): boolean
get "strength"(): double
get "firingStack"(): $ItemStack
get "shooter"(): $Player
get "drawProgress"(): integer
set "strength"(value: double)
set "hasSuspend"(value: boolean)
get "initialBaseYaw"(): double
set "ammoStack"(value: $ItemStack$Type)
set "infiniteAmmo"(value: boolean)
get "initialAccuracy"(): float
set "drawProgress"(value: integer)
get "initialCount"(): integer
set "basePitch"(value: double)
get "initialStrength"(): double
set "baseYaw"(value: double)
set "accuracy"(value: float)
set "multishotSpread"(value: double)
get "listenerList"(): $ListenerList
set "count"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularLooseProjectilesEvent$Type = ($ModularLooseProjectilesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularLooseProjectilesEvent_ = $ModularLooseProjectilesEvent$Type;
}}
declare module "packages/se/mickelus/mutil/data/$AbstractUpdateDataPacket" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AbstractUpdateDataPacket extends $AbstractPacket {

constructor()
constructor(arg0: string, arg1: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractUpdateDataPacket$Type = ($AbstractUpdateDataPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractUpdateDataPacket_ = $AbstractUpdateDataPacket$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$BasicSchematic" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$BaseSchematic, $BaseSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$BaseSchematic"

export class $BasicSchematic extends $BaseSchematic {

constructor(arg0: string, arg1: $ItemModule$Type, arg2: $Item$Type)

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getDescription"(arg0: $ItemStack$Type): string
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "getGlyph"(): $GlyphData
public "getNumMaterialSlots"(): integer
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicSchematic$Type = ($BasicSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicSchematic_ = $BasicSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$VectorDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"

export class $VectorDeserializer implements $JsonDeserializer<($Vector3f)> {

constructor()

public static "deserialize"(arg0: $JsonElement$Type): $Vector3f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VectorDeserializer$Type = ($VectorDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VectorDeserializer_ = $VectorDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloDiagonalGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $HoloDiagonalGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $GuiAttachment$Type, arg4: integer)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "animateOpen"(): void
public "animateReopen"(): void
public "stopAnimations"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloDiagonalGui$Type = ($HoloDiagonalGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloDiagonalGui_ = $HoloDiagonalGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloItemGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HoloItemGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $IModularItem$Type, arg3: integer, arg4: $Runnable$Type, arg5: $Consumer$Type<(string)>)
constructor(arg0: integer, arg1: integer, arg2: $IModularItem$Type, arg3: $ItemStack$Type, arg4: integer, arg5: $Runnable$Type, arg6: $Consumer$Type<(string)>)

public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onItemSelected"(arg0: $IModularItem$Type): void
public "setSelected"(arg0: boolean): void
set "selected"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloItemGui$Type = ($HoloItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloItemGui_ = $HoloItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$OrCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $OrCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrCondition$Type = ($OrCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrCondition_ = $OrCondition$Type;
}}
declare module "packages/se/mickelus/tetra/trades/$TreasureMapForEmeralds" {
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$MapDecoration$Type, $MapDecoration$Type$Type} from "packages/net/minecraft/world/level/saveddata/maps/$MapDecoration$Type"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $TreasureMapForEmeralds implements $VillagerTrades$ItemListing {

constructor(arg0: integer, arg1: $TagKey$Type<($Structure$Type)>, arg2: string, arg3: $MapDecoration$Type$Type, arg4: integer, arg5: integer)

public "getOffer"(arg0: $Entity$Type, arg1: $RandomSource$Type): $MerchantOffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreasureMapForEmeralds$Type = ($TreasureMapForEmeralds);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TreasureMapForEmeralds_ = $TreasureMapForEmeralds$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerHeadBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $HammerHeadBlockEntity extends $BlockEntity {
static "type": $RegistryObject<($BlockEntityType<($HammerHeadBlockEntity)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "activate"(): void
public "isJammed"(): boolean
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "setJammed"(arg0: boolean): void
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getUnjamTime"(): long
public "getActivationTime"(): long
public "getUpdateTag"(): $CompoundTag
get "jammed"(): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
set "jammed"(value: boolean)
get "unjamTime"(): long
get "activationTime"(): long
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerHeadBlockEntity$Type = ($HammerHeadBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerHeadBlockEntity_ = $HammerHeadBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$ScannerOverlayGui" {
import {$PlayerEvent$PlayerChangedDimensionEvent, $PlayerEvent$PlayerChangedDimensionEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerChangedDimensionEvent"
import {$PlayerEvent$PlayerLoggedOutEvent, $PlayerEvent$PlayerLoggedOutEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerLoggedOutEvent"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $ScannerOverlayGui extends $GuiRoot implements $IGuiOverlay {
static readonly "tag": $TagKey<($Block)>
static "instance": $ScannerOverlayGui

constructor()

public "isAvailable"(): boolean
public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "getStatus"(): string
public "onPlayerLoggedOut"(arg0: $PlayerEvent$PlayerLoggedOutEvent$Type): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
public "onPlayerChangedDimension"(arg0: $PlayerEvent$PlayerChangedDimensionEvent$Type): void
public "isSnoozed"(): boolean
public "toggleSnooze"(): void
get "available"(): boolean
get "status"(): string
get "snoozed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScannerOverlayGui$Type = ($ScannerOverlayGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScannerOverlayGui_ = $ScannerOverlayGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltSlotType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ToolbeltSlotType extends $Enum<($ToolbeltSlotType)> {
static readonly "quickslot": $ToolbeltSlotType
static readonly "potion": $ToolbeltSlotType
static readonly "quiver": $ToolbeltSlotType
static readonly "storage": $ToolbeltSlotType


public static "values"(): ($ToolbeltSlotType)[]
public static "valueOf"(arg0: string): $ToolbeltSlotType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltSlotType$Type = (("potion") | ("quiver") | ("storage") | ("quickslot")) | ($ToolbeltSlotType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltSlotType_ = $ToolbeltSlotType$Type;
}}
declare module "packages/se/mickelus/tetra/items/$ReverberatingPearlItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ReverberatingPearlItem extends $TetraItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReverberatingPearlItem$Type = ($ReverberatingPearlItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReverberatingPearlItem_ = $ReverberatingPearlItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleList" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiModuleList extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<(string)>, arg3: $BiConsumer$Type<(string), (string)>)

public "update"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string): void
public "setFocus"(arg0: string): void
public "showAnimation"(): void
set "focus"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleList$Type = ($GuiModuleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleList_ = $GuiModuleList$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$LungeEffect$LungeData" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $LungeEffect$LungeData {

constructor(arg0: $ItemStack$Type, arg1: float, arg2: float, arg3: float, arg4: integer, arg5: double)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LungeEffect$LungeData$Type = ($LungeEffect$LungeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LungeEffect$LungeData_ = $LungeEffect$LungeData$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$ModularOverrideList" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$UnresolvedItemModel, $UnresolvedItemModel$Type} from "packages/se/mickelus/tetra/client/model/$UnresolvedItemModel"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $ModularOverrideList extends $ItemOverrides {
static readonly "EMPTY": $ItemOverrides
static readonly "NO_OVERRIDE": float

constructor(arg0: $UnresolvedItemModel$Type, arg1: $IGeometryBakingContext$Type, arg2: $ModelBaker$Type, arg3: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg4: $ModelState$Type, arg5: $ResourceLocation$Type)

public "clearCache"(): void
public "resolve"(arg0: $BakedModel$Type, arg1: $ItemStack$Type, arg2: $ClientLevel$Type, arg3: $LivingEntity$Type, arg4: integer): $BakedModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularOverrideList$Type = ($ModularOverrideList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularOverrideList_ = $ModularOverrideList$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$EarthpiercerItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EarthpiercerItem extends $TetraItem {
static readonly "identifier": string
static "instance": $EarthpiercerItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EarthpiercerItem$Type = ($EarthpiercerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EarthpiercerItem_ = $EarthpiercerItem$Type;
}}
declare module "packages/se/mickelus/tetra/module/$MultiSlotModule" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"

export class $MultiSlotModule extends $ItemModule {
static readonly "repairLevelFactor": float

constructor(arg0: $ResourceLocation$Type, arg1: $ModuleData$Type)

public "getModels"(arg0: $ItemStack$Type): ($ModuleModel)[]
public "getUnlocalizedName"(): string
get "unlocalizedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiSlotModule$Type = ($MultiSlotModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiSlotModule_ = $MultiSlotModule$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ArmorPenetrationEffect" {
import {$LivingDamageEvent, $LivingDamageEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent"
import {$LivingHurtEvent, $LivingHurtEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent"

export class $ArmorPenetrationEffect {

constructor()

public static "onLivingDamage"(arg0: $LivingDamageEvent$Type): void
public static "onLivingHurt"(arg0: $LivingHurtEvent$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorPenetrationEffect$Type = ($ArmorPenetrationEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorPenetrationEffect_ = $ArmorPenetrationEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltInventory" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotType, $SlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$SlotType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $ToolbeltInventory implements $Container {

constructor(arg0: string, arg1: $ItemStack$Type, arg2: integer, arg3: $SlotType$Type)

public "setChanged"(): void
public "emptyOverflowSlots"(arg0: $Player$Type): void
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "getItem"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getSlotEffects"(): $List<($Collection<($ItemEffect)>)>
public "isItemValid"(arg0: $ItemStack$Type): boolean
public "takeItemStack"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "clearContent"(): void
public "isEmpty"(): boolean
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stillValid"(arg0: $Player$Type): boolean
public "stopOpen"(arg0: $Player$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "writeToNBT"(arg0: $CompoundTag$Type): void
public "getFirstIndexForItem"(arg0: $Item$Type): integer
public "storeItemInInventory"(arg0: $ItemStack$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "slotEffects"(): $List<($Collection<($ItemEffect)>)>
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltInventory$Type = ($ToolbeltInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltInventory_ = $ToolbeltInventory$Type;
}}
declare module "packages/se/mickelus/tetra/loot/$ScrollDataFunction" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$LootItemFunctionType, $LootItemFunctionType$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$LootItemFunctionType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LootItemConditionalFunction, $LootItemConditionalFunction$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$LootItemConditionalFunction"

export class $ScrollDataFunction extends $LootItemConditionalFunction {
static readonly "identifier": string
static "type": $RegistryObject<($LootItemFunctionType)>


public "getType"(): $LootItemFunctionType
public static "decorate"(arg0: $BiFunction$Type<($ItemStack$Type), ($LootContext$Type), ($ItemStack$Type)>, arg1: $Consumer$Type<($ItemStack$Type)>, arg2: $LootContext$Type): $Consumer<($ItemStack)>
get "type"(): $LootItemFunctionType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollDataFunction$Type = ($ScrollDataFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollDataFunction_ = $ScrollDataFunction$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$ExhaustedPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$PlayerEvent$BreakSpeed, $PlayerEvent$BreakSpeed$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $ExhaustedPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $ExhaustedPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public static "onBreakSpeed"(arg0: $PlayerEvent$BreakSpeed$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExhaustedPotionEffect$Type = ($ExhaustedPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExhaustedPotionEffect_ = $ExhaustedPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $OutcomeMaterial {
 "count": integer

constructor()

public "getDisplayNames"(): ($Component)[]
public "isValid"(): boolean
public "offsetCount"(arg0: float, arg1: integer): $OutcomeMaterial
public "getPredicate"(): $ItemPredicate
public "getApplicableItemStacks"(): ($ItemStack)[]
public "isTagged"(): boolean
get "displayNames"(): ($Component)[]
get "valid"(): boolean
get "predicate"(): $ItemPredicate
get "applicableItemStacks"(): ($ItemStack)[]
get "tagged"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutcomeMaterial$Type = ($OutcomeMaterial);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutcomeMaterial_ = $OutcomeMaterial$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloFilterButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $HoloFilterButton extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<(string)>)

public "reset"(): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onCharType"(arg0: character, arg1: integer): boolean
public "getTooltipLines"(): $List<($Component)>
public "updateFilter"(arg0: string): void
public "onKeyPress"(arg0: integer, arg1: integer, arg2: integer): boolean
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloFilterButton$Type = ($HoloFilterButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloFilterButton_ = $HoloFilterButton$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement" {
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export interface $CraftingRequirement {

 "test"(arg0: $CraftingContext$Type): boolean

(arg0: $CraftingContext$Type): boolean
}

export namespace $CraftingRequirement {
const any: $CraftingRequirement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingRequirement$Type = ($CraftingRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingRequirement_ = $CraftingRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PredicateSlot" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PredicateSlot extends $Slot {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(arg0: $Container$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $Predicate$Type<($ItemStack$Type)>)

public "mayPlace"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PredicateSlot$Type = ($PredicateSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PredicateSlot_ = $PredicateSlot$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$ToolCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ToolCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolCondition$Type = ($ToolCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolCondition_ = $ToolCondition$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ModularShieldBannerModel" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Model, $Model$Type} from "packages/net/minecraft/client/model/$Model"
import {$ModelPart, $ModelPart$Type} from "packages/net/minecraft/client/model/geom/$ModelPart"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"

export class $ModularShieldBannerModel extends $Model {

constructor(arg0: $ModelPart$Type)

public static "createLayer"(): $LayerDefinition
public "getModel"(arg0: string): $ModelPart
public "renderToBuffer"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: integer, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularShieldBannerModel$Type = ($ModularShieldBannerModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularShieldBannerModel_ = $ModularShieldBannerModel$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$GeodeItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GeodeItem extends $TetraItem {
static readonly "identifier": string
static "instance": $GeodeItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeItem$Type = ($GeodeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeodeItem_ = $GeodeItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$JankEffect" {
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $JankEffect {

constructor()

public static "jankItemsDelayed"(arg0: $ServerLevel$Type, arg1: $BlockPos$Type, arg2: integer, arg3: float, arg4: $Entity$Type): void
public static "jankItems"(arg0: $ServerLevel$Type, arg1: $BlockPos$Type, arg2: integer, arg3: float, arg4: $Entity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JankEffect$Type = ($JankEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JankEffect_ = $JankEffect$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$GlyphDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"

export class $GlyphDeserializer implements $JsonDeserializer<($GlyphData)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $GlyphData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlyphDeserializer$Type = ($GlyphDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlyphDeserializer_ = $GlyphDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ExtractionEffect" {
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ExtractionEffect {

constructor()

public static "breakBlocks"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $ServerLevel$Type, arg4: $BlockState$Type, arg5: $BlockPos$Type, arg6: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtractionEffect$Type = ($ExtractionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtractionEffect_ = $ExtractionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/data/$UpdateDataPacket" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractUpdateDataPacket, $AbstractUpdateDataPacket$Type} from "packages/se/mickelus/mutil/data/$AbstractUpdateDataPacket"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UpdateDataPacket extends $AbstractUpdateDataPacket {

constructor()
constructor(arg0: string, arg1: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "handle"(arg0: $Player$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpdateDataPacket$Type = ($UpdateDataPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpdateDataPacket_ = $UpdateDataPacket$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$StorageInventory" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolbeltInventory, $ToolbeltInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StorageInventory extends $ToolbeltInventory {
static "maxSize": integer

constructor(arg0: $ItemStack$Type)

public static "getColumns"(arg0: integer): integer
public "storeItemInInventory"(arg0: $ItemStack$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StorageInventory$Type = ($StorageInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StorageInventory_ = $StorageInventory$Type;
}}
declare module "packages/se/mickelus/mutil/gui/animation/$GuiAnimation" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $GuiAnimation {

 "start"(): void
 "stop"(): void
}

export namespace $GuiAnimation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiAnimation$Type = ($GuiAnimation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiAnimation_ = $GuiAnimation$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/system/$HoloSystemRootGui" {
import {$HoloRootBaseGui, $HoloRootBaseGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloRootBaseGui"

export class $HoloSystemRootGui extends $HoloRootBaseGui {

constructor(arg0: integer, arg1: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSystemRootGui$Type = ($HoloSystemRootGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSystemRootGui_ = $HoloSystemRootGui$Type;
}}
declare module "packages/se/mickelus/tetra/loot/$ReplaceTableModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootModifier, $LootModifier$Type} from "packages/net/minecraftforge/common/loot/$LootModifier"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ReplaceTableModifier extends $LootModifier {
static readonly "codec": $Supplier<($Codec<($ReplaceTableModifier)>)>
 "table": $ResourceLocation


public "codec"(): $Codec<(any)>
public static "getJson"<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceTableModifier$Type = ($ReplaceTableModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplaceTableModifier_ = $ReplaceTableModifier$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$ToolRequirementGui" {
import {$GuiTool, $GuiTool$Type} from "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiTool"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ToolRequirementGui extends $GuiTool {
static readonly "width": integer

constructor(arg0: integer, arg1: integer, arg2: $ToolAction$Type)
constructor(arg0: integer, arg1: integer, arg2: $ToolAction$Type, arg3: string)

public "getTooltipLines"(): $List<($Component)>
public "setTooltipRequirementVisibility"(arg0: boolean): $ToolRequirementGui
public "updateRequirement"(arg0: integer, arg1: integer): $ToolRequirementGui
public "setTooltipVisibility"(arg0: boolean): $ToolRequirementGui
get "tooltipLines"(): $List<($Component)>
set "tooltipRequirementVisibility"(value: boolean)
set "tooltipVisibility"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolRequirementGui$Type = ($ToolRequirementGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolRequirementGui_ = $ToolRequirementGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/$AbilityStats" {
import {$GuiStatBar, $GuiStatBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBar"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$GuiStatIndicator, $GuiStatIndicator$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatIndicator"

export class $AbilityStats {
static readonly "abilitySpeedGetter": $IStatGetter
static readonly "abilityDefensiveGetter": $IStatGetter
static readonly "abilityDefEffGetter": $IStatGetter
static readonly "abilityOverchargeGetter": $IStatGetter
static readonly "abilityOverchargeEffGetter": $IStatGetter
static readonly "abilityMomentumGetter": $IStatGetter
static readonly "abilityMomentumEffGetter": $IStatGetter
static readonly "abilityComboGetter": $IStatGetter
static readonly "abilityComboEffGetter": $IStatGetter
static readonly "abilityRevengeGetter": $IStatGetter
static readonly "abilityRevengeEffGetter": $IStatGetter
static readonly "abilityOverextendGetter": $IStatGetter
static readonly "abilityOverextendEffGetter": $IStatGetter
static readonly "abilityExhilarationGetter": $IStatGetter
static readonly "abilityExhilarationEffGetter": $IStatGetter
static readonly "abilityEchoGetter": $IStatGetter
static readonly "abilityEchoEffGetter": $IStatGetter
static readonly "lungeGetter": $IStatGetter
static readonly "executeGetter": $IStatGetter
static readonly "slamGetter": $IStatGetter
static readonly "slamEntityGetter": $IStatGetter
static readonly "punctureGetter": $IStatGetter
static readonly "pryGetter": $IStatGetter
static readonly "pry": $GuiStatBar
static readonly "overpowerGetter": $IStatGetter
static readonly "reapGetter": $IStatGetter
static readonly "reap": $GuiStatBar
static "abilitySpeedIndicator": $GuiStatIndicator
static readonly "lunge": $GuiStatBar
static readonly "execute": $GuiStatBar
static readonly "slam": $GuiStatBar
static readonly "puncture": $GuiStatBar
static readonly "overpower": $GuiStatBar

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbilityStats$Type = ($AbilityStats);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbilityStats_ = $AbilityStats$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiSlotDetail" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GuiSlotDetail extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<($UpgradeSchematic$Type)>, arg3: $Runnable$Type, arg4: $Runnable$Type, arg5: $Consumer$Type<($Map$Type<(string), (integer)>)>, arg6: $Consumer$Type<($Map$Type<(string), (integer)>)>)

public "update"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $Map$Type<($ToolAction$Type), (integer)>): void
public "updatePreview"(arg0: $UpgradeSchematic$Type, arg1: string, arg2: $ItemStack$Type, arg3: $ItemStack$Type): void
public "keyTyped"(arg0: character): void
public "onTileEntityChange"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type, arg3: string, arg4: $UpgradeSchematic$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSlotDetail$Type = ($GuiSlotDetail);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSlotDetail_ = $GuiSlotDetail$Type;
}}
declare module "packages/se/mickelus/mutil/network/$PacketHandler" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PacketHandler {

constructor(arg0: string, arg1: string, arg2: string)

public "sendToAllPlayers"(arg0: $AbstractPacket$Type): void
public "registerPacket"<T extends $AbstractPacket>(arg0: $Class$Type<(T)>, arg1: $Supplier$Type<(T)>): boolean
public "sendToAllPlayersNear"(arg0: $AbstractPacket$Type, arg1: $BlockPos$Type, arg2: double, arg3: $ResourceKey$Type<($Level$Type)>): void
public "onMessage"(arg0: $AbstractPacket$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
public "sendTo"(arg0: $AbstractPacket$Type, arg1: $ServerPlayer$Type): void
public "sendToServer"(arg0: $AbstractPacket$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketHandler$Type = ($PacketHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketHandler_ = $PacketHandler$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiText" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiText extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string)

public "setColor"(arg0: integer): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setString"(arg0: string): void
set "color"(value: integer)
set "string"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiText$Type = ($GuiText);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiText_ = $GuiText$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/crossbow/$ShootableDummyItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ProjectileWeaponItem, $ProjectileWeaponItem$Type} from "packages/net/minecraft/world/item/$ProjectileWeaponItem"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ShootableDummyItem extends $ProjectileWeaponItem {
static readonly "identifier": string
static readonly "ammoPredicate": $Predicate<($ItemStack)>
static readonly "ARROW_ONLY": $Predicate<($ItemStack)>
static readonly "ARROW_OR_FIREWORK": $Predicate<($ItemStack)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "getAllSupportedProjectiles"(): $Predicate<($ItemStack)>
public "getSupportedHeldProjectiles"(): $Predicate<($ItemStack)>
public "getDefaultProjectileRange"(): integer
get "allSupportedProjectiles"(): $Predicate<($ItemStack)>
get "supportedHeldProjectiles"(): $Predicate<($ItemStack)>
get "defaultProjectileRange"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShootableDummyItem$Type = ($ShootableDummyItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShootableDummyItem_ = $ShootableDummyItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiInventoryInfo" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiInventoryInfo extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Player$Type)

public "update"(): void
public "update"(arg0: $UpgradeSchematic$Type, arg1: string, arg2: $ItemStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiInventoryInfo$Type = ($GuiInventoryInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiInventoryInfo_ = $GuiInventoryInfo$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterBlockingDuration" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterBlockingDuration implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterBlockingDuration$Type = ($TooltipGetterBlockingDuration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterBlockingDuration_ = $TooltipGetterBlockingDuration$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ItemModuleMajor" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$TweakData, $TweakData$Type} from "packages/se/mickelus/tetra/module/data/$TweakData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemModuleMajor extends $ItemModule {
static readonly "settleImprovement": string
static readonly "arrestedImprovement": string
static readonly "repairLevelFactor": float

constructor(arg0: string, arg1: string)

public "getProperties"(arg0: $ItemStack$Type): $ItemProperties
public "getModels"(arg0: $ItemStack$Type): ($ModuleModel)[]
public "tickProgression"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): void
public "getImprovement"(arg0: $ItemStack$Type, arg1: string): $ImprovementData
public "removeImprovement"(arg0: $ItemStack$Type, arg1: string): void
public static "removeImprovement"(arg0: $ItemStack$Type, arg1: string, arg2: string): void
public "getTweaks"(arg0: $ItemStack$Type): ($TweakData)[]
public "getSettleProgress"(arg0: $ItemStack$Type): integer
public "getSettleMaxCount"(arg0: $ItemStack$Type): integer
public "getSettleLimit"(arg0: $ItemStack$Type): integer
public "getEnchantmentKeys"(arg0: $ItemStack$Type): $Set<(string)>
public "getMagicCapacityCost"(arg0: $ItemStack$Type): integer
public "getMagicCapacityGain"(arg0: $ItemStack$Type): integer
public "getAttributeModifiers"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getEnchantments"(arg0: $ItemStack$Type): $Map<($Enchantment), (integer)>
public "getToolData"(arg0: $ItemStack$Type): $ToolData
public "acceptsEnchantment"(arg0: $ItemStack$Type, arg1: $Enchantment$Type, arg2: boolean): boolean
public "isTweakable"(arg0: $ItemStack$Type): boolean
public "getImprovements"(arg0: $ItemStack$Type): ($ImprovementData)[]
public "acceptsImprovement"(arg0: string): boolean
public "removeEnchantments"(arg0: $ItemStack$Type): void
public "getEffectData"(arg0: $ItemStack$Type): $EffectData
public "addImprovement"(arg0: $ItemStack$Type, arg1: string, arg2: integer): void
public static "addImprovement"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: integer): void
public "removeModule"(arg0: $ItemStack$Type, arg1: boolean): ($ItemStack)[]
public "getAspects"(arg0: $ItemStack$Type): $AspectData
public "acceptsImprovementLevel"(arg0: string, arg1: integer): boolean
public "getImprovementLevel"(arg0: $ItemStack$Type, arg1: string): integer
public "getImprovementMagicCapacityGain"(arg0: $ItemStack$Type): integer
public "getImprovementMagicCapacityCost"(arg0: $ItemStack$Type): integer
public "getEnchantmentMagicCapacityCost"(arg0: $ItemStack$Type): integer
public "removeCollidingImprovements"(arg0: $ItemStack$Type, arg1: string, arg2: integer): void
public "getApplicableEnchantmentCategories"(arg0: $ItemStack$Type, arg1: boolean): ($EnchantmentCategory)[]
public "getEnchantmentsPrimitive"(arg0: $ItemStack$Type): $Map<(string), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModuleMajor$Type = ($ItemModuleMajor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModuleMajor_ = $ItemModuleMajor$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$PristineQuartzItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PristineQuartzItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PristineQuartzItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PristineQuartzItem$Type = ($PristineQuartzItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PristineQuartzItem_ = $PristineQuartzItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$TetraBlock" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InitializableBlock, $InitializableBlock$Type} from "packages/se/mickelus/tetra/blocks/$InitializableBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"

export class $TetraBlock extends $Block implements $InitializableBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public static "dropBlockInventory"(arg0: $Block$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): void
public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraBlock$Type = ($TetraBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraBlock_ = $TetraBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPistonRenderer" {
import {$CoreExtractorPistonBlockEntity, $CoreExtractorPistonBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPistonBlockEntity"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $CoreExtractorPistonRenderer implements $BlockEntityRenderer<($CoreExtractorPistonBlockEntity)> {

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $CoreExtractorPistonBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $CoreExtractorPistonBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CoreExtractorPistonBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorPistonRenderer$Type = ($CoreExtractorPistonRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorPistonRenderer_ = $CoreExtractorPistonRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SweepingEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $SweepingEffect {

constructor()

public static "truesweep"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: boolean): void
public static "sweepAttack"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type, arg3: integer): void
public static "getSweepingLevel"(arg0: $ItemStack$Type): integer
public static "triggerTruesweep"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweepingEffect$Type = ($SweepingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SweepingEffect_ = $SweepingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$ToolbeltContainer" {
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$StorageInventory, $StorageInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$StorageInventory"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$QuiverInventory, $QuiverInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuiverInventory"
import {$QuickslotInventory, $QuickslotInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuickslotInventory"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$PotionsInventory, $PotionsInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PotionsInventory"

export class $ToolbeltContainer extends $AbstractContainerMenu {
static "type": $RegistryObject<($MenuType<($ToolbeltContainer)>)>
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(arg0: integer, arg1: $Container$Type, arg2: $ItemStack$Type, arg3: $Player$Type)

public static "create"(arg0: integer, arg1: $Inventory$Type): $ToolbeltContainer
public "getPotionInventory"(): $PotionsInventory
public "getQuiverInventory"(): $QuiverInventory
public "stillValid"(arg0: $Player$Type): boolean
public "removed"(arg0: $Player$Type): void
public "getStorageInventory"(): $StorageInventory
public "getQuickslotInventory"(): $QuickslotInventory
public "quickMoveStack"(arg0: $Player$Type, arg1: integer): $ItemStack
get "potionInventory"(): $PotionsInventory
get "quiverInventory"(): $QuiverInventory
get "storageInventory"(): $StorageInventory
get "quickslotInventory"(): $QuickslotInventory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltContainer$Type = ($ToolbeltContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltContainer_ = $ToolbeltContainer$Type;
}}
declare module "packages/se/mickelus/mutil/util/$CastOptional" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export class $CastOptional {

constructor()

public static "cast"<T>(arg0: any, arg1: $Class$Type<(T)>): $Optional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CastOptional$Type = ($CastOptional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CastOptional_ = $CastOptional$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$MaterialVariantData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $MaterialVariantData extends $VariantData {
 "materials": ($ResourceLocation)[]
 "extract": $MaterialMultiplier
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

public "combine"(arg0: $MaterialData$Type): $VariantData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialVariantData$Type = ($MaterialVariantData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialVariantData_ = $MaterialVariantData$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$VerticalTabIconButtonGui" {
import {$VerticalTabButtonGui, $VerticalTabButtonGui$Type} from "packages/se/mickelus/tetra/gui/$VerticalTabButtonGui"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $VerticalTabIconButtonGui extends $VerticalTabButtonGui {

constructor(arg0: integer, arg1: integer, arg2: $ResourceLocation$Type, arg3: integer, arg4: integer, arg5: string, arg6: string, arg7: $Runnable$Type, arg8: boolean)

public "setActive"(arg0: boolean): void
set "active"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalTabIconButtonGui$Type = ($VerticalTabIconButtonGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VerticalTabIconButtonGui_ = $VerticalTabIconButtonGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$WorkbenchScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WorkbenchContainer, $WorkbenchContainer$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchContainer"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $WorkbenchScreen extends $AbstractContainerScreen<($WorkbenchContainer)> {
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $WorkbenchContainer$Type, arg1: $Inventory$Type, arg2: $Component$Type)

public "m_7856_"(): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseReleased"(arg0: double, arg1: double, arg2: integer): boolean
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "mouseScrolled"(arg0: double, arg1: double, arg2: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchScreen$Type = ($WorkbenchScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchScreen_ = $WorkbenchScreen$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/bow/$RangedProgressOverlay" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $RangedProgressOverlay implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangedProgressOverlay$Type = ($RangedProgressOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangedProgressOverlay_ = $RangedProgressOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterBashing" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterBashing implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterBashing$Type = ($TooltipGetterBashing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterBashing_ = $TooltipGetterBashing$Type;
}}
declare module "packages/se/mickelus/mutil/data/$MergingDataStore" {
import {$DataStore, $DataStore$Type} from "packages/se/mickelus/mutil/data/$DataStore"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MergingDataStore<V, U> extends $DataStore<(V)> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $Class$Type<(V)>, arg4: $Class$Type<(U)>, arg5: $DataDistributor$Type)

public "parseData"(arg0: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
public "loadFromPacket"(arg0: $Map$Type<($ResourceLocation$Type), (string)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergingDataStore$Type<V, U> = ($MergingDataStore<(V), (U)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergingDataStore_<V, U> = $MergingDataStore$Type<(V), (U)>;
}}
declare module "packages/se/mickelus/tetra/levelgen/$ForgedContainerProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $ForgedContainerProcessor extends $StructureProcessor {
static readonly "INSTANCE": $ForgedContainerProcessor
static readonly "codec": $Codec<($ForgedContainerProcessor)>
static "type": $RegistryObject<($StructureProcessorType<(any)>)>

constructor()

public "process"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type, arg6: $StructureTemplate$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerProcessor$Type = ($ForgedContainerProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerProcessor_ = $ForgedContainerProcessor$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$EnchantmentMapping" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"

export class $EnchantmentMapping {
 "enchantment": $Enchantment
 "improvement": string
 "extract": boolean
 "apply": boolean
 "multiplier": float

constructor()

public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentMapping$Type = ($EnchantmentMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentMapping_ = $EnchantmentMapping$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloHeaderGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$HoloPage, $HoloPage$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/$HoloPage"

export class $HoloHeaderGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Consumer$Type<($HoloPage$Type)>)

public "changePage"(arg0: $HoloPage$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloHeaderGui$Type = ($HoloHeaderGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloHeaderGui_ = $HoloHeaderGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$GuiQuiverBackdrop" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"

export class $GuiQuiverBackdrop extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiQuiverBackdrop$Type = ($GuiQuiverBackdrop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiQuiverBackdrop_ = $GuiQuiverBackdrop$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$InteractiveBlockOverlayGui" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$GuiRootHud, $GuiRootHud$Type} from "packages/se/mickelus/mutil/gui/hud/$GuiRootHud"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $InteractiveBlockOverlayGui extends $GuiRootHud {

constructor()

public "update"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Player$Type, arg5: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractiveBlockOverlayGui$Type = ($InteractiveBlockOverlayGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractiveBlockOverlayGui_ = $InteractiveBlockOverlayGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IStatGetter {

 "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
 "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
 "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
 "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}

export namespace $IStatGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStatGetter$Type = ($IStatGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStatGetter_ = $IStatGetter$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiStringSmall2" {
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiString, $GuiString$Type} from "packages/se/mickelus/mutil/gui/$GuiString"

export class $GuiStringSmall2 extends $GuiString {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: string)

public "setString"(arg0: string): void
set "string"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStringSmall2$Type = ($GuiStringSmall2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStringSmall2_ = $GuiStringSmall2$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/bow/$RangedFOVTransformer" {
import {$ComputeFovModifierEvent, $ComputeFovModifierEvent$Type} from "packages/net/minecraftforge/client/event/$ComputeFovModifierEvent"

export class $RangedFOVTransformer {

constructor()

public "onFOVUpdate"(arg0: $ComputeFovModifierEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangedFOVTransformer$Type = ($RangedFOVTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangedFOVTransformer_ = $RangedFOVTransformer$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$MaterialOutcomeDefinition" {
import {$OutcomeDefinition, $OutcomeDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeDefinition"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$OutcomeMaterial, $OutcomeMaterial$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialOutcomeDefinition extends $OutcomeDefinition {
 "materials": ($ResourceLocation)[]
 "countOffset": integer
 "countFactor": float
 "toolOffset": integer
 "toolFactor": float
 "experienceOffset": float
 "experienceFactor": float
 "material": $OutcomeMaterial
 "hidden": boolean
 "materialSlot": integer
 "experienceCost": integer
 "requiredTools": $ToolData
 "moduleKey": string
 "moduleVariant": string
 "improvements": $Map<(string), (integer)>

constructor()

public "combine"(arg0: $MaterialData$Type): $OutcomeDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialOutcomeDefinition$Type = ($MaterialOutcomeDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialOutcomeDefinition_ = $MaterialOutcomeDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$ChthonicExtractorTile" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $ChthonicExtractorTile extends $BlockEntity {
static "type": $RegistryObject<($BlockEntityType<($ChthonicExtractorTile)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "damage"(arg0: integer): void
public "setDamage"(arg0: integer): void
public "getDamage"(): integer
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChthonicExtractorTile$Type = ($ChthonicExtractorTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChthonicExtractorTile_ = $ChthonicExtractorTile$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$SettleToast" {
import {$Toast, $Toast$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ToastComponent, $ToastComponent$Type} from "packages/net/minecraft/client/gui/components/toasts/$ToastComponent"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Toast$Visibility, $Toast$Visibility$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast$Visibility"

export class $SettleToast implements $Toast {

constructor(arg0: $ItemStack$Type, arg1: string)

public "render"(arg0: $GuiGraphics$Type, arg1: $ToastComponent$Type, arg2: long): $Toast$Visibility
public "getToken"(): any
public "slotCount"(): integer
public "width"(): integer
public "height"(): integer
get "token"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SettleToast$Type = ($SettleToast);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SettleToast_ = $SettleToast$Type;
}}
declare module "packages/se/mickelus/mutil/util/$RotationHelper" {
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $RotationHelper {

constructor()

public static "getHorizontalAngle"(arg0: $Vec3$Type, arg1: $Vec3$Type): double
public static "rotationFromFacing"(arg0: $Direction$Type): $Rotation
public static "shiftAxis"(arg0: $Vec3i$Type): $Vec3i
public static "rotatePitch"(arg0: $BlockPos$Type, arg1: float): $BlockPos
public static "rotateYaw"(arg0: $BlockPos$Type, arg1: float): $BlockPos
public static "rotateDirection"(arg0: $VoxelShape$Type, arg1: $Direction$Type): $VoxelShape
public static "rotateDirection"(arg0: $BlockPos$Type, arg1: $Direction$Type): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationHelper$Type = ($RotationHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotationHelper_ = $RotationHelper$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$UnboundExtractionEffect" {
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $UnboundExtractionEffect {

constructor()

public static "breakBlocks"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $ServerLevel$Type, arg4: $BlockState$Type, arg5: $BlockPos$Type, arg6: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnboundExtractionEffect$Type = ($UnboundExtractionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnboundExtractionEffect_ = $UnboundExtractionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/$ClientSetup" {
import {$RegisterGuiOverlaysEvent, $RegisterGuiOverlaysEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterGuiOverlaysEvent"
import {$FMLClientSetupEvent, $FMLClientSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent"
import {$EntityRenderersEvent$RegisterRenderers, $EntityRenderersEvent$RegisterRenderers$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent$RegisterRenderers"
import {$EntityRenderersEvent$RegisterLayerDefinitions, $EntityRenderersEvent$RegisterLayerDefinitions$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent$RegisterLayerDefinitions"
import {$ModelEvent$RegisterGeometryLoaders, $ModelEvent$RegisterGeometryLoaders$Type} from "packages/net/minecraftforge/client/event/$ModelEvent$RegisterGeometryLoaders"
import {$RegisterKeyMappingsEvent, $RegisterKeyMappingsEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterKeyMappingsEvent"
import {$RegisterParticleProvidersEvent, $RegisterParticleProvidersEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterParticleProvidersEvent"

export class $ClientSetup {

constructor()

public static "init"(): void
public static "registerKeyMappings"(arg0: $RegisterKeyMappingsEvent$Type): void
public static "registerGuiOverlays"(arg0: $RegisterGuiOverlaysEvent$Type): void
public static "clientSetup"(arg0: $FMLClientSetupEvent$Type): void
public static "modelRegistryReady"(arg0: $ModelEvent$RegisterGeometryLoaders$Type): void
public static "registerEntityLayerDefinitions"(arg0: $EntityRenderersEvent$RegisterLayerDefinitions$Type): void
public static "registerParticleFactory"(arg0: $RegisterParticleProvidersEvent$Type): void
public static "registerEntityRenderers"(arg0: $EntityRenderersEvent$RegisterRenderers$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientSetup$Type = ($ClientSetup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientSetup_ = $ClientSetup$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$ItemDisplayContextDeserializer" {
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"

export class $ItemDisplayContextDeserializer implements $JsonDeserializer<($ItemDisplayContext)> {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDisplayContextDeserializer$Type = ($ItemDisplayContextDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDisplayContextDeserializer_ = $ItemDisplayContextDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterSum" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterSum implements $IStatGetter {

constructor(...arg0: ($IStatGetter$Type)[])
constructor(arg0: double, ...arg1: ($IStatGetter$Type)[])

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterSum$Type = ($StatGetterSum);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterSum_ = $StatGetterSum$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$NotRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $NotRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotRequirement$Type = ($NotRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotRequirement_ = $NotRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$StoreToolbeltItemPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $StoreToolbeltItemPacket extends $AbstractPacket {

constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StoreToolbeltItemPacket$Type = ($StoreToolbeltItemPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StoreToolbeltItemPacket_ = $StoreToolbeltItemPacket$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloStatsGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$GuiStatBase, $GuiStatBase$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HoloStatsGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string, arg3: string, arg4: $Player$Type): void
public "realignBars"(): void
public static "addBar"(arg0: $GuiStatBase$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloStatsGui$Type = ($HoloStatsGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloStatsGui_ = $HoloStatsGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$AspectIconGui" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AspectIconGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemStack$Type, arg1: string): void
public "update"(arg0: $ItemStack$Type, arg1: $ItemModule$Type): void
public "getTooltipLines"(): $List<($Component)>
public "onMouseScroll"(arg0: double, arg1: double, arg2: double): boolean
public "updateDetailTooltip"(): void
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AspectIconGui$Type = ($AspectIconGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AspectIconGui_ = $AspectIconGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$OutcomeDefinition" {
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$OutcomeMaterial, $OutcomeMaterial$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $OutcomeDefinition {
 "material": $OutcomeMaterial
 "hidden": boolean
 "materialSlot": integer
 "experienceCost": integer
 "requiredTools": $ToolData
 "moduleKey": string
 "moduleVariant": string
 "improvements": $Map<(string), (integer)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutcomeDefinition$Type = ($OutcomeDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutcomeDefinition_ = $OutcomeDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$MaterialReductionOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialReductionOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialReductionOutcome$Type = ($MaterialReductionOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialReductionOutcome_ = $MaterialReductionOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$TickHandlerBooster" {
import {$TickEvent$PlayerTickEvent, $TickEvent$PlayerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$PlayerTickEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TickHandlerBooster {

constructor()

public "onPlayerTick"(arg0: $TickEvent$PlayerTickEvent$Type): void
public "tickItem"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickHandlerBooster$Type = ($TickHandlerBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickHandlerBooster_ = $TickHandlerBooster$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$FocusGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $FocusGui extends $GuiElement {

constructor()

public "update"(arg0: $Player$Type): void
public "setSpread"(arg0: float, arg1: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FocusGui$Type = ($FocusGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FocusGui_ = $FocusGui$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$SlotCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SlotCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotCondition$Type = ($SlotCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotCondition_ = $SlotCondition$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$ClipRectGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $ClipRectGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipRectGui$Type = ($ClipRectGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClipRectGui_ = $ClipRectGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloImprovementVariantGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloImprovementVariantGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $OutcomePreview$Type, arg5: boolean, arg6: $Consumer$Type<($OutcomePreview$Type)>, arg7: $Consumer$Type<($OutcomePreview$Type)>, arg8: $Consumer$Type<($OutcomePreview$Type)>)

public "setMuted"(arg0: boolean): void
public "getTooltipLines"(): $List<($Component)>
set "muted"(value: boolean)
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloImprovementVariantGui$Type = ($HoloImprovementVariantGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloImprovementVariantGui_ = $HoloImprovementVariantGui$Type;
}}
declare module "packages/se/mickelus/tetra/$ClientScheduler" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"

export class $ClientScheduler {

constructor()

public static "schedule"(arg0: string, arg1: integer, arg2: $Runnable$Type): void
public static "schedule"(arg0: integer, arg1: $Runnable$Type): void
public static "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientScheduler$Type = ($ClientScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientScheduler_ = $ClientScheduler$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$BaseMultiblockSchematicItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MultiblockSchematicBlock, $MultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BaseMultiblockSchematicItem extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type, arg1: $MultiblockSchematicBlock$Type)

public "getName"(arg0: $ItemStack$Type): $Component
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseMultiblockSchematicItem$Type = ($BaseMultiblockSchematicItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseMultiblockSchematicItem_ = $BaseMultiblockSchematicItem$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$BlockUseCriterion" {
import {$PropertyMatcher, $PropertyMatcher$Type} from "packages/se/mickelus/tetra/blocks/$PropertyMatcher"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$AbstractCriterionTriggerInstance, $AbstractCriterionTriggerInstance$Type} from "packages/net/minecraft/advancements/critereon/$AbstractCriterionTriggerInstance"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GenericTrigger, $GenericTrigger$Type} from "packages/se/mickelus/tetra/advancements/$GenericTrigger"
import {$ContextAwarePredicate, $ContextAwarePredicate$Type} from "packages/net/minecraft/advancements/critereon/$ContextAwarePredicate"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockUseCriterion extends $AbstractCriterionTriggerInstance {
static readonly "trigger": $GenericTrigger<($BlockUseCriterion)>

constructor(arg0: $ContextAwarePredicate$Type, arg1: $PropertyMatcher$Type, arg2: $PropertyMatcher$Type, arg3: $ItemPredicate$Type, arg4: $Map$Type<(string), (string)>)

public "test"(arg0: $BlockState$Type, arg1: $ItemStack$Type, arg2: $Map$Type<(string), (string)>): boolean
public static "trigger"(arg0: $ServerPlayer$Type, arg1: $BlockState$Type, arg2: $ItemStack$Type): void
public static "trigger"(arg0: $ServerPlayer$Type, arg1: $BlockState$Type, arg2: $ItemStack$Type, arg3: $Map$Type<(string), (string)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockUseCriterion$Type = ($BlockUseCriterion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockUseCriterion_ = $BlockUseCriterion$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$DepletedBedrockBlock" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DepletedBedrockBlock extends $TetraBlock {
static readonly "identifier": string
static "instance": $DepletedBedrockBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepletedBedrockBlock$Type = ($DepletedBedrockBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DepletedBedrockBlock_ = $DepletedBedrockBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock$Arrangement" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ScrollBlock$Arrangement extends $Enum<($ScrollBlock$Arrangement)> {
static readonly "wall": $ScrollBlock$Arrangement
static readonly "open": $ScrollBlock$Arrangement
static readonly "rolled": $ScrollBlock$Arrangement


public static "values"(): ($ScrollBlock$Arrangement)[]
public static "valueOf"(arg0: string): $ScrollBlock$Arrangement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollBlock$Arrangement$Type = (("rolled") | ("wall") | ("open")) | ($ScrollBlock$Arrangement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollBlock$Arrangement_ = $ScrollBlock$Arrangement$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAttributeAddition" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAttributeAddition implements $IStatGetter {

constructor(arg0: $Attribute$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAttributeAddition$Type = ($StatGetterAttributeAddition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAttributeAddition_ = $StatGetterAttributeAddition$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirementDeserializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $CraftingRequirementDeserializer implements $JsonDeserializer<($CraftingRequirement)> {

constructor()

public static "get"(arg0: $JsonObject$Type): $CraftingRequirement
public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $CraftingRequirement
public static "registerSupplier"(arg0: string, arg1: $Function$Type<($JsonObject$Type), ($CraftingRequirement$Type)>): void
public static "registerSupplier"(arg0: string, arg1: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingRequirementDeserializer$Type = ($CraftingRequirementDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingRequirementDeserializer_ = $CraftingRequirementDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPipeBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $CoreExtractorPipeBlock extends $TetraBlock {
static readonly "facingProp": $DirectionProperty
static readonly "poweredProp": $BooleanProperty
static readonly "identifier": string
static "instance": $CoreExtractorPipeBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public static "isPowered"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "neighborChanged"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Block$Type, arg4: $BlockPos$Type, arg5: boolean): void
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorPipeBlock$Type = ($CoreExtractorPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorPipeBlock_ = $CoreExtractorPipeBlock$Type;
}}
declare module "packages/se/mickelus/tetra/module/$Priority" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Priority extends $Enum<($Priority)> {
static readonly "LOWEST": $Priority
static readonly "LOWER": $Priority
static readonly "LOW": $Priority
static readonly "BASE": $Priority
static readonly "HIGH": $Priority
static readonly "HIGHER": $Priority
static readonly "HIGHEST": $Priority


public static "values"(): ($Priority)[]
public static "valueOf"(arg0: string): $Priority
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Priority$Type = (("high") | ("low") | ("highest") | ("lower") | ("lowest") | ("base") | ("higher")) | ($Priority);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Priority_ = $Priority$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$SlotRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $SlotRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotRequirement$Type = ($SlotRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotRequirement_ = $SlotRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteractionHandler" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$SecondaryInteraction, $SecondaryInteraction$Type} from "packages/se/mickelus/tetra/interactions/$SecondaryInteraction"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SecondaryInteractionHandler {

constructor()

public static "getInteraction"(arg0: string): $SecondaryInteraction
public static "dispatchInteraction"(arg0: $SecondaryInteraction$Type, arg1: $Player$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): void
public static "getInteractions"(): $Collection<($SecondaryInteraction)>
public static "registerInteraction"(arg0: $SecondaryInteraction$Type): void
public static "findRelevantAction"(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): $SecondaryInteraction
get "interactions"(): $Collection<($SecondaryInteraction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteractionHandler$Type = ($SecondaryInteractionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteractionHandler_ = $SecondaryInteractionHandler$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/$CraftingEffect" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CraftingEffect {
 "replace": boolean

constructor()

public static "copyFields"(arg0: $CraftingEffect$Type, arg1: $CraftingEffect$Type): void
public "applyOutcomes"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: ($ItemStack$Type)[], arg7: $Map$Type<($ToolAction$Type), (integer)>, arg8: $Level$Type, arg9: $UpgradeSchematic$Type, arg10: $BlockPos$Type, arg11: $BlockState$Type, arg12: boolean): boolean
public "isApplicable"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingEffect$Type = ($CraftingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingEffect_ = $CraftingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$VariantData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"

export class $VariantData extends $ItemProperties {
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

public static "merge"(arg0: $VariantData$Type, arg1: $VariantData$Type): $VariantData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantData$Type = ($VariantData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantData_ = $VariantData$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ApplyBannerSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ApplyBannerSchematic implements $UpgradeSchematic {

constructor()

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "checkTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
public "getNumMaterialSlots"(): integer
public "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
public "getSeverity"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): float
public "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "getRequiredTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Collection<($ToolAction)>
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "isHoning"(): boolean
public "getRarity"(): $SchematicRarity
public "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
public "getApplicableMaterials"(): (string)[]
public "matchesRequirements"(arg0: $CraftingContext$Type): boolean
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "getMaterialTranslation"(): $MaterialMultiplier
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
get "honing"(): boolean
get "rarity"(): $SchematicRarity
get "applicableMaterials"(): (string)[]
get "materialTranslation"(): $MaterialMultiplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyBannerSchematic$Type = ($ApplyBannerSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyBannerSchematic_ = $ApplyBannerSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSeparatorsGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $HoloSeparatorsGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "animateOpen"(): void
public "animateReopen"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSeparatorsGui$Type = ($HoloSeparatorsGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSeparatorsGui_ = $HoloSeparatorsGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$RuinedMultiblockSchematicBlock" {
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$HorizontalDirectionalBlock, $HorizontalDirectionalBlock$Type} from "packages/net/minecraft/world/level/block/$HorizontalDirectionalBlock"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $RuinedMultiblockSchematicBlock extends $HorizontalDirectionalBlock implements $IInteractiveBlock {
static readonly "facingProp": $DirectionProperty
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: $ResourceLocation$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedMultiblockSchematicBlock$Type = ($RuinedMultiblockSchematicBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RuinedMultiblockSchematicBlock_ = $RuinedMultiblockSchematicBlock$Type;
}}
declare module "packages/se/mickelus/mutil/gui/impl/$GuiHorizontalLayoutGroup" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $GuiHorizontalLayoutGroup extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "triggerLayout"(): void
public "forceLayout"(): void
public "addChild"(arg0: $GuiElement$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiHorizontalLayoutGroup$Type = ($GuiHorizontalLayoutGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiHorizontalLayoutGroup_ = $GuiHorizontalLayoutGroup$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$ImprovementData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $ImprovementData extends $VariantData {
 "level": integer
 "enchantment": boolean
 "group": string
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

public "getLevel"(): integer
get "level"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImprovementData$Type = ($ImprovementData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImprovementData_ = $ImprovementData$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$MaterialCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialCondition$Type = ($MaterialCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialCondition_ = $MaterialCondition$Type;
}}
declare module "packages/se/mickelus/tetra/items/loot/$DragonSinewItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $DragonSinewItem extends $TetraItem {
static readonly "identifier": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "createEntity"(arg0: $Level$Type, arg1: $Entity$Type, arg2: $ItemStack$Type): $Entity
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "hasCustomEntity"(arg0: $ItemStack$Type): boolean
public "onEntityItemUpdate"(arg0: $ItemStack$Type, arg1: $ItemEntity$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DragonSinewItem$Type = ($DragonSinewItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DragonSinewItem_ = $DragonSinewItem$Type;
}}
declare module "packages/se/mickelus/mutil/$Perks$Data" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Perks$Data {
 "support": integer
 "contribute": integer
 "community": integer
 "moderate": integer

constructor()

public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Perks$Data$Type = ($Perks$Data);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Perks$Data_ = $Perks$Data$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$SeepingBedrockBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $SeepingBedrockBlock extends $TetraBlock {
static readonly "activeProp": $IntegerProperty
static readonly "identifier": string
static "instance": $SeepingBedrockBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public static "isActive"(arg0: $BlockState$Type): boolean
public static "isActive"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeepingBedrockBlock$Type = ($SeepingBedrockBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeepingBedrockBlock_ = $SeepingBedrockBlock$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiTexture" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiTexture extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $ResourceLocation$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: $ResourceLocation$Type)

public "setColor"(arg0: integer): $GuiTexture
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setTextureCoordinates"(arg0: integer, arg1: integer): $GuiTexture
public "setUseDefaultBlending"(arg0: boolean): $GuiTexture
public "setSpriteSize"(arg0: integer, arg1: integer): $GuiTexture
set "color"(value: integer)
set "useDefaultBlending"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTexture$Type = ($GuiTexture);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTexture_ = $GuiTexture$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$ToolbeltModule" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MultiSlotMajorModule, $MultiSlotMajorModule$Type} from "packages/se/mickelus/tetra/module/$MultiSlotMajorModule"

export class $ToolbeltModule extends $MultiSlotMajorModule {
static readonly "settleImprovement": string
static readonly "arrestedImprovement": string
static readonly "repairLevelFactor": float

constructor(arg0: $ResourceLocation$Type, arg1: $ModuleData$Type)

public "postRemove"(arg0: $ItemStack$Type, arg1: $Player$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltModule$Type = ($ToolbeltModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltModule_ = $ToolbeltModule$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$HoneProgressGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HoneProgressGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemStack$Type, arg1: boolean): void
public "getTooltipLines"(): $List<($Component)>
public "showAnimation"(): void
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoneProgressGui$Type = ($HoneProgressGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoneProgressGui_ = $HoneProgressGui$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$BleedingPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $BleedingPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $BleedingPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BleedingPotionEffect$Type = ($BleedingPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BleedingPotionEffect_ = $BleedingPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$MetalScrapItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MetalScrapItem extends $TetraItem {
static readonly "identifier": string
static "instance": $RegistryObject<($MetalScrapItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalScrapItem$Type = ($MetalScrapItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetalScrapItem_ = $MetalScrapItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PotionSlot" {
import {$PredicateSlot, $PredicateSlot$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PredicateSlot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$PotionsInventory, $PotionsInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PotionsInventory"

export class $PotionSlot extends $PredicateSlot {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(arg0: $PotionsInventory$Type, arg1: integer, arg2: integer, arg3: integer)

public "remove"(arg0: integer): $ItemStack
public "getMaxStackSize"(arg0: $ItemStack$Type): integer
public "getMaxStackSize"(): integer
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionSlot$Type = ($PotionSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionSlot_ = $PotionSlot$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$WallScrollBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$ScrollBlock, $ScrollBlock$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $WallScrollBlock extends $ScrollBlock {
static readonly "identifier": string
static "instance": $ScrollBlock
static readonly "sound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallScrollBlock$Type = ($WallScrollBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WallScrollBlock_ = $WallScrollBlock$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$EffectData" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$TierData, $TierData$Type} from "packages/se/mickelus/tetra/module/data/$TierData"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EffectData extends $TierData<($ItemEffect)> {
 "levelMap": $Map<(T), (float)>
 "efficiencyMap": $Map<(T), (float)>

constructor()

public static "merge"(arg0: $EffectData$Type, arg1: $EffectData$Type): $EffectData
public static "merge"(arg0: $Collection$Type<($EffectData$Type)>): $EffectData
public static "multiply"(arg0: $EffectData$Type, arg1: float, arg2: float): $EffectData
public static "overwrite"(arg0: $EffectData$Type, arg1: $EffectData$Type): $EffectData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectData$Type = ($EffectData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectData_ = $EffectData$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/transfer/$TransferUnitBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$EnumTransferConfig, $EnumTransferConfig$Type} from "packages/se/mickelus/tetra/blocks/forged/transfer/$EnumTransferConfig"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$EnumTransferState, $EnumTransferState$Type} from "packages/se/mickelus/tetra/blocks/forged/transfer/$EnumTransferState"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $TransferUnitBlock extends $TetraWaterloggedBlock implements $IInteractiveBlock, $EntityBlock {
static readonly "identifier": string
static readonly "facingProp": $DirectionProperty
static readonly "plateProp": $BooleanProperty
static readonly "cellProp": $IntegerProperty
static readonly "configProp": $EnumProperty<($EnumTransferConfig)>
static readonly "transferProp": $EnumProperty<($EnumTransferState)>
static readonly "interactions": ($BlockInteraction)[]
static "instance": $TransferUnitBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public static "hasPlate"(arg0: $BlockState$Type): boolean
public static "updateCellProp"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: boolean, arg3: integer): void
public static "isSending"(arg0: $BlockState$Type): boolean
public static "setSending"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: boolean): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public static "getFacing"(arg0: $BlockState$Type): $Direction
public static "getEffectPowered"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $EnumTransferConfig
public static "setReceiving"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: boolean): void
public static "removePlate"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
public static "attachPlate"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type): boolean
public static "isReceiving"(arg0: $BlockState$Type): boolean
public "neighborChanged"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Block$Type, arg4: $BlockPos$Type, arg5: boolean): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public static "reconfigure"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransferUnitBlock$Type = ($TransferUnitBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransferUnitBlock_ = $TransferUnitBlock$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBarBlockingDuration" {
import {$GuiStatBar, $GuiStatBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBar"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiStatBarBlockingDuration extends $GuiStatBar {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatBarBlockingDuration$Type = ($GuiStatBarBlockingDuration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatBarBlockingDuration_ = $GuiStatBarBlockingDuration$Type;
}}
declare module "packages/se/mickelus/tetra/event/$ModularProjectileSpawnEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$AbstractArrow, $AbstractArrow$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ModularProjectileSpawnEvent extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $LivingEntity$Type, arg3: $AbstractArrow$Type, arg4: $Level$Type, arg5: integer)

public "getLevel"(): $Level
public "isCancelable"(): boolean
public "getAmmoStack"(): $ItemStack
public "getProjectileEntity"(): $AbstractArrow
public "getFiringStack"(): $ItemStack
public "getShooter"(): $LivingEntity
public "getDrawProgress"(): integer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $Level
get "cancelable"(): boolean
get "ammoStack"(): $ItemStack
get "projectileEntity"(): $AbstractArrow
get "firingStack"(): $ItemStack
get "shooter"(): $LivingEntity
get "drawProgress"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularProjectileSpawnEvent$Type = ($ModularProjectileSpawnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularProjectileSpawnEvent_ = $ModularProjectileSpawnEvent$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ReapEffect" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ReapEffect extends $ChargedAbilityEffect {
static readonly "instance": $ReapEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $BlockPos$Type, arg6: $Vec3$Type, arg7: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReapEffect$Type = ($ReapEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReapEffect_ = $ReapEffect$Type;
}}
declare module "packages/se/mickelus/tetra/properties/$PropertyHelper" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PropertyHelper {

constructor()

public static "getPlayerToolLevels"(arg0: $Player$Type): $Map<($ToolAction), (integer)>
public static "getPlayerEffectLevel"(arg0: $Player$Type, arg1: $ItemEffect$Type): integer
public static "getPlayerEffectEfficiency"(arg0: $Player$Type, arg1: $ItemEffect$Type): float
public static "consumeActionToolToolbelt"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ToolAction$Type, arg3: integer, arg4: boolean): $ItemStack
public static "getItemTools"(arg0: $ItemStack$Type): $Set<($ToolAction)>
public static "getPlayerTools"(arg0: $Player$Type): $Set<($ToolAction)>
public static "getItemToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
public static "getToolbeltToolLevels"(arg0: $Player$Type): $Map<($ToolAction), (integer)>
public static "getPlayerProvidingItemStack"(arg0: $ToolAction$Type, arg1: integer, arg2: $Entity$Type): $ItemStack
public static "consumeCraftToolToolbelt"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ToolAction$Type, arg3: integer, arg4: boolean): $ItemStack
public static "getCombinedToolLevels"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): $Map<($ToolAction), (integer)>
public static "getCombinedToolLevel"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $ToolAction$Type): integer
public static "consumeCraftToolInventory"(arg0: $Container$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public static "consumeActionToolInventory"(arg0: $Container$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public static "getToolbeltProvidingItemStack"(arg0: $ToolAction$Type, arg1: integer, arg2: $Player$Type): $ItemStack
public static "getPlayerToolLevel"(arg0: $Player$Type, arg1: $ToolAction$Type): integer
public static "getBlockTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Collection<($ToolAction)>
public static "getBlockToolLevels"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Map<($ToolAction), (integer)>
public static "getToolbeltTools"(arg0: $Player$Type): $Set<($ToolAction)>
public static "getBlockToolLevel"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type): integer
public static "getInventoryProvidingItemStack"(arg0: $Container$Type, arg1: $ToolAction$Type, arg2: integer): $ItemStack
public static "getInventoryToolLevel"(arg0: $Container$Type, arg1: $ToolAction$Type): integer
public static "getInventoryTools"(arg0: $Container$Type): $Set<($ToolAction)>
public static "getInventoryToolLevels"(arg0: $Container$Type): $Map<($ToolAction), (integer)>
public static "getToolbeltToolLevel"(arg0: $Player$Type, arg1: $ToolAction$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyHelper$Type = ($PropertyHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyHelper_ = $PropertyHelper$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$ApplyImprovementOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ApplyImprovementOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyImprovementOutcome$Type = ($ApplyImprovementOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyImprovementOutcome_ = $ApplyImprovementOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$DestabilizationEffect" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"

export class $DestabilizationEffect {
 "destabilizationKey": string
 "minLevel": integer
 "maxLevel": integer
 "requiredMod": string
 "probability": float
 "instabilityLimit": integer
 "improvementKey": string

constructor()

public static "init"(): void
public static "getKeys"(): (string)[]
public "toJson"(): $JsonObject
public static "getEffectsForImprovement"(arg0: integer, arg1: ($ImprovementData$Type)[]): ($DestabilizationEffect)[]
get "keys"(): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DestabilizationEffect$Type = ($DestabilizationEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DestabilizationEffect_ = $DestabilizationEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloRootBaseGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $HoloRootBaseGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "onReload"(): void
public "animateOpen"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloRootBaseGui$Type = ($HoloRootBaseGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloRootBaseGui_ = $HoloRootBaseGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$WorkbenchStatsGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$GuiStatBase, $GuiStatBase$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $WorkbenchStatsGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string, arg3: string, arg4: $Player$Type): void
public "realignBars"(): void
public static "addBar"(arg0: $GuiStatBase$Type): void
public "showAnimation"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchStatsGui$Type = ($WorkbenchStatsGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchStatsGui_ = $WorkbenchStatsGui$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$ModuleCraftCriterion" {
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$AbstractCriterionTriggerInstance, $AbstractCriterionTriggerInstance$Type} from "packages/net/minecraft/advancements/critereon/$AbstractCriterionTriggerInstance"
import {$MinMaxBounds$Ints, $MinMaxBounds$Ints$Type} from "packages/net/minecraft/advancements/critereon/$MinMaxBounds$Ints"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GenericTrigger, $GenericTrigger$Type} from "packages/se/mickelus/tetra/advancements/$GenericTrigger"
import {$ContextAwarePredicate, $ContextAwarePredicate$Type} from "packages/net/minecraft/advancements/critereon/$ContextAwarePredicate"

export class $ModuleCraftCriterion extends $AbstractCriterionTriggerInstance {
static readonly "trigger": $GenericTrigger<($ModuleCraftCriterion)>

constructor(arg0: $ContextAwarePredicate$Type, arg1: $ItemPredicate$Type, arg2: $ItemPredicate$Type, arg3: string, arg4: string, arg5: string, arg6: string, arg7: $ToolAction$Type, arg8: $MinMaxBounds$Ints$Type)

public "test"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string, arg3: string, arg4: string, arg5: string, arg6: $ToolAction$Type, arg7: integer): boolean
public static "trigger"(arg0: $ServerPlayer$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string, arg5: string, arg6: string, arg7: $ToolAction$Type, arg8: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleCraftCriterion$Type = ($ModuleCraftCriterion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleCraftCriterion_ = $ModuleCraftCriterion$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$CraftButtonGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CraftButtonGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $Runnable$Type)

public "update"(arg0: $UpgradeSchematic$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $ItemStack$Type, arg4: ($ItemStack$Type)[], arg5: string, arg6: $Map$Type<($ToolAction$Type), (integer)>): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftButtonGui$Type = ($CraftButtonGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftButtonGui_ = $CraftButtonGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterMultishot" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterMultishot implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterMultishot$Type = ($TooltipGetterMultishot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterMultishot_ = $TooltipGetterMultishot$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$RuinedMultiblockSchematicBlock, $RuinedMultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$RuinedMultiblockSchematicBlock"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$HorizontalDirectionalBlock, $HorizontalDirectionalBlock$Type} from "packages/net/minecraft/world/level/block/$HorizontalDirectionalBlock"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $MultiblockSchematicBlock extends $HorizontalDirectionalBlock implements $IInteractiveBlock {
static readonly "facingProp": $DirectionProperty
readonly "x": integer
readonly "y": integer
readonly "height": integer
readonly "width": integer
readonly "ruinedRef": $RegistryObject<($RuinedMultiblockSchematicBlock)>
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: string, arg2: $RegistryObject$Type<($RuinedMultiblockSchematicBlock$Type)>, arg3: $ResourceLocation$Type, arg4: integer, arg5: integer, arg6: integer, arg7: integer)

public "destroy"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: $ItemStack$Type): void
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicBlock$Type = ($MultiblockSchematicBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicBlock_ = $MultiblockSchematicBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$ISchematicProviderBlock" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ISchematicProviderBlock {

 "canUnlockSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
 "getSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
}

export namespace $ISchematicProviderBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISchematicProviderBlock$Type = ($ISchematicProviderBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISchematicProviderBlock_ = $ISchematicProviderBlock$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiTextures" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GuiTextures {
static readonly "workbench": $ResourceLocation
static readonly "holo": $ResourceLocation
static readonly "toolActions": $ResourceLocation
static readonly "playerInventory": $ResourceLocation
static readonly "toolbelt": $ResourceLocation
static readonly "glyphs": $ResourceLocation
static readonly "hud": $ResourceLocation

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTextures$Type = ($GuiTextures);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTextures_ = $GuiTextures$Type;
}}
declare module "packages/se/mickelus/mutil/util/$JsonOptional" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export class $JsonOptional {

constructor()

public static "field"(arg0: $JsonObject$Type, arg1: string): $Optional<($JsonElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonOptional$Type = ($JsonOptional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonOptional_ = $JsonOptional$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ItemModule" {
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$TweakData, $TweakData$Type} from "packages/se/mickelus/tetra/module/data/$TweakData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IToolProvider, $IToolProvider$Type} from "packages/se/mickelus/tetra/properties/$IToolProvider"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$ItemAspect, $ItemAspect$Type} from "packages/se/mickelus/tetra/aspect/$ItemAspect"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemModule implements $IToolProvider {
static readonly "repairLevelFactor": float

constructor(arg0: string, arg1: string)

public static "getName"(arg0: string, arg1: string): string
public "getName"(arg0: $ItemStack$Type): string
public "getKey"(): string
public "getProperties"(arg0: $ItemStack$Type): $ItemProperties
public "getSlot"(): string
public "getDescription"(arg0: $ItemStack$Type): string
public "getToolLevels"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getModels"(arg0: $ItemStack$Type): ($ModuleModel)[]
public "getMagicCapacity"(arg0: $ItemStack$Type): integer
public "getVariantData"(): ($VariantData)[]
public "getVariantData"(arg0: string): $VariantData
public "getVariantData"(arg0: $ItemStack$Type): $VariantData
public "getRenderLayer"(): $Priority
public "getItemPrefix"(arg0: $ItemStack$Type): string
public "hasTweak"(arg0: $ItemStack$Type, arg1: string): boolean
public "setTweakStep"(arg0: $ItemStack$Type, arg1: string, arg2: integer): void
public "getToolEfficiency"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): float
public "hasAspect"(arg0: $ItemStack$Type, arg1: $ItemAspect$Type): boolean
public "postRemove"(arg0: $ItemStack$Type, arg1: $Player$Type): void
public "getTweaks"(arg0: $ItemStack$Type): ($TweakData)[]
public "getTweakStep"(arg0: $ItemStack$Type, arg1: $TweakData$Type): integer
public "getSpeedModifier"(arg0: $ItemStack$Type): double
public "getItemNamePriority"(arg0: $ItemStack$Type): $Priority
public "getItemPrefixPriority"(arg0: $ItemStack$Type): $Priority
public "getEffectEfficiency"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): float
public "getRepairRequiredTools"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Collection<($ToolAction)>
public "getRepairRequiredToolLevels"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getRepairDefinitions"(arg0: $ItemStack$Type): $Collection<($RepairDefinition)>
public "getRepairRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ToolAction$Type): integer
public "getMagicCapacityCost"(arg0: $ItemStack$Type): integer
public "getDurabilityMultiplier"(arg0: $ItemStack$Type): float
public "getMagicCapacityGain"(arg0: $ItemStack$Type): integer
public "addModule"(arg0: $ItemStack$Type, arg1: string, arg2: $Player$Type): void
public "getDamageModifier"(arg0: $ItemStack$Type): double
public "getAttributeModifiers"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
public "getTools"(arg0: $ItemStack$Type): $Set<($ToolAction)>
public "getToolData"(arg0: $ItemStack$Type): $ToolData
public "getIntegrityGain"(arg0: $ItemStack$Type): integer
public "getIntegrityCost"(arg0: $ItemStack$Type): integer
public "isTweakable"(arg0: $ItemStack$Type): boolean
public "getUnlocalizedName"(): string
public "getItemName"(arg0: $ItemStack$Type): string
public "getEffectData"(arg0: $ItemStack$Type): $EffectData
public "canProvideTools"(arg0: $ItemStack$Type): boolean
public "getEffects"(arg0: $ItemStack$Type): $Collection<($ItemEffect)>
public "getEffectLevel"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): integer
public "removeModule"(arg0: $ItemStack$Type, arg1: boolean): ($ItemStack)[]
public "removeModule"(arg0: $ItemStack$Type): ($ItemStack)[]
public "getDurability"(arg0: $ItemStack$Type): integer
public "getAspects"(arg0: $ItemStack$Type): $AspectData
public "getDestabilizationChance"(arg0: integer, arg1: integer, arg2: float): float
public "getDestabilizationChance"(arg0: $ItemStack$Type, arg1: float): float
public "getRepairExperienceCost"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): integer
public "getRepairDefinition"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $RepairDefinition
public "getDamageMultiplierModifier"(arg0: $ItemStack$Type): double
public "getSpeedMultiplierModifier"(arg0: $ItemStack$Type): double
public "getDefaultData"(): $VariantData
public "onActionConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public "onCraftConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
get "key"(): string
get "slot"(): string
get "variantData"(): ($VariantData)[]
get "renderLayer"(): $Priority
get "unlocalizedName"(): string
get "defaultData"(): $VariantData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModule$Type = ($ItemModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModule_ = $ItemModule$Type;
}}
declare module "packages/se/mickelus/tetra/data/$CraftingEffectStore" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$MergingDataStore, $MergingDataStore$Type} from "packages/se/mickelus/mutil/data/$MergingDataStore"
import {$CraftingEffect, $CraftingEffect$Type} from "packages/se/mickelus/tetra/craftingeffect/$CraftingEffect"

export class $CraftingEffectStore extends $MergingDataStore<($CraftingEffect), (($CraftingEffect)[])> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $DataDistributor$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingEffectStore$Type = ($CraftingEffectStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingEffectStore_ = $CraftingEffectStore$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSchematicGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloSchematicGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Consumer$Type<($OutcomePreview$Type)>)

public "update"(arg0: $IModularItem$Type, arg1: string, arg2: $UpgradeSchematic$Type): void
public "animateOpen"(): void
public "getTooltipLines"(): $List<($Component)>
public "onKeyPress"(arg0: integer, arg1: integer, arg2: integer): boolean
public "openVariant"(arg0: $OutcomePreview$Type): void
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSchematicGui$Type = ($HoloSchematicGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSchematicGui_ = $HoloSchematicGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$TweakData" {
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $TweakData {
 "variant": string
 "improvement": string
 "key": string
 "steps": integer

constructor()

public "getProperties"(arg0: integer): $ItemProperties
public "getAttributeModifiers"(arg0: integer): $Multimap<($Attribute), ($AttributeModifier)>
public "getToolLevel"(arg0: $ToolAction$Type, arg1: integer): integer
public "getToolData"(arg0: integer): $ToolData
public "getEffectData"(arg0: integer): $EffectData
public "getEffectLevel"(arg0: $ItemEffect$Type, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TweakData$Type = ($TweakData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TweakData_ = $TweakData$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialTranslation" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HoloMaterialTranslation extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $UpgradeSchematic$Type): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialTranslation$Type = ($HoloMaterialTranslation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialTranslation_ = $HoloMaterialTranslation$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ITooltipGetter {

 "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
 "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
 "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
 "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
 "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string

(arg0: $Player$Type, arg1: $ItemStack$Type): string
}

export namespace $ITooltipGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITooltipGetter$Type = ($ITooltipGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITooltipGetter_ = $ITooltipGetter$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiClickable" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiClickable extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Runnable$Type)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiClickable$Type = ($GuiClickable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiClickable_ = $GuiClickable$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloImprovementButton" {
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HoloImprovementButton extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $Runnable$Type)

public "updateCount"(arg0: integer): void
public "hide"(): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "show"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloImprovementButton$Type = ($HoloImprovementButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloImprovementButton_ = $HoloImprovementButton$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$MaterialData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$MaterialColors, $MaterialColors$Type} from "packages/se/mickelus/tetra/module/data/$MaterialColors"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$OutcomeMaterial, $OutcomeMaterial$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeMaterial"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialData {
 "replace": boolean
 "key": string
 "category": string
 "hidden": boolean
 "hiddenOutcomes": boolean
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "primary": float
 "secondary": float
 "tertiary": float
 "durability": float
 "integrityGain": float
 "integrityCost": float
 "magicCapacity": integer
 "effects": $EffectData
 "aspects": $AspectData
 "toolLevel": integer
 "toolEfficiency": float
 "tints": $MaterialColors
 "textures": (string)[]
 "textureOverrides": (string)[]
 "tintOverrides": boolean
 "material": $OutcomeMaterial
 "requiredTools": $ToolData
 "experienceCost": float
 "tags": $Set<($TagKey<($Item)>)>
 "features": (string)[]
 "improvements": $Map<(string), (integer)>

constructor()

public static "copyFields"(arg0: $MaterialData$Type, arg1: $MaterialData$Type): void
public static "kneadModel"(arg0: $ModuleModel$Type, arg1: $MaterialData$Type, arg2: $List$Type<(string)>): $ModuleModel
public "shallowCopy"(): $MaterialData
public static "appendString"(arg0: $ResourceLocation$Type, arg1: string): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialData$Type = ($MaterialData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialData_ = $MaterialData$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$SmallHealthPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SmallHealthPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SmallHealthPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmallHealthPotionEffect$Type = ($SmallHealthPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmallHealthPotionEffect_ = $SmallHealthPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$FeatureFlagRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $FeatureFlagRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureFlagRequirement$Type = ($FeatureFlagRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FeatureFlagRequirement_ = $FeatureFlagRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/client/particle/$SweepingStrikeParticleType" {
import {$SweepingStrikeParticleOption, $SweepingStrikeParticleOption$Type} from "packages/se/mickelus/tetra/client/particle/$SweepingStrikeParticleOption"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $SweepingStrikeParticleType extends $ParticleType<($SweepingStrikeParticleOption)> {
static readonly "identifier": string
static "instance": $ParticleType<($SweepingStrikeParticleOption)>

constructor()

public "codec"(): $Codec<($SweepingStrikeParticleOption)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweepingStrikeParticleType$Type = ($SweepingStrikeParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SweepingStrikeParticleType_ = $SweepingStrikeParticleType$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantGroupGui" {
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloVariantGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: $List$Type<($OutcomePreview$Type)>, arg4: integer, arg5: $IStatSorter$Type, arg6: $Player$Type, arg7: $Consumer$Type<($OutcomePreview$Type)>, arg8: $Consumer$Type<($OutcomePreview$Type)>, arg9: $Consumer$Type<($OutcomePreview$Type)>)

public "updateSelection"(arg0: $OutcomePreview$Type): void
public "animateIn"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloVariantGroupGui$Type = ($HoloVariantGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloVariantGroupGui_ = $HoloVariantGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$SchematicCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SchematicCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicCondition$Type = ($SchematicCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicCondition_ = $SchematicCondition$Type;
}}
declare module "packages/se/mickelus/mutil/gui/animation/$Applier" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $Applier {

constructor(arg0: float, arg1: float, arg2: boolean, arg3: boolean)
constructor(arg0: float, arg1: float)
constructor(arg0: float)

public "start"(arg0: integer): void
public "setElement"(arg0: $GuiElement$Type): void
public "preDraw"(arg0: float): void
set "element"(value: $GuiElement$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Applier$Type = ($Applier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Applier_ = $Applier$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/screen/$GuiStorageBackdrop" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"

export class $GuiStorageBackdrop extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Collection$Type<($Collection$Type<($ItemEffect$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStorageBackdrop$Type = ($GuiStorageBackdrop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStorageBackdrop_ = $GuiStorageBackdrop$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock" {
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IInteractiveBlock {

 "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]

(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
}

export namespace $IInteractiveBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInteractiveBlock$Type = ($IInteractiveBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInteractiveBlock_ = $IInteractiveBlock$Type;
}}
declare module "packages/se/mickelus/mutil/$ConfigHandler" {
import {$ConfigHandler$Client, $ConfigHandler$Client$Type} from "packages/se/mickelus/mutil/$ConfigHandler$Client"

export class $ConfigHandler {
static "client": $ConfigHandler$Client


public static "setup"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigHandler$Type = ($ConfigHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigHandler_ = $ConfigHandler$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$MaterialMultiplier" {
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $MaterialMultiplier {
 "primaryAttributes": $Multimap<($Attribute), ($AttributeModifier)>
 "secondaryAttributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tertiaryAttributes": $Multimap<($Attribute), ($AttributeModifier)>
 "durability": float
 "durabilityMultiplier": float
 "integrity": float
 "magicCapacity": float
 "primaryEffects": $EffectData
 "secondaryEffects": $EffectData
 "tertiaryEffects": $EffectData
 "tools": $ToolData
 "glyph": $GlyphData
 "availableTextures": (string)[]
 "models": ($ModuleModel)[]

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialMultiplier$Type = ($MaterialMultiplier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialMultiplier_ = $MaterialMultiplier$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleMajor" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiModule, $GuiModule$Type} from "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModule"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiModuleMajor extends $GuiModule {

constructor(arg0: integer, arg1: integer, arg2: $GuiAttachment$Type, arg3: $ItemStack$Type, arg4: $ItemStack$Type, arg5: string, arg6: string, arg7: $ItemModuleMajor$Type, arg8: $ItemModuleMajor$Type, arg9: $Consumer$Type<(string)>, arg10: $BiConsumer$Type<(string), (string)>)

public "showAnimation"(arg0: integer): void
public static "getEnchantmentUnion"(arg0: $Set$Type<($Enchantment$Type)>, arg1: $Set$Type<($Enchantment$Type)>): $List<($Enchantment)>
public static "getImprovementUnion"(arg0: ($ImprovementData$Type)[], arg1: ($ImprovementData$Type)[]): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleMajor$Type = ($GuiModuleMajor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleMajor_ = $GuiModuleMajor$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$PiercingEffect" {
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $PiercingEffect {

constructor()

public static "pierceBlocks"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $ServerLevel$Type, arg4: $BlockState$Type, arg5: $BlockPos$Type, arg6: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PiercingEffect$Type = ($PiercingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PiercingEffect_ = $PiercingEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$UnwaveringPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $UnwaveringPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $UnwaveringPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnwaveringPotionEffect$Type = ($UnwaveringPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnwaveringPotionEffect_ = $UnwaveringPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$FierySelfEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $FierySelfEffect {

constructor()

public static "perform"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FierySelfEffect$Type = ($FierySelfEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FierySelfEffect_ = $FierySelfEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerBaseRenderer" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$HammerBaseBlockEntity, $HammerBaseBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerBaseBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $HammerBaseRenderer implements $BlockEntityRenderer<($HammerBaseBlockEntity)> {
static readonly "material": $Material
static "layer": $ModelLayerLocation

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public static "createLayer"(): $LayerDefinition
public "render"(arg0: $HammerBaseBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $HammerBaseBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $HammerBaseBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerBaseRenderer$Type = ($HammerBaseRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerBaseRenderer_ = $HammerBaseRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$TetraSeparateTransformsModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemLayerModel, $ItemLayerModel$Type} from "packages/se/mickelus/tetra/client/model/$ItemLayerModel"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $TetraSeparateTransformsModel implements $IUnbakedGeometry<($TetraSeparateTransformsModel)> {

constructor(arg0: $ItemLayerModel$Type, arg1: $Map$Type<($ItemDisplayContext$Type), ($ItemLayerModel$Type)>)

public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraSeparateTransformsModel$Type = ($TetraSeparateTransformsModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraSeparateTransformsModel_ = $TetraSeparateTransformsModel$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBase" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"

export class $GuiStatBase extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): void
public "setAlignment"(arg0: $GuiAlignment$Type): void
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
set "alignment"(value: $GuiAlignment$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatBase$Type = ($GuiStatBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatBase_ = $GuiStatBase$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleBackdrop" {
import {$GuiTextureOffset, $GuiTextureOffset$Type} from "packages/se/mickelus/mutil/gui/$GuiTextureOffset"

export class $GuiModuleBackdrop extends $GuiTextureOffset {

constructor(arg0: integer, arg1: integer, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleBackdrop$Type = ($GuiModuleBackdrop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleBackdrop_ = $GuiModuleBackdrop$Type;
}}
declare module "packages/se/mickelus/mutil/$Perks" {
import {$Perks$Data, $Perks$Data$Type} from "packages/se/mickelus/mutil/$Perks$Data"

export class $Perks {

constructor()

public static "init"(arg0: string): void
public static "getData"(): $Perks$Data
get "data"(): $Perks$Data
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Perks$Type = ($Perks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Perks_ = $Perks$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteractionPacket" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SecondaryInteractionPacket extends $BlockPosPacket {

constructor()
constructor(arg0: string, arg1: $BlockPos$Type, arg2: $Entity$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteractionPacket$Type = ($SecondaryInteractionPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteractionPacket_ = $SecondaryInteractionPacket$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiSliderSegmented" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiSliderSegmented extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Consumer$Type<(integer)>)

public "setValue"(arg0: integer): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onMouseRelease"(arg0: integer, arg1: integer, arg2: integer): void
set "value"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSliderSegmented$Type = ($GuiSliderSegmented);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSliderSegmented_ = $GuiSliderSegmented$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$UniqueVariantData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $UniqueVariantData extends $VariantData {
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueVariantData$Type = ($UniqueVariantData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniqueVariantData_ = $UniqueVariantData$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ThrownModularItemRenderer" {
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ThrownModularItemEntity, $ThrownModularItemEntity$Type} from "packages/se/mickelus/tetra/items/modular/$ThrownModularItemEntity"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ThrownModularItemRenderer extends $EntityRenderer<($ThrownModularItemEntity)> {
 "shadowRadius": float

constructor(arg0: $EntityRendererProvider$Context$Type)

public "render"(arg0: $ThrownModularItemEntity$Type, arg1: float, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer): void
public "getTextureLocation"(arg0: $ThrownModularItemEntity$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThrownModularItemRenderer$Type = ($ThrownModularItemRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThrownModularItemRenderer_ = $ThrownModularItemRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$HonePacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $HonePacket extends $AbstractPacket {

constructor()
constructor(arg0: $ItemStack$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HonePacket$Type = ($HonePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HonePacket_ = $HonePacket$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$CleanseSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CleanseSchematic implements $UpgradeSchematic {

constructor()

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getSeverity"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): float
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "checkTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
public "getNumMaterialSlots"(): integer
public "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
public "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "getRequiredTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Collection<($ToolAction)>
public "isHoning"(): boolean
public "getRarity"(): $SchematicRarity
public "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
public "getApplicableMaterials"(): (string)[]
public "matchesRequirements"(arg0: $CraftingContext$Type): boolean
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "getMaterialTranslation"(): $MaterialMultiplier
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
get "honing"(): boolean
get "rarity"(): $SchematicRarity
get "applicableMaterials"(): (string)[]
get "materialTranslation"(): $MaterialMultiplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CleanseSchematic$Type = ($CleanseSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CleanseSchematic_ = $CleanseSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $BlockInteraction {
 "requiredTool": $ToolAction
 "requiredLevel": integer
 "alwaysReveal": boolean
 "face": $Direction
 "minX": float
 "minY": float
 "maxX": float
 "maxY": float
 "predicate": $Predicate<($BlockState)>
 "outcome": $InteractionOutcome

constructor<V extends $Comparable<(V)>>(arg0: $ToolAction$Type, arg1: integer, arg2: $Direction$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: $Property$Type<(V)>, arg8: V, arg9: $InteractionOutcome$Type)
constructor(arg0: $ToolAction$Type, arg1: integer, arg2: $Direction$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: $Predicate$Type<($BlockState$Type)>, arg8: $InteractionOutcome$Type)
constructor<V extends $Comparable<(V)>>(arg0: $ToolAction$Type, arg1: integer, arg2: $Direction$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: $InteractionOutcome$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "getLoot"(arg0: $ResourceLocation$Type, arg1: $ServerLevel$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): $List<($ItemStack)>
public static "getLoot"(arg0: $ResourceLocation$Type, arg1: $Player$Type, arg2: $InteractionHand$Type, arg3: $ServerLevel$Type, arg4: $BlockState$Type): $List<($ItemStack)>
public "applicableForBlock"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): boolean
public "isWithinBounds"(arg0: double, arg1: double): boolean
public "applyOutcome"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): void
public static "getInteractionAtPoint"(arg0: $Player$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $Direction$Type, arg4: double, arg5: double, arg6: double): $BlockInteraction
public static "attemptInteraction"(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public static "dropLoot"(arg0: $ResourceLocation$Type, arg1: $ServerLevel$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): void
public static "dropLoot"(arg0: $ResourceLocation$Type, arg1: $Player$Type, arg2: $InteractionHand$Type, arg3: $ServerLevel$Type, arg4: $BlockState$Type): void
public "isPotentialInteraction"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): boolean
public "isPotentialInteraction"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Direction$Type, arg5: $Collection$Type<($ToolAction$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockInteraction$Type = ($BlockInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockInteraction_ = $BlockInteraction$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollData" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ScrollData {
 "key": string
 "details": string
 "isIntricate": boolean
 "material": integer
 "ribbon": integer
 "glyphs": $List<(integer)>
 "schematics": $List<($ResourceLocation)>
 "craftingEffects": $List<($ResourceLocation)>

constructor()
constructor(arg0: string, arg1: $Optional$Type<(string)>, arg2: boolean, arg3: integer, arg4: integer, arg5: $List$Type<(integer)>, arg6: $List$Type<($ResourceLocation$Type)>, arg7: $List$Type<($ResourceLocation$Type)>)

public "write"(arg0: $JsonObject$Type): $JsonElement
public "write"(arg0: $ItemStack$Type): void
public static "write"(arg0: ($ScrollData$Type)[], arg1: $CompoundTag$Type): $CompoundTag
public static "read"(arg0: $JsonObject$Type): $ScrollData
public static "read"(arg0: $CompoundTag$Type): ($ScrollData)[]
public static "read"(arg0: $ItemStack$Type): $ScrollData
public static "readMaterialFast"(arg0: $ItemStack$Type): integer
public static "readRibbonFast"(arg0: $ItemStack$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollData$Type = ($ScrollData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollData_ = $ScrollData$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$ChargeBarGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $ChargeBarGui extends $GuiElement {

constructor()

public "update"(arg0: $Player$Type): void
public "setProgress"(arg0: float, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChargeBarGui$Type = ($ChargeBarGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChargeBarGui_ = $ChargeBarGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$InvalidSchematicException" {
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $InvalidSchematicException extends $Exception {

constructor(arg0: string, arg1: (string)[])

public "printMessage"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidSchematicException$Type = ($InvalidSchematicException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidSchematicException_ = $InvalidSchematicException$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ForgedContainerBlock extends $TetraWaterloggedBlock implements $IInteractiveBlock, $EntityBlock {
static readonly "identifier": string
static readonly "facingProp": $DirectionProperty
static readonly "flippedProp": $BooleanProperty
static readonly "locked1Prop": $BooleanProperty
static readonly "locked2Prop": $BooleanProperty
static readonly "anyLockedProp": $BooleanProperty
static readonly "openProp": $BooleanProperty
static readonly "interactions": ($BlockInteraction)[]
static "instance": $RegistryObject<($ForgedContainerBlock)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "clientInit"(): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: $ItemStack$Type): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "commonInit"(arg0: $PacketHandler$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerBlock$Type = ($ForgedContainerBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerBlock_ = $ForgedContainerBlock$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$AbilityUseResult" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AbilityUseResult extends $Enum<($AbilityUseResult)> {
static readonly "fail": $AbilityUseResult
static readonly "hit": $AbilityUseResult
static readonly "crit": $AbilityUseResult
static readonly "magicCrit": $AbilityUseResult


public static "values"(): ($AbilityUseResult)[]
public static "valueOf"(arg0: string): $AbilityUseResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbilityUseResult$Type = (("fail") | ("hit") | ("magiccrit") | ("crit")) | ($AbilityUseResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbilityUseResult_ = $AbilityUseResult$Type;
}}
declare module "packages/se/mickelus/tetra/levelgen/$ForgedCrateProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $ForgedCrateProcessor extends $StructureProcessor {
static readonly "INSTANCE": $ForgedCrateProcessor
static readonly "codec": $Codec<($ForgedCrateProcessor)>
static "type": $RegistryObject<($StructureProcessorType<(any)>)>

constructor()

public "process"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type, arg6: $StructureTemplate$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedCrateProcessor$Type = ($ForgedCrateProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedCrateProcessor_ = $ForgedCrateProcessor$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/suspend/$SuspendPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SuspendPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SuspendPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuspendPotionEffect$Type = ($SuspendPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuspendPotionEffect_ = $SuspendPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$JumpHandlerBooster" {
import {$InputEvent$Key, $InputEvent$Key$Type} from "packages/net/minecraftforge/client/event/$InputEvent$Key"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"

export class $JumpHandlerBooster {

constructor(arg0: $Minecraft$Type)

public "onKeyInput"(arg0: $InputEvent$Key$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JumpHandlerBooster$Type = ($JumpHandlerBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JumpHandlerBooster_ = $JumpHandlerBooster$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$AspectData" {
import {$ItemAspect, $ItemAspect$Type} from "packages/se/mickelus/tetra/aspect/$ItemAspect"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$TierData, $TierData$Type} from "packages/se/mickelus/tetra/module/data/$TierData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AspectData extends $TierData<($ItemAspect)> {
 "levelMap": $Map<(T), (float)>
 "efficiencyMap": $Map<(T), (float)>

constructor()

public static "merge"(arg0: $AspectData$Type, arg1: $AspectData$Type): $AspectData
public static "merge"(arg0: $Collection$Type<($AspectData$Type)>): $AspectData
public static "multiply"(arg0: $AspectData$Type, arg1: float, arg2: float): $AspectData
public static "overwrite"(arg0: $AspectData$Type, arg1: $AspectData$Type): $AspectData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AspectData$Type = ($AspectData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AspectData_ = $AspectData$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$CraftingContext" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CraftingContext {
readonly "world": $Level
readonly "pos": $BlockPos
readonly "blockState": $BlockState
readonly "player": $Player
readonly "targetStack": $ItemStack
readonly "slot": string
readonly "unlocks": ($ResourceLocation)[]
readonly "targetModule": $ItemModule
readonly "targetMajorModule": $ItemModuleMajor

constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $ItemStack$Type, arg5: string, arg6: ($ResourceLocation$Type)[])

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingContext$Type = ($CraftingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingContext_ = $CraftingContext$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$ScrollBarGui" {
import {$GuiHorizontalScrollable, $GuiHorizontalScrollable$Type} from "packages/se/mickelus/mutil/gui/impl/$GuiHorizontalScrollable"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ScrollBarGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $GuiHorizontalScrollable$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $GuiHorizontalScrollable$Type, arg5: boolean)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollBarGui$Type = ($ScrollBarGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollBarGui_ = $ScrollBarGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSlotGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"

export class $HoloSlotGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $GuiAttachment$Type, arg3: string, arg4: string, arg5: $Consumer$Type<(string)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSlotGui$Type = ($HoloSlotGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSlotGui_ = $HoloSlotGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$RemoveSchematic" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$BaseSchematic, $BaseSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$BaseSchematic"

export class $RemoveSchematic extends $BaseSchematic {

constructor()

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "getNumMaterialSlots"(): integer
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveSchematic$Type = ($RemoveSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveSchematic_ = $RemoveSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterMagicCapacity" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterMagicCapacity implements $IStatGetter {

constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "hasGain"(arg0: $ItemStack$Type): boolean
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterMagicCapacity$Type = ($StatGetterMagicCapacity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterMagicCapacity_ = $StatGetterMagicCapacity$Type;
}}
declare module "packages/se/mickelus/mutil/$ConfigHandler$Client" {
import {$ForgeConfigSpec$BooleanValue, $ForgeConfigSpec$BooleanValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue"

export class $ConfigHandler$Client {
 "queryPerks": $ForgeConfigSpec$BooleanValue


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigHandler$Client$Type = ($ConfigHandler$Client);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigHandler$Client_ = $ConfigHandler$Client$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$QuadTransformerBuilder" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IQuadTransformer, $IQuadTransformer$Type} from "packages/net/minecraftforge/client/model/$IQuadTransformer"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"

export class $QuadTransformerBuilder {

constructor()

public "add"(arg0: integer, arg1: $IQuadTransformer$Type): $QuadTransformerBuilder
public "get"(): $Int2ObjectMap<($List<($IQuadTransformer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadTransformerBuilder$Type = ($QuadTransformerBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadTransformerBuilder_ = $QuadTransformerBuilder$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$PriedPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $PriedPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $PriedPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PriedPotionEffect$Type = ($PriedPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PriedPotionEffect_ = $PriedPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$AcceptsImprovementRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $AcceptsImprovementRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptsImprovementRequirement$Type = ($AcceptsImprovementRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptsImprovementRequirement_ = $AcceptsImprovementRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$GeodeBlock" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $GeodeBlock extends $TetraBlock {
static readonly "identifier": string
static "instance": $GeodeBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getCloneItemStack"(arg0: $BlockState$Type, arg1: $HitResult$Type, arg2: $BlockGetter$Type, arg3: $BlockPos$Type, arg4: $Player$Type): $ItemStack
public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeBlock$Type = ($GeodeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeodeBlock_ = $GeodeBlock$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SlamEffect" {
import {$AbilityUseResult, $AbilityUseResult$Type} from "packages/se/mickelus/tetra/effect/$AbilityUseResult"
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $SlamEffect extends $ChargedAbilityEffect {
static readonly "instance": $SlamEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $BlockPos$Type, arg5: $Vec3$Type, arg6: integer): void
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
public "getChargeTime"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type): integer
public "directSlam"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): $AbilityUseResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlamEffect$Type = ($SlamEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlamEffect_ = $SlamEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlockEntity$ScanResult" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HolosphereBlockEntity$ScanResult extends $Record {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "timestamp"(): long
public "height"(): integer
public "chunkZ"(): integer
public "chunkX"(): integer
public "temperature"(): float
public "structures"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereBlockEntity$ScanResult$Type = ($HolosphereBlockEntity$ScanResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereBlockEntity$ScanResult_ = $HolosphereBlockEntity$ScanResult$Type;
}}
declare module "packages/se/mickelus/mutil/data/deserializer/$ResourceLocationDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ResourceLocationDeserializer implements $JsonDeserializer<($ResourceLocation)> {

constructor()

public static "deserialize"(arg0: $JsonElement$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResourceLocationDeserializer$Type = ($ResourceLocationDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResourceLocationDeserializer_ = $ResourceLocationDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$AbilityOverlays" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $AbilityOverlays extends $GuiRoot implements $IGuiOverlay {
static "instance": $AbilityOverlays

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbilityOverlays$Type = ($AbilityOverlays);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbilityOverlays_ = $AbilityOverlays$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/holo/$HolosphereEntityRenderer" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$HolosphereBlockEntity$ScanResult, $HolosphereBlockEntity$ScanResult$Type} from "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlockEntity$ScanResult"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"
import {$HolosphereBlockEntity, $HolosphereBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/holo/$HolosphereBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $HolosphereEntityRenderer implements $BlockEntityRenderer<($HolosphereBlockEntity)> {
static readonly "material": $Material

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public "render"(arg0: $HolosphereBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "renderBackdrop"(arg0: $VertexConsumer$Type, arg1: $PoseStack$Type, arg2: $Quaternionf$Type, arg3: integer, arg4: float, arg5: long): void
public "renderMarker"(arg0: $VertexConsumer$Type, arg1: $PoseStack$Type, arg2: $TextureAtlasSprite$Type, arg3: $Quaternionf$Type, arg4: float, arg5: long, arg6: integer, arg7: float, arg8: float, arg9: float, arg10: $HolosphereBlockEntity$ScanResult$Type): void
public "shouldRender"(arg0: $HolosphereBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $HolosphereBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereEntityRenderer$Type = ($HolosphereEntityRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereEntityRenderer_ = $HolosphereEntityRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$PropertyMatcher" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export class $PropertyMatcher implements $Predicate<($BlockState)> {
static readonly "any": $PropertyMatcher

constructor()

public "test"(arg0: $BlockState$Type): boolean
public static "deserialize"(arg0: $JsonElement$Type): $PropertyMatcher
public "where"<V extends $Comparable<(V)>>(arg0: $Property$Type<(V)>, arg1: $Predicate$Type<(any)>): $PropertyMatcher
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public "negate"(): $Predicate<($BlockState)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyMatcher$Type = ($PropertyMatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyMatcher_ = $PropertyMatcher$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSortPopover" {
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ZOffsetGui, $ZOffsetGui$Type} from "packages/se/mickelus/tetra/gui/$ZOffsetGui"

export class $HoloSortPopover extends $ZOffsetGui {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<($IStatSorter$Type)>)

public "update"(arg0: ($IStatSorter$Type)[]): void
public "onSelect"(arg0: $IStatSorter$Type): void
public "onKeyPress"(arg0: integer, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSortPopover$Type = ($HoloSortPopover);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSortPopover_ = $HoloSortPopover$Type;
}}
declare module "packages/se/mickelus/tetra/client/keymap/$TetraKeyMappings" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"

export class $TetraKeyMappings {
static readonly "bindingGroup": string
static readonly "accessBinding": $KeyMapping
static readonly "restockBinding": $KeyMapping
static readonly "openBinding": $KeyMapping
static readonly "secondaryUseBinding": $KeyMapping

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraKeyMappings$Type = ($TetraKeyMappings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraKeyMappings_ = $TetraKeyMappings$Type;
}}
declare module "packages/se/mickelus/tetra/data/provider/$TetraTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$TagsProvider, $TagsProvider$Type} from "packages/net/minecraft/data/tags/$TagsProvider"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $TetraTagsProvider extends $TagsProvider<($Block)> {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: string, arg3: $ExistingFileHelper$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraTagsProvider$Type = ($TetraTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraTagsProvider_ = $TetraTagsProvider$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$EnchantmentDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $EnchantmentDeserializer implements $JsonDeserializer<($Enchantment)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Enchantment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentDeserializer$Type = ($EnchantmentDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentDeserializer_ = $EnchantmentDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialImprovementGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HoloMaterialImprovementGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: boolean, arg4: boolean)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialImprovementGui$Type = ($HoloMaterialImprovementGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialImprovementGui_ = $HoloMaterialImprovementGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$TransformKey" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TransformKey extends $Enum<($TransformKey)> {
static readonly "none": $TransformKey
static readonly "thirdperson_lefthand": $TransformKey
static readonly "thirdperson_righthand": $TransformKey
static readonly "firstperson_lefthand": $TransformKey
static readonly "firstperson_righthand": $TransformKey
static readonly "head": $TransformKey
static readonly "gui": $TransformKey
static readonly "ground": $TransformKey
static readonly "fixed": $TransformKey


public static "values"(): ($TransformKey)[]
public static "valueOf"(arg0: string): $TransformKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformKey$Type = (("head") | ("firstperson_righthand") | ("thirdperson_lefthand") | ("firstperson_lefthand") | ("thirdperson_righthand") | ("gui") | ("ground") | ("fixed") | ("none")) | ($TransformKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformKey_ = $TransformKey$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$ConfigSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$BaseSchematic, $BaseSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$BaseSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicDefinition, $SchematicDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicDefinition"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConfigSchematic extends $BaseSchematic {

constructor(arg0: $SchematicDefinition$Type)
constructor(arg0: $SchematicDefinition$Type, arg1: string, arg2: string)

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "isHoning"(): boolean
public "getRarity"(): $SchematicRarity
public "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "getNumMaterialSlots"(): integer
public "getApplicableMaterials"(): (string)[]
public "matchesRequirements"(arg0: $CraftingContext$Type): boolean
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "getMaterialTranslation"(): $MaterialMultiplier
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "honing"(): boolean
get "rarity"(): $SchematicRarity
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
get "applicableMaterials"(): (string)[]
get "materialTranslation"(): $MaterialMultiplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigSchematic$Type = ($ConfigSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigSchematic_ = $ConfigSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchActionPacket" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $WorkbenchActionPacket extends $BlockPosPacket {

constructor()
constructor(arg0: $BlockPos$Type, arg1: string)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchActionPacket$Type = ($WorkbenchActionPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchActionPacket_ = $WorkbenchActionPacket$Type;
}}
declare module "packages/se/mickelus/tetra/data/provider/$TetraBlockStateProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$WallSide, $WallSide$Type} from "packages/net/minecraft/world/level/block/state/properties/$WallSide"
import {$BlockStateProvider, $BlockStateProvider$Type} from "packages/net/minecraftforge/client/model/generators/$BlockStateProvider"

export class $TetraBlockStateProvider extends $BlockStateProvider {
static readonly "WALL_PROPS": $ImmutableMap<($Direction), ($Property<($WallSide)>)>

constructor(arg0: $PackOutput$Type, arg1: string, arg2: $ExistingFileHelper$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraBlockStateProvider$Type = ($TetraBlockStateProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraBlockStateProvider_ = $TetraBlockStateProvider$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPistonBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CoreExtractorPistonBlock extends $TetraWaterloggedBlock implements $EntityBlock {
static readonly "identifier": string
static readonly "hackProp": $BooleanProperty
static readonly "boundingBox": $VoxelShape
static "instance": $RegistryObject<($CoreExtractorPistonBlock)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorPistonBlock$Type = ($CoreExtractorPistonBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorPistonBlock_ = $CoreExtractorPistonBlock$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$LubricantDispenserItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LubricantDispenserItem extends $TetraItem {
static readonly "identifier": string
static "instance": $RegistryObject<($LubricantDispenserItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LubricantDispenserItem$Type = ($LubricantDispenserItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LubricantDispenserItem_ = $LubricantDispenserItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuickslotInventory" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolbeltInventory, $ToolbeltInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $QuickslotInventory extends $ToolbeltInventory {
static readonly "maxSize": integer

constructor(arg0: $ItemStack$Type)

public "setChanged"(): void
public "readFromNBT"(arg0: $CompoundTag$Type): void
public "getShadowOfSlot"(arg0: integer): $ItemStack
public "writeToNBT"(arg0: $CompoundTag$Type): void
public "storeItemInInventory"(arg0: $ItemStack$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuickslotInventory$Type = ($QuickslotInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuickslotInventory_ = $QuickslotInventory$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ShieldModelData" {
import {$ShieldModelData$Part, $ShieldModelData$Part$Type} from "packages/se/mickelus/tetra/items/modular/impl/shield/$ShieldModelData$Part"
import {$UVPair, $UVPair$Type} from "packages/net/minecraft/client/model/geom/builders/$UVPair"
import {$PartDefinition, $PartDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$PartDefinition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ShieldModelData {
static readonly "uvCodec": $Codec<($UVPair)>
static readonly "codec": $Codec<($ShieldModelData)>

constructor(arg0: $List$Type<($ShieldModelData$Part$Type)>)

public "populatePartDefinition"(arg0: $PartDefinition$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShieldModelData$Type = ($ShieldModelData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShieldModelData_ = $ShieldModelData$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$ChthonicExtractorBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $ChthonicExtractorBlock extends $TetraBlock implements $IInteractiveBlock, $EntityBlock {
static readonly "identifier": string
static readonly "usedIdentifier": string
static readonly "description": string
static readonly "extendedDescription": string
static readonly "maxDamage": integer
static "instance": $ChthonicExtractorBlock
static "item": $Item
static "usedItem": $Item
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public static "registerItems"(arg0: $DeferredRegister$Type<($Item$Type)>): $RegistryObject<($BlockItem)>
public "setPlacedBy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: $ItemStack$Type): void
public "playerWillDestroy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getDrops"(arg0: $BlockState$Type, arg1: $LootParams$Builder$Type): $List<($ItemStack)>
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChthonicExtractorBlock$Type = ($ChthonicExtractorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChthonicExtractorBlock_ = $ChthonicExtractorBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiActionList" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$WorkbenchAction, $WorkbenchAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GuiActionList extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "updateActions"(arg0: $ItemStack$Type, arg1: ($WorkbenchAction$Type)[], arg2: $Player$Type, arg3: $Consumer$Type<($WorkbenchAction$Type)>, arg4: $WorkbenchTile$Type): void
public "updateTools"(arg0: $Map$Type<($ToolAction$Type), (integer)>): void
public "showAnimation"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiActionList$Type = ($GuiActionList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiActionList_ = $GuiActionList$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ItemEffect" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ItemEffect {
static readonly "hauntedKey": string
static readonly "workable": $ItemEffect
static readonly "unstable": $ItemEffect
static readonly "howling": $ItemEffect
static readonly "bleeding": $ItemEffect
static readonly "backstab": $ItemEffect
static readonly "armorPenetration": $ItemEffect
static readonly "crushing": $ItemEffect
static readonly "skewering": $ItemEffect
static readonly "sweeping": $ItemEffect
static readonly "truesweep": $ItemEffect
static readonly "strikingAxe": $ItemEffect
static readonly "strikingPickaxe": $ItemEffect
static readonly "strikingCut": $ItemEffect
static readonly "strikingShovel": $ItemEffect
static readonly "strikingHoe": $ItemEffect
static readonly "sweepingStrike": $ItemEffect
static readonly "sweepingFocus": $ItemEffect
static readonly "planarSweep": $ItemEffect
static readonly "extraction": $ItemEffect
static readonly "unboundExtraction": $ItemEffect
static readonly "extractionMedialLimit": $ItemEffect
static readonly "extractionLateralLimit": $ItemEffect
static readonly "extractionAxialLimit": $ItemEffect
static readonly "extractionAxialAmplify": $ItemEffect
static readonly "extractionPlanarAmplify": $ItemEffect
static readonly "unbreaking": $ItemEffect
static readonly "blocking": $ItemEffect
static readonly "blockingReflect": $ItemEffect
static readonly "bashing": $ItemEffect
static readonly "ricochet": $ItemEffect
static readonly "piercing": $ItemEffect
static readonly "piercingHarvest": $ItemEffect
static readonly "jab": $ItemEffect
static readonly "counterweight": $ItemEffect
static readonly "quickStrike": $ItemEffect
static readonly "softStrike": $ItemEffect
static readonly "severing": $ItemEffect
static readonly "stun": $ItemEffect
static readonly "abilityDefensive": $ItemEffect
static readonly "abilityOvercharge": $ItemEffect
static readonly "abilityMomentum": $ItemEffect
static readonly "abilityCombo": $ItemEffect
static readonly "abilityRevenge": $ItemEffect
static readonly "abilityOverextend": $ItemEffect
static readonly "abilityExhilaration": $ItemEffect
static readonly "abilitySpeed": $ItemEffect
static readonly "abilityEcho": $ItemEffect
static readonly "execute": $ItemEffect
static readonly "lunge": $ItemEffect
static readonly "slam": $ItemEffect
static readonly "puncture": $ItemEffect
static readonly "pry": $ItemEffect
static readonly "overpower": $ItemEffect
static readonly "reap": $ItemEffect
static readonly "denailing": $ItemEffect
static readonly "fierySelf": $ItemEffect
static readonly "enderReverb": $ItemEffect
static readonly "sculkTaint": $ItemEffect
static readonly "haunted": $ItemEffect
static readonly "stabilizing": $ItemEffect
static readonly "criticalStrike": $ItemEffect
static readonly "intuit": $ItemEffect
static readonly "earthbind": $ItemEffect
static readonly "reaching": $ItemEffect
static readonly "janking": $ItemEffect
static readonly "throwable": $ItemEffect
static readonly "shieldbreaker": $ItemEffect
static readonly "booster": $ItemEffect
static readonly "quickSlot": $ItemEffect
static readonly "storageSlot": $ItemEffect
static readonly "potionSlot": $ItemEffect
static readonly "quiverSlot": $ItemEffect
static readonly "quickAccess": $ItemEffect
static readonly "cellSocket": $ItemEffect
static readonly "suspendSelf": $ItemEffect
static readonly "releaseLatch": $ItemEffect
static readonly "flow": $ItemEffect
static readonly "overbowed": $ItemEffect
static readonly "multishot": $ItemEffect
static readonly "ammoCapacity": $ItemEffect
static readonly "zoom": $ItemEffect
static readonly "spread": $ItemEffect
static readonly "focus": $ItemEffect
static readonly "focusEcho": $ItemEffect
static readonly "velocity": $ItemEffect
static readonly "suspend": $ItemEffect
static readonly "rangeCritical": $ItemEffect
static readonly "sweeperRange": $ItemEffect
static readonly "sweeperHorizontalSpread": $ItemEffect
static readonly "sweeperVerticalSpread": $ItemEffect
static readonly "percussionScanner": $ItemEffect


public static "get"(arg0: string): $ItemEffect
public "getKey"(): string
get "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEffect$Type = ($ItemEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEffect_ = $ItemEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$MaterialColors" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MaterialColors {
 "texture": integer
 "glyph": integer
 "emission": integer

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialColors$Type = ($MaterialColors);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialColors_ = $MaterialColors$Type;
}}
declare module "packages/se/mickelus/tetra/properties/$TetraAttributes" {
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $TetraAttributes {
static readonly "registry": $DeferredRegister<($Attribute)>
static "drawStrength": $RegistryObject<($Attribute)>
static "drawSpeed": $RegistryObject<($Attribute)>
static "abilityCooldown": $RegistryObject<($Attribute)>
static "abilityDamage": $RegistryObject<($Attribute)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraAttributes$Type = ($TetraAttributes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraAttributes_ = $TetraAttributes$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect" {
import {$ChargedAbilityEffect$TargetRequirement, $ChargedAbilityEffect$TargetRequirement$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect$TargetRequirement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ChargedAbilityEffect {

constructor(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: $ItemEffect$Type, arg5: $ChargedAbilityEffect$TargetRequirement$Type, arg6: $UseAnim$Type)
constructor(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: $ItemEffect$Type, arg5: $ChargedAbilityEffect$TargetRequirement$Type, arg6: $UseAnim$Type, arg7: string)

public "isAvailable"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): boolean
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $BlockPos$Type, arg6: $Vec3$Type, arg7: integer): void
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $BlockPos$Type, arg5: $Vec3$Type, arg6: integer): void
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: integer): void
public "canPerform"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type, arg3: $LivingEntity$Type, arg4: $BlockPos$Type, arg5: integer): boolean
public "getCooldown"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): integer
public "canOvercharge"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): boolean
public "getChargeTime"(arg0: $Player$Type, arg1: $ItemModularHandheld$Type, arg2: $ItemStack$Type): integer
public "getChargeTime"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): integer
public "getOverchargeBonus"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: integer): integer
public "isDefensive"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: $InteractionHand$Type): boolean
public static "getOverchargeProgress"(arg0: float): double
public "getOverchargeProgress"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type, arg2: integer): double
public "getSpeedBonusMultiplier"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): float
public "getModelTransform"(): string
public "getPose"(): $UseAnim
public "canCharge"(arg0: $ItemModularHandheld$Type, arg1: $ItemStack$Type): boolean
get "modelTransform"(): string
get "pose"(): $UseAnim
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChargedAbilityEffect$Type = ($ChargedAbilityEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChargedAbilityEffect_ = $ChargedAbilityEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterSweeping" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterSweeping implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterSweeping$Type = ($TooltipGetterSweeping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterSweeping_ = $TooltipGetterSweeping$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$AspectRequirement" {
import {$ItemAspect, $ItemAspect$Type} from "packages/se/mickelus/tetra/aspect/$ItemAspect"
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$IntegerPredicate, $IntegerPredicate$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$IntegerPredicate"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $AspectRequirement implements $CraftingRequirement {

constructor(arg0: $ItemAspect$Type, arg1: $IntegerPredicate$Type)

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AspectRequirement$Type = ($AspectRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AspectRequirement_ = $AspectRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$TransformationDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $TransformationDeserializer implements $JsonDeserializer<($Transformation)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Transformation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformationDeserializer$Type = ($TransformationDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformationDeserializer_ = $TransformationDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModule" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"

export class $GuiModule extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $GuiAttachment$Type, arg3: $ItemStack$Type, arg4: $ItemStack$Type, arg5: string, arg6: string, arg7: $ItemModule$Type, arg8: $ItemModule$Type, arg9: $Consumer$Type<(string)>, arg10: $BiConsumer$Type<(string), (string)>)

public "updateSelectedHighlight"(arg0: string): void
public "showAnimation"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModule$Type = ($GuiModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModule_ = $GuiModule$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ModuleRegistry" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $ModuleRegistry {
static "instance": $ModuleRegistry

constructor()

public "getModule"(arg0: $ResourceLocation$Type): $ItemModule
public "registerModuleType"(arg0: $ResourceLocation$Type, arg1: $BiFunction$Type<($ResourceLocation$Type), ($ModuleData$Type), ($ItemModule$Type)>): void
public "getAllModules"(): $Collection<($ItemModule)>
get "allModules"(): $Collection<($ItemModule)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleRegistry$Type = ($ModuleRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleRegistry_ = $ModuleRegistry$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$QuickLatchItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $QuickLatchItem extends $TetraItem {
static readonly "identifier": string
static "instance": $QuickLatchItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuickLatchItem$Type = ($QuickLatchItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuickLatchItem_ = $QuickLatchItem$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterStriking" {
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$StatGetterEffectLevel, $StatGetterEffectLevel$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectLevel"

export class $StatGetterStriking extends $StatGetterEffectLevel {

constructor(arg0: $ToolAction$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterStriking$Type = ($StatGetterStriking);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterStriking_ = $StatGetterStriking$Type;
}}
declare module "packages/se/mickelus/tetra/client/particle/$SweepingStrikeParticle" {
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$TextureSheetParticle, $TextureSheetParticle$Type} from "packages/net/minecraft/client/particle/$TextureSheetParticle"

export class $SweepingStrikeParticle extends $TextureSheetParticle {
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "age": integer
 "rCol": float
 "gCol": float
 "bCol": float


public "getRenderType"(): $ParticleRenderType
public "tick"(): void
public "render"(arg0: $VertexConsumer$Type, arg1: $Camera$Type, arg2: float): void
get "renderType"(): $ParticleRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweepingStrikeParticle$Type = ($SweepingStrikeParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SweepingStrikeParticle_ = $SweepingStrikeParticle$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$ColorQuadTransformer" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IQuadTransformer, $IQuadTransformer$Type} from "packages/net/minecraftforge/client/model/$IQuadTransformer"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $ColorQuadTransformer implements $IQuadTransformer {

constructor(arg0: integer)

public "processInPlace"(arg0: $BakedQuad$Type): void
public "andThen"(arg0: $IQuadTransformer$Type): $IQuadTransformer
public "process"(arg0: $List$Type<($BakedQuad$Type)>): $List<($BakedQuad)>
public "process"(arg0: $BakedQuad$Type): $BakedQuad
public "processInPlace"(arg0: $List$Type<($BakedQuad$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorQuadTransformer$Type = ($ColorQuadTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColorQuadTransformer_ = $ColorQuadTransformer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$ScannerDebugRenderer" {
import {$RenderLevelStageEvent, $RenderLevelStageEvent$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent"
import {$ScannerOverlayGui, $ScannerOverlayGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$ScannerOverlayGui"

export class $ScannerDebugRenderer {

constructor(arg0: $ScannerOverlayGui$Type)

public "onRenderWorld"(arg0: $RenderLevelStageEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScannerDebugRenderer$Type = ($ScannerDebugRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScannerDebugRenderer_ = $ScannerDebugRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterUnbreaking" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterUnbreaking implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterUnbreaking$Type = ($TooltipGetterUnbreaking);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterUnbreaking_ = $TooltipGetterUnbreaking$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloImprovementListGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$OutcomeStack, $OutcomeStack$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$OutcomeStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloImprovementListGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Consumer$Type<($OutcomePreview$Type)>, arg5: $Consumer$Type<($OutcomePreview$Type)>, arg6: $Consumer$Type<($OutcomeStack$Type)>)

public "hide"(): void
public "updateSelection"(arg0: $ItemStack$Type, arg1: $List$Type<($OutcomeStack$Type)>): void
public "show"(): void
public "forceHide"(): void
public "updateSchematics"(arg0: $ItemStack$Type, arg1: string, arg2: ($UpgradeSchematic$Type)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloImprovementListGui$Type = ($HoloImprovementListGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloImprovementListGui_ = $HoloImprovementListGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollRenderer" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ScrollTile, $ScrollTile$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollTile"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $ScrollRenderer implements $BlockEntityRenderer<($ScrollTile)> {
static readonly "material": $Material
static "layer": $ModelLayerLocation

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public static "createLayer"(): $LayerDefinition
public "render"(arg0: $ScrollTile$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $ScrollTile$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $ScrollTile$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollRenderer$Type = ($ScrollRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollRenderer_ = $ScrollRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiTool" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"

export class $GuiTool extends $GuiElement {
static readonly "width": integer

constructor(arg0: integer, arg1: integer, arg2: $ToolAction$Type)

public "update"(arg0: integer, arg1: integer): void
public "getToolAction"(): $ToolAction
get "toolAction"(): $ToolAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTool$Type = ($GuiTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTool_ = $GuiTool$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAbilityDamage" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAbilityDamage implements $IStatGetter {

constructor(arg0: double, arg1: double)
constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAbilityDamage$Type = ($StatGetterAbilityDamage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAbilityDamage_ = $StatGetterAbilityDamage$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialsButtonGui" {
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $HoloMaterialsButtonGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $Runnable$Type)

public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialsButtonGui$Type = ($HoloMaterialsButtonGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialsButtonGui_ = $HoloMaterialsButtonGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAnd" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAnd implements $IStatGetter {

constructor(...arg0: ($IStatGetter$Type)[])

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAnd$Type = ($StatGetterAnd);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAnd_ = $StatGetterAnd$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$RuinedMultiblockSchematicItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BaseMultiblockSchematicItem, $BaseMultiblockSchematicItem$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$BaseMultiblockSchematicItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MultiblockSchematicBlock, $MultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicBlock"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RuinedMultiblockSchematicItem extends $BaseMultiblockSchematicItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Block$Type, arg1: $MultiblockSchematicBlock$Type)

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedMultiblockSchematicItem$Type = ($RuinedMultiblockSchematicItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RuinedMultiblockSchematicItem_ = $RuinedMultiblockSchematicItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchPacketUpdate" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $WorkbenchPacketUpdate extends $AbstractPacket {

constructor()
constructor(arg0: $BlockPos$Type, arg1: $UpgradeSchematic$Type, arg2: string)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchPacketUpdate$Type = ($WorkbenchPacketUpdate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchPacketUpdate_ = $WorkbenchPacketUpdate$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiItem$CountMode, $GuiItem$CountMode$Type} from "packages/se/mickelus/mutil/gui/$GuiItem$CountMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiItem extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setResetDepthTest"(arg0: boolean): $GuiItem
public "setTooltip"(arg0: boolean): $GuiItem
public "getTooltipLines"(): $List<($Component)>
public "setOpacityThreshold"(arg0: float): $GuiItem
public "setItem"(arg0: $ItemStack$Type): $GuiItem
public "setCountVisibility"(arg0: $GuiItem$CountMode$Type): $GuiItem
public "setRenderDecoration"(arg0: boolean): $GuiItem
set "resetDepthTest"(value: boolean)
set "tooltip"(value: boolean)
get "tooltipLines"(): $List<($Component)>
set "opacityThreshold"(value: float)
set "item"(value: $ItemStack$Type)
set "countVisibility"(value: $GuiItem$CountMode$Type)
set "renderDecoration"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiItem$Type = ($GuiItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiItem_ = $GuiItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantItemGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloVariantItemGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $OutcomePreview$Type, arg5: $Consumer$Type<($OutcomePreview$Type)>, arg6: $Consumer$Type<($OutcomePreview$Type)>, arg7: $Consumer$Type<($OutcomePreview$Type)>)
constructor(arg0: integer, arg1: integer, arg2: $OutcomePreview$Type, arg3: string, arg4: $Consumer$Type<($OutcomePreview$Type)>, arg5: $Consumer$Type<($OutcomePreview$Type)>, arg6: $Consumer$Type<($OutcomePreview$Type)>)

public "updateSelection"(arg0: $OutcomePreview$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloVariantItemGui$Type = ($HoloVariantItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloVariantItemGui_ = $HoloVariantItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/$TetraCommand" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $TetraCommand {

constructor()

public static "register"(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>, arg1: $CommandBuildContext$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraCommand$Type = ($TetraCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraCommand_ = $TetraCommand$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/sorting/$NaturalSorter" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $NaturalSorter implements $IStatSorter {

constructor()

public "getName"(): string
public "compare"<T>(arg0: $Player$Type, arg1: $Function$Type<(any), ($ItemStack$Type)>): $Comparator<(T)>
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getWeight"(arg0: $Player$Type, arg1: $ItemStack$Type): integer
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NaturalSorter$Type = ($NaturalSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NaturalSorter_ = $NaturalSorter$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiSources" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$List, $List$Type} from "packages/java/util/$List"

export class $GuiSources extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "update"(arg0: $UpgradeSchematic$Type): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSources$Type = ($GuiSources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSources_ = $GuiSources$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiString" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiString extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string)
constructor(arg0: integer, arg1: integer, arg2: string)

public "setColor"(arg0: integer): void
public "setShadow"(arg0: boolean): $GuiString
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setString"(arg0: string): void
set "color"(value: integer)
set "shadow"(value: boolean)
set "string"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiString$Type = ($GuiString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiString_ = $GuiString$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ThrownModularItemEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IEntityAdditionalSpawnData, $IEntityAdditionalSpawnData$Type} from "packages/net/minecraftforge/entity/$IEntityAdditionalSpawnData"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractArrow, $AbstractArrow$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IntOpenHashSet, $IntOpenHashSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntOpenHashSet"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AbstractArrow$Pickup, $AbstractArrow$Pickup$Type} from "packages/net/minecraft/world/entity/projectile/$AbstractArrow$Pickup"
import {$PlayMessages$SpawnEntity, $PlayMessages$SpawnEntity$Type} from "packages/net/minecraftforge/network/$PlayMessages$SpawnEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ThrownModularItemEntity extends $AbstractArrow implements $IEntityAdditionalSpawnData {
static readonly "unlocalizedName": string
static readonly "stackKey": string
static readonly "dealtDamageKey": string
static readonly "preferredSlotKey": string
static "type": $EntityType<($ThrownModularItemEntity)>
static "preferUnavailable": integer
static "preferOffhand": integer
static "preferToolbelt": integer
 "returningTicks": integer
 "pickup": $AbstractArrow$Pickup
 "shakeTime": integer
 "piercingIgnoreEntityIds": $IntOpenHashSet
 "ownerUUID": $UUID
 "cachedOwner": $Entity
 "leftOwner": boolean
 "hasBeenShot": boolean
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $PlayMessages$SpawnEntity$Type, arg1: $Level$Type)
constructor(arg0: $Level$Type, arg1: double, arg2: double, arg3: double)
constructor(arg0: $Level$Type, arg1: $Player$Type, arg2: $ItemStack$Type)
constructor(arg0: $EntityType$Type<(any)>, arg1: $Level$Type)

public "hasDealtDamage"(): boolean
public "getThrownStack"(): $ItemStack
public "tick"(): void
public "onGround"(): boolean
public "playerTouch"(arg0: $Player$Type): void
public "readAdditionalSaveData"(arg0: $CompoundTag$Type): void
public "addAdditionalSaveData"(arg0: $CompoundTag$Type): void
public "m_6901_"(): void
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
public "shouldRender"(arg0: double, arg1: double, arg2: double): boolean
public "writeSpawnData"(arg0: $FriendlyByteBuf$Type): void
public "readSpawnData"(arg0: $FriendlyByteBuf$Type): void
get "thrownStack"(): $ItemStack
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThrownModularItemEntity$Type = ($ThrownModularItemEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThrownModularItemEntity_ = $ThrownModularItemEntity$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleEnchantment" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $GuiModuleEnchantment extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Enchantment$Type, arg3: integer, arg4: integer, arg5: $Runnable$Type, arg6: $Runnable$Type)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleEnchantment$Type = ($GuiModuleEnchantment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleEnchantment_ = $GuiModuleEnchantment$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiRoot" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiRoot extends $GuiElement {

constructor(arg0: $Minecraft$Type)

public "draw"(arg0: $GuiGraphics$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiRoot$Type = ($GuiRoot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiRoot_ = $GuiRoot$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ModularItem, $ModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$ModularItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$AbilityUseResult, $AbilityUseResult$Type} from "packages/se/mickelus/tetra/effect/$AbilityUseResult"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemModularHandheld extends $ModularItem {
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type)

public "isBlocking"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
public "onActionConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public "dowseBlock"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type): boolean
public "denailBlock"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $InteractionHand$Type, arg4: $Direction$Type): boolean
public "bashEntity"(arg0: $ItemStack$Type, arg1: integer, arg2: $Player$Type, arg3: $LivingEntity$Type): void
public "jabEntity"(arg0: $ItemStack$Type, arg1: integer, arg2: $Player$Type, arg3: $LivingEntity$Type): void
public "hitEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $LivingEntity$Type, arg3: double, arg4: float, arg5: float): $AbilityUseResult
public "hitEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $LivingEntity$Type, arg3: double, arg4: double, arg5: float, arg6: float): $AbilityUseResult
public "getEntityHitDamage"(): integer
public static "canDenail"(arg0: $BlockState$Type): boolean
public "isShield"(arg0: $ItemStack$Type): boolean
public "onShieldDisabled"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public "getCooldownBase"(arg0: $ItemStack$Type): double
public "getEffectAttributes"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "canDisableShield"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $LivingEntity$Type, arg3: $LivingEntity$Type): boolean
public "canPerformAction"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
public "isCorrectToolForDrops"(arg0: $ItemStack$Type, arg1: $BlockState$Type): boolean
public "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getUseDuration"(arg0: $ItemStack$Type): integer
public "getAbilityBaseDamage"(arg0: $ItemStack$Type): double
public "applyBlockBreakEffects"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type, arg4: $LivingEntity$Type): void
public "getBlockDestroyDamage"(): integer
public "triggerChargedAbility"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "onPlayerStoppedUsingSecondary"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "getChargeableAbility"(arg0: $ItemStack$Type): $ChargedAbilityEffect
public static "handleSecondaryAbility"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $LivingEntity$Type): void
public static "handleChargedAbility"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $LivingEntity$Type, arg3: $BlockPos$Type, arg4: $Vec3$Type, arg5: integer): void
public "itemInteractionForEntitySecondary"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $LivingEntity$Type, arg3: $InteractionHand$Type): boolean
public "getCounterWeightBonus"(arg0: $ItemStack$Type): double
public static "getCounterWeightBonus"(arg0: integer, arg1: integer): double
public static "getAttackSpeedHarvestModifier"(arg0: double): double
public static "getEfficiencyEnchantmentBonus"(arg0: integer): double
public "getDestroySpeed"(arg0: $ItemStack$Type, arg1: $BlockState$Type): float
public "finishUsingItem"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type): $ItemStack
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "hurtEnemy"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type): boolean
public "mineBlock"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type, arg4: $LivingEntity$Type): boolean
public "interactLivingEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $LivingEntity$Type, arg3: $InteractionHand$Type): $InteractionResult
public "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
public "getUseAnimation"(arg0: $ItemStack$Type): $UseAnim
public "isDamageable"(arg0: $ItemStack$Type): boolean
public "onLeftClickEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $Entity$Type): boolean
public "getBlockProgress"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): float
public "throwItem"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: integer, arg3: float): void
public "isThrowing"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
public "causeRiptideEffect"(arg0: $Player$Type, arg1: integer): void
public "getToolActions"(arg0: $ItemStack$Type): $Set<($ToolAction)>
public "getHarvestTier"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
public "onCraftConsume"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Player$Type, arg3: $ToolAction$Type, arg4: integer, arg5: boolean): $ItemStack
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
get "entityHitDamage"(): integer
get "blockDestroyDamage"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModularHandheld$Type = ($ItemModularHandheld);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModularHandheld_ = $ItemModularHandheld$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantListGui" {
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloVariantListGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Consumer$Type<($OutcomePreview$Type)>, arg4: $Consumer$Type<($OutcomePreview$Type)>, arg5: $Consumer$Type<($OutcomePreview$Type)>)

public "update"(arg0: ($OutcomePreview$Type)[]): void
public "updateSelection"(arg0: $OutcomePreview$Type): void
public "onCharType"(arg0: character, arg1: integer): boolean
public "updateFilter"(arg0: string): void
public "onMouseScroll"(arg0: double, arg1: double, arg2: double): boolean
public "changeSorting"(arg0: $IStatSorter$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloVariantListGui$Type = ($HoloVariantListGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloVariantListGui_ = $HoloVariantListGui$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiElement" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$KeyframeAnimation, $KeyframeAnimation$Type} from "packages/se/mickelus/mutil/gui/animation/$KeyframeAnimation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "remove"(): void
public "getChildren"<T>(arg0: $Class$Type<(T)>): $List<(T)>
public "getChildren"(): $List<($GuiElement)>
public "getChild"(arg0: integer): $GuiElement
public "setWidth"(arg0: integer): void
public "setOpacity"(arg0: float): $GuiElement
public "setAttachmentAnchor"(arg0: $GuiAttachment$Type): $GuiElement
public "getY"(): integer
public "updateAnimations"(): void
public "setVisible"(arg0: boolean): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setX"(arg0: integer): void
public "setY"(arg0: integer): void
public "getX"(): integer
public "isVisible"(): boolean
public "getWidth"(): integer
public "getHeight"(): integer
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onKeyRelease"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onCharType"(arg0: character, arg1: integer): boolean
public "getTooltipLines"(): $List<($Component)>
public "addChild"(arg0: $GuiElement$Type): void
public "shouldRemove"(): boolean
public "getAttachmentAnchor"(): $GuiAttachment
public "setAttachment"(arg0: $GuiAttachment$Type): $GuiElement
public "setAttachmentPoint"(arg0: $GuiAttachment$Type): $GuiElement
public "hasFocus"(): boolean
public "setHeight"(arg0: integer): void
public "onKeyPress"(arg0: integer, arg1: integer, arg2: integer): boolean
public "onMouseScroll"(arg0: double, arg1: double, arg2: double): boolean
public "getOpacity"(): float
public "onMouseRelease"(arg0: integer, arg1: integer, arg2: integer): void
public "getAttachmentPoint"(): $GuiAttachment
public "addAnimation"(arg0: $KeyframeAnimation$Type): void
public "clearChildren"(): void
public "getNumChildren"(): integer
public "removeAnimation"(arg0: $KeyframeAnimation$Type): void
get "children"(): $List<($GuiElement)>
set "width"(value: integer)
set "opacity"(value: float)
set "attachmentAnchor"(value: $GuiAttachment$Type)
get "y"(): integer
set "visible"(value: boolean)
set "x"(value: integer)
set "y"(value: integer)
get "x"(): integer
get "visible"(): boolean
get "width"(): integer
get "height"(): integer
get "tooltipLines"(): $List<($Component)>
get "attachmentAnchor"(): $GuiAttachment
set "attachment"(value: $GuiAttachment$Type)
set "attachmentPoint"(value: $GuiAttachment$Type)
set "height"(value: integer)
get "opacity"(): float
get "attachmentPoint"(): $GuiAttachment
get "numChildren"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElement$Type = ($GuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElement_ = $GuiElement$Type;
}}
declare module "packages/se/mickelus/tetra/trades/$ItemsForEmeraldsTrade" {
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ItemsForEmeraldsTrade implements $VillagerTrades$ItemListing {

constructor(arg0: $ItemStack$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer)
constructor(arg0: $ItemStack$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: float)

public "getOffer"(arg0: $Entity$Type, arg1: $RandomSource$Type): $MerchantOffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemsForEmeraldsTrade$Type = ($ItemsForEmeraldsTrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemsForEmeraldsTrade_ = $ItemsForEmeraldsTrade$Type;
}}
declare module "packages/se/mickelus/tetra/data/$ImprovementStore" {
import {$MaterialStore, $MaterialStore$Type} from "packages/se/mickelus/tetra/data/$MaterialStore"
import {$DataStore, $DataStore$Type} from "packages/se/mickelus/mutil/data/$DataStore"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"

export class $ImprovementStore extends $DataStore<(($ImprovementData)[])> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $MaterialStore$Type, arg4: $DataDistributor$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImprovementStore$Type = ($ImprovementStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImprovementStore_ = $ImprovementStore$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollItemColor" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"

export class $ScrollItemColor implements $ItemColor {

constructor()

public "getColor"(arg0: $ItemStack$Type, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollItemColor$Type = ($ScrollItemColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollItemColor_ = $ScrollItemColor$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/$ModularHolosphereItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ModularItem, $ModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$ModularItem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularHolosphereItem extends $ModularItem {
static readonly "coreKey": string
static readonly "frameKey": string
static readonly "scannerKey": string
static readonly "repositoryKey": string
static readonly "identifier": string
static "instance": $ModularHolosphereItem
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public static "findHolosphere"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type): $ItemStack
public static "findHolosphere"(arg0: $Player$Type): $ItemStack
public static "findHolosphere"(arg0: $Level$Type, arg1: $BlockPos$Type): $ItemStack
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public static "showGui"(): void
public "getCooldownBase"(arg0: $ItemStack$Type): double
public "commonInit"(arg0: $PacketHandler$Type): void
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(arg0: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public static "getCreativeItemStack"(): $ItemStack
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
get "creativeItemStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularHolosphereItem$Type = ($ModularHolosphereItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularHolosphereItem_ = $ModularHolosphereItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedPillarBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InitializableBlock, $InitializableBlock$Type} from "packages/se/mickelus/tetra/blocks/$InitializableBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$RotatedPillarBlock, $RotatedPillarBlock$Type} from "packages/net/minecraft/world/level/block/$RotatedPillarBlock"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"

export class $ForgedPillarBlock extends $RotatedPillarBlock implements $InitializableBlock {
static readonly "identifier": string
static readonly "AXIS": $EnumProperty<($Direction$Axis)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedPillarBlock$Type = ($ForgedPillarBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedPillarBlock_ = $ForgedPillarBlock$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$SlotType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SlotType extends $Enum<($SlotType)> {
static readonly "storage": $SlotType
static readonly "quiver": $SlotType
static readonly "potion": $SlotType
static readonly "quick": $SlotType


public static "values"(): ($SlotType)[]
public static "valueOf"(arg0: string): $SlotType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotType$Type = (("potion") | ("quick") | ("storage") | ("quiver")) | ($SlotType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotType_ = $SlotType$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$NotCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NotCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotCondition$Type = ($NotCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotCondition_ = $NotCondition$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$ApplyNbtOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ApplyNbtOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyNbtOutcome$Type = ($ApplyNbtOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyNbtOutcome_ = $ApplyNbtOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$LungeEchoPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $LungeEchoPacket extends $AbstractPacket {

constructor()
constructor(arg0: boolean)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LungeEchoPacket$Type = ($LungeEchoPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LungeEchoPacket_ = $LungeEchoPacket$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterDecimal" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterDecimal implements $ITooltipGetter {

constructor(arg0: string, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterDecimal$Type = ($TooltipGetterDecimal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterDecimal_ = $TooltipGetterDecimal$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/$CraftingEffectRegistry" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingEffect, $CraftingEffect$Type} from "packages/se/mickelus/tetra/craftingeffect/$CraftingEffect"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CraftingEffectRegistry {
static "instance": $CraftingEffectRegistry

constructor()

public static "registerEffectType"(arg0: string, arg1: $Class$Type<(any)>): void
public static "getConditionClass"(arg0: string): $Class<(any)>
public static "getEffectClass"(arg0: string): $Class<(any)>
public static "getEffects"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): ($CraftingEffect)[]
public static "registerConditionType"(arg0: string, arg1: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingEffectRegistry$Type = ($CraftingEffectRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingEffectRegistry_ = $CraftingEffectRegistry$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$ModularToolbeltItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SlotType, $SlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$SlotType"
import {$ModularItem, $ModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$ModularItem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularToolbeltItem extends $ModularItem implements $MenuProvider {
static readonly "identifier": string
static readonly "slot1Key": string
static readonly "slot2Key": string
static readonly "slot3Key": string
static readonly "beltKey": string
static readonly "slot1Suffix": string
static readonly "slot2Suffix": string
static readonly "slot3Suffix": string
static "instance": $RegistryObject<($ModularToolbeltItem)>
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "clientInit"(): void
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getDisplayName"(): $Component
public "getNumSlots"(arg0: $ItemStack$Type, arg1: $SlotType$Type): integer
public "getSlotEffects"(arg0: $ItemStack$Type, arg1: $SlotType$Type): $List<($Collection<($ItemEffect)>)>
public "commonInit"(arg0: $PacketHandler$Type): void
public "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "createMenu"(arg0: integer, arg1: $Inventory$Type, arg2: $Player$Type): $AbstractContainerMenu
public static "getCreativeTabItemStacks"(): $Collection<($ItemStack)>
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
get "displayName"(): $Component
get "creativeTabItemStacks"(): $Collection<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularToolbeltItem$Type = ($ModularToolbeltItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularToolbeltItem_ = $ModularToolbeltItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/particle/$SparkleParticleType" {
import {$SimpleParticleType, $SimpleParticleType$Type} from "packages/net/minecraft/core/particles/$SimpleParticleType"

export class $SparkleParticleType {
static readonly "identifier": string
static "instance": $SimpleParticleType

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkleParticleType$Type = ($SparkleParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkleParticleType_ = $SparkleParticleType$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$ImprovementCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ImprovementCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImprovementCondition$Type = ($ImprovementCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImprovementCondition_ = $ImprovementCondition$Type;
}}
declare module "packages/se/mickelus/tetra/aspect/$ItemAspect" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ItemAspect {
static readonly "armor": $ItemAspect
static readonly "armorFeet": $ItemAspect
static readonly "armorLegs": $ItemAspect
static readonly "armorChest": $ItemAspect
static readonly "armorHead": $ItemAspect
static readonly "edgedWeapon": $ItemAspect
static readonly "bluntWeapon": $ItemAspect
static readonly "pointyWeapon": $ItemAspect
static readonly "throwable": $ItemAspect
static readonly "blockBreaker": $ItemAspect
static readonly "fishingRod": $ItemAspect
static readonly "breakable": $ItemAspect
static readonly "bow": $ItemAspect
static readonly "wearable": $ItemAspect
static readonly "crossbow": $ItemAspect
static readonly "vanishable": $ItemAspect


public static "get"(arg0: string): $ItemAspect
public "getKey"(): string
get "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAspect$Type = ($ItemAspect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAspect_ = $ItemAspect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/suspend/$JumpHandlerSuspend" {
import {$InputEvent$Key, $InputEvent$Key$Type} from "packages/net/minecraftforge/client/event/$InputEvent$Key"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"

export class $JumpHandlerSuspend {

constructor(arg0: $Minecraft$Type)

public "onKeyInput"(arg0: $InputEvent$Key$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JumpHandlerSuspend$Type = ($JumpHandlerSuspend);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JumpHandlerSuspend_ = $JumpHandlerSuspend$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBar" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$GuiStatIndicator, $GuiStatIndicator$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatIndicator"
import {$GuiStatBase, $GuiStatBase$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiStatBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiAlignment, $GuiAlignment$Type} from "packages/se/mickelus/mutil/gui/$GuiAlignment"
import {$ILabelGetter, $ILabelGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ILabelGetter"

export class $GuiStatBar extends $GuiStatBase {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string, arg4: double, arg5: double, arg6: boolean, arg7: $IStatGetter$Type, arg8: $ILabelGetter$Type, arg9: $ITooltipGetter$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string, arg4: double, arg5: double, arg6: boolean, arg7: boolean, arg8: boolean, arg9: $IStatGetter$Type, arg10: $ILabelGetter$Type, arg11: $ITooltipGetter$Type)

public "update"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): void
public "setAlignment"(arg0: $GuiAlignment$Type): void
public "getTooltipLines"(): $List<($Component)>
public "updateValue"(arg0: double, arg1: double): void
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: string, arg4: string): boolean
public "setIndicators"(...arg0: ($GuiStatIndicator$Type)[]): $GuiStatBar
set "alignment"(value: $GuiAlignment$Type)
get "tooltipLines"(): $List<($Component)>
set "indicators"(value: ($GuiStatIndicator$Type)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStatBar$Type = ($GuiStatBar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStatBar_ = $GuiStatBar$Type;
}}
declare module "packages/se/mickelus/tetra/data/$ModuleStore" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$MergingDataStore, $MergingDataStore$Type} from "packages/se/mickelus/mutil/data/$MergingDataStore"

export class $ModuleStore extends $MergingDataStore<($ModuleData), (($ModuleData)[])> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $DataDistributor$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleStore$Type = ($ModuleStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleStore_ = $ModuleStore$Type;
}}
declare module "packages/se/mickelus/mutil/data/$DataDistributor" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $DataDistributor {

 "sendToPlayer"(arg0: $ServerPlayer$Type, arg1: string, arg2: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
 "sendToAll"(arg0: string, arg1: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
}

export namespace $DataDistributor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataDistributor$Type = ($DataDistributor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataDistributor_ = $DataDistributor$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$SculkTaintEffect" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$SculkSpreader, $SculkSpreader$Type} from "packages/net/minecraft/world/level/block/$SculkSpreader"

export class $SculkTaintEffect {

constructor()

public static "perform"(arg0: $ServerLevel$Type, arg1: $BlockPos$Type, arg2: integer, arg3: float): void
public static "tickSpread"(arg0: $SculkSpreader$Type, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type, arg3: integer): void
public static "startSpread"(arg0: $ServerLevel$Type, arg1: $BlockPos$Type, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkTaintEffect$Type = ($SculkTaintEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SculkTaintEffect_ = $SculkTaintEffect$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$QuiverGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$QuiverInventory, $QuiverInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuiverInventory"

export class $QuiverGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "clear"(): void
public "setVisible"(arg0: boolean): void
public "getHand"(): $InteractionHand
public "setInventory"(arg0: $QuiverInventory$Type): void
public "getFocus"(): integer
set "visible"(value: boolean)
get "hand"(): $InteractionHand
set "inventory"(value: $QuiverInventory$Type)
get "focus"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuiverGroupGui$Type = ($QuiverGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuiverGroupGui_ = $QuiverGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/$HoloGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HoloGui extends $Screen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor()

public static "getInstance"(): $HoloGui
public "onShow"(): void
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "removed"(): void
public "openSchematic"(arg0: $IModularItem$Type, arg1: $ItemStack$Type, arg2: string, arg3: $UpgradeSchematic$Type, arg4: $Runnable$Type): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "mouseScrolled"(arg0: double, arg1: double, arg2: double): boolean
public "keyReleased"(arg0: integer, arg1: integer, arg2: integer): boolean
get "instance"(): $HoloGui
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloGui$Type = ($HoloGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloGui_ = $HoloGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloDescription" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloDescription extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $UpgradeSchematic$Type, arg1: $ItemStack$Type): void
public "update"(arg0: ($OutcomePreview$Type)[]): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloDescription$Type = ($HoloDescription);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloDescription_ = $HoloDescription$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiStringSmall" {
import {$GuiAttachment, $GuiAttachment$Type} from "packages/se/mickelus/mutil/gui/$GuiAttachment"
import {$GuiString, $GuiString$Type} from "packages/se/mickelus/mutil/gui/$GuiString"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiStringSmall extends $GuiString {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer, arg4: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $GuiAttachment$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: string)

public "getY"(): integer
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setX"(arg0: integer): void
public "setY"(arg0: integer): void
public "getX"(): integer
public "getWidth"(): integer
public "getHeight"(): integer
get "y"(): integer
set "x"(value: integer)
set "y"(value: integer)
get "x"(): integer
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiStringSmall$Type = ($GuiStringSmall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiStringSmall_ = $GuiStringSmall$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ItemColors" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ItemColors {
static "oak": integer
static "oak_glyph": integer
static "spruce": integer
static "spruce_glyph": integer
static "birch": integer
static "birch_glyph": integer
static "jungle": integer
static "jungle_glyph": integer
static "acacia": integer
static "acacia_glyph": integer
static "dark_oak": integer
static "dark_oak_glyph": integer
static "crimson": integer
static "crimson_glyph": integer
static "warped": integer
static "warped_glyph": integer
static "cobblestone": integer
static "cobblestone_glyph": integer
static "stone": integer
static "stone_glyph": integer
static "granite": integer
static "granite_glyph": integer
static "diorite": integer
static "diorite_glyph": integer
static "andesite": integer
static "andesite_glyph": integer
static "blackstone": integer
static "blackstone_glyph": integer
static "obsidian": integer
static "obsidian_glyph": integer
static "flint": integer
static "flint_glyph": integer
static "iron": integer
static "iron_dark": integer
static "iron_glyph": integer
static "netherite": integer
static "netherite_glyph": integer
static "gold": integer
static "gold_glyph": integer
static "diamond": integer
static "diamond_glyph": integer
static "lapis": integer
static "lapis_glyph": integer
static "emerald": integer
static "emerald_glyph": integer
static "copper": integer
static "copper_glyph": integer
static "tin": integer
static "tin_glyph": integer
static "silver": integer
static "silver_glyph": integer
static "nickel": integer
static "nickel_glyph": integer
static "lead": integer
static "lead_glyph": integer
static "bronze": integer
static "bronze_glyph": integer
static "electrum": integer
static "electrum_glyph": integer
static "steel": integer
static "steel_glyph": integer
static "prismarine": integer
static "prismarine_dark": integer
static "prismarine_glyph": integer
static "stick": integer
static "stick_glyph": integer
static "maple": integer
static "maple_glyph": integer
static "cherry": integer
static "cherry_glyph": integer
static "baobab": integer
static "baobab_glyph": integer
static "bone": integer
static "bone_glyph": integer
static "blaze_rod": integer
static "blaze_rod_glyph": integer
static "end_rod": integer
static "end_rod_glyph": integer
static "greatwood": integer
static "greatwood_glyph": integer
static "treated_wood": integer
static "treated_wood_glyph": integer
static "forged_beam": integer
static "forged_beam_glyph": integer
static "string": integer
static "string_glyph": integer
static "wool": integer
static "wool_glyph": integer
static "leather": integer
static "leather_glyph": integer
static "hide": integer
static "hide_glyph": integer
static "turtle": integer
static "turtle_glyph": integer
static "shulker": integer
static "shulker_glyph": integer
static "phantom": integer
static "phantom_glyph": integer
static "dragon": integer
static "dragon_glyph": integer
static "vine": integer
static "vine_glyph": integer
static "weeping": integer
static "weeping_glyph": integer
static "bolt": integer
static "bolt_glyph": integer
static "vent": integer
static "vent_glyph": integer
static "thaumium": integer
static "thaumium_glyph": integer
static "ironwood": integer
static "ironwood_glyph": integer
static "steeleaf": integer
static "steeleaf_glyph": integer
static "fierymetal": integer
static "fierymetal_glyph": integer
static "knightmetal": integer
static "knightmetal_glyph": integer
static "inherit": integer

constructor()

public static "get"(arg0: string): integer
public static "exists"(arg0: string): boolean
public static "define"(arg0: integer, arg1: string): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemColors$Type = ($ItemColors);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemColors_ = $ItemColors$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ModularShieldRenderer" {
import {$BlockEntityWithoutLevelRenderer, $BlockEntityWithoutLevelRenderer$Type} from "packages/net/minecraft/client/renderer/$BlockEntityWithoutLevelRenderer"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$ModularShieldBannerModel, $ModularShieldBannerModel$Type} from "packages/se/mickelus/tetra/items/modular/impl/shield/$ModularShieldBannerModel"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"

export class $ModularShieldRenderer extends $BlockEntityWithoutLevelRenderer {
static "layer": $ModelLayerLocation
static "bannerLayer": $ModelLayerLocation
 "bannerModel": $ModularShieldBannerModel

constructor(arg0: $Minecraft$Type)

public "onResourceManagerReload"(arg0: $ResourceManager$Type): void
public "renderByItem"(arg0: $ItemStack$Type, arg1: $ItemDisplayContext$Type, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularShieldRenderer$Type = ($ModularShieldRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularShieldRenderer_ = $ModularShieldRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/module/$ReplacementDefinition" {
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ReplacementDefinition {
 "predicate": $ItemPredicate
 "itemStack": $ItemStack

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementDefinition$Type = ($ReplacementDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplacementDefinition_ = $ReplacementDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/bar/$GuiBarSplit" {
import {$GuiBar, $GuiBar$Type} from "packages/se/mickelus/tetra/gui/stats/bar/$GuiBar"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiBarSplit extends $GuiBar {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: double, arg4: boolean)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiBarSplit$Type = ($GuiBarSplit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiBarSplit_ = $GuiBarSplit$Type;
}}
declare module "packages/se/mickelus/tetra/loot/$FortuneBonusCondition" {
import {$LootContextParam, $LootContextParam$Type} from "packages/net/minecraft/world/level/storage/loot/parameters/$LootContextParam"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ValidationContext, $ValidationContext$Type} from "packages/net/minecraft/world/level/storage/loot/$ValidationContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"

export class $FortuneBonusCondition implements $LootItemCondition {
static readonly "identifier": string
static "type": $RegistryObject<($LootItemConditionType)>

constructor()

public "test"(arg0: $LootContext$Type): boolean
public "getType"(): $LootItemConditionType
public "validate"(arg0: $ValidationContext$Type): void
public "getReferencedContextParams"(): $Set<($LootContextParam<(any)>)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public "negate"(): $Predicate<($LootContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
public "applyLootHandler"(context: $LootContext$Type, loot: $List$Type<($ItemStack$Type)>): boolean
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FortuneBonusCondition$Type = ($FortuneBonusCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FortuneBonusCondition_ = $FortuneBonusCondition$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiSchematicDetail" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GuiSchematicDetail extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Runnable$Type, arg3: $Runnable$Type)

public "update"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $WorkbenchTile$Type, arg3: $UpgradeSchematic$Type, arg4: $ItemStack$Type, arg5: string, arg6: ($ItemStack$Type)[], arg7: $Map$Type<($ToolAction$Type), (integer)>, arg8: $Player$Type): void
public "getTooltipLines"(): $List<($Component)>
public "updateMagicCapacity"(arg0: $UpgradeSchematic$Type, arg1: string, arg2: $ItemStack$Type, arg3: $ItemStack$Type): void
public "updateAvailableTools"(arg0: $Map$Type<($ToolAction$Type), (integer)>): void
public "updateButton"(arg0: $UpgradeSchematic$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $ItemStack$Type, arg4: ($ItemStack$Type)[], arg5: string, arg6: $Map$Type<($ToolAction$Type), (integer)>): void
public "flash"(): void
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSchematicDetail$Type = ($GuiSchematicDetail);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSchematicDetail_ = $GuiSchematicDetail$Type;
}}
declare module "packages/se/mickelus/tetra/event/$ModularItemDamageEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ModularItemDamageEvent extends $Event {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer)

public "getUsingEntity"(): $LivingEntity
public "getOriginalAmount"(): integer
public "isCancelable"(): boolean
public "setAmount"(arg0: integer): void
public "getAmount"(): integer
public "getItemStack"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "usingEntity"(): $LivingEntity
get "originalAmount"(): integer
get "cancelable"(): boolean
set "amount"(value: integer)
get "amount"(): integer
get "itemStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularItemDamageEvent$Type = ($ModularItemDamageEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularItemDamageEvent_ = $ModularItemDamageEvent$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$EnderReverbEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EnderReverbEffect {

constructor()

public static "perform"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnderReverbEffect$Type = ($EnderReverbEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnderReverbEffect_ = $EnderReverbEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$IntegerPredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $IntegerPredicate implements $Predicate<(integer)> {

constructor(arg0: integer, arg1: integer)

public "test"(arg0: integer): boolean
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
public "negate"(): $Predicate<(integer)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
public static "isEqual"<T>(arg0: any): $Predicate<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerPredicate$Type = ($IntegerPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerPredicate_ = $IntegerPredicate$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/rack/$RackBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$IToolProviderBlock, $IToolProviderBlock$Type} from "packages/se/mickelus/tetra/blocks/$IToolProviderBlock"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RackBlock extends $TetraWaterloggedBlock implements $EntityBlock, $IToolProviderBlock {
static readonly "identifier": string
static readonly "facingProp": $DirectionProperty
static "instance": $RackBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "clientInit"(): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "onActionConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: $Player$Type, arg5: $ToolAction$Type, arg6: integer, arg7: boolean): $ItemStack
public "getToolLevel"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type): integer
public "getTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Collection<($ToolAction)>
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "onCraftConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: string, arg5: boolean, arg6: $Player$Type, arg7: $ToolAction$Type, arg8: integer, arg9: boolean): $ItemStack
public "canProvideTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
public "getToolLevels"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Map<($ToolAction), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RackBlock$Type = ($RackBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RackBlock_ = $RackBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiInventoryHighlight" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $GuiInventoryHighlight extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiInventoryHighlight$Type = ($GuiInventoryHighlight);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiInventoryHighlight_ = $GuiInventoryHighlight$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterInteger" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterInteger implements $ITooltipGetter {

constructor(arg0: string, arg1: $IStatGetter$Type, arg2: boolean)
constructor(arg0: string, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterInteger$Type = ($TooltipGetterInteger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterInteger_ = $TooltipGetterInteger$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$StunPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $StunPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $StunPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StunPotionEffect$Type = ($StunPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StunPotionEffect_ = $StunPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/action/$ConfigActionImpl" {
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ConfigAction, $ConfigAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$ConfigAction"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConfigActionImpl extends $ConfigAction {
 "key": string
 "requirement": $ItemPredicate
 "requiredTools": $ToolData
 "lootTable": $ResourceLocation
 "inWorld": boolean

constructor()

public "getKey"(): string
public "canPerformOn"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "perform"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $WorkbenchTile$Type): void
public "allowInWorldInteraction"(): boolean
public "getRequiredToolActions"(arg0: $ItemStack$Type): $Collection<($ToolAction)>
public "getRequiredTools"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
get "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigActionImpl$Type = ($ConfigActionImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigActionImpl_ = $ConfigActionImpl$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterDecimalSingle" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterDecimalSingle implements $ITooltipGetter {

constructor(arg0: string, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterDecimalSingle$Type = ($TooltipGetterDecimalSingle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterDecimalSingle_ = $TooltipGetterDecimalSingle$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$EffectHelper" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EffectHelper {

constructor()

public static "tryReplant"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
public static "getSprinting"(arg0: $LivingEntity$Type): boolean
public static "sendEventToPlayer"(arg0: $ServerPlayer$Type, arg1: integer, arg2: $BlockPos$Type, arg3: integer): void
public static "getEffectEfficiency"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): float
public static "applyEnchantmentHitEffects"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type): void
public static "setCooledAttackStrength"(arg0: $Player$Type, arg1: float): void
public static "getCooledAttackStrength"(arg0: $Player$Type): float
public static "getModifiedEfficiency"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: float, arg3: $BlockState$Type, arg4: $BlockPos$Type): float
public static "breakBlock"(arg0: $Level$Type, arg1: $Player$Type, arg2: $ItemStack$Type, arg3: $BlockPos$Type, arg4: $BlockState$Type, arg5: boolean, arg6: boolean): boolean
public static "setSprinting"(arg0: $LivingEntity$Type, arg1: boolean): void
public static "getEffectLevel"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectHelper$Type = ($EffectHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectHelper_ = $EffectHelper$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$BookEnchantSchematic" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BookEnchantSchematic implements $UpgradeSchematic {

constructor()

public "getName"(): string
public "getKey"(): string
public "getType"(): $SchematicType
public "getDescription"(arg0: $ItemStack$Type): string
public "getSources"(): (string)[]
public "acceptsMaterial"(arg0: $ItemStack$Type, arg1: string, arg2: integer, arg3: $ItemStack$Type): boolean
public "isMaterialsValid"(arg0: $ItemStack$Type, arg1: string, arg2: ($ItemStack$Type)[]): boolean
public "getSlotName"(arg0: $ItemStack$Type, arg1: integer): string
public "canApplyUpgrade"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string, arg4: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "isRelevant"(arg0: $ItemStack$Type): boolean
public "applyUpgrade"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: boolean, arg3: string, arg4: $Player$Type): $ItemStack
public "checkTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $Map$Type<($ToolAction$Type), (integer)>): boolean
public "getPreviews"(arg0: $ItemStack$Type, arg1: string): ($OutcomePreview)[]
public "getExperienceCost"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): integer
public "getGlyph"(): $GlyphData
public "getRequiredQuantity"(arg0: $ItemStack$Type, arg1: integer, arg2: $ItemStack$Type): integer
public "isIntegrityViolation"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: ($ItemStack$Type)[], arg3: string): boolean
public "getNumMaterialSlots"(): integer
public "getSlotPlaceholders"(arg0: $ItemStack$Type, arg1: integer): ($ItemStack)[]
public "isApplicableForSlot"(arg0: string, arg1: $ItemStack$Type): boolean
public "getRequiredToolLevels"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Map<($ToolAction), (integer)>
public "getSeverity"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): float
public "isVisibleForPlayer"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "getRequiredTools"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[]): $Collection<($ToolAction)>
public "isHoning"(): boolean
public "getRarity"(): $SchematicRarity
public "willReplace"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: string): boolean
public "getApplicableMaterials"(): (string)[]
public "matchesRequirements"(arg0: $CraftingContext$Type): boolean
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $ToolAction$Type): integer
public "getMaterialTranslation"(): $MaterialMultiplier
get "name"(): string
get "key"(): string
get "type"(): $SchematicType
get "sources"(): (string)[]
get "glyph"(): $GlyphData
get "numMaterialSlots"(): integer
get "honing"(): boolean
get "rarity"(): $SchematicRarity
get "applicableMaterials"(): (string)[]
get "materialTranslation"(): $MaterialMultiplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BookEnchantSchematic$Type = ($BookEnchantSchematic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BookEnchantSchematic_ = $BookEnchantSchematic$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterBlockingReflect" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterBlockingReflect implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterBlockingReflect$Type = ($TooltipGetterBlockingReflect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterBlockingReflect_ = $TooltipGetterBlockingReflect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/sorting/$StatSorters" {
import {$IStatSorter, $IStatSorter$Type} from "packages/se/mickelus/tetra/gui/stats/sorting/$IStatSorter"
import {$List, $List$Type} from "packages/java/util/$List"

export class $StatSorters {
static readonly "none": $IStatSorter
static readonly "sorters": $List<($IStatSorter)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatSorters$Type = ($StatSorters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatSorters_ = $StatSorters$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$PotionItemGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $PotionItemGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $ItemStack$Type, arg3: integer, arg4: boolean)

public "getSlot"(): integer
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
get "slot"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionItemGui$Type = ($PotionItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionItemGui_ = $PotionItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$IModularItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Cache, $Cache$Type} from "packages/com/google/common/cache/$Cache"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$ItemProperties, $ItemProperties$Type} from "packages/se/mickelus/tetra/module/data/$ItemProperties"
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$SynergyData, $SynergyData$Type} from "packages/se/mickelus/tetra/module/data/$SynergyData"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IModularItem {

 "getProperties"(arg0: $ItemStack$Type): $ItemProperties
 "getItem"(): $Item
 "getIdentifier"(arg0: $ItemStack$Type): string
 "getAttributeValue"(arg0: $ItemStack$Type, arg1: $Attribute$Type, arg2: double): double
 "getAttributeValue"(arg0: $ItemStack$Type, arg1: $Attribute$Type): double
 "getModels"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): $ImmutableList<($ModuleModel)>
 "clearCaches"(): void
 "hasVariantSynergy"(arg0: $SynergyData$Type, arg1: (string)[]): boolean
 "hasModuleSynergy"(arg0: $ItemStack$Type, arg1: $SynergyData$Type, arg2: ($ItemModule$Type)[]): boolean
 "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
 "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
 "tickProgression"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): void
 "applyDamage"(arg0: integer, arg1: $ItemStack$Type, arg2: $LivingEntity$Type): void
 "isBroken"(arg0: integer, arg1: integer): boolean
 "isBroken"(arg0: $ItemStack$Type): boolean
 "applyUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
 "getTransformVariant"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
 "getAttributeModifiersCached"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getEffectDataCached"(arg0: $ItemStack$Type): $EffectData
 "hasImprovementSynergy"(arg0: $SynergyData$Type, arg1: (string)[]): boolean
 "getAttributeModifiersCollapsed"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getEffectAttributes"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getEffectEfficiency"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): float
 "getModuleAttributes"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getDisplayNamePrefixes"(arg0: $ItemStack$Type): string
 "getMajorModuleNames"(arg0: $ItemStack$Type): (string)[]
 "getAttributeModifierCache"(): $Cache<(string), ($Multimap<($Attribute), ($AttributeModifier)>)>
 "canGainHoneProgress"(arg0: $ItemStack$Type): boolean
 "getHoneIntegrityMultiplier"(arg0: $ItemStack$Type): integer
 "getRepairRequiredExperience"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): integer
 "tickHoningProgression"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): void
 "getRepairMaterialCount"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): integer
 "getRepairModuleName"(arg0: $ItemStack$Type): string
 "getRepairRequiredTools"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Collection<($ToolAction)>
 "getRepairRequiredToolLevels"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $Map<($ToolAction), (integer)>
 "getRepairDefinitions"(arg0: $ItemStack$Type): $Collection<($RepairDefinition)>
 "getStabilityModifier"(arg0: $ItemStack$Type): float
 "applyNegativeUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
 "applyPositiveUsageEffects"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: double): void
 "applyDestabilizationEffects"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: float): void
 "incrementRepairCount"(arg0: $ItemStack$Type): void
 "getHoningIntegrityPenalty"(arg0: $ItemStack$Type): integer
 "getImprovementTooltip"(arg0: string, arg1: integer, arg2: boolean): string
 "getRepairRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ToolAction$Type): integer
 "getMinorModuleNames"(arg0: $ItemStack$Type): (string)[]
 "getAttributeModifiers"(arg0: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getTooltip"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $TooltipFlag$Type): $List<($Component)>
 "assemble"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: float): void
 "getEffectDataCache"(): $Cache<(string), ($EffectData)>
 "getRequiredModules"(arg0: $ItemStack$Type): (string)[]
 "getAllModules"(arg0: $ItemStack$Type): $Collection<($ItemModule)>
 "getPropertyCache"(): $Cache<(string), ($ItemProperties)>
 "getHoneBase"(arg0: $ItemStack$Type): integer
 "getMinorModuleKeys"(arg0: $ItemStack$Type): (string)[]
 "getDataCacheKey"(arg0: $ItemStack$Type): string
 "getSynergyData"(arg0: $ItemStack$Type): ($SynergyData)[]
 "getMajorModuleKeys"(arg0: $ItemStack$Type): (string)[]
 "getEnchantability"(arg0: $ItemStack$Type): integer
 "getAllSynergyData"(arg0: $ItemStack$Type): ($SynergyData)[]
 "acceptsEnchantment"(arg0: $ItemStack$Type, arg1: $Enchantment$Type, arg2: boolean): boolean
 "getDefaultStack"(): $ItemStack
 "getNumMajorModules"(arg0: $ItemStack$Type): integer
 "getNumMinorModules"(arg0: $ItemStack$Type): integer
 "isModuleRequired"(arg0: $ItemStack$Type, arg1: string): boolean
 "hasModule"(arg0: $ItemStack$Type, arg1: $ItemModule$Type): boolean
 "getMinorModules"(arg0: $ItemStack$Type): ($ItemModule)[]
 "getMajorModules"(arg0: $ItemStack$Type): ($ItemModuleMajor)[]
 "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
 "getHonedCount"(arg0: $ItemStack$Type): integer
 "getReducedDamage"(arg0: integer, arg1: $ItemStack$Type, arg2: $LivingEntity$Type): integer
 "getModuleFromSlot"(arg0: $ItemStack$Type, arg1: string): $ItemModule
 "getRepairModule"(arg0: $ItemStack$Type): $Optional<($ItemModule)>
 "getRepairCount"(arg0: $ItemStack$Type): integer
 "getRepairCycle"(arg0: $ItemStack$Type): ($ItemModule)[]
 "getRepairAmount"(arg0: $ItemStack$Type): integer
 "fixIdentifiers"(arg0: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
 "getImprovements"(arg0: $ItemStack$Type): ($ImprovementData)[]
 "getPropertiesCached"(arg0: $ItemStack$Type): $ItemProperties
 "getItemName"(arg0: $ItemStack$Type): string
 "setHoningProgress"(arg0: $ItemStack$Type, arg1: integer): void
 "getHoningLimit"(arg0: $ItemStack$Type): integer
 "getHoningProgress"(arg0: $ItemStack$Type): integer
 "getRepairSlot"(arg0: $ItemStack$Type): string
 "repair"(arg0: $ItemStack$Type): void
 "tweak"(arg0: $ItemStack$Type, arg1: string, arg2: $Map$Type<(string), (integer)>): void
 "getEffectData"(arg0: $ItemStack$Type): $EffectData
 "getEffects"(arg0: $ItemStack$Type): $Collection<($ItemEffect)>
 "getEffectLevel"(arg0: $ItemStack$Type, arg1: $ItemEffect$Type): integer
 "getTags"(arg0: $ItemStack$Type): $Set<($TagKey<($Item)>)>
}

export namespace $IModularItem {
const logger: $Logger
const defaultMajorOffsets: ($GuiModuleOffsets)[]
const defaultMinorOffsets: ($GuiModuleOffsets)[]
const identifierKey: string
const repairCountKey: string
const cooledStrengthKey: string
const honeProgressKey: string
const honeAvailableKey: string
const honeCountKey: string
function getImprovementDescription(arg0: string): string
function getIntegrityGain(arg0: $ItemStack$Type): integer
function getIntegrityCost(arg0: $ItemStack$Type): integer
function updateIdentifier(arg0: $CompoundTag$Type): void
function updateIdentifier(arg0: $ItemStack$Type): void
function putModuleInSlot(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
function putModuleInSlot(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
function getHoningSeed(arg0: $ItemStack$Type): integer
function getImprovementName(arg0: string, arg1: integer): string
function removeHoneable(arg0: $ItemStack$Type): void
function isHoneable(arg0: $ItemStack$Type): boolean
function removeAllEnchantments(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModularItem$Type = ($IModularItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModularItem_ = $IModularItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$OpenToolbeltItemPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $OpenToolbeltItemPacket extends $AbstractPacket {

constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpenToolbeltItemPacket$Type = ($OpenToolbeltItemPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpenToolbeltItemPacket_ = $OpenToolbeltItemPacket$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$EffectPair" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EffectPair {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectPair$Type = ($EffectPair);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectPair_ = $EffectPair$Type;
}}
declare module "packages/se/mickelus/mutil/util/$Filter" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $Filter {

constructor()

public static "distinct"<T>(arg0: $Function$Type<(any), (any)>): $Predicate<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Filter$Type = ($Filter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Filter_ = $Filter$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/rack/$RackTile" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $RackTile extends $BlockEntity {
static readonly "unlocalizedName": string
static readonly "inventorySize": integer
static "type": $BlockEntityType<($RackTile)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getRenderBoundingBox"(): $AABB
public "slotInteract"(arg0: integer, arg1: $Player$Type, arg2: $InteractionHand$Type): void
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "renderBoundingBox"(): $AABB
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RackTile$Type = ($RackTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RackTile_ = $RackTile$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$HolosphereGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HolosphereGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemStack$Type): void
public "clear"(): void
public "setVisible"(arg0: boolean): void
public "performActions"(): void
set "visible"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolosphereGroupGui$Type = ($HolosphereGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolosphereGroupGui_ = $HolosphereGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialFeatureGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"

export class $HoloMaterialFeatureGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: boolean, arg4: boolean)

public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialFeatureGui$Type = ($HoloMaterialFeatureGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialFeatureGui_ = $HoloMaterialFeatureGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$InteractiveToolGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $InteractiveToolGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $ToolAction$Type, arg3: integer, arg4: $Player$Type)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "hide"(): void
public "show"(): void
public "updateFadeTime"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractiveToolGui$Type = ($InteractiveToolGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractiveToolGui_ = $InteractiveToolGui$Type;
}}
declare module "packages/se/mickelus/mutil/gui/animation/$AnimationChain" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeyframeAnimation, $KeyframeAnimation$Type} from "packages/se/mickelus/mutil/gui/animation/$KeyframeAnimation"
import {$GuiAnimation, $GuiAnimation$Type} from "packages/se/mickelus/mutil/gui/animation/$GuiAnimation"

export class $AnimationChain implements $GuiAnimation {

constructor(...arg0: ($KeyframeAnimation$Type)[])

public "start"(): void
public "stop"(): void
public "setLooping"(arg0: boolean): $AnimationChain
public "onStop"(arg0: $Consumer$Type<(boolean)>): $AnimationChain
set "looping"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnimationChain$Type = ($AnimationChain);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnimationChain_ = $AnimationChain$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$QuiverItemGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $QuiverItemGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $ItemStack$Type, arg3: integer)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "updateFocusState"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "getItemStack"(): $ItemStack
get "itemStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuiverItemGui$Type = ($QuiverItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuiverItemGui_ = $QuiverItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $CraftingEffectCondition {

 "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean

(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}

export namespace $CraftingEffectCondition {
const any: $CraftingEffectCondition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingEffectCondition$Type = ($CraftingEffectCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingEffectCondition_ = $CraftingEffectCondition$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$RarityDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"

export class $RarityDeserializer implements $JsonDeserializer<($Rarity)> {

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Rarity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RarityDeserializer$Type = ($RarityDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RarityDeserializer_ = $RarityDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorPistonBlockEntity" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $CoreExtractorPistonBlockEntity extends $BlockEntity {
static "type": $RegistryObject<($BlockEntityType<($CoreExtractorPistonBlockEntity)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "isActive"(): boolean
public "tick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "setEndTime"(arg0: long): void
public "activate"(): void
public "getProgress"(arg0: float): float
get "active"(): boolean
set "endTime"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorPistonBlockEntity$Type = ($CoreExtractorPistonBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorPistonBlockEntity_ = $CoreExtractorPistonBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiMagicUsage" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiMagicUsage extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "update"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string): void
public "getTooltipLines"(): $List<($Component)>
public "hasChanged"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string): boolean
public "providesCapacity"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string): boolean
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiMagicUsage$Type = ($GuiMagicUsage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiMagicUsage_ = $GuiMagicUsage$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedBlockCommon" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"

export class $ForgedBlockCommon {
static readonly "propertiesSolid": $BlockBehaviour$Properties
static readonly "propertiesNotSolid": $BlockBehaviour$Properties
static readonly "locationTooltip": $Component
static readonly "unsettlingTooltip": $Component

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedBlockCommon$Type = ($ForgedBlockCommon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedBlockCommon_ = $ForgedBlockCommon$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/bow/$GuiRangedProgress" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"

export class $GuiRangedProgress extends $GuiRoot {

constructor(arg0: $Minecraft$Type)

public "draw"(arg0: $GuiGraphics$Type): void
public "setProgress"(arg0: float, arg1: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiRangedProgress$Type = ($GuiRangedProgress);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiRangedProgress_ = $GuiRangedProgress$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$SecondaryAbilityPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $SecondaryAbilityPacket extends $AbstractPacket {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $InteractionHand$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryAbilityPacket$Type = ($SecondaryAbilityPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryAbilityPacket_ = $SecondaryAbilityPacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/extractor/$CoreExtractorBaseBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $CoreExtractorBaseBlock extends $TetraWaterloggedBlock implements $EntityBlock {
static readonly "identifier": string
static readonly "facingProp": $DirectionProperty
static "instance": $RegistryObject<($CoreExtractorBaseBlock)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: $ItemStack$Type): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "neighborChanged"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Block$Type, arg4: $BlockPos$Type, arg5: boolean): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreExtractorBaseBlock$Type = ($CoreExtractorBaseBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreExtractorBaseBlock_ = $CoreExtractorBaseBlock$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEnchantmentLevel" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterEnchantmentLevel implements $IStatGetter {

constructor(arg0: $Enchantment$Type, arg1: double)
constructor(arg0: $Enchantment$Type, arg1: double, arg2: double)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterEnchantmentLevel$Type = ($StatGetterEnchantmentLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterEnchantmentLevel_ = $StatGetterEnchantmentLevel$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/$ToolbeltHelper" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ToolbeltSlotType, $ToolbeltSlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltSlotType"

export class $ToolbeltHelper {

constructor()

public static "getToolbeltItems"(arg0: $Player$Type): $List<($ItemStack)>
public static "emptyOverflowSlots"(arg0: $ItemStack$Type, arg1: $Player$Type): void
public static "findToolbelt"(arg0: $Player$Type): $ItemStack
public static "equipItemFromToolbelt"(arg0: $Player$Type, arg1: $ToolbeltSlotType$Type, arg2: integer, arg3: $InteractionHand$Type): void
public static "storeItemInToolbelt"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public static "storeItemInToolbelt"(arg0: $Player$Type): boolean
public static "getQuickAccessSlotIndex"(arg0: $Player$Type, arg1: $HitResult$Type, arg2: $BlockState$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltHelper$Type = ($ToolbeltHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltHelper_ = $ToolbeltHelper$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/$ModularSingleHeadedItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiModuleOffsets, $GuiModuleOffsets$Type} from "packages/se/mickelus/tetra/gui/$GuiModuleOffsets"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModularSingleHeadedItem extends $ItemModularHandheld {
static readonly "headKey": string
static readonly "handleKey": string
static readonly "bindingKey": string
static readonly "identifier": string
static "instance": $ModularSingleHeadedItem
static readonly "nailedTag": $TagKey<($Block)>
static readonly "blockingDurationLimit": integer
static readonly "attackDamageModifier": $UUID
static readonly "attackSpeedModifier": $UUID
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "updateConfig"(arg0: integer, arg1: integer): void
public "getMinorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getMajorGuiOffsets"(arg0: $ItemStack$Type): $GuiModuleOffsets
public "getTransformVariant"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public "commonInit"(arg0: $PacketHandler$Type): void
public "getModelCacheKey"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): string
public static "getImprovementDescription"(arg0: string): string
public static "getIntegrityGain"(arg0: $ItemStack$Type): integer
public static "getIntegrityCost"(arg0: $ItemStack$Type): integer
public static "updateIdentifier"(arg0: $CompoundTag$Type): void
public static "updateIdentifier"(arg0: $ItemStack$Type): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string, arg4: string): void
public static "putModuleInSlot"(arg0: $ItemStack$Type, arg1: string, arg2: string, arg3: string): void
public static "getHoningSeed"(arg0: $ItemStack$Type): integer
public static "getImprovementName"(arg0: string, arg1: integer): string
public static "removeHoneable"(arg0: $ItemStack$Type): void
public static "isHoneable"(arg0: $ItemStack$Type): boolean
public static "removeAllEnchantments"(arg0: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModularSingleHeadedItem$Type = ($ModularSingleHeadedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModularSingleHeadedItem_ = $ModularSingleHeadedItem$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloSchematicListGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"

export class $HoloSchematicListGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Consumer$Type<($UpgradeSchematic$Type)>)

public "update"(arg0: $IModularItem$Type, arg1: string): void
public "animateOpen"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloSchematicListGui$Type = ($HoloSchematicListGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloSchematicListGui_ = $HoloSchematicListGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/$BasicMajorModule" {
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BasicMajorModule extends $ItemModuleMajor {
static readonly "settleImprovement": string
static readonly "arrestedImprovement": string
static readonly "repairLevelFactor": float

constructor(arg0: $ResourceLocation$Type, arg1: $ModuleData$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicMajorModule$Type = ($BasicMajorModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicMajorModule_ = $BasicMajorModule$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$RemoveImprovementOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RemoveImprovementOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveImprovementOutcome$Type = ($RemoveImprovementOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveImprovementOutcome_ = $RemoveImprovementOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/outcome/$ApplyEnchantmentOutcome" {
import {$CraftingEffectOutcome, $CraftingEffectOutcome$Type} from "packages/se/mickelus/tetra/craftingeffect/outcome/$CraftingEffectOutcome"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ApplyEnchantmentOutcome implements $CraftingEffectOutcome {

constructor()

public "apply"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $Level$Type, arg8: $UpgradeSchematic$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean, arg12: ($ItemStack$Type)[]): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyEnchantmentOutcome$Type = ($ApplyEnchantmentOutcome);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyEnchantmentOutcome_ = $ApplyEnchantmentOutcome$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$AndCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AndCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndCondition$Type = ($AndCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndCondition_ = $AndCondition$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$GatherRepairInstancesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$RepairInstance, $RepairInstance$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairInstance"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GatherRepairInstancesEvent extends $Event {
readonly "itemStack": $ItemStack
readonly "initialInstances": ($RepairInstance)[]
 "instances": ($RepairInstance)[]

constructor()
constructor(arg0: $ItemStack$Type, arg1: ($RepairInstance$Type)[])

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GatherRepairInstancesEvent$Type = ($GatherRepairInstancesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GatherRepairInstancesEvent_ = $GatherRepairInstancesEvent$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerBaseBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $HammerBaseBlock extends $TetraBlock implements $IInteractiveBlock, $EntityBlock {
static readonly "identifier": string
static readonly "facingProp": $DirectionProperty
static readonly "qualityImprovementKey": string
static readonly "interactions": ($BlockInteraction)[]
static "instance": $HammerBaseBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "clientInit"(): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: $ItemStack$Type): void
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "isFunctional"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
public "getHammerLevel"(arg0: $Level$Type, arg1: $BlockPos$Type): integer
public "onNeighborChange"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): void
public "applyActionEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: $Player$Type, arg5: $ToolAction$Type, arg6: integer, arg7: boolean): $ItemStack
public "applyCraftEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: string, arg5: boolean, arg6: $Player$Type, arg7: $ToolAction$Type, arg8: integer, arg9: boolean): $ItemStack
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public static "removeModule"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type, arg6: boolean): boolean
public "consumeFuel"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerBaseBlock$Type = ($HammerBaseBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerBaseBlock_ = $HammerBaseBlock$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$ModuleData" {
import {$VariantData, $VariantData$Type} from "packages/se/mickelus/tetra/module/data/$VariantData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"

export class $ModuleData {
 "slots": (string)[]
 "slotSuffixes": (string)[]
 "type": $ResourceLocation
 "replace": boolean
 "renderLayer": $Priority
 "namePriority": $Priority
 "prefixPriority": $Priority
 "tweakKey": $ResourceLocation
 "perk": boolean
 "improvements": ($ResourceLocation)[]
 "variants": ($VariantData)[]

constructor()

public static "copyFields"(arg0: $ModuleData$Type, arg1: $ModuleData$Type): void
public "shallowCopy"(): $ModuleData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleData$Type = ($ModuleData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleData_ = $ModuleData$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiSynergyIndicator" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiSynergyIndicator extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: boolean)
constructor(arg0: integer, arg1: integer)

public "getValueInteger"(arg0: integer, arg1: integer): string
public "getValueMultiplier"(arg0: double): string
public "getValueDouble"(arg0: double, arg1: double): string
public "update"(arg0: $ItemStack$Type, arg1: string): void
public "update"(arg0: $ItemStack$Type, arg1: $ItemModule$Type): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiSynergyIndicator$Type = ($GuiSynergyIndicator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiSynergyIndicator_ = $GuiSynergyIndicator$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ComboPoints" {
import {$AttackEntityEvent, $AttackEntityEvent$Type} from "packages/net/minecraftforge/event/entity/player/$AttackEntityEvent"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ComboPoints {

constructor()

public static "get"(arg0: $Entity$Type): integer
public static "increment"(arg0: $Entity$Type): void
public static "reset"(arg0: $Entity$Type): void
public static "canSpend"(arg0: $IModularItem$Type, arg1: $ItemStack$Type): boolean
public static "canSpend"(arg0: $LivingEntity$Type): boolean
public static "onAttackEntity"(arg0: $AttackEntityEvent$Type): void
public static "getAndReset"(arg0: $Entity$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComboPoints$Type = ($ComboPoints);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComboPoints_ = $ComboPoints$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedPlatformBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ForgedPlatformBlock extends $TetraBlock {
static readonly "identifier": string
static "instance": $ForgedPlatformBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedPlatformBlock$Type = ($ForgedPlatformBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedPlatformBlock_ = $ForgedPlatformBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$InteractiveBlockOverlay" {
import {$RenderHighlightEvent$Block, $RenderHighlightEvent$Block$Type} from "packages/net/minecraftforge/client/event/$RenderHighlightEvent$Block"

export class $InteractiveBlockOverlay {

constructor()

public "renderOverlay"(arg0: $RenderHighlightEvent$Block$Type): void
public static "markDirty"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractiveBlockOverlay$Type = ($InteractiveBlockOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractiveBlockOverlay_ = $InteractiveBlockOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterToolEfficiency" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterToolEfficiency implements $IStatGetter {

constructor(arg0: $ToolAction$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterToolEfficiency$Type = ($StatGetterToolEfficiency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterToolEfficiency_ = $StatGetterToolEfficiency$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloVariantDetailGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OutcomeStack, $OutcomeStack$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$OutcomeStack"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"

export class $HoloVariantDetailGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Consumer$Type<($OutcomePreview$Type)>)

public "hide"(): void
public "animateOpen"(): void
public "show"(): void
public "onImprovementSelect"(arg0: $OutcomeStack$Type): void
public "updateStats"(arg0: $OutcomePreview$Type, arg1: $OutcomePreview$Type): void
public "forceHide"(): void
public "updateVariant"(arg0: $OutcomePreview$Type, arg1: $OutcomePreview$Type, arg2: string): void
public "hideImprovements"(): void
public "showImprovements"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloVariantDetailGui$Type = ($HoloVariantDetailGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloVariantDetailGui_ = $HoloVariantDetailGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$CombustionChamberItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CombustionChamberItem extends $TetraItem {
static readonly "identifier": string
static "instance": $RegistryObject<($CombustionChamberItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombustionChamberItem$Type = ($CombustionChamberItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombustionChamberItem_ = $CombustionChamberItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/gui/$ScrollScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ScrollScreen extends $Screen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: string)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "mouseScrolled"(arg0: double, arg1: double, arg2: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollScreen$Type = ($ScrollScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollScreen_ = $ScrollScreen$Type;
}}
declare module "packages/se/mickelus/mutil/scheduling/$AbstractScheduler" {
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $AbstractScheduler {

constructor()

public "tick"(arg0: $TickEvent$Type): void
public "schedule"(arg0: string, arg1: integer, arg2: $Runnable$Type): void
public "schedule"(arg0: integer, arg1: $Runnable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractScheduler$Type = ($AbstractScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractScheduler_ = $AbstractScheduler$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$PrimaryMultiblockSchematicBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$RuinedMultiblockSchematicBlock, $RuinedMultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$RuinedMultiblockSchematicBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$MultiblockSchematicBlock, $MultiblockSchematicBlock$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicBlock"
import {$ISchematicProviderBlock, $ISchematicProviderBlock$Type} from "packages/se/mickelus/tetra/blocks/$ISchematicProviderBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $PrimaryMultiblockSchematicBlock extends $MultiblockSchematicBlock implements $ISchematicProviderBlock {
static readonly "complete": $BooleanProperty
static readonly "facingProp": $DirectionProperty
readonly "x": integer
readonly "y": integer
readonly "height": integer
readonly "width": integer
readonly "ruinedRef": $RegistryObject<($RuinedMultiblockSchematicBlock)>
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type, arg1: string, arg2: $RegistryObject$Type<($RuinedMultiblockSchematicBlock$Type)>, arg3: $ResourceLocation$Type, arg4: integer, arg5: integer, arg6: integer, arg7: integer)

public "updateComplete"(arg0: $BlockState$Type, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): void
public "onPlace"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "canUnlockSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
public "getSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimaryMultiblockSchematicBlock$Type = ($PrimaryMultiblockSchematicBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PrimaryMultiblockSchematicBlock_ = $PrimaryMultiblockSchematicBlock$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingEffect" {
import {$ProjectileImpactEvent, $ProjectileImpactEvent$Type} from "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $HowlingEffect {

constructor()

public static "trigger"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: integer): void
public static "sendPacket"(): void
public static "deflectProjectile"(arg0: $ProjectileImpactEvent$Type, arg1: $Projectile$Type, arg2: $HitResult$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingEffect$Type = ($HowlingEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingEffect_ = $HowlingEffect$Type;
}}
declare module "packages/se/mickelus/mutil/$MUtilMod" {
import {$FMLClientSetupEvent, $FMLClientSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent"

export class $MUtilMod {
static readonly "MOD_ID": string

constructor()

public static "clientSetup"(arg0: $FMLClientSetupEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MUtilMod$Type = ($MUtilMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MUtilMod_ = $MUtilMod$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$StunEffect" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $StunEffect {

constructor()

public static "perform"(arg0: $ItemStack$Type, arg1: integer, arg2: $LivingEntity$Type, arg3: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StunEffect$Type = ($StunEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StunEffect_ = $StunEffect$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiExperience" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"

export class $GuiExperience extends $GuiElement {

constructor(arg0: integer, arg1: integer)
constructor(arg0: integer, arg1: integer, arg2: string)

public "update"(arg0: integer, arg1: boolean): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiExperience$Type = ($GuiExperience);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiExperience_ = $GuiExperience$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$GlyphData" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GlyphData {
 "tint": integer
 "textureX": integer
 "textureY": integer
 "textureLocation": $ResourceLocation

constructor(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: string, arg1: integer, arg2: integer)
constructor(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer)
constructor()

public "equals"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlyphData$Type = ($GlyphData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlyphData_ = $GlyphData$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$UniqueImprovementData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $UniqueImprovementData extends $ImprovementData {
 "level": integer
 "enchantment": boolean
 "group": string
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueImprovementData$Type = ($UniqueImprovementData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniqueImprovementData_ = $UniqueImprovementData$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$SmallStrengthPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SmallStrengthPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SmallStrengthPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmallStrengthPotionEffect$Type = ($SmallStrengthPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmallStrengthPotionEffect_ = $SmallStrengthPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$SeveredPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SeveredPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SeveredPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeveredPotionEffect$Type = ($SeveredPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeveredPotionEffect_ = $SeveredPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiModuleOffsets" {
import {$ArchetypeSlotDefinition, $ArchetypeSlotDefinition$Type} from "packages/se/mickelus/tetra/items/modular/impl/dynamic/$ArchetypeSlotDefinition"

export class $GuiModuleOffsets {

constructor(...arg0: (integer)[])
constructor(arg0: ($ArchetypeSlotDefinition$Type)[])

public "size"(): integer
public "getY"(arg0: integer): integer
public "getAlignment"(arg0: integer): boolean
public "getX"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleOffsets$Type = ($GuiModuleOffsets);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleOffsets_ = $GuiModuleOffsets$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$WorkbenchAction, $WorkbenchAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $WorkbenchTile extends $BlockEntity implements $MenuProvider {
static readonly "identifier": string
static readonly "inventorySlots": integer
static readonly "maxMaterialSlots": integer
static "type": $RegistryObject<($BlockEntityType<($WorkbenchTile)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "update"(arg0: $UpgradeSchematic$Type, arg1: string, arg2: $Player$Type): void
public static "init"(arg0: $PacketHandler$Type): void
public "getDisplayName"(): $Component
public "setChanged"(): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public static "consumeCraftingToolEffects"(arg0: $ItemStack$Type, arg1: string, arg2: boolean, arg3: $ToolAction$Type, arg4: integer, arg5: $Player$Type, arg6: $Level$Type, arg7: $BlockPos$Type, arg8: $BlockState$Type, arg9: boolean): $ItemStack
public static "applyCraftingBonusEffects"(arg0: $ItemStack$Type, arg1: string, arg2: boolean, arg3: $Player$Type, arg4: ($ItemStack$Type)[], arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type, arg11: boolean): $ItemStack
public "getAvailableActions"(arg0: $Player$Type): ($WorkbenchAction)[]
public "setCurrentSchematic"(arg0: $UpgradeSchematic$Type, arg1: string): void
public "isTargetPlaceholder"(): boolean
public "removeChangeListener"(arg0: string): void
public "getUnlockedSchematics"(): ($ResourceLocation)[]
public "getCurrentSchematic"(): $UpgradeSchematic
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$Type, arg2: $Player$Type): $AbstractContainerMenu
public "getTargetItemStack"(): $ItemStack
public "performAction"(arg0: $Player$Type, arg1: string): void
public "performAction"(arg0: string): void
public "initiateCrafting"(arg0: $Player$Type): void
public "clearSchematic"(): void
public "getMaterials"(): ($ItemStack)[]
public "getCurrentSlot"(): string
public "applyTweaks"(arg0: $Player$Type, arg1: string, arg2: $Map$Type<(string), (integer)>): void
public "addChangeListener"(arg0: string, arg1: $Runnable$Type): void
public "tweak"(arg0: $Player$Type, arg1: string, arg2: $Map$Type<(string), (integer)>): void
public "getInteractions"(): ($BlockInteraction)[]
public "craft"(arg0: $Player$Type): void
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
get "displayName"(): $Component
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "targetPlaceholder"(): boolean
get "unlockedSchematics"(): ($ResourceLocation)[]
get "currentSchematic"(): $UpgradeSchematic
get "targetItemStack"(): $ItemStack
get "materials"(): ($ItemStack)[]
get "currentSlot"(): string
get "interactions"(): ($BlockInteraction)[]
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchTile$Type = ($WorkbenchTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchTile_ = $WorkbenchTile$Type;
}}
declare module "packages/se/mickelus/tetra/data/$MaterialStore" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$MergingDataStore, $MergingDataStore$Type} from "packages/se/mickelus/mutil/data/$MergingDataStore"

export class $MaterialStore extends $MergingDataStore<($MaterialData), (($MaterialData)[])> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $DataDistributor$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialStore$Type = ($MaterialStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialStore_ = $MaterialStore$Type;
}}
declare module "packages/se/mickelus/tetra/module/$SchematicRegistry" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $SchematicRegistry {
static "instance": $SchematicRegistry

constructor()

public static "getAllSchematics"(): $Collection<($UpgradeSchematic)>
public "registerSchematic"(arg0: $UpgradeSchematic$Type): void
public static "getSchematic"(arg0: string): $UpgradeSchematic
public static "getSchematic"(arg0: $ResourceLocation$Type): $UpgradeSchematic
public static "getSchematics"(arg0: $ItemStack$Type, arg1: string): ($UpgradeSchematic)[]
public static "getSchematics"(arg0: $ItemStack$Type): ($UpgradeSchematic)[]
public static "getSchematics"(arg0: $ItemStack$Type, arg1: string, arg2: $Player$Type, arg3: $Level$Type, arg4: $BlockPos$Type, arg5: $BlockState$Type, arg6: ($ResourceLocation$Type)[]): ($UpgradeSchematic)[]
public static "getSchematics"(arg0: $CraftingContext$Type): ($UpgradeSchematic)[]
get "allSchematics"(): $Collection<($UpgradeSchematic)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicRegistry$Type = ($SchematicRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicRegistry_ = $SchematicRegistry$Type;
}}
declare module "packages/se/mickelus/tetra/levelgen/$ForgedHammerProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $ForgedHammerProcessor extends $StructureProcessor {
static readonly "INSTANCE": $ForgedHammerProcessor
static readonly "codec": $Codec<($ForgedHammerProcessor)>
static "type": $RegistryObject<($StructureProcessorType<(any)>)>

constructor()

public "process"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type, arg6: $StructureTemplate$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedHammerProcessor$Type = ($ForgedHammerProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedHammerProcessor_ = $ForgedHammerProcessor$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$GuiColors" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GuiColors {
static readonly "normal": integer
static readonly "add": integer
static readonly "remove": integer
static readonly "change": integer
static readonly "hover": integer
static readonly "selected": integer
static readonly "muted": integer
static readonly "mutedStrong": integer
static readonly "hoverMuted": integer
static readonly "warning": integer
static readonly "negative": integer
static readonly "positive": integer
static readonly "scanner": integer
static readonly "hone": integer
static readonly "temporarySchematic": integer
static readonly "destabilized": integer
static readonly "source": integer
static readonly "separator": integer

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiColors$Type = ($GuiColors);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiColors_ = $GuiColors$Type;
}}
declare module "packages/se/mickelus/tetra/items/forged/$VibrationDebuffer" {
import {$TickEvent$PlayerTickEvent, $TickEvent$PlayerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$PlayerTickEvent"

export class $VibrationDebuffer {

constructor()

public "onPlayerTick"(arg0: $TickEvent$PlayerTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationDebuffer$Type = ($VibrationDebuffer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VibrationDebuffer_ = $VibrationDebuffer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$ToolbeltOverlay" {
import {$InputEvent$Key, $InputEvent$Key$Type} from "packages/net/minecraftforge/client/event/$InputEvent$Key"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ToolbeltSlotType, $ToolbeltSlotType$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltSlotType"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $ToolbeltOverlay extends $GuiRoot implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "draw"(arg0: $GuiGraphics$Type): void
public "onKeyInput"(arg0: $InputEvent$Key$Type): void
public "toggleActive"(arg0: boolean): void
public "setInventories"(arg0: $ItemStack$Type): void
public "getFocusIndex"(): integer
public "getFocusHand"(): $InteractionHand
public "getFocusType"(): $ToolbeltSlotType
set "inventories"(value: $ItemStack$Type)
get "focusIndex"(): integer
get "focusHand"(): $InteractionHand
get "focusType"(): $ToolbeltSlotType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolbeltOverlay$Type = ($ToolbeltOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolbeltOverlay_ = $ToolbeltOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/$TetraDamageTypes" {
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export interface $TetraDamageTypes {

}

export namespace $TetraDamageTypes {
const bleeding: $ResourceKey<($DamageType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraDamageTypes$Type = ($TetraDamageTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraDamageTypes_ = $TetraDamageTypes$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$CritEffect" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CriticalHitEvent, $CriticalHitEvent$Type} from "packages/net/minecraftforge/event/entity/player/$CriticalHitEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $CritEffect {

constructor()

public static "rollMultiplier"(arg0: $RandomSource$Type, arg1: $IModularItem$Type, arg2: $ItemStack$Type): double
public static "onBlockBreak"(arg0: $LivingEntity$Type): void
public static "critBlock"(arg0: $Level$Type, arg1: $Player$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $ItemStack$Type, arg5: integer): boolean
public static "critEntity"(arg0: $CriticalHitEvent$Type, arg1: $ItemStack$Type, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CritEffect$Type = ($CritEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CritEffect_ = $CritEffect$Type;
}}
declare module "packages/se/mickelus/tetra/$TetraRegistries" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$FMLClientSetupEvent, $FMLClientSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$LootItemFunctionType, $LootItemFunctionType$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$LootItemFunctionType"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$BuildCreativeModeTabContentsEvent, $BuildCreativeModeTabContentsEvent$Type} from "packages/net/minecraftforge/event/$BuildCreativeModeTabContentsEvent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $TetraRegistries {
static readonly "blocks": $DeferredRegister<($Block)>
static readonly "items": $DeferredRegister<($Item)>
static readonly "blockEntities": $DeferredRegister<($BlockEntityType<(any)>)>
static readonly "containers": $DeferredRegister<($MenuType<(any)>)>
static readonly "entities": $DeferredRegister<($EntityType<(any)>)>
static readonly "particles": $DeferredRegister<($ParticleType<(any)>)>
static readonly "effects": $DeferredRegister<($MobEffect)>
static readonly "sounds": $DeferredRegister<($SoundEvent)>
static readonly "lootModifiers": $DeferredRegister<($Codec<(any)>)>
static readonly "lootConditions": $DeferredRegister<($LootItemConditionType)>
static readonly "lootFunctions": $DeferredRegister<($LootItemFunctionType)>
static readonly "structureProcessors": $DeferredRegister<($StructureProcessorType<(any)>)>
static readonly "creativeTabs": $DeferredRegister<($CreativeModeTab)>
static readonly "forgeHammerBreakTag": $TagKey<($Block)>
static readonly "forgeHammerTier": $Tier

constructor()

public static "init"(arg0: $IEventBus$Type): void
public static "setup"(arg0: $FMLCommonSetupEvent$Type): void
public static "clientSetup"(arg0: $FMLClientSetupEvent$Type): void
public static "registerBlockItem"<B extends $Block>(arg0: $RegistryObject$Type<(B)>): $RegistryObject<($Item)>
public static "buildContents"(arg0: $BuildCreativeModeTabContentsEvent$Type): void
public static "registerStructureProcessor"<P extends $StructureProcessor>(arg0: string, arg1: $StructureProcessorType$Type<(P)>): $RegistryObject<($StructureProcessorType<(any)>)>
set "up"(value: $FMLCommonSetupEvent$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraRegistries$Type = ($TetraRegistries);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraRegistries_ = $TetraRegistries$Type;
}}
declare module "packages/se/mickelus/mutil/gui/hud/$GuiRootHud" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $GuiRootHud extends $GuiElement {

constructor()

public "draw"(arg0: $GuiGraphics$Type, arg1: $Vec3$Type, arg2: $BlockHitResult$Type, arg3: $VoxelShape$Type): void
public "draw"(arg0: $GuiGraphics$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: $Direction$Type, arg8: $AABB$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiRootHud$Type = ($GuiRootHud);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiRootHud_ = $GuiRootHud$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$MaterialItemPredicate" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $MaterialItemPredicate extends $ItemPredicate {
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor(arg0: $JsonObject$Type)

public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialItemPredicate$Type = ($MaterialItemPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialItemPredicate_ = $MaterialItemPredicate$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollDrops" {
import {$LootTableLoadEvent, $LootTableLoadEvent$Type} from "packages/net/minecraftforge/event/$LootTableLoadEvent"

export class $ScrollDrops {

constructor()

public "onLootTableLoad"(arg0: $LootTableLoadEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollDrops$Type = ($ScrollDrops);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollDrops_ = $ScrollDrops$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$OutcomePreview" {
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $OutcomePreview {
 "moduleKey": string
 "variantName": string
 "variantKey": string
 "category": string
 "level": integer
 "glyph": $GlyphData
 "itemStack": $ItemStack
 "type": $SchematicType
 "tools": $ToolData
 "materials": ($ItemStack)[]

constructor(arg0: string, arg1: string, arg2: string, arg3: string, arg4: integer, arg5: $GlyphData$Type, arg6: $ItemStack$Type, arg7: $SchematicType$Type, arg8: $ToolData$Type, arg9: ($ItemStack$Type)[])

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "isApplied"(arg0: $ItemStack$Type, arg1: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutcomePreview$Type = ($OutcomePreview);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutcomePreview_ = $OutcomePreview$Type;
}}
declare module "packages/se/mickelus/tetra/client/model/$ItemLayerModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IQuadTransformer, $IQuadTransformer$Type} from "packages/net/minecraftforge/client/model/$IQuadTransformer"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $ItemLayerModel implements $IUnbakedGeometry<($ItemLayerModel)> {

constructor(arg0: $List$Type<($Material$Type)>, arg1: $Int2ObjectMap$Type<($List$Type<($IQuadTransformer$Type)>)>, arg2: $Int2ObjectMap$Type<($ResourceLocation$Type)>)

public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemLayerModel$Type = ($ItemLayerModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemLayerModel_ = $ItemLayerModel$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/booster/$OverlayBooster" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $OverlayBooster implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverlayBooster$Type = ($OverlayBooster);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverlayBooster_ = $OverlayBooster$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$ILabelGetter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ILabelGetter {

 "getLabelMerged"(arg0: double, arg1: double): string
 "getLabel"(arg0: double, arg1: double, arg2: boolean): string
}

export namespace $ILabelGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILabelGetter$Type = ($ILabelGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILabelGetter_ = $ILabelGetter$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$SchemaSlotGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SchemaSlotGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "update"(arg0: $UpgradeSchematic$Type, arg1: $Player$Type, arg2: $Level$Type, arg3: $BlockPos$Type, arg4: $WorkbenchTile$Type, arg5: $ItemStack$Type, arg6: string, arg7: ($ItemStack$Type)[]): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchemaSlotGui$Type = ($SchemaSlotGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchemaSlotGui_ = $SchemaSlotGui$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$OverpowerEffect" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemModularHandheld, $ItemModularHandheld$Type} from "packages/se/mickelus/tetra/items/modular/$ItemModularHandheld"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $OverpowerEffect extends $ChargedAbilityEffect {
static readonly "instance": $OverpowerEffect


public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $Vec3$Type, arg6: integer): void
public "perform"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $ItemModularHandheld$Type, arg3: $ItemStack$Type, arg4: $LivingEntity$Type, arg5: $BlockPos$Type, arg6: $Vec3$Type, arg7: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverpowerEffect$Type = ($OverpowerEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverpowerEffect_ = $OverpowerEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$OutcomePreviewEnchantment" {
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$OutcomePreview, $OutcomePreview$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomePreview"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $OutcomePreviewEnchantment extends $OutcomePreview {
 "moduleKey": string
 "variantName": string
 "variantKey": string
 "category": string
 "level": integer
 "glyph": $GlyphData
 "itemStack": $ItemStack
 "type": $SchematicType
 "tools": $ToolData
 "materials": ($ItemStack)[]

constructor(arg0: string, arg1: string, arg2: string, arg3: integer, arg4: $GlyphData$Type, arg5: $ItemStack$Type, arg6: $SchematicType$Type, arg7: $ToolData$Type, arg8: ($ItemStack$Type)[])

public "isApplied"(arg0: $ItemStack$Type, arg1: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutcomePreviewEnchantment$Type = ($OutcomePreviewEnchantment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutcomePreviewEnchantment_ = $OutcomePreviewEnchantment$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$ApplyHitTargetEffectsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ApplyHitTargetEffectsEvent extends $Event {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $LivingEntity$Type, arg2: $ItemStack$Type)

public "getTarget"(): $LivingEntity
public "isCancelable"(): boolean
public "getAttacker"(): $LivingEntity
public "getUsedItemStack"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "target"(): $LivingEntity
get "cancelable"(): boolean
get "attacker"(): $LivingEntity
get "usedItemStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApplyHitTargetEffectsEvent$Type = ($ApplyHitTargetEffectsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApplyHitTargetEffectsEvent_ = $ApplyHitTargetEffectsEvent$Type;
}}
declare module "packages/se/mickelus/tetra/$ServerScheduler" {
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $ServerScheduler {

constructor()

public static "schedule"(arg0: string, arg1: integer, arg2: $Runnable$Type): void
public static "schedule"(arg0: integer, arg1: $Runnable$Type): void
public static "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScheduler$Type = ($ServerScheduler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerScheduler_ = $ServerScheduler$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$ScannerBarGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $ScannerBarGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer)

public "setStatus"(arg0: string): void
public "setHorizontalSpread"(arg0: integer): void
public "highlightMid"(arg0: integer, arg1: boolean): void
public "highlightDown"(arg0: integer, arg1: boolean): void
public "highlightUp"(arg0: integer, arg1: boolean): void
public static "getDegreesPerUnit"(): double
set "status"(value: string)
set "horizontalSpread"(value: integer)
get "degreesPerUnit"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScannerBarGui$Type = ($ScannerBarGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScannerBarGui_ = $ScannerBarGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$SchematicRarity" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SchematicRarity extends $Enum<($SchematicRarity)> {
static readonly "temporary": $SchematicRarity
static readonly "hone": $SchematicRarity
static readonly "basic": $SchematicRarity
 "tint": integer


public static "values"(): ($SchematicRarity)[]
public static "valueOf"(arg0: string): $SchematicRarity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicRarity$Type = (("temporary") | ("basic") | ("hone")) | ($SchematicRarity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicRarity_ = $SchematicRarity$Type;
}}
declare module "packages/se/mickelus/tetra/effect/$TruesweepPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $TruesweepPacket extends $AbstractPacket {

constructor()

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TruesweepPacket$Type = ($TruesweepPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TruesweepPacket_ = $TruesweepPacket$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $HowlingPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $HowlingPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "isDurationEffectTick"(arg0: integer, arg1: integer): boolean
public "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingPotionEffect$Type = ($HowlingPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingPotionEffect_ = $HowlingPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/effect/revenge/$RevengeTracker" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$LivingAttackEvent, $LivingAttackEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingAttackEvent"
import {$IModularItem, $IModularItem$Type} from "packages/se/mickelus/tetra/items/modular/$IModularItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $RevengeTracker {

constructor()

public static "addEnemy"(arg0: $Entity$Type, arg1: $Entity$Type): void
public static "addEnemy"(arg0: $Entity$Type, arg1: integer): void
public static "removeEnemy"(arg0: $Entity$Type, arg1: integer): void
public static "removeEnemy"(arg0: $Entity$Type, arg1: $Entity$Type): void
public static "canRevenge"(arg0: $LivingEntity$Type): boolean
public static "canRevenge"(arg0: $IModularItem$Type, arg1: $ItemStack$Type): boolean
public static "canRevenge"(arg0: $Entity$Type, arg1: $Entity$Type): boolean
public static "removeEnemySynced"(arg0: $ServerPlayer$Type, arg1: $Entity$Type): void
public static "onAttackEntity"(arg0: $LivingAttackEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RevengeTracker$Type = ($RevengeTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RevengeTracker_ = $RevengeTracker$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterScannerHorizontalRange" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterScannerHorizontalRange implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterScannerHorizontalRange$Type = ($TooltipGetterScannerHorizontalRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterScannerHorizontalRange_ = $TooltipGetterScannerHorizontalRange$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialItemGui" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"

export class $HoloMaterialItemGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: $MaterialData$Type, arg3: $Consumer$Type<($MaterialData$Type)>, arg4: $Consumer$Type<($MaterialData$Type)>, arg5: $Consumer$Type<($MaterialData$Type)>)

public "updateSelection"(arg0: $MaterialData$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialItemGui$Type = ($HoloMaterialItemGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialItemGui_ = $HoloMaterialItemGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$QuadRenderer" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$QuadRenderer$Vertex, $QuadRenderer$Vertex$Type} from "packages/se/mickelus/tetra/blocks/scroll/$QuadRenderer$Vertex"

export class $QuadRenderer {
readonly "vertexPositions": ($QuadRenderer$Vertex)[]
readonly "normal": $Vector3f

constructor(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: boolean, arg10: $Direction$Type)

public "render"(arg0: $PoseStack$Type, arg1: $VertexConsumer$Type, arg2: integer, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadRenderer$Type = ($QuadRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadRenderer_ = $QuadRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/compat/curios/$CuriosCompat" {
import {$InterModEnqueueEvent, $InterModEnqueueEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$InterModEnqueueEvent"

export class $CuriosCompat {
static readonly "modId": string
static readonly "isLoaded": boolean

constructor()

public static "enqueueIMC"(arg0: $InterModEnqueueEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuriosCompat$Type = ($CuriosCompat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CuriosCompat_ = $CuriosCompat$Type;
}}
declare module "packages/se/mickelus/tetra/data/$SchematicStore" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$MergingDataStore, $MergingDataStore$Type} from "packages/se/mickelus/mutil/data/$MergingDataStore"
import {$SchematicDefinition, $SchematicDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicDefinition"

export class $SchematicStore extends $MergingDataStore<($SchematicDefinition), (($SchematicDefinition)[])> {

constructor(arg0: $Gson$Type, arg1: string, arg2: string, arg3: $DataDistributor$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicStore$Type = ($SchematicStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicStore_ = $SchematicStore$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerHeadBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TetraWaterloggedBlock, $TetraWaterloggedBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IToolProviderBlock, $IToolProviderBlock$Type} from "packages/se/mickelus/tetra/blocks/$IToolProviderBlock"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HammerHeadBlock extends $TetraWaterloggedBlock implements $IInteractiveBlock, $IToolProviderBlock, $EntityBlock {
static readonly "identifier": string
static readonly "shape": $VoxelShape
static readonly "jamShape": $VoxelShape
static "instance": $HammerHeadBlock
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "onActionConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: $Player$Type, arg5: $ToolAction$Type, arg6: integer, arg7: boolean): $ItemStack
public "getToolLevel"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type): integer
public "getTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Collection<($ToolAction)>
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $RandomSource$Type): void
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "onCraftConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: string, arg5: boolean, arg6: $Player$Type, arg7: $ToolAction$Type, arg8: integer, arg9: boolean): $ItemStack
public "canProvideTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getToolLevels"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Map<($ToolAction), (integer)>
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerHeadBlock$Type = ($HammerHeadBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerHeadBlock_ = $HammerHeadBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$TileEntityOutcome" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $TileEntityOutcome<T extends $BlockEntity> implements $InteractionOutcome {

constructor(arg0: $Class$Type<(T)>, arg1: $Function$Type<(T), (boolean)>)

public "apply"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityOutcome$Type<T> = ($TileEntityOutcome<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityOutcome_<T> = $TileEntityOutcome$Type<(T)>;
}}
declare module "packages/se/mickelus/tetra/gui/$InvertColorGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $InvertColorGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvertColorGui$Type = ($InvertColorGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvertColorGui_ = $InvertColorGui$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$AspectCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AspectCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AspectCondition$Type = ($AspectCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AspectCondition_ = $AspectCondition$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedWorkbenchBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractWorkbenchBlock, $AbstractWorkbenchBlock$Type} from "packages/se/mickelus/tetra/blocks/workbench/$AbstractWorkbenchBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"

export class $ForgedWorkbenchBlock extends $AbstractWorkbenchBlock implements $SimpleWaterloggedBlock {
static readonly "identifier": string
static readonly "axis": $EnumProperty<($Direction$Axis)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedWorkbenchBlock$Type = ($ForgedWorkbenchBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedWorkbenchBlock_ = $ForgedWorkbenchBlock$Type;
}}
declare module "packages/se/mickelus/tetra/crafting/$ScrollIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ScrollIngredient extends $Ingredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getSerializer"(): $IIngredientSerializer<(any)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollIngredient$Type = ($ScrollIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollIngredient_ = $ScrollIngredient$Type;
}}
declare module "packages/se/mickelus/mutil/network/$BlockPosPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPosPacket extends $AbstractPacket {

constructor()
constructor(arg0: $BlockPos$Type)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPosPacket$Type = ($BlockPosPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPosPacket_ = $BlockPosPacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$ToolRequirementListGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ToolRequirementListGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $UpgradeSchematic$Type, arg1: $ItemStack$Type, arg2: string, arg3: ($ItemStack$Type)[], arg4: $Map$Type<($ToolAction$Type), (integer)>): void
public "updateAvailableTools"(arg0: $Map$Type<($ToolAction$Type), (integer)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolRequirementListGui$Type = ($ToolRequirementListGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolRequirementListGui_ = $ToolRequirementListGui$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$ToggleableSlot" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$SlotItemHandler, $SlotItemHandler$Type} from "packages/net/minecraftforge/items/$SlotItemHandler"

export class $ToggleableSlot extends $SlotItemHandler {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(arg0: $IItemHandler$Type, arg1: integer, arg2: integer, arg3: integer)

public "toggle"(arg0: boolean): void
public "isActive"(): boolean
public "mayPlace"(arg0: $ItemStack$Type): boolean
public "mayPickup"(arg0: $Player$Type): boolean
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToggleableSlot$Type = ($ToggleableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToggleableSlot_ = $ToggleableSlot$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$NeverRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $NeverRequirement implements $CraftingRequirement {

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NeverRequirement$Type = ($NeverRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NeverRequirement_ = $NeverRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/util/$TierHelper" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $TierHelper {
static "tiers": $List<($Tier)>

constructor()

public static "init"(): void
public static "getIndex"(arg0: $Tier$Type): integer
public static "getTier"(arg0: integer): $Tier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TierHelper$Type = ($TierHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TierHelper_ = $TierHelper$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/$IToolProviderBlock" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IToolProviderBlock {

 "getToolLevels"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Map<($ToolAction), (integer)>
 "onActionConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: $Player$Type, arg5: $ToolAction$Type, arg6: integer, arg7: boolean): $ItemStack
 "getToolLevel"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type): integer
 "getTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Collection<($ToolAction)>
 "onCraftConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: string, arg5: boolean, arg6: $Player$Type, arg7: $ToolAction$Type, arg8: integer, arg9: boolean): $ItemStack
 "canProvideTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
}

export namespace $IToolProviderBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IToolProviderBlock$Type = ($IToolProviderBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IToolProviderBlock_ = $IToolProviderBlock$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$QuaternionDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $QuaternionDeserializer implements $JsonDeserializer<($Quaternionf)> {

constructor()

public static "deserialize"(arg0: $JsonElement$Type): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuaternionDeserializer$Type = ($QuaternionDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuaternionDeserializer_ = $QuaternionDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$ModuleRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $ModuleRequirement implements $CraftingRequirement {

constructor(arg0: string, arg1: string, arg2: string)

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleRequirement$Type = ($ModuleRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleRequirement_ = $ModuleRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingIndicatorGui" {
import {$GuiTexture, $GuiTexture$Type} from "packages/se/mickelus/mutil/gui/$GuiTexture"

export class $HowlingIndicatorGui extends $GuiTexture {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: boolean)

public "reset"(): void
public "show"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingIndicatorGui$Type = ($HowlingIndicatorGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingIndicatorGui_ = $HowlingIndicatorGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/chthonic/$FracturedBedrockTile" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $FracturedBedrockTile extends $BlockEntity {
static readonly "extractorBreakable": $TagKey<($Block)>
static "type": $BlockEntityType<($FracturedBedrockTile)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "tick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "updateLuck"(): void
public "getProjectedTier"(): integer
public "activate"(arg0: integer): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public static "breakBlock"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): boolean
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
get "projectedTier"(): integer
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FracturedBedrockTile$Type = ($FracturedBedrockTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FracturedBedrockTile_ = $FracturedBedrockTile$Type;
}}
declare module "packages/se/mickelus/mutil/gui/impl/$GuiVerticalLayoutGroup" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $GuiVerticalLayoutGroup extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "triggerLayout"(): void
public "forceLayout"(): void
public "addChild"(arg0: $GuiElement$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiVerticalLayoutGroup$Type = ($GuiVerticalLayoutGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiVerticalLayoutGroup_ = $GuiVerticalLayoutGroup$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/salvage/$TileBlockInteraction" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $TileBlockInteraction<T extends $BlockEntity> extends $BlockInteraction {
 "requiredTool": $ToolAction
 "requiredLevel": integer
 "alwaysReveal": boolean
 "face": $Direction
 "minX": float
 "minY": float
 "maxX": float
 "maxY": float
 "predicate": $Predicate<($BlockState)>
 "outcome": $InteractionOutcome

constructor(arg0: $ToolAction$Type, arg1: integer, arg2: $Direction$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: $Class$Type<(T)>, arg8: $Function$Type<(T), (boolean)>, arg9: $InteractionOutcome$Type)

public "applicableForBlock"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileBlockInteraction$Type<T> = ($TileBlockInteraction<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileBlockInteraction_<T> = $TileBlockInteraction$Type<(T)>;
}}
declare module "packages/se/mickelus/tetra/items/forged/$BoltItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BoltItem extends $TetraItem {
static readonly "identifier": string
static "instance": $BoltItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoltItem$Type = ($BoltItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoltItem_ = $BoltItem$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchPacketTweak" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $WorkbenchPacketTweak extends $BlockPosPacket {

constructor()
constructor(arg0: $BlockPos$Type, arg1: string, arg2: $Map$Type<(string), (integer)>)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchPacketTweak$Type = ($WorkbenchPacketTweak);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchPacketTweak_ = $WorkbenchPacketTweak$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterCooldown" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterCooldown implements $IStatGetter {

constructor(arg0: double, arg1: double)
constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterCooldown$Type = ($StatGetterCooldown);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterCooldown_ = $StatGetterCooldown$Type;
}}
declare module "packages/se/mickelus/tetra/advancements/$BlockInteractionCriterion" {
import {$PropertyMatcher, $PropertyMatcher$Type} from "packages/se/mickelus/tetra/blocks/$PropertyMatcher"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$AbstractCriterionTriggerInstance, $AbstractCriterionTriggerInstance$Type} from "packages/net/minecraft/advancements/critereon/$AbstractCriterionTriggerInstance"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$GenericTrigger, $GenericTrigger$Type} from "packages/se/mickelus/tetra/advancements/$GenericTrigger"
import {$ContextAwarePredicate, $ContextAwarePredicate$Type} from "packages/net/minecraft/advancements/critereon/$ContextAwarePredicate"

export class $BlockInteractionCriterion extends $AbstractCriterionTriggerInstance {
static readonly "trigger": $GenericTrigger<($BlockInteractionCriterion)>

constructor(arg0: $ContextAwarePredicate$Type, arg1: $PropertyMatcher$Type, arg2: $PropertyMatcher$Type, arg3: $ToolAction$Type, arg4: integer)

public "test"(arg0: $BlockState$Type, arg1: $BlockState$Type, arg2: $ToolAction$Type, arg3: integer): boolean
public static "trigger"(arg0: $ServerPlayer$Type, arg1: $BlockState$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type, arg4: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockInteractionCriterion$Type = ($BlockInteractionCriterion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockInteractionCriterion_ = $BlockInteractionCriterion$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterUnbreaking" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterUnbreaking implements $IStatGetter {

constructor(arg0: $IStatGetter$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterUnbreaking$Type = ($StatGetterUnbreaking);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterUnbreaking_ = $StatGetterUnbreaking$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerBaseBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$HammerEffect, $HammerEffect$Type} from "packages/se/mickelus/tetra/blocks/forged/hammer/$HammerEffect"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $HammerBaseBlockEntity extends $BlockEntity {
static "type": $RegistryObject<($BlockEntityType<($HammerBaseBlockEntity)>)>
 "blockState": $BlockState

constructor(arg0: $BlockPos$Type, arg1: $BlockState$Type)

public "tick"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "isFunctional"(): boolean
public "getHammerLevel"(): integer
public "isFueled"(): boolean
public static "writeModules"(arg0: $CompoundTag$Type, arg1: $HammerEffect$Type, arg2: $HammerEffect$Type): void
public "getFacing"(): $Direction
public "getJamChance"(): float
public static "writeCells"(arg0: $CompoundTag$Type, ...arg1: ($ItemStack$Type)[]): void
public "getCellFuel"(arg0: integer): integer
public "hasEffect"(arg0: $HammerEffect$Type): boolean
public "setModule"(arg0: boolean, arg1: $Item$Type): boolean
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getStackInSlot"(arg0: integer): $ItemStack
public "load"(arg0: $CompoundTag$Type): void
public "m_183515_"(arg0: $CompoundTag$Type): void
public "getEffect"(arg0: boolean): $HammerEffect
public "hasCellInSlot"(arg0: integer): boolean
public "removeCellFromSlot"(arg0: integer): $ItemStack
public "putCellInSlot"(arg0: $ItemStack$Type, arg1: integer): boolean
public "getEffectLevel"(arg0: $HammerEffect$Type): integer
public "removeModule"(arg0: boolean): $Item
public "consumeFuel"(): void
public "consumeFuel"(arg0: integer, arg1: integer): void
public "updateRedstonePower"(): void
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
get "functional"(): boolean
get "hammerLevel"(): integer
get "fueled"(): boolean
get "facing"(): $Direction
get "jamChance"(): float
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HammerBaseBlockEntity$Type = ($HammerBaseBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HammerBaseBlockEntity_ = $HammerBaseBlockEntity$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ScrollBlock$Arrangement, $ScrollBlock$Arrangement$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock$Arrangement"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$ICraftingEffectProviderBlock, $ICraftingEffectProviderBlock$Type} from "packages/se/mickelus/tetra/blocks/$ICraftingEffectProviderBlock"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$ISchematicProviderBlock, $ISchematicProviderBlock$Type} from "packages/se/mickelus/tetra/blocks/$ISchematicProviderBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $ScrollBlock extends $TetraBlock implements $EntityBlock, $ISchematicProviderBlock, $ICraftingEffectProviderBlock {
static readonly "sound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $ScrollBlock$Arrangement$Type)

public "playerWillDestroy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type): void
public "dropScrolls"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public "getArrangement"(): $ScrollBlock$Arrangement
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(arg0: $BlockState$Type): $RenderShape
public "canSurvive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "canUnlockCraftingEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
public "canUnlockSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
public "getCraftingEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
public "getSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "arrangement"(): $ScrollBlock$Arrangement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollBlock$Type = ($ScrollBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollBlock_ = $ScrollBlock$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/action/$ConfigAction" {
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$WorkbenchAction, $WorkbenchAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConfigAction implements $WorkbenchAction {
 "key": string
 "requirement": $ItemPredicate
 "requiredTools": $ToolData
 "lootTable": $ResourceLocation
 "inWorld": boolean

constructor()

public "getKey"(): string
public "canPerformOn"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "perform"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $WorkbenchTile$Type): void
public "allowInWorldInteraction"(): boolean
public "getRequiredToolActions"(arg0: $ItemStack$Type): $Collection<($ToolAction)>
public "getRequiredTools"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
get "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigAction$Type = ($ConfigAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigAction_ = $ConfigAction$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/holo/$ToggleScanModeInteraction" {
import {$SecondaryInteractionBase, $SecondaryInteractionBase$Type} from "packages/se/mickelus/tetra/interactions/$SecondaryInteractionBase"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ToggleScanModeInteraction extends $SecondaryInteractionBase {

constructor(arg0: string, arg1: boolean)

public "perform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): void
public "canPerform"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToggleScanModeInteraction$Type = ($ToggleScanModeInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToggleScanModeInteraction_ = $ToggleScanModeInteraction$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/gui/$ScrollPageButtonGui" {
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $ScrollPageButtonGui extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: boolean, arg3: $Runnable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollPageButtonGui$Type = ($ScrollPageButtonGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollPageButtonGui_ = $ScrollPageButtonGui$Type;
}}
declare module "packages/se/mickelus/tetra/client/particle/$SweepingStrikeParticleOption" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $SweepingStrikeParticleOption extends $Record implements $ParticleOptions {
static readonly "CODEC": $Codec<($SweepingStrikeParticleOption)>
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($SweepingStrikeParticleOption)>

constructor(duration: integer, reverse: boolean, pitch: float, yaw: float)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "reverse"(): boolean
public "duration"(): integer
public "yaw"(): float
public "pitch"(): float
public "getType"(): $ParticleType<($SweepingStrikeParticleOption)>
public "writeToString"(): string
public "writeToNetwork"(arg0: $FriendlyByteBuf$Type): void
get "type"(): $ParticleType<($SweepingStrikeParticleOption)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweepingStrikeParticleOption$Type = ($SweepingStrikeParticleOption);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SweepingStrikeParticleOption_ = $SweepingStrikeParticleOption$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$PerformSide" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PerformSide extends $Enum<($PerformSide)> {
static readonly "client": $PerformSide
static readonly "server": $PerformSide
static readonly "both": $PerformSide


public static "values"(): ($PerformSide)[]
public static "valueOf"(arg0: string): $PerformSide
public "runServer"(): boolean
public "runClient"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerformSide$Type = (("server") | ("client") | ("both")) | ($PerformSide);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PerformSide_ = $PerformSide$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialStatGui" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$ILabelGetter, $ILabelGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ILabelGetter"

export class $HoloMaterialStatGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: string, arg3: $ILabelGetter$Type, arg4: $Function$Type<($MaterialData$Type), (float)>)

public "update"(arg0: $MaterialData$Type, arg1: $MaterialData$Type): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialStatGui$Type = ($HoloMaterialStatGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialStatGui_ = $HoloMaterialStatGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/suspend/$ToggleSuspendPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $ToggleSuspendPacket extends $AbstractPacket {

constructor()
constructor(arg0: boolean)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToggleSuspendPacket$Type = ($ToggleSuspendPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToggleSuspendPacket_ = $ToggleSuspendPacket$Type;
}}
declare module "packages/se/mickelus/tetra/interactions/$SecondaryInteractionOverlay" {
import {$InputEvent$Key, $InputEvent$Key$Type} from "packages/net/minecraftforge/client/event/$InputEvent$Key"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $SecondaryInteractionOverlay extends $GuiRoot implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onKeyInput"(arg0: $InputEvent$Key$Type): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecondaryInteractionOverlay$Type = ($SecondaryInteractionOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecondaryInteractionOverlay_ = $SecondaryInteractionOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$TierData" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TierData<T> {
 "levelMap": $Map<(T), (float)>
 "efficiencyMap": $Map<(T), (float)>

constructor()

public "contains"(arg0: T): boolean
public "getLevel"(arg0: T): integer
public "getLevelMap"(): $Map<(T), (integer)>
public "getEfficiency"(arg0: T): float
public "getValues"(): $Set<(T)>
get "levelMap"(): $Map<(T), (integer)>
get "values"(): $Set<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TierData$Type<T> = ($TierData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TierData_<T> = $TierData$Type<(T)>;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicScrollHandler" {
import {$StackedMultiblockSchematicItem, $StackedMultiblockSchematicItem$Type} from "packages/se/mickelus/tetra/blocks/multischematic/$StackedMultiblockSchematicItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InputEvent$MouseScrollingEvent, $InputEvent$MouseScrollingEvent$Type} from "packages/net/minecraftforge/client/event/$InputEvent$MouseScrollingEvent"

export class $MultiblockSchematicScrollHandler {

constructor()

public static "setupSchematic"(arg0: string, arg1: integer): void
public static "addSchematic"(arg0: string, arg1: integer, arg2: $StackedMultiblockSchematicItem$Type): void
public static "shiftSchematic"(arg0: $Player$Type, arg1: boolean): void
public static "onMouseScroll"(arg0: $InputEvent$MouseScrollingEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicScrollHandler$Type = ($MultiblockSchematicScrollHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicScrollHandler_ = $MultiblockSchematicScrollHandler$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiAttachment" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $GuiAttachment extends $Enum<($GuiAttachment)> {
static readonly "topLeft": $GuiAttachment
static readonly "topCenter": $GuiAttachment
static readonly "topRight": $GuiAttachment
static readonly "middleLeft": $GuiAttachment
static readonly "middleCenter": $GuiAttachment
static readonly "middleRight": $GuiAttachment
static readonly "bottomLeft": $GuiAttachment
static readonly "bottomCenter": $GuiAttachment
static readonly "bottomRight": $GuiAttachment


public static "values"(): ($GuiAttachment)[]
public static "valueOf"(arg0: string): $GuiAttachment
public "flipHorizontal"(): $GuiAttachment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiAttachment$Type = (("bottomcenter") | ("bottomleft") | ("middleleft") | ("topleft") | ("topright") | ("middleright") | ("middlecenter") | ("topcenter") | ("bottomright")) | ($GuiAttachment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiAttachment_ = $GuiAttachment$Type;
}}
declare module "packages/se/mickelus/tetra/$TetraToolActions" {
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"

export class $TetraToolActions {
static readonly "cut": $ToolAction
static readonly "hammer": $ToolAction
static readonly "pry": $ToolAction
static readonly "dowse": $ToolAction

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TetraToolActions$Type = ($TetraToolActions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TetraToolActions_ = $TetraToolActions$Type;
}}
declare module "packages/se/mickelus/tetra/data/$DataManager" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$DestabilizationEffect, $DestabilizationEffect$Type} from "packages/se/mickelus/tetra/module/improvement/$DestabilizationEffect"
import {$UnlockData, $UnlockData$Type} from "packages/se/mickelus/tetra/blocks/workbench/unlocks/$UnlockData"
import {$TweakData, $TweakData$Type} from "packages/se/mickelus/tetra/module/data/$TweakData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SchematicStore, $SchematicStore$Type} from "packages/se/mickelus/tetra/data/$SchematicStore"
import {$CraftingEffect, $CraftingEffect$Type} from "packages/se/mickelus/tetra/craftingeffect/$CraftingEffect"
import {$MaterialStore, $MaterialStore$Type} from "packages/se/mickelus/tetra/data/$MaterialStore"
import {$EnchantmentMapping, $EnchantmentMapping$Type} from "packages/se/mickelus/tetra/module/data/$EnchantmentMapping"
import {$ConfigActionImpl, $ConfigActionImpl$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$ConfigActionImpl"
import {$AddReloadListenerEvent, $AddReloadListenerEvent$Type} from "packages/net/minecraftforge/event/$AddReloadListenerEvent"
import {$DataStore, $DataStore$Type} from "packages/se/mickelus/mutil/data/$DataStore"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$ReplacementDefinition, $ReplacementDefinition$Type} from "packages/se/mickelus/tetra/module/$ReplacementDefinition"
import {$DataDistributor, $DataDistributor$Type} from "packages/se/mickelus/mutil/data/$DataDistributor"
import {$ArchetypeDefinition, $ArchetypeDefinition$Type} from "packages/se/mickelus/tetra/items/modular/impl/dynamic/$ArchetypeDefinition"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$PlayerEvent$PlayerLoggedInEvent, $PlayerEvent$PlayerLoggedInEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerLoggedInEvent"
import {$SynergyData, $SynergyData$Type} from "packages/se/mickelus/tetra/module/data/$SynergyData"
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$TagsUpdatedEvent, $TagsUpdatedEvent$Type} from "packages/net/minecraftforge/event/$TagsUpdatedEvent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DataManager implements $DataDistributor {
static readonly "gson": $Gson
static "instance": $DataManager
readonly "tierData": $DataStore<(($ResourceLocation)[])>
readonly "tweakData": $DataStore<(($TweakData)[])>
readonly "materialData": $MaterialStore
readonly "improvementData": $DataStore<(($ImprovementData)[])>
readonly "moduleData": $DataStore<($ModuleData)>
readonly "repairData": $DataStore<($RepairDefinition)>
readonly "enchantmentData": $DataStore<(($EnchantmentMapping)[])>
readonly "synergyData": $DataStore<(($SynergyData)[])>
readonly "replacementData": $DataStore<(($ReplacementDefinition)[])>
readonly "schematicData": $SchematicStore
readonly "craftingEffectData": $DataStore<($CraftingEffect)>
readonly "actionData": $DataStore<(($ConfigActionImpl)[])>
readonly "destabilizationData": $DataStore<(($DestabilizationEffect)[])>
readonly "unlockData": $DataStore<($UnlockData)>
readonly "archetypeData": $DataStore<($ArchetypeDefinition)>

constructor()

public "sendToPlayer"(arg0: $ServerPlayer$Type, arg1: string, arg2: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
public "tagsUpdated"(arg0: $TagsUpdatedEvent$Type): void
public "sendToAll"(arg0: string, arg1: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
public "addReloadListener"(arg0: $AddReloadListenerEvent$Type): void
public "getSynergyData"(arg0: string): ($SynergyData)[]
public "playerConnected"(arg0: $PlayerEvent$PlayerLoggedInEvent$Type): void
public "onDataRecieved"(arg0: string, arg1: $Map$Type<($ResourceLocation$Type), (string)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataManager$Type = ($DataManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataManager_ = $DataManager$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$ItemPredicateDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"

export class $ItemPredicateDeserializer implements $JsonDeserializer<($ItemPredicate)> {

constructor()

public static "deserialize"(arg0: $JsonElement$Type): $ItemPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicateDeserializer$Type = ($ItemPredicateDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPredicateDeserializer_ = $ItemPredicateDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/scan/$ScannerSound" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$AbstractTickableSoundInstance, $AbstractTickableSoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$AbstractTickableSoundInstance"

export class $ScannerSound extends $AbstractTickableSoundInstance {

constructor(arg0: $Minecraft$Type)

public "activate"(): void
public "tick"(): void
public "canStartSilent"(): boolean
public static "createUnseededRandom"(): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScannerSound$Type = ($ScannerSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScannerSound_ = $ScannerSound$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiTweakControls" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GuiTweakControls extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<($Map$Type<(string), (integer)>)>, arg3: $Consumer$Type<($Map$Type<(string), (integer)>)>)

public "update"(arg0: $ItemModule$Type, arg1: $ItemStack$Type): void
public "flash"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTweakControls$Type = ($GuiTweakControls);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTweakControls_ = $GuiTweakControls$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiTextureOffset" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiTexture, $GuiTexture$Type} from "packages/se/mickelus/mutil/gui/$GuiTexture"

export class $GuiTextureOffset extends $GuiTexture {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $ResourceLocation$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: $ResourceLocation$Type)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTextureOffset$Type = ($GuiTextureOffset);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTextureOffset_ = $GuiTextureOffset$Type;
}}
declare module "packages/se/mickelus/tetra/module/$MultiSlotMajorModule" {
import {$ModuleData, $ModuleData$Type} from "packages/se/mickelus/tetra/module/data/$ModuleData"
import {$ItemModuleMajor, $ItemModuleMajor$Type} from "packages/se/mickelus/tetra/module/$ItemModuleMajor"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"

export class $MultiSlotMajorModule extends $ItemModuleMajor {
static readonly "settleImprovement": string
static readonly "arrestedImprovement": string
static readonly "repairLevelFactor": float

constructor(arg0: $ResourceLocation$Type, arg1: $ModuleData$Type)

public "getModels"(arg0: $ItemStack$Type): ($ModuleModel)[]
public "getUnlocalizedName"(): string
get "unlocalizedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiSlotMajorModule$Type = ($MultiSlotMajorModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiSlotMajorModule_ = $MultiSlotMajorModule$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingOverlay" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $HowlingOverlay implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingOverlay$Type = ($HowlingOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingOverlay_ = $HowlingOverlay$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/scroll/$OpenScrollBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$ScrollBlock, $ScrollBlock$Type} from "packages/se/mickelus/tetra/blocks/scroll/$ScrollBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $OpenScrollBlock extends $ScrollBlock {
static readonly "identifier": string
static "instance": $ScrollBlock
static readonly "sound": $SoundType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpenScrollBlock$Type = ($OpenScrollBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpenScrollBlock_ = $OpenScrollBlock$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterToolCompoundEfficiency" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterToolCompoundEfficiency implements $IStatGetter {

constructor(arg0: $IStatGetter$Type, arg1: $IStatGetter$Type, arg2: $IStatGetter$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterToolCompoundEfficiency$Type = ($StatGetterToolCompoundEfficiency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterToolCompoundEfficiency_ = $StatGetterToolCompoundEfficiency$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$LabelGetterBasic" {
import {$ILabelGetter, $ILabelGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ILabelGetter"

export class $LabelGetterBasic implements $ILabelGetter {
static readonly "integerLabel": $ILabelGetter
static readonly "integerLabelInverted": $ILabelGetter
static readonly "decimalLabel": $ILabelGetter
static readonly "singleDecimalLabel": $ILabelGetter
static readonly "decimalLabelInverted": $ILabelGetter
static readonly "percentageLabel": $ILabelGetter
static readonly "percentageLabelInverted": $ILabelGetter
static readonly "percentageLabelDecimal": $ILabelGetter
static readonly "percentageLabelDecimalInverted": $ILabelGetter
static readonly "noLabel": $ILabelGetter

constructor(arg0: string, arg1: string, arg2: boolean)
constructor(arg0: string, arg1: string)
constructor(arg0: string)

public "getLabelMerged"(arg0: double, arg1: double): string
public "getLabel"(arg0: double, arg1: double, arg2: boolean): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LabelGetterBasic$Type = ($LabelGetterBasic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LabelGetterBasic_ = $LabelGetterBasic$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectEfficiency" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterEffectEfficiency implements $IStatGetter {

constructor(arg0: $ItemEffect$Type, arg1: double)
constructor(arg0: $ItemEffect$Type, arg1: double, arg2: double)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterEffectEfficiency$Type = ($StatGetterEffectEfficiency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterEffectEfficiency_ = $StatGetterEffectEfficiency$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterVelocity" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterVelocity implements $ITooltipGetter {
static readonly "drawStrengthGetter": $IStatGetter

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterVelocity$Type = ($TooltipGetterVelocity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterVelocity_ = $TooltipGetterVelocity$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$PristineDiamondItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PristineDiamondItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PristineDiamondItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PristineDiamondItem$Type = ($PristineDiamondItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PristineDiamondItem_ = $PristineDiamondItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/gui/$RevengeGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $RevengeGui extends $GuiElement {

constructor()

public "update"(arg0: $Player$Type, arg1: $HitResult$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RevengeGui$Type = ($RevengeGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RevengeGui_ = $RevengeGui$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$ForgedContainerMenu, $ForgedContainerMenu$Type} from "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerMenu"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $ForgedContainerScreen extends $AbstractContainerScreen<($ForgedContainerMenu)> {
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $ForgedContainerMenu$Type, arg1: $Inventory$Type, arg2: $Component$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseReleased"(arg0: double, arg1: double, arg2: integer): boolean
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "m_181908_"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerScreen$Type = ($ForgedContainerScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerScreen_ = $ForgedContainerScreen$Type;
}}
declare module "packages/se/mickelus/tetra/items/$InitializableItem" {
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"

export interface $InitializableItem {

 "clientInit"(): void
 "commonInit"(arg0: $PacketHandler$Type): void
}

export namespace $InitializableItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InitializableItem$Type = ($InitializableItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InitializableItem_ = $InitializableItem$Type;
}}
declare module "packages/se/mickelus/tetra/effect/potion/$SmallAbsorbPotionEffect" {
import {$IClientMobEffectExtensions, $IClientMobEffectExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions"
import {$AttributeMap, $AttributeMap$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeMap"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $SmallAbsorbPotionEffect extends $MobEffect {
static readonly "identifier": string
static "instance": $SmallAbsorbPotionEffect

constructor()

public "initializeClient"(arg0: $Consumer$Type<($IClientMobEffectExtensions$Type)>): void
public "addAttributeModifiers"(arg0: $LivingEntity$Type, arg1: $AttributeMap$Type, arg2: integer): void
public "removeAttributeModifiers"(arg0: $LivingEntity$Type, arg1: $AttributeMap$Type, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmallAbsorbPotionEffect$Type = ($SmallAbsorbPotionEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmallAbsorbPotionEffect_ = $SmallAbsorbPotionEffect$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$ProgressionHelper" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ProgressionHelper {

constructor()

public static "showHoneToastClient"(arg0: $ItemStack$Type): void
public static "showSettleToastClient"(arg0: $ItemStack$Type, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressionHelper$Type = ($ProgressionHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressionHelper_ = $ProgressionHelper$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAbilityChargeTime" {
import {$ChargedAbilityEffect, $ChargedAbilityEffect$Type} from "packages/se/mickelus/tetra/effect/$ChargedAbilityEffect"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAbilityChargeTime implements $IStatGetter {

constructor(arg0: $ChargedAbilityEffect$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAbilityChargeTime$Type = ($StatGetterAbilityChargeTime);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAbilityChargeTime_ = $StatGetterAbilityChargeTime$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterDurability" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterDurability implements $IStatGetter {

constructor()

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterDurability$Type = ($StatGetterDurability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterDurability_ = $StatGetterDurability$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$RepairInfoGui" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $RepairInfoGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: ($ItemStack$Type)[]): void
public "getTooltipLines"(): $List<($Component)>
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairInfoGui$Type = ($RepairInfoGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairInfoGui_ = $RepairInfoGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterSweepingRange" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$StatGetterEffectEfficiency, $StatGetterEffectEfficiency$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectEfficiency"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterSweepingRange extends $StatGetterEffectEfficiency {

constructor()

public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterSweepingRange$Type = ($StatGetterSweepingRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterSweepingRange_ = $StatGetterSweepingRange$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ChangeCompartmentPacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $ChangeCompartmentPacket extends $AbstractPacket {

constructor()
constructor(arg0: integer)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChangeCompartmentPacket$Type = ($ChangeCompartmentPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChangeCompartmentPacket_ = $ChangeCompartmentPacket$Type;
}}
declare module "packages/se/mickelus/tetra/$FeatureFlag" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FeatureFlag extends $Enum<($FeatureFlag)> {
static readonly "laminatedStave": $FeatureFlag
static readonly "bedrockExtraction": $FeatureFlag


public static "values"(): ($FeatureFlag)[]
public static "valueOf"(arg0: string): $FeatureFlag
public static "isEnabled"(arg0: $FeatureFlag$Type): boolean
public static "matchesAnyKey"(arg0: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureFlag$Type = (("laminatedstave") | ("bedrockextraction")) | ($FeatureFlag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FeatureFlag_ = $FeatureFlag$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiClickable, $GuiClickable$Type} from "packages/se/mickelus/mutil/gui/$GuiClickable"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $GuiButton extends $GuiClickable {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: string, arg5: $Runnable$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: string, arg5: $Runnable$Type, arg6: $Component$Type)
constructor(arg0: integer, arg1: integer, arg2: string, arg3: $Runnable$Type)

public "setText"(arg0: string): void
public "setEnabled"(arg0: boolean): void
public "onMouseClick"(arg0: integer, arg1: integer, arg2: integer): boolean
public "getTooltipLines"(): $List<($Component)>
set "text"(value: string)
set "enabled"(value: boolean)
get "tooltipLines"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiButton$Type = ($GuiButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiButton_ = $GuiButton$Type;
}}
declare module "packages/se/mickelus/tetra/$LooseItemPredicate" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $LooseItemPredicate extends $ItemPredicate {
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor(arg0: $JsonObject$Type)

public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LooseItemPredicate$Type = ($LooseItemPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LooseItemPredicate_ = $LooseItemPredicate$Type;
}}
declare module "packages/se/mickelus/tetra/module/improvement/$SettlePacket" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$AbstractPacket, $AbstractPacket$Type} from "packages/se/mickelus/mutil/network/$AbstractPacket"

export class $SettlePacket extends $AbstractPacket {

constructor()
constructor(arg0: $ItemStack$Type, arg1: string)

public "toBytes"(arg0: $FriendlyByteBuf$Type): void
public "handle"(arg0: $Player$Type): void
public "fromBytes"(arg0: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SettlePacket$Type = ($SettlePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SettlePacket_ = $SettlePacket$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$ActionInteraction" {
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$InteractionOutcome, $InteractionOutcome$Type} from "packages/se/mickelus/tetra/blocks/salvage/$InteractionOutcome"

export class $ActionInteraction extends $BlockInteraction {
 "requiredTool": $ToolAction
 "requiredLevel": integer
 "alwaysReveal": boolean
 "face": $Direction
 "minX": float
 "minY": float
 "maxX": float
 "maxY": float
 "predicate": $Predicate<($BlockState)>
 "outcome": $InteractionOutcome

constructor(arg0: $ToolAction$Type, arg1: integer, arg2: string)

public static "create"(arg0: $WorkbenchTile$Type): $ActionInteraction
public "applicableForBlock"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): boolean
public "applyOutcome"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $Direction$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ActionInteraction$Type = ($ActionInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ActionInteraction_ = $ActionInteraction$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/action/$RepairAction" {
import {$WorkbenchTile, $WorkbenchTile$Type} from "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$WorkbenchAction, $WorkbenchAction$Type} from "packages/se/mickelus/tetra/blocks/workbench/action/$WorkbenchAction"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RepairAction implements $WorkbenchAction {
static readonly "key": string

constructor()

public "getKey"(): string
public "canPerformOn"(arg0: $Player$Type, arg1: $WorkbenchTile$Type, arg2: $ItemStack$Type): boolean
public "perform"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $WorkbenchTile$Type): void
public "getRequiredToolActions"(arg0: $ItemStack$Type): $Collection<($ToolAction)>
public "getRequiredTools"(arg0: $ItemStack$Type): $Map<($ToolAction), (integer)>
public "getRequiredToolLevel"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): integer
public "allowInWorldInteraction"(): boolean
get "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairAction$Type = ($RepairAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairAction_ = $RepairAction$Type;
}}
declare module "packages/se/mickelus/tetra/$Tooltips" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"

export class $Tooltips {
static readonly "reveal": $Component
static readonly "expand": $Component
static readonly "expanded": $Component

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tooltips$Type = ($Tooltips);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Tooltips_ = $Tooltips$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$QuiverInventory" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolbeltInventory, $ToolbeltInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $QuiverInventory extends $ToolbeltInventory {
static "maxSize": integer

constructor(arg0: $ItemStack$Type)

public "getAggregatedStacks"(): ($ItemStack)[]
public "getFirstIndexForStack"(arg0: $ItemStack$Type): integer
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
get "aggregatedStacks"(): ($ItemStack)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuiverInventory$Type = ($QuiverInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuiverInventory_ = $QuiverInventory$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/$ForgedCrateBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$FallingBlock, $FallingBlock$Type} from "packages/net/minecraft/world/level/block/$FallingBlock"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InitializableBlock, $InitializableBlock$Type} from "packages/se/mickelus/tetra/blocks/$InitializableBlock"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$PacketHandler, $PacketHandler$Type} from "packages/se/mickelus/mutil/network/$PacketHandler"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"

export class $ForgedCrateBlock extends $FallingBlock implements $InitializableBlock, $IInteractiveBlock, $SimpleWaterloggedBlock {
static readonly "propFacing": $DirectionProperty
static readonly "propStacked": $BooleanProperty
static readonly "propIntegrity": $IntegerProperty
static readonly "interactionLootTable": $ResourceLocation
static readonly "identifier": string
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()

public "getStateForPlacement"(arg0: $BlockPlaceContext$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$Type, arg1: $BlockGetter$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
public "updateShape"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $BlockState$Type, arg3: $LevelAccessor$Type, arg4: $BlockPos$Type, arg5: $BlockPos$Type): $BlockState
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "getFluidState"(arg0: $BlockState$Type): $FluidState
public "rotate"(arg0: $BlockState$Type, arg1: $Rotation$Type): $BlockState
public "mirror"(arg0: $BlockState$Type, arg1: $Mirror$Type): $BlockState
public "getShape"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $CollisionContext$Type): $VoxelShape
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "clientInit"(): void
public "commonInit"(arg0: $PacketHandler$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedCrateBlock$Type = ($ForgedCrateBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedCrateBlock_ = $ForgedCrateBlock$Type;
}}
declare module "packages/se/mickelus/tetra/levelgen/$TransferUnitProcessor" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StructurePlaceSettings, $StructurePlaceSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructurePlaceSettings"
import {$StructureProcessor, $StructureProcessor$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessor"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureTemplate, $StructureTemplate$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureTemplate"

export class $TransferUnitProcessor extends $StructureProcessor {
static readonly "INSTANCE": $TransferUnitProcessor
static readonly "codec": $Codec<($TransferUnitProcessor)>
static "type": $RegistryObject<($StructureProcessorType<(any)>)>

constructor()

public "process"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $StructureTemplate$StructureBlockInfo$Type, arg4: $StructureTemplate$StructureBlockInfo$Type, arg5: $StructurePlaceSettings$Type, arg6: $StructureTemplate$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransferUnitProcessor$Type = ($TransferUnitProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransferUnitProcessor_ = $TransferUnitProcessor$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/shield/$ShieldModelData$Part" {
import {$UVPair, $UVPair$Type} from "packages/net/minecraft/client/model/geom/builders/$UVPair"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"

export class $ShieldModelData$Part {

constructor(arg0: $Vector3f$Type, arg1: $Vector3f$Type, arg2: $Vector3f$Type, arg3: $UVPair$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShieldModelData$Part$Type = ($ShieldModelData$Part);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShieldModelData$Part_ = $ShieldModelData$Part$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterPercentage" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterPercentage implements $ITooltipGetter {

constructor(arg0: string, arg1: $IStatGetter$Type)

public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterPercentage$Type = ($TooltipGetterPercentage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterPercentage_ = $TooltipGetterPercentage$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/geode/$PristineEmeraldItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TetraItem, $TetraItem$Type} from "packages/se/mickelus/tetra/items/$TetraItem"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PristineEmeraldItem extends $TetraItem {
static readonly "identifier": string
static "instance": $PristineEmeraldItem
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor()

public "appendHoverText"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PristineEmeraldItem$Type = ($PristineEmeraldItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PristineEmeraldItem_ = $PristineEmeraldItem$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterSpread" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$StatGetterEffectEfficiency, $StatGetterEffectEfficiency$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterEffectEfficiency"
import {$ItemEffect, $ItemEffect$Type} from "packages/se/mickelus/tetra/effect/$ItemEffect"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterSpread extends $StatGetterEffectEfficiency {

constructor(arg0: $ItemEffect$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterSpread$Type = ($StatGetterSpread);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterSpread_ = $StatGetterSpread$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialIntegrityStatGui" {
import {$HoloMaterialStatGui, $HoloMaterialStatGui$Type} from "packages/se/mickelus/tetra/items/modular/impl/holo/gui/craft/$HoloMaterialStatGui"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"

export class $HoloMaterialIntegrityStatGui extends $HoloMaterialStatGui {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $MaterialData$Type, arg1: $MaterialData$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoloMaterialIntegrityStatGui$Type = ($HoloMaterialIntegrityStatGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoloMaterialIntegrityStatGui_ = $HoloMaterialIntegrityStatGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/$StatsHelper" {
import {$StatFormat, $StatFormat$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$StatFormat"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"

export class $StatsHelper {
static readonly "barLength": integer

constructor()

public static "sum"(arg0: double, ...arg1: ($IStatGetter$Type)[]): $IStatGetter
public static "sum"(...arg0: ($IStatGetter$Type)[]): $IStatGetter
public static "multiply"(arg0: double, ...arg1: ($IStatGetter$Type)[]): $IStatGetter
public static "multiply"(...arg0: ($IStatGetter$Type)[]): $IStatGetter
public static "withStats"(...arg0: ($IStatGetter$Type)[]): ($IStatGetter)[]
public static "withFormat"(...arg0: ($StatFormat$Type)[]): ($StatFormat)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatsHelper$Type = ($StatsHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatsHelper_ = $StatsHelper$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/$SchematicDefinition" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$OutcomeDefinition, $OutcomeDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$OutcomeDefinition"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$SchematicType, $SchematicType$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicType"
import {$SchematicRarity, $SchematicRarity$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicRarity"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"

export class $SchematicDefinition {
 "replace": boolean
 "localizationKey": string
 "slots": (string)[]
 "keySuffixes": (string)[]
 "materialSlotCount": integer
 "repair": boolean
 "hone": boolean
 "requirement": $CraftingRequirement
 "materialRevealSlot": integer
 "displayType": $SchematicType
 "rarity": $SchematicRarity
 "glyph": $GlyphData
 "translation": $MaterialMultiplier
 "applicableMaterials": (string)[]
 "outcomes": ($OutcomeDefinition)[]
 "sources": (string)[]
 "key": string

constructor()

public static "copyFields"(arg0: $SchematicDefinition$Type, arg1: $SchematicDefinition$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicDefinition$Type = ($SchematicDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchematicDefinition_ = $SchematicDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/client/$ToolActionIconStore" {
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PreparableReloadListener$PreparationBarrier, $PreparableReloadListener$PreparationBarrier$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener$PreparationBarrier"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$ResourceManagerReloadListener, $ResourceManagerReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManagerReloadListener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$ProfilerFiller, $ProfilerFiller$Type} from "packages/net/minecraft/util/profiling/$ProfilerFiller"

export class $ToolActionIconStore implements $ResourceManagerReloadListener {
static "instance": $ToolActionIconStore

constructor()

public "getIcon"(arg0: $ToolAction$Type): $GlyphData
public "onResourceManagerReload"(arg0: $ResourceManager$Type): void
public "reload"(arg0: $PreparableReloadListener$PreparationBarrier$Type, arg1: $ResourceManager$Type, arg2: $ProfilerFiller$Type, arg3: $ProfilerFiller$Type, arg4: $Executor$Type, arg5: $Executor$Type): $CompletableFuture<(void)>
public "getName"(): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolActionIconStore$Type = ($ToolActionIconStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolActionIconStore_ = $ToolActionIconStore$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterSweepingFocus" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterSweepingFocus implements $ITooltipGetter {

constructor(arg0: $IStatGetter$Type)

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterSweepingFocus$Type = ($TooltipGetterSweepingFocus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterSweepingFocus_ = $TooltipGetterSweepingFocus$Type;
}}
declare module "packages/se/mickelus/tetra/module/schematic/requirement/$LockedRequirement" {
import {$CraftingRequirement, $CraftingRequirement$Type} from "packages/se/mickelus/tetra/module/schematic/requirement/$CraftingRequirement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingContext, $CraftingContext$Type} from "packages/se/mickelus/tetra/module/schematic/$CraftingContext"

export class $LockedRequirement implements $CraftingRequirement {
 "key": $ResourceLocation

constructor()

public "test"(arg0: $CraftingContext$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LockedRequirement$Type = ($LockedRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LockedRequirement_ = $LockedRequirement$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/multischematic/$MultiblockSchematicGui" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export class $MultiblockSchematicGui extends $GuiRoot implements $IGuiOverlay {

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
public "onClientTick"(arg0: $TickEvent$ClientTickEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicGui$Type = ($MultiblockSchematicGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicGui_ = $MultiblockSchematicGui$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$ItemTagKeyDeserializer" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$TypeToken, $TypeToken$Type} from "packages/com/google/common/reflect/$TypeToken"

export class $ItemTagKeyDeserializer implements $JsonDeserializer<($TagKey<($Item)>)> {
static readonly "typeToken": $TypeToken<($TagKey<($Item)>)>

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $TagKey<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTagKeyDeserializer$Type = ($ItemTagKeyDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTagKeyDeserializer_ = $ItemTagKeyDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/transfer/$EnumTransferConfig" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $EnumTransferConfig extends $Enum<($EnumTransferConfig)> implements $StringRepresentable {
static readonly "send": $EnumTransferConfig
static readonly "redstone": $EnumTransferConfig
static readonly "receive": $EnumTransferConfig


public static "values"(): ($EnumTransferConfig)[]
public static "valueOf"(arg0: string): $EnumTransferConfig
public "getSerializedName"(): string
public static "getNextConfiguration"(arg0: $EnumTransferConfig$Type): $EnumTransferConfig
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumTransferConfig$Type = (("receive") | ("send") | ("redstone")) | ($EnumTransferConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumTransferConfig_ = $EnumTransferConfig$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/$ItemPredicateModular" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemPredicate, $ItemPredicate$Type} from "packages/net/minecraft/advancements/critereon/$ItemPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemPredicateModular extends $ItemPredicate {
static readonly "ANY": $ItemPredicate
 "items": $Set<($Item)>

constructor(arg0: ((string)[])[])
constructor(arg0: $JsonObject$Type)

public "test"(arg0: $ItemStack$Type, arg1: string): boolean
public "matches"(arg0: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicateModular$Type = ($ItemPredicateModular);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPredicateModular_ = $ItemPredicateModular$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$AbstractWorkbenchBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IInteractiveBlock, $IInteractiveBlock$Type} from "packages/se/mickelus/tetra/blocks/salvage/$IInteractiveBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockInteraction, $BlockInteraction$Type} from "packages/se/mickelus/tetra/blocks/salvage/$BlockInteraction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TetraBlock, $TetraBlock$Type} from "packages/se/mickelus/tetra/blocks/$TetraBlock"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AbstractWorkbenchBlock extends $TetraBlock implements $IInteractiveBlock, $EntityBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(arg0: $BlockBehaviour$Properties$Type)

public "getToolLevels"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Map<($ToolAction), (integer)>
public "onActionConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: $Player$Type, arg5: $ToolAction$Type, arg6: integer, arg7: boolean): $ItemStack
public "getToolLevel"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ToolAction$Type): integer
public "getTools"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $Collection<($ToolAction)>
public "use"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: $InteractionHand$Type, arg5: $BlockHitResult$Type): $InteractionResult
public "onRemove"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: boolean): void
public "getPotentialInteractions"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type, arg4: $Collection$Type<($ToolAction$Type)>): ($BlockInteraction)[]
public "getCraftingEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
public "onCraftConsumeTool"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ItemStack$Type, arg4: string, arg5: boolean, arg6: $Player$Type, arg7: $ToolAction$Type, arg8: integer, arg9: boolean): $ItemStack
public "getSchematics"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): ($ResourceLocation)[]
public "newBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type): $BlockEntity
public "getTicker"<T extends $BlockEntity>(arg0: $Level$Type, arg1: $BlockState$Type, arg2: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractWorkbenchBlock$Type = ($AbstractWorkbenchBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractWorkbenchBlock_ = $AbstractWorkbenchBlock$Type;
}}
declare module "packages/se/mickelus/mutil/gui/$GuiTextSmall" {
import {$GuiText, $GuiText$Type} from "packages/se/mickelus/mutil/gui/$GuiText"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $GuiTextSmall extends $GuiText {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: string)

public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "setString"(arg0: string): void
set "string"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTextSmall$Type = ($GuiTextSmall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTextSmall_ = $GuiTextSmall$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/gui/$GuiModuleDetails" {
import {$ItemModule, $ItemModule$Type} from "packages/se/mickelus/tetra/module/$ItemModule"
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GuiModuleDetails extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "update"(arg0: $ItemModule$Type, arg1: $ItemStack$Type): void
public "flash"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiModuleDetails$Type = ($GuiModuleDetails);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiModuleDetails_ = $GuiModuleDetails$Type;
}}
declare module "packages/se/mickelus/tetra/craftingeffect/condition/$CraftTypeCondition" {
import {$UpgradeSchematic, $UpgradeSchematic$Type} from "packages/se/mickelus/tetra/module/schematic/$UpgradeSchematic"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CraftingEffectCondition, $CraftingEffectCondition$Type} from "packages/se/mickelus/tetra/craftingeffect/condition/$CraftingEffectCondition"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CraftTypeCondition implements $CraftingEffectCondition {

constructor()

public "test"(arg0: ($ResourceLocation$Type)[], arg1: $ItemStack$Type, arg2: string, arg3: boolean, arg4: $Player$Type, arg5: ($ItemStack$Type)[], arg6: $Map$Type<($ToolAction$Type), (integer)>, arg7: $UpgradeSchematic$Type, arg8: $Level$Type, arg9: $BlockPos$Type, arg10: $BlockState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftTypeCondition$Type = ($CraftTypeCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftTypeCondition_ = $CraftTypeCondition$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/workbench/$WorkbenchPacketCraft" {
import {$BlockPosPacket, $BlockPosPacket$Type} from "packages/se/mickelus/mutil/network/$BlockPosPacket"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $WorkbenchPacketCraft extends $BlockPosPacket {

constructor()
constructor(arg0: $BlockPos$Type)

public "handle"(arg0: $Player$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorkbenchPacketCraft$Type = ($WorkbenchPacketCraft);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorkbenchPacketCraft_ = $WorkbenchPacketCraft$Type;
}}
declare module "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerRenderer" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$ForgedContainerBlockEntity, $ForgedContainerBlockEntity$Type} from "packages/se/mickelus/tetra/blocks/forged/container/$ForgedContainerBlockEntity"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ModelPart, $ModelPart$Type} from "packages/net/minecraft/client/model/geom/$ModelPart"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"

export class $ForgedContainerRenderer implements $BlockEntityRenderer<($ForgedContainerBlockEntity)> {
static readonly "material": $Material
static "layer": $ModelLayerLocation
 "lid": $ModelPart
 "base": $ModelPart
 "locks": ($ModelPart)[]

constructor(arg0: $BlockEntityRendererProvider$Context$Type)

public static "createLayer"(): $LayerDefinition
public "render"(arg0: $ForgedContainerBlockEntity$Type, arg1: float, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer, arg5: integer): void
public "shouldRender"(arg0: $ForgedContainerBlockEntity$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $ForgedContainerBlockEntity$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgedContainerRenderer$Type = ($ForgedContainerRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgedContainerRenderer_ = $ForgedContainerRenderer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/dynamic/$ArchetypeDefinition" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ArchetypeSlotDefinition, $ArchetypeSlotDefinition$Type} from "packages/se/mickelus/tetra/items/modular/impl/dynamic/$ArchetypeSlotDefinition"

export class $ArchetypeDefinition extends $Record {

constructor(id: string, honeable: boolean, honeBase: integer, honeIntegrityMultiplier: integer, slots: ($ArchetypeSlotDefinition$Type)[])

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "id"(): string
public "slots"(): ($ArchetypeSlotDefinition)[]
public "honeable"(): boolean
public "honeIntegrityMultiplier"(): integer
public "honeBase"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArchetypeDefinition$Type = ($ArchetypeDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArchetypeDefinition_ = $ArchetypeDefinition$Type;
}}
declare module "packages/se/mickelus/tetra/trades/$TradeHandler" {
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$VillagerTradesEvent, $VillagerTradesEvent$Type} from "packages/net/minecraftforge/event/village/$VillagerTradesEvent"
import {$WandererTradesEvent, $WandererTradesEvent$Type} from "packages/net/minecraftforge/event/village/$WandererTradesEvent"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $TradeHandler {
static readonly "ruinsTag": $TagKey<($Structure)>

constructor()

public "setupVillagerTrades"(arg0: $VillagerTradesEvent$Type): void
public "setupWandererTrades"(arg0: $WandererTradesEvent$Type): void
set "upVillagerTrades"(value: $VillagerTradesEvent$Type)
set "upWandererTrades"(value: $WandererTradesEvent$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TradeHandler$Type = ($TradeHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TradeHandler_ = $TradeHandler$Type;
}}
declare module "packages/se/mickelus/tetra/data/deserializer/$AttributesDeserializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonDeserializer, $JsonDeserializer$Type} from "packages/com/google/gson/$JsonDeserializer"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$TypeToken, $TypeToken$Type} from "packages/com/google/common/reflect/$TypeToken"

export class $AttributesDeserializer implements $JsonDeserializer<($Multimap<($Attribute), ($AttributeModifier)>)> {
static readonly "typeToken": $TypeToken<($Multimap<($Attribute), ($AttributeModifier)>)>

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $Multimap<($Attribute), ($AttributeModifier)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributesDeserializer$Type = ($AttributesDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributesDeserializer_ = $AttributesDeserializer$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$QuickslotDirectionGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"

export class $QuickslotDirectionGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: boolean)

public "animateOut"(): void
public "animateIn"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuickslotDirectionGui$Type = ($QuickslotDirectionGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuickslotDirectionGui_ = $QuickslotDirectionGui$Type;
}}
declare module "packages/se/mickelus/tetra/module/data/$MaterialImprovementData" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ImprovementData, $ImprovementData$Type} from "packages/se/mickelus/tetra/module/data/$ImprovementData"
import {$MaterialData, $MaterialData$Type} from "packages/se/mickelus/tetra/module/data/$MaterialData"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GlyphData, $GlyphData$Type} from "packages/se/mickelus/tetra/module/data/$GlyphData"
import {$ModuleModel, $ModuleModel$Type} from "packages/se/mickelus/tetra/module/data/$ModuleModel"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$EffectData, $EffectData$Type} from "packages/se/mickelus/tetra/module/data/$EffectData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MaterialMultiplier, $MaterialMultiplier$Type} from "packages/se/mickelus/tetra/module/data/$MaterialMultiplier"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$AspectData, $AspectData$Type} from "packages/se/mickelus/tetra/module/data/$AspectData"
import {$Priority, $Priority$Type} from "packages/se/mickelus/tetra/module/$Priority"
import {$ToolData, $ToolData$Type} from "packages/se/mickelus/tetra/module/data/$ToolData"

export class $MaterialImprovementData extends $ImprovementData {
 "materials": ($ResourceLocation)[]
 "extract": $MaterialMultiplier
 "level": integer
 "enchantment": boolean
 "group": string
 "replace": boolean
 "key": string
 "category": string
 "attributes": $Multimap<($Attribute), ($AttributeModifier)>
 "tools": $ToolData
 "effects": $EffectData
 "aspects": $AspectData
 "namePriority": $Priority
 "prefixPriority": $Priority
 "glyph": $GlyphData
 "models": ($ModuleModel)[]
 "magicCapacity": integer
 "durability": integer
 "durabilityMultiplier": float
 "integrity": integer
 "integrityUsage": integer
 "integrityMultiplier": float
 "tags": $Set<($TagKey<($Item)>)>
 "rarity": $Rarity

constructor()

public "combine"(arg0: $MaterialData$Type): $ImprovementData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialImprovementData$Type = ($MaterialImprovementData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialImprovementData_ = $MaterialImprovementData$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$StatGetterAttribute" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IStatGetter, $IStatGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$IStatGetter"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StatGetterAttribute implements $IStatGetter {

constructor(arg0: $Attribute$Type, arg1: boolean, arg2: boolean)
constructor(arg0: $Attribute$Type, arg1: boolean)
constructor(arg0: $Attribute$Type)

public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string): double
public "getValue"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: string, arg3: string): double
public "withOffset"(arg0: double): $StatGetterAttribute
public "shouldShow"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatGetterAttribute$Type = ($StatGetterAttribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatGetterAttribute_ = $StatGetterAttribute$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/gui/overlay/$PotionGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$PotionsInventory, $PotionsInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PotionsInventory"

export class $PotionGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer)

public "clear"(): void
public "setVisible"(arg0: boolean): void
public "draw"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public "getHand"(): $InteractionHand
public "setInventory"(arg0: $PotionsInventory$Type): void
public "getFocus"(): integer
set "visible"(value: boolean)
get "hand"(): $InteractionHand
set "inventory"(value: $PotionsInventory$Type)
get "focus"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionGroupGui$Type = ($PotionGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionGroupGui_ = $PotionGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$PotionsInventory" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ToolbeltInventory, $ToolbeltInventory$Type} from "packages/se/mickelus/tetra/items/modular/impl/toolbelt/inventory/$ToolbeltInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PotionsInventory extends $ToolbeltInventory {
static "maxSize": integer

constructor(arg0: $ItemStack$Type)

public "emptyOverflowSlots"(arg0: $Player$Type): void
public "takeItemStack"(arg0: integer): $ItemStack
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "storeItemInInventory"(arg0: $ItemStack$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionsInventory$Type = ($PotionsInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionsInventory_ = $PotionsInventory$Type;
}}
declare module "packages/se/mickelus/tetra/gui/$VerticalTabGroupGui" {
import {$GuiElement, $GuiElement$Type} from "packages/se/mickelus/mutil/gui/$GuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $VerticalTabGroupGui extends $GuiElement {

constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<(integer)>, ...arg3: (string)[])
constructor(arg0: integer, arg1: integer, arg2: $Consumer$Type<(integer)>, arg3: $ResourceLocation$Type, arg4: integer, arg5: integer, ...arg6: (string)[])

public "setActive"(arg0: integer): void
public "keyTyped"(arg0: character): void
public "setHasContent"(arg0: integer, arg1: boolean): void
set "active"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalTabGroupGui$Type = ($VerticalTabGroupGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VerticalTabGroupGui_ = $VerticalTabGroupGui$Type;
}}
declare module "packages/se/mickelus/tetra/gui/stats/getter/$TooltipGetterArthropod" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ITooltipGetter, $ITooltipGetter$Type} from "packages/se/mickelus/tetra/gui/stats/getter/$ITooltipGetter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TooltipGetterArthropod implements $ITooltipGetter {

constructor()

public "getTooltipBase"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "hasExtendedTooltip"(arg0: $Player$Type, arg1: $ItemStack$Type): boolean
public "getTooltipExtended"(arg0: $Player$Type, arg1: $ItemStack$Type): string
public "getTooltipExtension"(arg0: $Player$Type, arg1: $ItemStack$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipGetterArthropod$Type = ($TooltipGetterArthropod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipGetterArthropod_ = $TooltipGetterArthropod$Type;
}}
declare module "packages/se/mickelus/tetra/module/$RepairRegistry" {
import {$RepairDefinition, $RepairDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$RepairDefinition"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SchematicDefinition, $SchematicDefinition$Type} from "packages/se/mickelus/tetra/module/schematic/$SchematicDefinition"

export class $RepairRegistry {
static "instance": $RepairRegistry

constructor()

public "injectFromSchematics"(arg0: $Collection$Type<($SchematicDefinition$Type)>): void
public "getDefinitions"(arg0: string): $List<($RepairDefinition)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepairRegistry$Type = ($RepairRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RepairRegistry_ = $RepairRegistry$Type;
}}
declare module "packages/se/mickelus/tetra/effect/howling/$HowlingProgressGui" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiRoot, $GuiRoot$Type} from "packages/se/mickelus/mutil/gui/$GuiRoot"

export class $HowlingProgressGui extends $GuiRoot {

constructor(arg0: $Minecraft$Type)

public "draw"(arg0: $GuiGraphics$Type): void
public "updateAmplifier"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HowlingProgressGui$Type = ($HowlingProgressGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HowlingProgressGui_ = $HowlingProgressGui$Type;
}}
declare module "packages/se/mickelus/tetra/data/provider/$MultiblockSchematicLootProvider" {
import {$BlockLootSubProvider, $BlockLootSubProvider$Type} from "packages/net/minecraft/data/loot/$BlockLootSubProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LootTableProvider$SubProviderEntry, $LootTableProvider$SubProviderEntry$Type} from "packages/net/minecraft/data/loot/$LootTableProvider$SubProviderEntry"

export class $MultiblockSchematicLootProvider extends $BlockLootSubProvider {


public static "getLootTables"(): $List<($LootTableProvider$SubProviderEntry)>
get "lootTables"(): $List<($LootTableProvider$SubProviderEntry)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockSchematicLootProvider$Type = ($MultiblockSchematicLootProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockSchematicLootProvider_ = $MultiblockSchematicLootProvider$Type;
}}
