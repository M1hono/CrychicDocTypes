declare module "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"

export interface $FloatConsumer extends $Consumer<(float)>, $DoubleConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: float): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
 "accept"(arg0: float): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(float)>
 "andThen"(arg0: $FloatConsumer$Type): $FloatConsumer

(arg0: float): void
}

export namespace $FloatConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatConsumer$Type = ($FloatConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatConsumer_ = $FloatConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ObjectCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectCollection$Type<K> = ($ObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectCollection_<K> = $ObjectCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"

export interface $Float2FloatFunction extends $Function<(float), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
 "get"(arg0: float): float
 "put"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(float), (T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): float
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: float): float
}

export namespace $Float2FloatFunction {
function identity(): $Float2FloatFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2FloatFunction$Type = ($Float2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2FloatFunction_ = $Float2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Double2ObjectFunction<V> extends $Function$0<(double), (V)>, $DoubleFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Double2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Double2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Double2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: any): V
}

export namespace $Double2ObjectFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ObjectFunction$Type<V> = ($Double2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ObjectFunction_<V> = $Double2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Float2ObjectFunction<V> extends $Function$0<(float), (V)>, $DoubleFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Float2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Float2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Float2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(float), (V)>

(arg0: any): V
}

export namespace $Float2ObjectFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ObjectFunction$Type<V> = ($Float2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ObjectFunction_<V> = $Float2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectLinkedOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Long2ObjectSortedMap, $Long2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$AbstractLong2ObjectSortedMap, $AbstractLong2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectSortedMap"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Long2ObjectLinkedOpenHashMap<V> extends $AbstractLong2ObjectSortedMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Long2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: long): V
public "remove"(arg0: long, arg1: any): boolean
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "hashCode"(): integer
public "clone"(): $Long2ObjectLinkedOpenHashMap<(V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "comparator"(): $LongComparator
public "removeFirst"(): V
public "removeLast"(): V
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "firstLongKey"(): long
public "lastLongKey"(): long
public "getAndMoveToFirst"(arg0: long): V
public "putAndMoveToLast"(arg0: long, arg1: V): V
public "getAndMoveToLast"(arg0: long): V
public "putAndMoveToFirst"(arg0: long, arg1: V): V
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectLinkedOpenHashMap$Type<V> = ($Long2ObjectLinkedOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectLinkedOpenHashMap_<V> = $Long2ObjectLinkedOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2IntMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Long2IntMap$Entry, $Long2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap$Entry"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Long2IntMap, $Long2IntMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap"
import {$AbstractLong2IntFunction, $AbstractLong2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2IntFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractLong2IntMap extends $AbstractLong2IntFunction implements $Long2IntMap, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: long): boolean
public "containsValue"(arg0: integer): boolean
public "mergeInt"(arg0: long, arg1: integer, arg2: $IntBinaryOperator$Type): integer
public "remove"(arg0: long, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: integer): integer
public "clear"(): void
public "replace"(arg0: long, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
public "replace"(arg0: long, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
public "replace"(arg0: long, arg1: integer): integer
public "replace"(arg0: long, arg1: integer): integer
public "size"(): integer
public "merge"(arg0: long, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "merge"(arg0: long, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(long), (integer)>)>
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: long, arg1: integer): integer
public "putIfAbsent"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: long, arg1: $LongToIntFunction$Type): integer
/**
 * 
 * @deprecated
 */
public "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): integer
public "computeIfAbsent"(arg0: long, arg1: $Long2IntFunction$Type): integer
/**
 * 
 * @deprecated
 */
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "mergeInt"(arg0: long, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
public "long2IntEntrySet"(): $ObjectSet<($Long2IntMap$Entry)>
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: long, arg1: $Long2IntFunction$Type): integer
public "computeIfAbsentNullable"(arg0: long, arg1: $LongFunction$Type<(any)>): integer
public "defaultReturnValue"(): integer
public "defaultReturnValue"(arg0: integer): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (integer)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer): $Map<(long), (integer)>
public static "of"<K, V>(): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer, arg16: long, arg17: integer, arg18: long, arg19: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer, arg16: long, arg17: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer): $Map<(long), (integer)>
public static "of"<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer): $Map<(long), (integer)>
public static "entry"<K, V>(arg0: long, arg1: integer): $Map$Entry<(long), (integer)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (integer)>
public static "identity"<T>(): $Function<(long), (long)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2IntMap$Type = ($AbstractLong2IntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2IntMap_ = $AbstractLong2IntMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"

export interface $DoubleConsumer extends $Consumer<(double)>, $DoubleConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(double)>
 "andThen"(arg0: $DoubleConsumer$Type): $DoubleConsumer
 "accept"(arg0: double): void

(arg0: double): void
}

export namespace $DoubleConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleConsumer$Type = ($DoubleConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleConsumer_ = $DoubleConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Short2ByteFunction extends $Function$0<(short), (byte)>, $IntUnaryOperator {

 "remove"(arg0: short): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: short): byte
 "put"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): byte
}

export namespace $Short2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ByteFunction$Type = ($Short2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ByteFunction_ = $Short2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"

export interface $ByteSpliterator extends $Spliterator$OfPrimitive<(byte), ($ByteConsumer), ($ByteSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $ByteConsumer$Type): void
 "tryAdvance"(arg0: $ByteConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $ByteSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteSpliterator$Type = ($ByteSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteSpliterator_ = $ByteSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntImmutableList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntListIterator, $IntListIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$IntLists$ImmutableListBase, $IntLists$ImmutableListBase$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntLists$ImmutableListBase"

export class $IntImmutableList extends $IntLists$ImmutableListBase implements $IntList, $RandomAccess, $Cloneable, $Serializable {

constructor(arg0: $IntIterator$Type)
constructor(arg0: (integer)[], arg1: integer, arg2: integer)
constructor(arg0: $IntList$Type)
constructor(arg0: (integer)[])
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $IntCollection$Type)

public "equals"(arg0: $IntImmutableList$Type): boolean
public "equals"(arg0: any): boolean
public "clone"(): $IntImmutableList
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $IntImmutableList$Type): integer
public "indexOf"(arg0: integer): integer
public "getInt"(arg0: integer): integer
public "lastIndexOf"(arg0: integer): integer
public "isEmpty"(): boolean
public "size"(): integer
public "subList"(arg0: integer, arg1: integer): $IntList
public "toArray"(arg0: (integer)[]): (integer)[]
public static "toList"(arg0: $IntStream$Type): $IntImmutableList
public static "of"(...arg0: (integer)[]): $IntImmutableList
public static "of"(): $IntImmutableList
public "forEach"(arg0: $IntConsumer$0$Type): void
public "toIntArray"(): (integer)[]
public "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public static "toListWithExpectedSize"(arg0: $IntStream$Type, arg1: integer): $IntImmutableList
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: integer): void
public "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "replaceAll"(arg0: $IntUnaryOperator$Type): void
public "replaceAll"(arg0: $IntUnaryOperator$0$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
public "size"(arg0: integer): void
public "iterator"(): $IntListIterator
public static "of"(arg0: integer, arg1: integer): $IntList
public static "of"(arg0: integer): $IntList
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
public "addAll"(arg0: $IntList$Type): boolean
public "addAll"(arg0: integer, arg1: $IntList$Type): boolean
public "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: integer): integer
public "sort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "removeInt"(arg0: integer): integer
public "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "unstableSort"(arg0: $IntComparator$Type): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (integer)[]): void
public "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $List<(integer)>
public static "of"<E>(arg0: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
public static "of"<E>(...arg0: (integer)[]): $List<(integer)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "contains"(arg0: integer): boolean
public "removeIf"(arg0: $IntPredicate$Type): boolean
public "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "toIntArray"(arg0: (integer)[]): (integer)[]
public "forEach"(arg0: $IntConsumer$Type): void
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntImmutableList$Type = ($IntImmutableList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntImmutableList_ = $IntImmutableList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $ObjectList<K> extends $List<(K)>, $Comparable<($List<(any)>)>, $ObjectCollection<(K)> {

 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $ObjectList<(K)>
 "addAll"(arg0: $ObjectList$Type<(any)>): boolean
 "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
 "sort"(arg0: $Comparator$Type<(any)>): void
 "listIterator"(arg0: integer): $ObjectListIterator<(K)>
 "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (K)[]): void
 "setElements"(arg0: (K)[]): void
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (K)[]): void
 "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "add"(arg0: integer, arg1: K): void
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): K
 "get"(arg0: integer): K
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: K): K
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectList {
function of<K>(...arg0: (K)[]): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K): $ObjectList<(K)>
function of<K>(): $ObjectList<(K)>
function of<K>(arg0: K): $ObjectList<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectList$Type<K> = ($ObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectList_<K> = $ObjectList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectFunction, $AbstractObject2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2ObjectMap<K, V> extends $AbstractObject2ObjectFunction<(K), (V)> implements $Object2ObjectMap<(K), (V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "put"(arg0: K, arg1: V): V
public "clear"(): void
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectMap$Type<K, V> = ($AbstractObject2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectMap_<K, V> = $AbstractObject2ObjectMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$LongPredicate, $LongPredicate$Type} from "packages/java/util/function/$LongPredicate"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Long2BooleanFunction extends $Function$0<(long), (boolean)>, $LongPredicate {

 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: boolean): boolean
 "put"(arg0: long, arg1: boolean): boolean
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): boolean
 "or"(arg0: $LongPredicate$Type): $LongPredicate
 "negate"(): $LongPredicate
 "and"(arg0: $LongPredicate$Type): $LongPredicate

(arg0: long): boolean
}

export namespace $Long2BooleanFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2BooleanFunction$Type = ($Long2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2BooleanFunction_ = $Long2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $BooleanStack extends $Stack<(boolean)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): boolean
 "push"(arg0: boolean): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: boolean): void
 "popBoolean"(): boolean
 "topBoolean"(): boolean
 "peekBoolean"(arg0: integer): boolean
 "isEmpty"(): boolean
}

export namespace $BooleanStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanStack$Type = ($BooleanStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanStack_ = $BooleanStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterable" {
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongIterable, $LongIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterable"

export interface $LongBidirectionalIterable extends $LongIterable {

 "iterator"(): $LongBidirectionalIterator
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator

(): $LongBidirectionalIterator
}

export namespace $LongBidirectionalIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterable$Type = ($LongBidirectionalIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterable_ = $LongBidirectionalIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$PrimitiveIterator$OfLong, $PrimitiveIterator$OfLong$Type} from "packages/java/util/$PrimitiveIterator$OfLong"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"

export interface $LongIterator extends $PrimitiveIterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "skip"(arg0: integer): integer
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterator$Type = ($LongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterator_ = $LongIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $IntStack extends $Stack<(integer)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): integer
 "push"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: integer): void
 "popInt"(): integer
 "peekInt"(arg0: integer): integer
 "topInt"(): integer
 "isEmpty"(): boolean
}

export namespace $IntStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntStack$Type = ($IntStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntStack_ = $IntStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2LongMap$Entry<K> extends $Map$Entry<(K), (long)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): long
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: long): long
 "setValue"(arg0: long): long
 "getLongValue"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2LongMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (long)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongMap$Entry$Type<K> = ($Object2LongMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongMap$Entry_<K> = $Object2LongMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Float2ShortFunction extends $Function$0<(float), (short)>, $DoubleToIntFunction {

 "remove"(arg0: float): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: float): short
 "put"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): short

(arg0: float): short
}

export namespace $Float2ShortFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ShortFunction$Type = ($Float2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ShortFunction_ = $Float2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$Spliterator$OfLong, $Spliterator$OfLong$Type} from "packages/java/util/$Spliterator$OfLong"

export interface $LongSpliterator extends $Spliterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $LongConsumer$0$Type): boolean
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "tryAdvance"(arg0: $LongConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $LongSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSpliterator$Type = ($LongSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSpliterator_ = $LongSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"

export interface $ShortSpliterator extends $Spliterator$OfPrimitive<(short), ($ShortConsumer), ($ShortSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
 "tryAdvance"(arg0: $ShortConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $ShortSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSpliterator$Type = ($ShortSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSpliterator_ = $ShortSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$AbstractFloatCollection" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatPredicate, $FloatPredicate$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export class $AbstractFloatCollection extends $AbstractCollection<(float)> implements $FloatCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: float): boolean
public "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (float)[]): (float)[]
public "contains"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $FloatCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $FloatCollection$Type): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $FloatCollection$Type): boolean
public "containsAll"(arg0: $FloatCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "rem"(arg0: float): boolean
public "toFloatArray"(): (float)[]
/**
 * 
 * @deprecated
 */
public "toFloatArray"(arg0: (float)[]): (float)[]
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(float)>
public "removeIf"(arg0: $FloatPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $DoublePredicate$Type): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(float)>
public "doubleStream"(): $DoubleStream
public "doubleIterator"(): $DoubleIterator
public "doubleSpliterator"(): $DoubleSpliterator
public "doubleParallelStream"(): $DoubleStream
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "forEach"(arg0: $DoubleConsumer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFloatCollection$Type = ($AbstractFloatCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractFloatCollection_ = $AbstractFloatCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"

export interface $BooleanSpliterator extends $Spliterator$OfPrimitive<(boolean), ($BooleanConsumer), ($BooleanSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $BooleanConsumer$Type): void
 "tryAdvance"(arg0: $BooleanConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $BooleanSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanSpliterator$Type = ($BooleanSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanSpliterator_ = $BooleanSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceSet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"

export interface $ReferenceSet<K> extends $ReferenceCollection<(K)>, $Set<(K)> {

 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ReferenceSet {
function of<K>(arg0: K, arg1: K): $ReferenceSet<(K)>
function of<K>(...arg0: (K)[]): $ReferenceSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ReferenceSet<(K)>
function of<K>(): $ReferenceSet<(K)>
function of<K>(arg0: K): $ReferenceSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceSet$Type<K> = ($ReferenceSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceSet_<K> = $ReferenceSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$LongUnaryOperator, $LongUnaryOperator$Type} from "packages/java/util/function/$LongUnaryOperator"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$Type as $LongUnaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongUnaryOperator"
import {$LongListIterator, $LongListIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongListIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongList extends $List<(long)>, $Comparable<($List<(any)>)>, $LongCollection {

 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: long): void
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): long
 "indexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: long): integer
 "replaceAll"(arg0: $LongUnaryOperator$0$Type): void
 "replaceAll"(arg0: $LongUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(long)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $LongList
 "iterator"(): $LongListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $LongCollection$Type): boolean
 "addAll"(arg0: $LongList$Type): boolean
 "addAll"(arg0: integer, arg1: $LongList$Type): boolean
 "set"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: long): long
 "sort"(arg0: $LongComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "getElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (long)[]): void
 "setElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (long)[]): void
 "removeLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $LongComparator$Type): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (long)[]): void
 "addElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longParallelStream"(): $LongStream
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongList {
function of(...arg0: (long)[]): $LongList
function of(): $LongList
function of(arg0: long, arg1: long): $LongList
function of(arg0: long): $LongList
function of(arg0: long, arg1: long, arg2: long): $LongList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
function of<E>(arg0: long, arg1: long): $List<(long)>
function of<E>(arg0: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
function of<E>(...arg0: (long)[]): $List<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongList$Type = ($LongList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongList_ = $LongList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Float2ByteFunction extends $Function$0<(float), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: float): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: float): byte
 "put"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): byte

(arg0: float): byte
}

export namespace $Float2ByteFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ByteFunction$Type = ($Float2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ByteFunction_ = $Float2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleList" {
import {$DoubleListIterator, $DoubleListIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleListIterator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DoubleComparator, $DoubleComparator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleComparator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$DoubleCollection, $DoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$Type as $DoubleUnaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleUnaryOperator"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoubleList extends $List<(double)>, $Comparable<($List<(any)>)>, $DoubleCollection {

 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: double): void
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): double
 "indexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: double): integer
 "replaceAll"(arg0: $DoubleUnaryOperator$0$Type): void
 "replaceAll"(arg0: $DoubleUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(double)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $DoubleList
 "iterator"(): $DoubleListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $DoubleCollection$Type): boolean
 "addAll"(arg0: $DoubleList$Type): boolean
 "addAll"(arg0: integer, arg1: $DoubleList$Type): boolean
 "set"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: double): double
 "sort"(arg0: $DoubleComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "getElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (double)[]): void
 "setElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (double)[]): void
 "removeDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $DoubleComparator$Type): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (double)[]): void
 "addElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (double)[]): (double)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
 "addAll"(arg0: $DoubleCollection$Type): boolean
 "removeIf"(arg0: $DoublePredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $DoubleCollection$Type): boolean
 "retainAll"(arg0: $DoubleCollection$Type): boolean
 "containsAll"(arg0: $DoubleCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
 "toDoubleArray"(): (double)[]
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $DoubleList {
function of(...arg0: (double)[]): $DoubleList
function of(): $DoubleList
function of(arg0: double, arg1: double): $DoubleList
function of(arg0: double): $DoubleList
function of(arg0: double, arg1: double, arg2: double): $DoubleList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
function of<E>(arg0: double, arg1: double): $List<(double)>
function of<E>(arg0: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
function of<E>(...arg0: (double)[]): $List<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleList$Type = ($DoubleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleList_ = $DoubleList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectArrayMap" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectArrayMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Serializable, $Cloneable {

constructor(arg0: (any)[], arg1: (any)[], arg2: integer)
constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (any)[], arg1: (any)[])
constructor()
constructor(arg0: integer)

public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "clone"(): $Object2ObjectArrayMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectArrayMap$Type<K, V> = ($Object2ObjectArrayMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectArrayMap_<K, V> = $Object2ObjectArrayMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongPredicate" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $LongPredicate extends $Predicate<(long)>, $LongPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
 "or"(arg0: $LongPredicate$0$Type): $LongPredicate
 "or"(arg0: $LongPredicate$Type): $LongPredicate
 "and"(arg0: $LongPredicate$Type): $LongPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
 "test"(arg0: long): boolean

(arg0: long): boolean
}

export namespace $LongPredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
function isEqual<T>(arg0: any): $Predicate<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongPredicate$Type = ($LongPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongPredicate_ = $LongPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$FastEntrySet" {
import {$Reference2ReferenceMap$Entry, $Reference2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Reference2ReferenceMap$FastEntrySet<K, V> extends $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)> {

 "fastIterator"(): $ObjectIterator<($Reference2ReferenceMap$Entry<(K), (V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Reference2ReferenceMap$Entry<(K), (V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Reference2ReferenceMap$Entry<(K), (V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Reference2ReferenceMap$FastEntrySet {
function of<K>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<K>(...arg0: ($Reference2ReferenceMap$Entry$Type<(K), (V)>)[]): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<K>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<K>(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<K>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg5: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg5: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg6: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg7: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg8: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg9: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg5: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg6: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg7: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg8: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg5: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg6: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg7: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
function of<E>(arg0: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg1: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg2: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg3: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg4: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg5: $Reference2ReferenceMap$Entry$Type<(K), (V)>, arg6: $Reference2ReferenceMap$Entry$Type<(K), (V)>): $Set<($Reference2ReferenceMap$Entry<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$FastEntrySet$Type<K, V> = ($Reference2ReferenceMap$FastEntrySet<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap$FastEntrySet_<K, V> = $Reference2ReferenceMap$FastEntrySet$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $ByteStack extends $Stack<(byte)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): byte
 "push"(arg0: byte): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: byte): void
 "peekByte"(arg0: integer): byte
 "popByte"(): byte
 "topByte"(): byte
 "isEmpty"(): boolean
}

export namespace $ByteStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteStack$Type = ($ByteStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteStack_ = $ByteStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2CharFunction<K> extends $Function$0<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
 "put"(arg0: K, arg1: character): character
 "getChar"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeChar"(arg0: any): character
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2CharFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Char2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (character)>

(arg0: any): character
}

export namespace $Object2CharFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2CharFunction$Type<K> = ($Object2CharFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2CharFunction_<K> = $Object2CharFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction" {
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ByteFunction extends $Function<(byte), (byte)>, $IntUnaryOperator {

 "remove"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
 "get"(arg0: byte): byte
 "put"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(byte), (T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): byte
}

export namespace $Byte2ByteFunction {
function identity(): $Byte2ByteFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ByteFunction$Type = ($Byte2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ByteFunction_ = $Byte2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/$BidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $BidirectionalIterator<K> extends $Iterator<(K)> {

 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $BidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BidirectionalIterator$Type<K> = ($BidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BidirectionalIterator_<K> = $BidirectionalIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$BidirectionalIterator, $BidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/$BidirectionalIterator"

export interface $ObjectBidirectionalIterator<K> extends $ObjectIterator<(K)>, $BidirectionalIterator<(K)> {

 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterator$Type<K> = ($ObjectBidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterator_<K> = $ObjectBidirectionalIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2IntMap$Entry<K> extends $Map$Entry<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntValue"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2IntMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (integer)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntMap$Entry$Type<K> = ($Object2IntMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntMap$Entry_<K> = $Object2IntMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Int2BooleanFunction extends $Function$0<(integer), (boolean)>, $IntPredicate {

 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: boolean): boolean
 "put"(arg0: integer, arg1: boolean): boolean
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate

(arg0: integer): boolean
}

export namespace $Int2BooleanFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2BooleanFunction$Type = ($Int2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2BooleanFunction_ = $Int2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanArrayList" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractBooleanList, $AbstractBooleanList$Type} from "packages/it/unimi/dsi/fastutil/booleans/$AbstractBooleanList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BooleanCollection, $BooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$BooleanComparator, $BooleanComparator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanComparator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$BooleanList, $BooleanList$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanList"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$BooleanIterator, $BooleanIterator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanIterator"

export class $BooleanArrayList extends $AbstractBooleanList implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $BooleanCollection$Type)
constructor(arg0: $BooleanList$Type)
constructor(arg0: (boolean)[])
constructor(arg0: (boolean)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $BooleanIterator$Type)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: boolean): void
public "add"(arg0: boolean): boolean
public "equals"(arg0: $BooleanArrayList$Type): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $BooleanArrayList$Type): integer
public "indexOf"(arg0: boolean): integer
public "getBoolean"(arg0: integer): boolean
public "clear"(): void
public static "wrap"(arg0: (boolean)[], arg1: integer): $BooleanArrayList
public static "wrap"(arg0: (boolean)[]): $BooleanArrayList
public "lastIndexOf"(arg0: boolean): integer
public "isEmpty"(): boolean
public "size"(): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $BooleanList
public "toArray"(arg0: (boolean)[]): (boolean)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "of"(...arg0: (boolean)[]): $BooleanArrayList
public static "of"(): $BooleanArrayList
public "elements"(): (boolean)[]
public "addAll"(arg0: integer, arg1: $BooleanList$Type): boolean
public "addAll"(arg0: integer, arg1: $BooleanCollection$Type): boolean
public "set"(arg0: integer, arg1: boolean): boolean
public "forEach"(arg0: $BooleanConsumer$Type): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $BooleanComparator$Type): void
public "removeAll"(arg0: $BooleanCollection$Type): boolean
public "rem"(arg0: boolean): boolean
public "getElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
public "removeBoolean"(arg0: integer): boolean
public "unstableSort"(arg0: $BooleanComparator$Type): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: boolean, arg1: boolean): $BooleanList
public static "of"(arg0: boolean): $BooleanList
public static "of"(arg0: boolean, arg1: boolean, arg2: boolean): $BooleanList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanArrayList$Type = ($BooleanArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanArrayList_ = $BooleanArrayList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$Type as $DoubleBinaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleBinaryOperator"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleMap$Entry, $Int2DoubleMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap$Entry"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2DoubleMap extends $Int2DoubleFunction, $Map<(integer), (double)> {

 "remove"(arg0: integer, arg1: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "clear"(): void
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double): double
 "replace"(arg0: integer, arg1: double): double
 "size"(): integer
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (double)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: double): double
 "putIfAbsent"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntToDoubleFunction$Type): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): double
 "computeIfAbsent"(arg0: integer, arg1: $Int2DoubleFunction$Type): double
 "containsValue"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2DoubleFunction$Type): double
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$Type<(any)>): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$0$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$Type): double
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "int2DoubleEntrySet"(): $ObjectSet<($Int2DoubleMap$Entry)>
 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: integer): double
}

export namespace $Int2DoubleMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double): $Map<(integer), (double)>
function of<K, V>(): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double, arg18: integer, arg19: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double): $Map<(integer), (double)>
function entry<K, V>(arg0: integer, arg1: double): $Map$Entry<(integer), (double)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (double)>
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleMap$Type = ($Int2DoubleMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleMap_ = $Int2DoubleMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntLists$ImmutableListBase" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntListIterator, $IntListIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$AbstractIntList, $AbstractIntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntList"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$List, $List$Type} from "packages/java/util/$List"

export class $IntLists$ImmutableListBase extends $AbstractIntList implements $IntList {


/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "clear"(): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $IntUnaryOperator$0$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
/**
 * 
 * @deprecated
 */
public "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: $IntList$Type): boolean
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: $Collection$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "addAll"(arg0: integer, arg1: $IntList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $IntPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "removeAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "retainAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "removeInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
public "removeElements"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "indexOf"(arg0: integer): integer
public "lastIndexOf"(arg0: integer): integer
public "replaceAll"(arg0: $IntUnaryOperator$Type): void
public "subList"(arg0: integer, arg1: integer): $IntList
public "iterator"(): $IntListIterator
public static "of"(...arg0: (integer)[]): $IntList
public static "of"(): $IntList
public static "of"(arg0: integer, arg1: integer): $IntList
public static "of"(arg0: integer): $IntList
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (integer)[]): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $List<(integer)>
public static "of"<E>(arg0: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
public static "of"<E>(...arg0: (integer)[]): $List<(integer)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "removeIf"(arg0: $IntPredicate$Type): boolean
public "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
public "toIntArray"(arg0: (integer)[]): (integer)[]
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntLists$ImmutableListBase$Type = ($IntLists$ImmutableListBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntLists$ImmutableListBase_ = $IntLists$ImmutableListBase$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Char2ObjectMap$FastEntrySet, $Char2ObjectMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$FastEntrySet"
import {$CharSet, $CharSet$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractChar2ObjectMap, $AbstractChar2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/chars/$AbstractChar2ObjectMap"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Char2ObjectMap, $Char2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Char2ObjectOpenHashMap<V> extends $AbstractChar2ObjectMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Char2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Char2ObjectMap$Type<(V)>)
constructor(arg0: (character)[], arg1: (V)[], arg2: float)
constructor(arg0: (character)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: character, arg1: any): boolean
public "remove"(arg0: character): V
public "get"(arg0: character): V
public "put"(arg0: character, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: character, arg1: V, arg2: V): boolean
public "replace"(arg0: character, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: character, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: character, arg1: V): V
public "compute"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: character): boolean
public "computeIfAbsent"(arg0: character, arg1: $IntFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: character, arg1: $Char2ObjectFunction$Type<(any)>): V
public "keySet"(): $CharSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: character, arg1: V): V
public "computeIfPresent"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "char2ObjectEntrySet"(): $Char2ObjectMap$FastEntrySet<(V)>
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectOpenHashMap$Type<V> = ($Char2ObjectOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectOpenHashMap_<V> = $Char2ObjectOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2ReferenceMap$Entry<V> extends $Map$Entry<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): long
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Long2ReferenceMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ReferenceMap$Entry$Type<V> = ($Long2ReferenceMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ReferenceMap$Entry_<V> = $Long2ReferenceMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatIterator" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $FloatIterator extends $PrimitiveIterator<(float), ($FloatConsumer)> {

 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "forEachRemaining"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextFloat"(): float
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $FloatIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatIterator$Type = ($FloatIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatIterator_ = $FloatIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongLinkedOpenHashSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$AbstractLongSortedSet, $AbstractLongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLongSortedSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongSortedSet, $LongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet"
import {$LongListIterator, $LongListIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongListIterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export class $LongLinkedOpenHashSet extends $AbstractLongSortedSet implements $Serializable, $Cloneable, $Hash {

constructor(arg0: (long)[], arg1: integer, arg2: integer)
constructor(arg0: (long)[], arg1: integer, arg2: integer, arg3: float)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>, arg1: float)
constructor(arg0: (long)[], arg1: float)
constructor(arg0: (long)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $Collection$Type<(any)>, arg1: float)
constructor()
constructor(arg0: integer)
constructor(arg0: $LongIterator$Type)
constructor(arg0: $LongIterator$Type, arg1: float)
constructor(arg0: $LongCollection$Type)
constructor(arg0: $LongCollection$Type, arg1: float)

public "removeLastLong"(): long
public "removeFirstLong"(): long
public "add"(arg0: long): boolean
public "remove"(arg0: long): boolean
public "hashCode"(): integer
public "clone"(): $LongLinkedOpenHashSet
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(arg0: long): $LongListIterator
public "iterator"(): $LongListIterator
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public static "of"(arg0: long, arg1: long): $LongLinkedOpenHashSet
public static "of"(arg0: long, arg1: long, arg2: long): $LongLinkedOpenHashSet
public static "of"(...arg0: (long)[]): $LongLinkedOpenHashSet
public static "of"(arg0: long): $LongLinkedOpenHashSet
public static "of"(): $LongLinkedOpenHashSet
public "contains"(arg0: long): boolean
public "addAll"(arg0: $LongCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $LongConsumer$Type): void
public static "toSet"(arg0: $LongStream$Type): $LongLinkedOpenHashSet
public "subSet"(arg0: long, arg1: long): $LongSortedSet
public "headSet"(arg0: long): $LongSortedSet
public "tailSet"(arg0: long): $LongSortedSet
public static "toSetWithExpectedSize"(arg0: $LongStream$Type, arg1: integer): $LongLinkedOpenHashSet
public "lastLong"(): long
public "firstLong"(): long
public "addAndMoveToFirst"(arg0: long): boolean
public "addAndMoveToLast"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongLinkedOpenHashSet$Type = ($LongLinkedOpenHashSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongLinkedOpenHashSet_ = $LongLinkedOpenHashSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2IntFunction extends $Function$0<(short), (integer)>, $IntUnaryOperator {

 "remove"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: short): integer
 "put"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): integer
}

export namespace $Short2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2IntFunction$Type = ($Short2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2IntFunction_ = $Short2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection" {
import {$DoublePredicate, $DoublePredicate$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleIterable, $DoubleIterable$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterable"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoubleCollection extends $Collection<(double)>, $DoubleIterable {

 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (double)[]): (double)[]
 "iterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $DoubleCollection$Type): boolean
 "removeIf"(arg0: $DoublePredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $DoubleCollection$Type): boolean
 "retainAll"(arg0: $DoubleCollection$Type): boolean
 "containsAll"(arg0: $DoubleCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
 "toDoubleArray"(): (double)[]
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $DoubleCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleCollection$Type = ($DoubleCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleCollection_ = $DoubleCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2ObjectFunction<V> extends $Function$0<(short), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Short2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Short2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Short2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: any): V
}

export namespace $Short2ObjectFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ObjectFunction$Type<V> = ($Short2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ObjectFunction_<V> = $Short2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $ObjectIterable<K> extends $Iterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterable$Type<K> = ($ObjectIterable<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterable_<K> = $ObjectIterable$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$AbstractDoubleCollection" {
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleCollection, $DoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export class $AbstractDoubleCollection extends $AbstractCollection<(double)> implements $DoubleCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: double): boolean
public "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (double)[]): (double)[]
public "contains"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $DoubleCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $DoubleConsumer$Type): void
public "removeIf"(arg0: $DoublePredicate$Type): boolean
public "removeAll"(arg0: $DoubleCollection$Type): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $DoubleCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $DoubleCollection$Type): boolean
public "rem"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
public "toDoubleArray"(arg0: (double)[]): (double)[]
public "toDoubleArray"(): (double)[]
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(double)>
public "removeIf"(arg0: $DoublePredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(double)>
public "doubleStream"(): $DoubleStream
public "doubleIterator"(): $DoubleIterator
public "doubleSpliterator"(): $DoubleSpliterator
public "doubleParallelStream"(): $DoubleStream
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDoubleCollection$Type = ($AbstractDoubleCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractDoubleCollection_ = $AbstractDoubleCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $ShortIterator extends $PrimitiveIterator<(short), ($ShortConsumer)> {

 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextShort"(): short
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterator$Type = ($ShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterator_ = $ShortIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$CharPredicate, $CharPredicate$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharPredicate"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$CharListIterator, $CharListIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharListIterator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharSpliterator, $CharSpliterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$CharComparator, $CharComparator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharComparator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$CharCollection, $CharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharCollection"
import {$CharUnaryOperator, $CharUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharUnaryOperator"

export interface $CharList extends $List<(character)>, $Comparable<($List<(any)>)>, $CharCollection {

 "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: character): void
 "add"(arg0: integer, arg1: character): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): character
 "indexOf"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getChar"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: character): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $CharUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(character)>): void
 "size"(arg0: integer): void
 "iterator"(): $CharListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $CharSpliterator
 "addAll"(arg0: $CharList$Type): boolean
 "addAll"(arg0: integer, arg1: $CharCollection$Type): boolean
 "addAll"(arg0: integer, arg1: $CharList$Type): boolean
 "set"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "sort"(arg0: $CharComparator$Type): void
 "getElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
 "removeChar"(arg0: integer): character
 "setElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (character)[]): void
 "setElements"(arg0: (character)[]): void
 "unstableSort"(arg0: $CharComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (character)[]): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (character)[]): (character)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(character)>
 "toCharArray"(): (character)[]
/**
 * 
 * @deprecated
 */
 "toCharArray"(arg0: (character)[]): (character)[]
 "intStream"(): $IntStream
 "contains"(arg0: character): boolean
 "addAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $CharPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $CharCollection$Type): boolean
 "retainAll"(arg0: $CharCollection$Type): boolean
 "containsAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(character)>
 "rem"(arg0: character): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $CharList {
function of(): $CharList
function of(arg0: character): $CharList
function of(arg0: character, arg1: character): $CharList
function of(arg0: character, arg1: character, arg2: character): $CharList
function of(...arg0: (character)[]): $CharList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character): $List<(character)>
function of<E>(arg0: character, arg1: character): $List<(character)>
function of<E>(arg0: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character, arg9: character): $List<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character): $List<(character)>
function of<E>(...arg0: (character)[]): $List<(character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharList$Type = ($CharList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharList_ = $CharList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $DoubleStack extends $Stack<(double)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): double
 "push"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: double): void
 "popDouble"(): double
 "peekDouble"(arg0: integer): double
 "topDouble"(): double
 "isEmpty"(): boolean
}

export namespace $DoubleStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleStack$Type = ($DoubleStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleStack_ = $DoubleStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Float2ReferenceFunction<V> extends $Function$0<(float), (V)>, $DoubleFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Float2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Float2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Float2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(float), (V)>

(arg0: any): V
}

export namespace $Float2ReferenceFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ReferenceFunction$Type<V> = ($Float2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ReferenceFunction_<V> = $Float2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToLongFunction, $DoubleToLongFunction$Type} from "packages/java/util/function/$DoubleToLongFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Double2LongFunction extends $Function$0<(double), (long)>, $DoubleToLongFunction {

 "remove"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: double): long
 "put"(arg0: double, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: double, arg1: long): long
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): long

(arg0: double): long
}

export namespace $Double2LongFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2LongFunction$Type = ($Double2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2LongFunction_ = $Double2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatCollection" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$FloatIterator, $FloatIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterator"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$FloatIterable, $FloatIterable$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterable"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatPredicate, $FloatPredicate$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $FloatCollection extends $Collection<(float)>, $FloatIterable {

 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (float)[]): (float)[]
 "iterator"(): $FloatIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(float)>
 "contains"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $FloatCollection$Type): boolean
 "removeIf"(arg0: $FloatPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $FloatCollection$Type): boolean
 "retainAll"(arg0: $FloatCollection$Type): boolean
 "containsAll"(arg0: $FloatCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(float)>
 "rem"(arg0: float): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toFloatArray"(arg0: (float)[]): (float)[]
 "toFloatArray"(): (float)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $FloatCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatCollection$Type = ($FloatCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatCollection_ = $FloatCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Char2ByteFunction extends $Function$0<(character), (byte)>, $IntUnaryOperator {

 "remove"(arg0: character): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: character): byte
 "put"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): byte
}

export namespace $Char2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ByteFunction$Type = ($Char2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ByteFunction_ = $Char2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ReferenceFunction<V> extends $Function$0<(byte), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Byte2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Byte2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Byte2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (V)>

(arg0: any): V
}

export namespace $Byte2ReferenceFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ReferenceFunction$Type<V> = ($Byte2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ReferenceFunction_<V> = $Byte2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatBidirectionalIterator" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatIterator, $FloatIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $FloatBidirectionalIterator extends $FloatIterator, $ObjectBidirectionalIterator<(float)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): float
 "back"(arg0: integer): integer
 "previousFloat"(): float
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "forEachRemaining"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextFloat"(): float
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $FloatBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatBidirectionalIterator$Type = ($FloatBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatBidirectionalIterator_ = $FloatBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2LongFunction extends $Function$0<(boolean), (long)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
 "remove"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: boolean): long
 "put"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: long): long
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): long

(arg0: any): long
}

export namespace $Boolean2LongFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2LongFunction$Type = ($Boolean2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2LongFunction_ = $Boolean2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2ObjectFunction<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ObjectFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectFunction$Type<K, V> = ($Reference2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectFunction_<K, V> = $Reference2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $CharComparator extends $Comparator<(character)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: character, arg1: character): integer
 "compare"(arg0: character, arg1: character): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(character)>
 "thenComparing"(arg0: $CharComparator$Type): $CharComparator
 "reversed"(): $CharComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(character)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(character)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(character)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(character)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(character)>
}

export namespace $CharComparator {
function reverseOrder<T>(): $Comparator<(character)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(character)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(character)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(character)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(character)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(character)>
function naturalOrder<T>(): $Comparator<(character)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(character)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharComparator$Type = ($CharComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharComparator_ = $CharComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2IntFunction extends $Function$0<(character), (integer)>, $IntUnaryOperator {

 "remove"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: character): integer
 "put"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): integer
}

export namespace $Char2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2IntFunction$Type = ($Char2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2IntFunction_ = $Char2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractLong2ObjectFunction<V> implements $Long2ObjectFunction<(V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
public "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
public "put"(arg0: long, arg1: V): V
public "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: long): boolean
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
public "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
public "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
public "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
public "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
public "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
public "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
public "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
public "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
public "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: long): V
public static "identity"<T>(): $Function<(long), (long)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectFunction$Type<V> = ($AbstractLong2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectFunction_<V> = $AbstractLong2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2CharFunction<K> extends $Function$0<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
 "put"(arg0: K, arg1: character): character
 "getChar"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeChar"(arg0: any): character
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2CharFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Char2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (character)>

(arg0: any): character
}

export namespace $Reference2CharFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2CharFunction$Type<K> = ($Reference2CharFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2CharFunction_<K> = $Reference2CharFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ObjectMap<V> extends $Long2ObjectFunction<(V)>, $Map<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "size"(): integer
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (V)>)>
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V): V
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}

export namespace $Long2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$Type<V> = ($Long2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap_<V> = $Long2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2DoubleFunction extends $Function$0<(short), (double)>, $IntToDoubleFunction {

 "remove"(arg0: short): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: short): double
 "put"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): double

(arg0: short): double
}

export namespace $Short2DoubleFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2DoubleFunction$Type = ($Short2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2DoubleFunction_ = $Short2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharArrayList" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractCharList, $AbstractCharList$Type} from "packages/it/unimi/dsi/fastutil/chars/$AbstractCharList"
import {$CharListIterator, $CharListIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharListIterator"
import {$CharList, $CharList$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharList"
import {$CharIterator, $CharIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharIterator"
import {$CharComparator, $CharComparator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharComparator"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$CharCollection, $CharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharCollection"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $CharArrayList extends $AbstractCharList implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $CharCollection$Type)
constructor(arg0: $CharList$Type)
constructor(arg0: (character)[])
constructor(arg0: (character)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $CharIterator$Type)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: character): void
public "add"(arg0: character): boolean
public "equals"(arg0: $CharArrayList$Type): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $CharArrayList$Type): integer
public "indexOf"(arg0: character): integer
public "getChar"(arg0: integer): character
public "clear"(): void
public static "wrap"(arg0: (character)[], arg1: integer): $CharArrayList
public static "wrap"(arg0: (character)[]): $CharArrayList
public "lastIndexOf"(arg0: character): integer
public "isEmpty"(): boolean
public "size"(): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $CharList
public "toArray"(arg0: (character)[]): (character)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "of"(...arg0: (character)[]): $CharArrayList
public static "of"(): $CharArrayList
public "elements"(): (character)[]
public "addAll"(arg0: integer, arg1: $CharList$Type): boolean
public "addAll"(arg0: integer, arg1: $CharCollection$Type): boolean
public "set"(arg0: integer, arg1: character): character
public "forEach"(arg0: $CharConsumer$Type): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $CharComparator$Type): void
public "removeAll"(arg0: $CharCollection$Type): boolean
public "listIterator"(arg0: integer): $CharListIterator
public "rem"(arg0: character): boolean
public "getElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
public "removeChar"(arg0: integer): character
public "setElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
public "unstableSort"(arg0: $CharComparator$Type): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: character): $CharList
public static "of"(arg0: character, arg1: character): $CharList
public static "of"(arg0: character, arg1: character, arg2: character): $CharList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharArrayList$Type = ($CharArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharArrayList_ = $CharArrayList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2BooleanMap$Entry<K> extends $Map$Entry<(K), (boolean)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): boolean
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: boolean): boolean
 "setValue"(arg0: boolean): boolean
 "getBooleanValue"(): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2BooleanMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (boolean)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (boolean)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (boolean)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (boolean)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (boolean)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2BooleanMap$Entry$Type<K> = ($Object2BooleanMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2BooleanMap$Entry_<K> = $Object2BooleanMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Boolean2CharFunction extends $Function$0<(boolean), (character)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
 "remove"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: boolean): character
 "put"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: character): character
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): character

(arg0: any): character
}

export namespace $Boolean2CharFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2CharFunction$Type = ($Boolean2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2CharFunction_ = $Boolean2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Reference2IntMap$Entry, $Reference2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap$Entry"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Reference2IntMap<K> extends $Reference2IntFunction<(K)>, $Map<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $IntCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Reference2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
 "reference2IntEntrySet"(): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Reference2IntFunction$Type<(any)>): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeInt"(arg0: any): integer
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2IntFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Int2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}

export namespace $Reference2IntMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntMap$Type<K> = ($Reference2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntMap_<K> = $Reference2IntMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $ByteComparator extends $Comparator<(byte)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: byte, arg1: byte): integer
 "compare"(arg0: byte, arg1: byte): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(byte)>
 "thenComparing"(arg0: $ByteComparator$Type): $ByteComparator
 "reversed"(): $ByteComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(byte)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(byte)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(byte)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(byte)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(byte)>
}

export namespace $ByteComparator {
function reverseOrder<T>(): $Comparator<(byte)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(byte)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(byte)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(byte)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(byte)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(byte)>
function naturalOrder<T>(): $Comparator<(byte)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(byte)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteComparator$Type = ($ByteComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteComparator_ = $ByteComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2DoubleFunction<K> extends $Function$0<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Double2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2DoubleFunction
 "removeDouble"(arg0: any): double
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>

(arg0: any): double
}

export namespace $Object2DoubleFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleFunction$Type<K> = ($Object2DoubleFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleFunction_<K> = $Object2DoubleFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Long2ByteFunction extends $Function$0<(long), (byte)>, $LongToIntFunction {

 "remove"(arg0: long): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: long): byte
 "put"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: long, arg1: byte): byte
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): byte

(arg0: long): byte
}

export namespace $Long2ByteFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ByteFunction$Type = ($Long2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ByteFunction_ = $Long2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap$FastEntrySet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Reference2IntMap$Entry, $Reference2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap$Entry"

export interface $Reference2IntMap$FastEntrySet<K> extends $ObjectSet<($Reference2IntMap$Entry<(K)>)> {

 "fastIterator"(): $ObjectIterator<($Reference2IntMap$Entry<(K)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Reference2IntMap$Entry$Type<(K)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Reference2IntMap$Entry<(K)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Reference2IntMap$Entry<(K)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Reference2IntMap$FastEntrySet {
function of<K>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
function of<K>(...arg0: ($Reference2IntMap$Entry$Type<(K)>)[]): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
function of<K>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
function of<K>(): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
function of<K>(arg0: $Reference2IntMap$Entry$Type<(K)>): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>, arg5: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>, arg5: $Reference2IntMap$Entry$Type<(K)>, arg6: $Reference2IntMap$Entry$Type<(K)>, arg7: $Reference2IntMap$Entry$Type<(K)>, arg8: $Reference2IntMap$Entry$Type<(K)>, arg9: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>, arg5: $Reference2IntMap$Entry$Type<(K)>, arg6: $Reference2IntMap$Entry$Type<(K)>, arg7: $Reference2IntMap$Entry$Type<(K)>, arg8: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>, arg5: $Reference2IntMap$Entry$Type<(K)>, arg6: $Reference2IntMap$Entry$Type<(K)>, arg7: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
function of<E>(arg0: $Reference2IntMap$Entry$Type<(K)>, arg1: $Reference2IntMap$Entry$Type<(K)>, arg2: $Reference2IntMap$Entry$Type<(K)>, arg3: $Reference2IntMap$Entry$Type<(K)>, arg4: $Reference2IntMap$Entry$Type<(K)>, arg5: $Reference2IntMap$Entry$Type<(K)>, arg6: $Reference2IntMap$Entry$Type<(K)>): $Set<($Reference2IntMap$Entry<(K)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntMap$FastEntrySet$Type<K> = ($Reference2IntMap$FastEntrySet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntMap$FastEntrySet_<K> = $Reference2IntMap$FastEntrySet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $FloatComparator extends $Comparator<(float)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: float, arg1: float): integer
 "compare"(arg0: float, arg1: float): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(float)>
 "thenComparing"(arg0: $FloatComparator$Type): $FloatComparator
 "reversed"(): $FloatComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(float)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(float)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(float)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(float)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(float)>
}

export namespace $FloatComparator {
function reverseOrder<T>(): $Comparator<(float)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(float)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(float)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(float)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(float)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(float)>
function naturalOrder<T>(): $Comparator<(float)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(float)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatComparator$Type = ($FloatComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatComparator_ = $FloatComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ShortConsumer extends $Consumer<(short)>, $IntConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(short)>
 "andThen"(arg0: $ShortConsumer$Type): $ShortConsumer

(arg0: short): void
}

export namespace $ShortConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortConsumer$Type = ($ShortConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortConsumer_ = $ShortConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Spliterator$OfDouble, $Spliterator$OfDouble$Type} from "packages/java/util/$Spliterator$OfDouble"

export interface $DoubleSpliterator extends $Spliterator$OfDouble {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $DoubleConsumer$Type): boolean
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "tryAdvance"(arg0: $DoubleConsumer$0$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $DoubleSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSpliterator$Type = ($DoubleSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSpliterator_ = $DoubleSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntIntPair" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Pair, $Pair$Type} from "packages/it/unimi/dsi/fastutil/$Pair"

export interface $IntIntPair extends $Pair<(integer), (integer)> {

 "value"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "value"(): integer
/**
 * 
 * @deprecated
 */
 "value"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "first"(arg0: integer): $IntIntPair
 "first"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "second"(): integer
 "second"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "second"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "key"(arg0: integer): $IntIntPair
 "key"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "left"(): integer
 "left"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "left"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "right"(arg0: integer): $IntIntPair
/**
 * 
 * @deprecated
 */
 "right"(): integer
 "right"(arg0: integer): $IntIntPair
 "firstInt"(): integer
 "rightInt"(): integer
 "secondInt"(): integer
 "keyInt"(): integer
 "leftInt"(): integer
 "valueInt"(): integer
}

export namespace $IntIntPair {
function of(arg0: integer, arg1: integer): $IntIntPair
function lexComparator(): $Comparator<($IntIntPair)>
function of<L, R>(arg0: integer, arg1: integer): $Pair<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIntPair$Type = ($IntIntPair);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIntPair_ = $IntIntPair$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Double2ReferenceFunction<V> extends $Function$0<(double), (V)>, $DoubleFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Double2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Double2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Double2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: any): V
}

export namespace $Double2ReferenceFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ReferenceFunction$Type<V> = ($Double2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ReferenceFunction_<V> = $Double2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Long2ReferenceFunction<V> extends $Function$0<(long), (V)>, $LongFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Long2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Long2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: any): V
}

export namespace $Long2ReferenceFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ReferenceFunction$Type<V> = ($Long2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ReferenceFunction_<V> = $Long2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2FloatFunction extends $Function$0<(character), (float)>, $IntToDoubleFunction {

 "remove"(arg0: character): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: character): float
 "put"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): float

(arg0: character): float
}

export namespace $Char2FloatFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2FloatFunction$Type = ($Char2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2FloatFunction_ = $Char2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Int2ObjectFunction<V> extends $Function$0<(integer), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Int2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Int2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: any): V
}

export namespace $Int2ObjectFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectFunction$Type<V> = ($Int2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectFunction_<V> = $Int2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $ByteUnaryOperator extends $UnaryOperator<(byte)>, $IntUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: byte): byte
 "apply"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (byte)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (V)>

(arg0: byte): byte
}

export namespace $ByteUnaryOperator {
function identity(): $ByteUnaryOperator
function negation(): $ByteUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteUnaryOperator$Type = ($ByteUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteUnaryOperator_ = $ByteUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2DoubleFunction extends $Function$0<(byte), (double)>, $IntToDoubleFunction {

 "remove"(arg0: byte): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: byte): double
 "put"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): double

(arg0: byte): double
}

export namespace $Byte2DoubleFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2DoubleFunction$Type = ($Byte2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2DoubleFunction_ = $Byte2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $ByteIterable extends $Iterable<(byte)> {

 "forEach"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $ByteIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteIterable$Type = ($ByteIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteIterable_ = $ByteIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$AbstractByteCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$ByteCollection, $ByteCollection$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteCollection"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BytePredicate, $BytePredicate$Type} from "packages/it/unimi/dsi/fastutil/bytes/$BytePredicate"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export class $AbstractByteCollection extends $AbstractCollection<(byte)> implements $ByteCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: byte): boolean
public "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (byte)[]): (byte)[]
public "contains"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $ByteCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "toByteArray"(arg0: (byte)[]): (byte)[]
public "toByteArray"(): (byte)[]
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $ByteCollection$Type): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $ByteCollection$Type): boolean
public "containsAll"(arg0: $ByteCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "rem"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(byte)>
public "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $BytePredicate$Type): boolean
public "removeIf"(arg0: $IntPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(byte)>
public "intSpliterator"(): $IntSpliterator
public "intIterator"(): $IntIterator
public "intParallelStream"(): $IntStream
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "forEach"(arg0: $IntConsumer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractByteCollection$Type = ($AbstractByteCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractByteCollection_ = $AbstractByteCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2ShortFunction<K> extends $Function$0<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
 "put"(arg0: K, arg1: short): short
 "getShort"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeShort"(arg0: any): short
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ShortFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Short2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>

(arg0: any): short
}

export namespace $Reference2ShortFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ShortFunction$Type<K> = ($Reference2ShortFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ShortFunction_<K> = $Reference2ShortFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Boolean2ReferenceFunction<V> extends $Function$0<(boolean), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Boolean2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Boolean2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (V)>

(arg0: any): V
}

export namespace $Boolean2ReferenceFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ReferenceFunction$Type<V> = ($Boolean2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ReferenceFunction_<V> = $Boolean2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongOpenHashSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$AbstractLongSet, $AbstractLongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLongSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export class $LongOpenHashSet extends $AbstractLongSet implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>, arg1: float)
constructor(arg0: $LongIterator$Type)
constructor(arg0: $LongIterator$Type, arg1: float)
constructor(arg0: (long)[])
constructor(arg0: (long)[], arg1: float)
constructor(arg0: (long)[], arg1: integer, arg2: integer)
constructor(arg0: (long)[], arg1: integer, arg2: integer, arg3: float)
constructor(arg0: $Collection$Type<(any)>, arg1: float)
constructor()
constructor(arg0: integer)
constructor(arg0: integer, arg1: float)
constructor(arg0: $LongCollection$Type)
constructor(arg0: $LongCollection$Type, arg1: float)
constructor(arg0: $Collection$Type<(any)>)

public "add"(arg0: long): boolean
public "remove"(arg0: long): boolean
public "hashCode"(): integer
public "clone"(): $LongOpenHashSet
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $LongIterator
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public static "of"(): $LongOpenHashSet
public static "of"(arg0: long): $LongOpenHashSet
public static "of"(arg0: long, arg1: long): $LongOpenHashSet
public static "of"(...arg0: (long)[]): $LongOpenHashSet
public static "of"(arg0: long, arg1: long, arg2: long): $LongOpenHashSet
public "contains"(arg0: long): boolean
public "addAll"(arg0: $LongCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $LongConsumer$Type): void
public static "toSet"(arg0: $LongStream$Type): $LongOpenHashSet
public static "toSetWithExpectedSize"(arg0: $LongStream$Type, arg1: integer): $LongOpenHashSet
/**
 * 
 * @deprecated
 */
public "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongOpenHashSet$Type = ($LongOpenHashSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongOpenHashSet_ = $LongOpenHashSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Char2ReferenceFunction<V> extends $Function$0<(character), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Char2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Char2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Char2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>

(arg0: any): V
}

export namespace $Char2ReferenceFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ReferenceFunction$Type<V> = ($Char2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ReferenceFunction_<V> = $Char2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteArrayList" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ByteCollection, $ByteCollection$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ByteIterator, $ByteIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteIterator"
import {$ByteComparator, $ByteComparator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteComparator"
import {$AbstractByteList, $AbstractByteList$Type} from "packages/it/unimi/dsi/fastutil/bytes/$AbstractByteList"
import {$ByteList, $ByteList$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ByteArrayList extends $AbstractByteList implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $ByteCollection$Type)
constructor(arg0: $ByteList$Type)
constructor(arg0: (byte)[])
constructor(arg0: (byte)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $ByteIterator$Type)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: byte): void
public "add"(arg0: byte): boolean
public "equals"(arg0: $ByteArrayList$Type): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $ByteArrayList$Type): integer
public "indexOf"(arg0: byte): integer
public "getByte"(arg0: integer): byte
public "clear"(): void
public static "wrap"(arg0: (byte)[], arg1: integer): $ByteArrayList
public static "wrap"(arg0: (byte)[]): $ByteArrayList
public "lastIndexOf"(arg0: byte): integer
public "isEmpty"(): boolean
public "size"(): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $ByteList
public "toArray"(arg0: (byte)[]): (byte)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "of"(...arg0: (byte)[]): $ByteArrayList
public static "of"(): $ByteArrayList
public "elements"(): (byte)[]
public "addAll"(arg0: integer, arg1: $ByteList$Type): boolean
public "addAll"(arg0: integer, arg1: $ByteCollection$Type): boolean
public "set"(arg0: integer, arg1: byte): byte
public "forEach"(arg0: $ByteConsumer$Type): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $ByteComparator$Type): void
public "removeAll"(arg0: $ByteCollection$Type): boolean
public "rem"(arg0: byte): boolean
public "getElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
public "removeByte"(arg0: integer): byte
public "unstableSort"(arg0: $ByteComparator$Type): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: byte): $ByteList
public static "of"(arg0: byte, arg1: byte): $ByteList
public static "of"(arg0: byte, arg1: byte, arg2: byte): $ByteList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteArrayList$Type = ($ByteArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteArrayList_ = $ByteArrayList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ByteMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Long2ByteMap$Entry, $Long2ByteMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteMap$Entry"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$ByteBinaryOperator, $ByteBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteBinaryOperator"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ByteMap extends $Long2ByteFunction, $Map<(long), (byte)> {

 "remove"(arg0: long, arg1: byte): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: byte): byte
 "clear"(): void
 "replace"(arg0: long, arg1: byte, arg2: byte): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: byte, arg2: byte): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: byte): byte
 "replace"(arg0: long, arg1: byte): byte
 "size"(): integer
 "merge"(arg0: long, arg1: byte, arg2: $BiFunction$Type<(any), (any), (any)>): byte
/**
 * 
 * @deprecated
 */
 "merge"(arg0: long, arg1: byte, arg2: $BiFunction$Type<(any), (any), (any)>): byte
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (byte)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: long, arg1: byte): byte
 "putIfAbsent"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): byte
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): byte
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $LongToIntFunction$Type): byte
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): byte
 "computeIfAbsent"(arg0: long, arg1: $Long2ByteFunction$Type): byte
 "containsValue"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): byte
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): byte
 "long2ByteEntrySet"(): $ObjectSet<($Long2ByteMap$Entry)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ByteFunction$Type): byte
 "computeIfAbsentNullable"(arg0: long, arg1: $LongFunction$Type<(any)>): byte
 "mergeByte"(arg0: long, arg1: byte, arg2: $IntBinaryOperator$Type): byte
 "mergeByte"(arg0: long, arg1: byte, arg2: $ByteBinaryOperator$Type): byte
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "remove"(arg0: long): byte
 "get"(arg0: long): byte
 "put"(arg0: long, arg1: byte): byte
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ByteFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: long): byte
}

export namespace $Long2ByteMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte): $Map<(long), (byte)>
function of<K, V>(): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte, arg10: long, arg11: byte, arg12: long, arg13: byte, arg14: long, arg15: byte, arg16: long, arg17: byte, arg18: long, arg19: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte, arg10: long, arg11: byte, arg12: long, arg13: byte, arg14: long, arg15: byte, arg16: long, arg17: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte, arg10: long, arg11: byte, arg12: long, arg13: byte, arg14: long, arg15: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte, arg10: long, arg11: byte, arg12: long, arg13: byte): $Map<(long), (byte)>
function of<K, V>(arg0: long, arg1: byte, arg2: long, arg3: byte, arg4: long, arg5: byte, arg6: long, arg7: byte, arg8: long, arg9: byte, arg10: long, arg11: byte): $Map<(long), (byte)>
function entry<K, V>(arg0: long, arg1: byte): $Map$Entry<(long), (byte)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (byte)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ByteMap$Type = ($Long2ByteMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ByteMap_ = $Long2ByteMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectOpenHashMap" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectOpenHashMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "keySet"(): $ObjectSet<(K)>
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectOpenHashMap$Type<K, V> = ($Object2ObjectOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectOpenHashMap_<K, V> = $Object2ObjectOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Int2ByteFunction extends $Function$0<(integer), (byte)>, $IntUnaryOperator {

 "remove"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: integer): byte
 "put"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: integer, arg1: byte): byte
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): byte
}

export namespace $Int2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ByteFunction$Type = ($Int2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ByteFunction_ = $Int2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$FastEntrySet" {
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Object2ObjectMap$FastEntrySet<K, V> extends $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)> {

 "fastIterator"(): $ObjectIterator<($Object2ObjectMap$Entry<(K), (V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Object2ObjectMap$Entry<(K), (V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Object2ObjectMap$Entry<(K), (V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Object2ObjectMap$FastEntrySet {
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(...arg0: ($Object2ObjectMap$Entry$Type<(K), (V)>)[]): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>, arg8: $Object2ObjectMap$Entry$Type<(K), (V)>, arg9: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>, arg8: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$FastEntrySet$Type<K, V> = ($Object2ObjectMap$FastEntrySet<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap$FastEntrySet_<K, V> = $Object2ObjectMap$FastEntrySet$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$AbstractCharCollection" {
import {$CharPredicate, $CharPredicate$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharPredicate"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharSpliterator, $CharSpliterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$CharCollection, $CharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharCollection"

export class $AbstractCharCollection extends $AbstractCollection<(character)> implements $CharCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: character): boolean
public "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (character)[]): (character)[]
/**
 * 
 * @deprecated
 */
public "toCharArray"(arg0: (character)[]): (character)[]
public "toCharArray"(): (character)[]
public "contains"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $CharCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $CharCollection$Type): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $CharCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $CharCollection$Type): boolean
public "rem"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(character)>
public "intStream"(): $IntStream
public "spliterator"(): $CharSpliterator
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $CharPredicate$Type): boolean
public "removeIf"(arg0: $IntPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(character)>
public "intSpliterator"(): $IntSpliterator
public "intIterator"(): $IntIterator
public "intParallelStream"(): $IntStream
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "forEach"(arg0: $IntConsumer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCharCollection$Type = ($AbstractCharCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractCharCollection_ = $AbstractCharCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $CharIterator extends $PrimitiveIterator<(character), ($CharConsumer)> {

 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextChar"(): character
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $CharIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharIterator$Type = ($CharIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharIterator_ = $CharIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $ShortUnaryOperator extends $UnaryOperator<(short)>, $IntUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: short): short
 "apply"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: short): short
}

export namespace $ShortUnaryOperator {
function identity(): $ShortUnaryOperator
function negation(): $ShortUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortUnaryOperator$Type = ($ShortUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortUnaryOperator_ = $ShortUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ByteMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2ByteMap$Entry extends $Map$Entry<(long), (byte)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): byte
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: byte): byte
 "setValue"(arg0: byte): byte
 "getByteValue"(): byte
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Long2ByteMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (byte)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (byte)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (byte)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (byte)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (byte)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ByteMap$Entry$Type = ($Long2ByteMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ByteMap$Entry_ = $Long2ByteMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2BooleanFunction<K> extends $Function$0<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeBoolean"(arg0: any): boolean
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Object2BooleanFunction {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2BooleanFunction$Type<K> = ($Object2BooleanFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2BooleanFunction_<K> = $Object2BooleanFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $CharConsumer extends $Consumer<(character)>, $IntConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: character): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: character): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(character)>
 "andThen"(arg0: $CharConsumer$Type): $CharConsumer

(arg0: character): void
}

export namespace $CharConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharConsumer$Type = ($CharConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharConsumer_ = $CharConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Short2ReferenceFunction<V> extends $Function$0<(short), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Short2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Short2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Short2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: any): V
}

export namespace $Short2ReferenceFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ReferenceFunction$Type<V> = ($Short2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ReferenceFunction_<V> = $Short2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Reference2ReferenceMap$Entry<K, V> extends $Map$Entry<(K), (V)> {

 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "getKey"(): K
 "setValue"(arg0: V): V
}

export namespace $Reference2ReferenceMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$Entry$Type<K, V> = ($Reference2ReferenceMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap$Entry_<K, V> = $Reference2ReferenceMap$Entry$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2LongFunction extends $Function$0<(character), (long)>, $IntToLongFunction {

 "remove"(arg0: character): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: character): long
 "put"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): long

(arg0: character): long
}

export namespace $Char2LongFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2LongFunction$Type = ($Char2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2LongFunction_ = $Char2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$AbstractDoubleList" {
import {$DoubleListIterator, $DoubleListIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleListIterator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$DoubleComparator, $DoubleComparator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleComparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleList, $DoubleList$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleList"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$DoubleCollection, $DoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection"
import {$AbstractDoubleCollection, $AbstractDoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$AbstractDoubleCollection"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$Type as $DoubleUnaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleUnaryOperator"
import {$DoubleStack, $DoubleStack$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleStack"

export class $AbstractDoubleList extends $AbstractDoubleCollection implements $DoubleList, $DoubleStack {


public "add"(arg0: double): boolean
public "add"(arg0: integer, arg1: double): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: double): integer
public "clear"(): void
public "lastIndexOf"(arg0: double): integer
public "replaceAll"(arg0: $DoubleUnaryOperator$0$Type): void
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $DoubleList
public "toArray"(arg0: (double)[]): (double)[]
public "contains"(arg0: double): boolean
public "addAll"(arg0: integer, arg1: $DoubleCollection$Type): boolean
public "addAll"(arg0: $DoubleCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: double): double
public "forEach"(arg0: $DoubleConsumer$Type): void
public "listIterator"(arg0: integer): $DoubleListIterator
public "rem"(arg0: double): boolean
public "push"(arg0: double): void
public "getElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
public "popDouble"(): double
public "setElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
public "peekDouble"(arg0: integer): double
public "topDouble"(): double
public "toDoubleArray"(): (double)[]
public "removeDouble"(arg0: integer): double
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (double)[]): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): double
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
public "replaceAll"(arg0: $DoubleUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(double)>): void
public static "of"(...arg0: (double)[]): $DoubleList
public static "of"(): $DoubleList
public static "of"(arg0: double, arg1: double): $DoubleList
public static "of"(arg0: double): $DoubleList
public static "of"(arg0: double, arg1: double, arg2: double): $DoubleList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $DoubleList$Type): boolean
public "addAll"(arg0: integer, arg1: $DoubleList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: double): double
public "sort"(arg0: $DoubleComparator$Type): void
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (double)[]): void
public "setElements"(arg0: (double)[]): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "unstableSort"(arg0: $DoubleComparator$Type): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): double
/**
 * 
 * @deprecated
 */
public "push"(arg0: double): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(double)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double): $List<(double)>
public static "of"<E>(arg0: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
public static "of"<E>(...arg0: (double)[]): $List<(double)>
set "elements"(value: (double)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDoubleList$Type = ($AbstractDoubleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractDoubleList_ = $AbstractDoubleList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export interface $ObjectSpliterator<K> extends $Spliterator<(K)> {

 "skip"(arg0: long): long
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "characteristics"(): integer
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
 "getComparator"(): $Comparator<(any)>
}

export namespace $ObjectSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSpliterator$Type<K> = ($ObjectSpliterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSpliterator_<K> = $ObjectSpliterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $DoubleIterable extends $Iterable<(double)> {

 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
}

export namespace $DoubleIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterable$Type = ($DoubleIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterable_ = $DoubleIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Int2ReferenceMap$Entry, $Int2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceMap$Entry"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2ReferenceMap<V> extends $Int2ReferenceFunction<(V)>, $Map<(integer), (V)> {

 "int2ReferenceEntrySet"(): $ObjectSet<($Int2ReferenceMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "values"(): $ReferenceCollection<(V)>
 "clear"(): void
 "replace"(arg0: integer, arg1: V): V
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "size"(): integer
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (V)>)>
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Int2ReferenceFunction$Type<(any)>): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ReferenceFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Int2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Int2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ReferenceFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V): V
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>
}

export namespace $Int2ReferenceMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
function of<K, V>(): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
function entry<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (V)>
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ReferenceMap$Type<V> = ($Int2ReferenceMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ReferenceMap_<V> = $Int2ReferenceMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Reference2ReferenceMap, $Reference2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2ReferenceMap$FastEntrySet, $Reference2ReferenceMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$FastEntrySet"
import {$AbstractReference2ReferenceMap, $AbstractReference2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2ReferenceMap"
import {$ReferenceSet, $ReferenceSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceSet"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Reference2ReferenceOpenHashMap<K, V> extends $AbstractReference2ReferenceMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Reference2ReferenceMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Reference2ReferenceMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
public "keySet"(): $ReferenceSet<(K)>
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "reference2ReferenceEntrySet"(): $Reference2ReferenceMap$FastEntrySet<(K), (V)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceOpenHashMap$Type<K, V> = ($Reference2ReferenceOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceOpenHashMap_<K, V> = $Reference2ReferenceOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractLong2ObjectFunction, $AbstractLong2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractLong2ObjectMap<V> extends $AbstractLong2ObjectFunction<(V)> implements $Long2ObjectMap<(V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: long): boolean
public "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
public "clear"(): void
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(long), (V)>)>
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
public "replace"(arg0: long, arg1: V): V
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
public static "of"<K, V>(): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
public "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
public static "identity"<T>(): $Function<(long), (long)>
[index: string | number]: V
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectMap$Type<V> = ($AbstractLong2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectMap_<V> = $AbstractLong2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$AbstractBooleanCollection" {
import {$BooleanPredicate, $BooleanPredicate$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$BooleanCollection, $BooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"

export class $AbstractBooleanCollection extends $AbstractCollection<(boolean)> implements $BooleanCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: boolean): boolean
public "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (boolean)[]): (boolean)[]
public "contains"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $BooleanCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $BooleanCollection$Type): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $BooleanCollection$Type): boolean
public "containsAll"(arg0: $BooleanCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "rem"(arg0: boolean): boolean
public "toBooleanArray"(): (boolean)[]
/**
 * 
 * @deprecated
 */
public "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $BooleanPredicate$Type): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBooleanCollection$Type = ($AbstractBooleanCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractBooleanCollection_ = $AbstractBooleanCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntSet extends $IntCollection, $Set<(integer)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $IntSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntSet {
function of(arg0: integer, arg1: integer): $IntSet
function of(): $IntSet
function of(...arg0: (integer)[]): $IntSet
function of(arg0: integer): $IntSet
function of(arg0: integer, arg1: integer, arg2: integer): $IntSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
function of<E>(arg0: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
function of<E>(...arg0: (integer)[]): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer): $Set<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSet$Type = ($IntSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSet_ = $IntSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$FastEntrySet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Long2ObjectMap$FastEntrySet<V> extends $ObjectSet<($Long2ObjectMap$Entry<(V)>)> {

 "fastIterator"(): $ObjectIterator<($Long2ObjectMap$Entry<(V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Long2ObjectMap$Entry$Type<(V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Long2ObjectMap$FastEntrySet {
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(...arg0: ($Long2ObjectMap$Entry$Type<(V)>)[]): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>, arg9: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$FastEntrySet$Type<V> = ($Long2ObjectMap$FastEntrySet<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap$FastEntrySet_<V> = $Long2ObjectMap$FastEntrySet$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Long2ShortFunction extends $Function$0<(long), (short)>, $LongToIntFunction {

 "remove"(arg0: long): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: long): short
 "put"(arg0: long, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: long, arg1: short): short
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): short

(arg0: long): short
}

export namespace $Long2ShortFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ShortFunction$Type = ($Long2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ShortFunction_ = $Long2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $IntUnaryOperator extends $UnaryOperator<(integer)>, $IntUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): integer
 "apply"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$0$Type): $IntUnaryOperator$0
 "andThen"(arg0: $IntUnaryOperator$0$Type): $IntUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: integer): integer
}

export namespace $IntUnaryOperator {
function identity(): $IntUnaryOperator
function negation(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntUnaryOperator$Type = ($IntUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntUnaryOperator_ = $IntUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$ByteIterator, $ByteIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteIterator"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $ByteBidirectionalIterator extends $ByteIterator, $ObjectBidirectionalIterator<(byte)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): byte
 "back"(arg0: integer): integer
 "previousByte"(): byte
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextByte"(): byte
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ByteBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBidirectionalIterator$Type = ($ByteBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBidirectionalIterator_ = $ByteBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Double2IntFunction extends $Function$0<(double), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: double): integer
 "put"(arg0: double, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: double, arg1: integer): integer
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): integer

(arg0: double): integer
}

export namespace $Double2IntFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2IntFunction$Type = ($Double2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2IntFunction_ = $Double2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Double2FloatFunction extends $Function$0<(double), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: double): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: double): float
 "put"(arg0: double, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: double, arg1: float): float
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): float
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: double): float
}

export namespace $Double2FloatFunction {
function identity(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2FloatFunction$Type = ($Double2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2FloatFunction_ = $Double2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$AbstractFloatList" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$FloatListIterator, $FloatListIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatListIterator"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$FloatStack, $FloatStack$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatStack"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$FloatList, $FloatList$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatList"
import {$FloatComparator, $FloatComparator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatComparator"
import {$FloatUnaryOperator, $FloatUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatUnaryOperator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FloatSpliterator, $FloatSpliterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatSpliterator"
import {$AbstractFloatCollection, $AbstractFloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$AbstractFloatCollection"

export class $AbstractFloatList extends $AbstractFloatCollection implements $FloatList, $FloatStack {


public "add"(arg0: float): boolean
public "add"(arg0: integer, arg1: float): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: float): integer
public "clear"(): void
public "lastIndexOf"(arg0: float): integer
public "size"(arg0: integer): void
public "toArray"(arg0: (float)[]): (float)[]
public "iterator"(): $FloatListIterator
public "contains"(arg0: float): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $FloatCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $FloatCollection$Type): boolean
public "set"(arg0: integer, arg1: float): float
public "forEach"(arg0: $FloatConsumer$Type): void
public "listIterator"(): $FloatListIterator
public "listIterator"(arg0: integer): $FloatListIterator
public "rem"(arg0: float): boolean
public "push"(arg0: float): void
public "getElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
public "popFloat"(): float
public "topFloat"(): float
public "peekFloat"(arg0: integer): float
public "toFloatArray"(): (float)[]
public "removeFloat"(arg0: integer): float
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (float)[]): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: float): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): float
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getFloat"(arg0: integer): float
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
public "replaceAll"(arg0: $DoubleUnaryOperator$Type): void
public "replaceAll"(arg0: $FloatUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(float)>): void
public static "of"(): $FloatList
public static "of"(arg0: float): $FloatList
public static "of"(arg0: float, arg1: float): $FloatList
public static "of"(arg0: float, arg1: float, arg2: float): $FloatList
public static "of"(...arg0: (float)[]): $FloatList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $FloatSpliterator
public "addAll"(arg0: $FloatList$Type): boolean
public "addAll"(arg0: integer, arg1: $FloatList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "sort"(arg0: $FloatComparator$Type): void
public "setElements"(arg0: (float)[]): void
public "setElements"(arg0: integer, arg1: (float)[]): void
public "unstableSort"(arg0: $FloatComparator$Type): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): float
/**
 * 
 * @deprecated
 */
public "push"(arg0: float): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(float)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float): $List<(float)>
public static "of"<E>(arg0: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): $List<(float)>
public static "of"<E>(...arg0: (float)[]): $List<(float)>
set "elements"(value: (float)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFloatList$Type = ($AbstractFloatList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractFloatList_ = $AbstractFloatList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$ByteBidirectionalIterator, $ByteBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteBidirectionalIterator"

export interface $ByteListIterator extends $ByteBidirectionalIterator, $ListIterator<(byte)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: byte): void
 "add"(arg0: byte): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: byte): void
 "set"(arg0: byte): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousByte"(): byte
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextByte"(): byte
}

export namespace $ByteListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteListIterator$Type = ($ByteListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteListIterator_ = $ByteListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReferenceList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ReferenceList, $ReferenceList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractReferenceCollection, $AbstractReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReferenceCollection"
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export class $AbstractReferenceList<K> extends $AbstractReferenceCollection<(K)> implements $ReferenceList<(K)>, $Stack<(K)> {


public "add"(arg0: K): boolean
public "add"(arg0: integer, arg1: K): void
public "remove"(arg0: integer): K
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "size"(arg0: integer): void
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $ObjectListIterator<(K)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "top"(): K
public "peek"(arg0: integer): K
public "push"(arg0: K): void
public "pop"(): K
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (K)[]): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "of"<K>(...arg0: (K)[]): $ReferenceList<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ReferenceList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ReferenceList<(K)>
public static "of"<K>(): $ReferenceList<(K)>
public static "of"<K>(arg0: K): $ReferenceList<(K)>
public "addAll"(arg0: $ReferenceList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $ReferenceList$Type<(any)>): boolean
public "sort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (K)[]): void
public "setElements"(arg0: (K)[]): void
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "isEmpty"(): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): K
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(K)>
public "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
public "size"(): integer
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
[index: number]: K
set "elements"(value: (K)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReferenceList$Type<K> = ($AbstractReferenceList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReferenceList_<K> = $AbstractReferenceList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongCollection" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongIterable, $LongIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterable"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"

export interface $LongCollection extends $Collection<(long)>, $LongIterable {

 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (long)[]): (long)[]
 "iterator"(): $LongIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longParallelStream"(): $LongStream
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongCollection$Type = ($LongCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongCollection_ = $LongCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2LongMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2LongMap$Entry extends $Map$Entry<(long), (long)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): long
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: long): long
 "setValue"(arg0: long): long
 "getLongValue"(): long
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Long2LongMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (long)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (long)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (long)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (long)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2LongMap$Entry$Type = ($Long2LongMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2LongMap$Entry_ = $Long2LongMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$IntBidirectionalIterator, $IntBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBidirectionalIterator"

export interface $IntListIterator extends $IntBidirectionalIterator, $ListIterator<(integer)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): void
 "add"(arg0: integer): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer): void
 "set"(arg0: integer): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
}

export namespace $IntListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntListIterator$Type = ($IntListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntListIterator_ = $IntListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatIterable" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $FloatIterable extends $Iterable<(float)> {

 "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
}

export namespace $FloatIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatIterable$Type = ($FloatIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatIterable_ = $FloatIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Double2ByteFunction extends $Function$0<(double), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: double): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: double): byte
 "put"(arg0: double, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: double, arg1: byte): byte
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): byte

(arg0: double): byte
}

export namespace $Double2ByteFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ByteFunction$Type = ($Double2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ByteFunction_ = $Double2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2IntMap<K> extends $Object2IntFunction<(K)>, $Map<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $IntCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeInt"(arg0: any): integer
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}

export namespace $Object2IntMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntMap$Type<K> = ($Object2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntMap_<K> = $Object2IntMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Hash$Strategy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash$Strategy<K> {

 "equals"(arg0: K, arg1: K): boolean
 "hashCode"(arg0: K): integer
}

export namespace $Hash$Strategy {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$Strategy$Type<K> = ($Hash$Strategy<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash$Strategy_<K> = $Hash$Strategy$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ObjectIterator<K> extends $Iterator<(K)> {

 "skip"(arg0: integer): integer
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterator$Type<K> = ($ObjectIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterator_<K> = $ObjectIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2FloatMap$Entry, $Object2FloatMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$FloatBinaryOperator, $FloatBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatBinaryOperator"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2FloatMap<K> extends $Object2FloatFunction<(K)>, $Map<(K), (float)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: float): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "values"(): $FloatCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float, arg2: float): boolean
 "replace"(arg0: K, arg1: float, arg2: float): boolean
 "replace"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float): float
 "size"(): integer
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (float)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: float): float
 "putIfAbsent"(arg0: K, arg1: float): float
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
 "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: float): boolean
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
/**
 * 
 * @deprecated
 */
 "mergeFloat"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $FloatBinaryOperator$Type): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $DoubleBinaryOperator$Type): float
 "computeFloat"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsentPartial"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
 "object2FloatEntrySet"(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
 "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2FloatFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Float2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): float
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
 "apply"(arg0: K): float
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>
}

export namespace $Object2FloatMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float): $Map<(K), (float)>
function of<K, V>(): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float, arg18: K, arg19: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float): $Map<(K), (float)>
function entry<K, V>(arg0: K, arg1: float): $Map$Entry<(K), (float)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (float)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$Type<K> = ($Object2FloatMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap_<K> = $Object2FloatMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatListIterator" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$FloatBidirectionalIterator, $FloatBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $FloatListIterator extends $FloatBidirectionalIterator, $ListIterator<(float)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: float): void
 "add"(arg0: float): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: float): void
 "set"(arg0: float): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousFloat"(): float
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "forEachRemaining"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextFloat"(): float
}

export namespace $FloatListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatListIterator$Type = ($FloatListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatListIterator_ = $FloatListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$AbstractObjectList, $AbstractObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectList"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectList, $ObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectList"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ObjectArrayList<K> extends $AbstractObjectList<(K)> implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $ObjectCollection$Type<(any)>)
constructor(arg0: $ObjectList$Type<(any)>)
constructor(arg0: (K)[])
constructor(arg0: (K)[], arg1: integer, arg2: integer)
constructor(arg0: $ObjectIterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: K): void
public "add"(arg0: K): boolean
public "remove"(arg0: any): boolean
public "remove"(arg0: integer): K
public "get"(arg0: integer): K
public "equals"(arg0: $ObjectArrayList$Type<(K)>): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $ObjectArrayList$Type<(any)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public static "wrap"<K>(arg0: (K)[]): $ObjectArrayList<(K)>
public static "wrap"<K>(arg0: (K)[], arg1: integer): $ObjectArrayList<(K)>
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "size"(arg0: integer): void
public "size"(): integer
public "toArray"<K>(arg0: (K)[]): (K)[]
public "toArray"(): (any)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "toList"<K>(): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public static "of"<K>(...arg0: (K)[]): $ObjectArrayList<(K)>
public static "of"<K>(): $ObjectArrayList<(K)>
public "elements"(): (K)[]
public "spliterator"(): $ObjectSpliterator<(K)>
public "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $Comparator$Type<(any)>): void
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "toListWithExpectedSize"<K>(arg0: integer): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectArrayList$Type<K> = ($ObjectArrayList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectArrayList_<K> = $ObjectArrayList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $ShortPredicate extends $Predicate<(short)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: short): boolean
 "test"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $ShortPredicate$Type): $ShortPredicate
 "or"(arg0: $IntPredicate$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(short)>
 "and"(arg0: $ShortPredicate$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(short)>

(arg0: short): boolean
}

export namespace $ShortPredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(short)>
function isEqual<T>(arg0: any): $Predicate<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortPredicate$Type = ($ShortPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortPredicate_ = $ShortPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$BytePredicate" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $BytePredicate extends $Predicate<(byte)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: byte): boolean
 "test"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $BytePredicate$Type): $BytePredicate
 "or"(arg0: $IntPredicate$Type): $BytePredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(byte)>
 "and"(arg0: $BytePredicate$Type): $BytePredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(byte)>

(arg0: byte): boolean
}

export namespace $BytePredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(byte)>
function isEqual<T>(arg0: any): $Predicate<(byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytePredicate$Type = ($BytePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytePredicate_ = $BytePredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2IntFunction extends $Function$0<(byte), (integer)>, $IntUnaryOperator {

 "remove"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: byte): integer
 "put"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): integer
}

export namespace $Byte2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2IntFunction$Type = ($Byte2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2IntFunction_ = $Byte2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Object2ShortFunction<K> extends $Function$0<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
 "put"(arg0: K, arg1: short): short
 "getShort"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeShort"(arg0: any): short
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ShortFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Short2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>

(arg0: any): short
}

export namespace $Object2ShortFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ShortFunction$Type<K> = ($Object2ShortFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ShortFunction_<K> = $Object2ShortFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $DoubleComparator extends $Comparator<(double)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: double, arg1: double): integer
 "compare"(arg0: double, arg1: double): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
 "thenComparing"(arg0: $DoubleComparator$Type): $DoubleComparator
 "reversed"(): $DoubleComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(double)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(double)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(double)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(double)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(double)>
}

export namespace $DoubleComparator {
function reverseOrder<T>(): $Comparator<(double)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(double)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(double)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(double)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(double)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(double)>
function naturalOrder<T>(): $Comparator<(double)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleComparator$Type = ($DoubleComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleComparator_ = $DoubleComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatSpliterator" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"

export interface $FloatSpliterator extends $Spliterator$OfPrimitive<(float), ($FloatConsumer), ($FloatSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $FloatConsumer$Type): void
 "tryAdvance"(arg0: $FloatConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $FloatSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatSpliterator$Type = ($FloatSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatSpliterator_ = $FloatSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/java/util/function/$LongConsumer"

export interface $LongConsumer extends $Consumer<(long)>, $LongConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(long)>
 "andThen"(arg0: $LongConsumer$Type): $LongConsumer
 "accept"(arg0: long): void

(arg0: long): void
}

export namespace $LongConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongConsumer$Type = ($LongConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongConsumer_ = $LongConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2DoubleFunction extends $Function$0<(character), (double)>, $IntToDoubleFunction {

 "remove"(arg0: character): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: character): double
 "put"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): double

(arg0: character): double
}

export namespace $Char2DoubleFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2DoubleFunction$Type = ($Char2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2DoubleFunction_ = $Char2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection" {
import {$ShortIterator, $ShortIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$ShortIterable, $ShortIterable$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterable"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ShortCollection extends $Collection<(short)>, $ShortIterable {

 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (short)[]): (short)[]
 "iterator"(): $ShortIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortCollection$Type = ($ShortCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortCollection_ = $ShortCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$Type as $LongUnaryOperator$0$Type} from "packages/java/util/function/$LongUnaryOperator"

export interface $LongUnaryOperator extends $UnaryOperator<(long)>, $LongUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: long): long
 "apply"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$0$Type): $LongUnaryOperator$0
 "andThen"(arg0: $LongUnaryOperator$0$Type): $LongUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: long): long
}

export namespace $LongUnaryOperator {
function identity(): $LongUnaryOperator
function negation(): $LongUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongUnaryOperator$Type = ($LongUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongUnaryOperator_ = $LongUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Int2IntMap$Entry, $Int2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap$Entry"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2IntMap extends $Int2IntFunction, $Map<(integer), (integer)> {

 "remove"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
 "clear"(): void
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer): integer
 "replace"(arg0: integer, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: integer): integer
 "putIfAbsent"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntUnaryOperator$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): integer
 "computeIfAbsent"(arg0: integer, arg1: $Int2IntFunction$Type): integer
 "containsValue"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
 "int2IntEntrySet"(): $ObjectSet<($Int2IntMap$Entry)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2IntFunction$Type): integer
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$Type<(any)>): integer
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "remove"(arg0: integer): integer
 "get"(arg0: integer): integer
 "put"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
}

export namespace $Int2IntMap {
function identity(): $Int2IntFunction
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Map<(integer), (integer)>
function of<K, V>(): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer, arg18: integer, arg19: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer): $Map<(integer), (integer)>
function entry<K, V>(arg0: integer, arg1: integer): $Map$Entry<(integer), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntMap$Type = ($Int2IntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntMap_ = $Int2IntMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Int2ShortFunction extends $Function$0<(integer), (short)>, $IntUnaryOperator {

 "remove"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: integer): short
 "put"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: integer, arg1: short): short
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): short
}

export namespace $Int2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ShortFunction$Type = ($Int2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ShortFunction_ = $Int2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction" {
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2BooleanFunction extends $Function$0<(byte), (boolean)>, $IntPredicate {

 "remove"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: boolean): boolean
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate

(arg0: byte): boolean
}

export namespace $Byte2BooleanFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2BooleanFunction$Type = ($Byte2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2BooleanFunction_ = $Byte2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2FloatFunction extends $Function$0<(byte), (float)>, $IntToDoubleFunction {

 "remove"(arg0: byte): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: byte): float
 "put"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): float

(arg0: byte): float
}

export namespace $Byte2FloatFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2FloatFunction$Type = ($Byte2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2FloatFunction_ = $Byte2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2ObjectFunction<V> extends $Function$0<(character), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Char2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Char2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Char2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>

(arg0: any): V
}

export namespace $Char2ObjectFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectFunction$Type<V> = ($Char2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectFunction_<V> = $Char2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $Float2BooleanFunction extends $Function$0<(float), (boolean)>, $DoublePredicate {

 "remove"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: boolean): boolean
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): boolean
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate

(arg0: float): boolean
}

export namespace $Float2BooleanFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2BooleanFunction$Type = ($Float2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2BooleanFunction_ = $Float2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction" {
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"

export interface $Object2ObjectFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Object2ObjectFunction {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectFunction$Type<K, V> = ($Object2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectFunction_<K, V> = $Object2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleListIterator" {
import {$DoubleBidirectionalIterator, $DoubleBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $DoubleListIterator extends $DoubleBidirectionalIterator, $ListIterator<(double)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: double): void
 "add"(arg0: double): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: double): void
 "set"(arg0: double): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousDouble"(): double
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "nextDouble"(): double
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
}

export namespace $DoubleListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleListIterator$Type = ($DoubleListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleListIterator_ = $DoubleListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2IntFunction extends $Function<(integer), (integer)>, $IntUnaryOperator {

 "remove"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "get"(arg0: integer): integer
 "put"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(integer), (T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): integer
}

export namespace $Int2IntFunction {
function identity(): $Int2IntFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntFunction$Type = ($Int2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntFunction_ = $Int2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $BooleanIterator extends $PrimitiveIterator<(boolean), ($BooleanConsumer)> {

 "forEachRemaining"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextBoolean"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $BooleanIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanIterator$Type = ($BooleanIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanIterator_ = $BooleanIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2FloatFunction extends $Function$0<(boolean), (float)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
 "remove"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: boolean): float
 "put"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: float): float
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): float

(arg0: any): float
}

export namespace $Boolean2FloatFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2FloatFunction$Type = ($Boolean2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2FloatFunction_ = $Boolean2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2ObjectMap$Entry, $Int2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap$Entry"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2ObjectMap<V> extends $Int2ObjectFunction<(V)>, $Map<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "size"(): integer
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (V)>)>
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$Type<(any)>): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "int2ObjectEntrySet"(): $ObjectSet<($Int2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Int2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Int2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V): V
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>
}

export namespace $Int2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
function of<K, V>(): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
function entry<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (V)>
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectMap$Type<V> = ($Int2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectMap_<V> = $Int2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2FloatFunction extends $Function$0<(short), (float)>, $IntToDoubleFunction {

 "remove"(arg0: short): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: short): float
 "put"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): float

(arg0: short): float
}

export namespace $Short2FloatFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2FloatFunction$Type = ($Short2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2FloatFunction_ = $Short2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2DoubleMap$Entry<K> extends $Map$Entry<(K), (double)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): double
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: double): double
 "setValue"(arg0: double): double
 "getDoubleValue"(): double
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2DoubleMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (double)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (double)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (double)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (double)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (double)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleMap$Entry$Type<K> = ($Object2DoubleMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleMap$Entry_<K> = $Object2DoubleMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Reference2IntMap$Entry<K> extends $Map$Entry<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntValue"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Reference2IntMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (integer)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntMap$Entry$Type<K> = ($Reference2IntMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntMap$Entry_<K> = $Reference2IntMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $ObjectSet<K> extends $ObjectCollection<(K)>, $Set<(K)> {

 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSet$Type<K> = ($ObjectSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSet_<K> = $ObjectSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntPredicate" {
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $IntPredicate extends $Predicate<(integer)>, $IntPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
 "or"(arg0: $IntPredicate$0$Type): $IntPredicate
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
 "test"(arg0: integer): boolean

(arg0: integer): boolean
}

export namespace $IntPredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
function isEqual<T>(arg0: any): $Predicate<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntPredicate$Type = ($IntPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntPredicate_ = $IntPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction" {
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2CharFunction extends $Function$0<(short), (character)>, $IntUnaryOperator {

 "remove"(arg0: short): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: short): character
 "put"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): character
}

export namespace $Short2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2CharFunction$Type = ($Short2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2CharFunction_ = $Short2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ShortSpliterator, $ShortSpliterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortCollection, $ShortCollection$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection"

export interface $ShortSet extends $ShortCollection, $Set<(short)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: short): boolean
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortSet {
function of(arg0: short, arg1: short): $ShortSet
function of(): $ShortSet
function of(...arg0: (short)[]): $ShortSet
function of(arg0: short): $ShortSet
function of(arg0: short, arg1: short, arg2: short): $ShortSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $Set<(short)>
function of<E>(arg0: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $Set<(short)>
function of<E>(...arg0: (short)[]): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $Set<(short)>
function of<E>(arg0: short, arg1: short): $Set<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSet$Type = ($ShortSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSet_ = $ShortSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $CharIterable extends $Iterable<(character)> {

 "forEach"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $CharIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharIterable$Type = ($CharIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharIterable_ = $CharIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2ObjectMap$Entry<V> extends $Map$Entry<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): integer
 "getIntKey"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Int2ObjectMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectMap$Entry$Type<V> = ($Int2ObjectMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectMap$Entry_<V> = $Int2ObjectMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2CharFunction extends $Function<(character), (character)>, $IntUnaryOperator {

 "remove"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
 "get"(arg0: character): character
 "put"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(character), (T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): character
}

export namespace $Char2CharFunction {
function identity(): $Char2CharFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2CharFunction$Type = ($Char2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2CharFunction_ = $Char2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$ByteIterable, $ByteIterable$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteIterable"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ByteIterator, $ByteIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteIterator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BytePredicate, $BytePredicate$Type} from "packages/it/unimi/dsi/fastutil/bytes/$BytePredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ByteCollection extends $Collection<(byte)>, $ByteIterable {

/**
 * 
 * @deprecated
 */
 "add"(arg0: byte): boolean
 "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (byte)[]): (byte)[]
 "iterator"(): $ByteIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(byte)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: byte): boolean
 "addAll"(arg0: $ByteCollection$Type): boolean
 "toByteArray"(): (byte)[]
/**
 * 
 * @deprecated
 */
 "toByteArray"(arg0: (byte)[]): (byte)[]
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $BytePredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ByteCollection$Type): boolean
 "retainAll"(arg0: $ByteCollection$Type): boolean
 "containsAll"(arg0: $ByteCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(byte)>
 "rem"(arg0: byte): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ByteCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteCollection$Type = ($ByteCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteCollection_ = $ByteCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$AbstractCharList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CharListIterator, $CharListIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$AbstractCharCollection, $AbstractCharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$AbstractCharCollection"
import {$CharList, $CharList$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharList"
import {$CharSpliterator, $CharSpliterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$CharComparator, $CharComparator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharComparator"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CharStack, $CharStack$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharStack"
import {$CharCollection, $CharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharCollection"
import {$CharUnaryOperator, $CharUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharUnaryOperator"

export class $AbstractCharList extends $AbstractCharCollection implements $CharList, $CharStack {


public "add"(arg0: character): boolean
public "add"(arg0: integer, arg1: character): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: character): integer
public "clear"(): void
public "lastIndexOf"(arg0: character): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $CharList
public "toArray"(arg0: (character)[]): (character)[]
public "iterator"(): $CharListIterator
public "toCharArray"(): (character)[]
public "contains"(arg0: character): boolean
public "addAll"(arg0: integer, arg1: $CharCollection$Type): boolean
public "addAll"(arg0: $CharCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: character): character
public "forEach"(arg0: $CharConsumer$Type): void
public "listIterator"(): $CharListIterator
public "listIterator"(arg0: integer): $CharListIterator
public "rem"(arg0: character): boolean
public "push"(arg0: character): void
public "getElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
public "peekChar"(arg0: integer): character
public "removeChar"(arg0: integer): character
public "setElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
public "popChar"(): character
public "topChar"(): character
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (character)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (character)[]): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: character): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): character
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getChar"(arg0: integer): character
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
public "replaceAll"(arg0: $IntUnaryOperator$Type): void
public "replaceAll"(arg0: $CharUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(character)>): void
public static "of"(): $CharList
public static "of"(arg0: character): $CharList
public static "of"(arg0: character, arg1: character): $CharList
public static "of"(arg0: character, arg1: character, arg2: character): $CharList
public static "of"(...arg0: (character)[]): $CharList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $CharSpliterator
public "addAll"(arg0: $CharList$Type): boolean
public "addAll"(arg0: integer, arg1: $CharList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "sort"(arg0: $CharComparator$Type): void
public "setElements"(arg0: integer, arg1: (character)[]): void
public "setElements"(arg0: (character)[]): void
public "unstableSort"(arg0: $CharComparator$Type): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): character
/**
 * 
 * @deprecated
 */
public "push"(arg0: character): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(character)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character): $List<(character)>
public static "of"<E>(arg0: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character, arg9: character): $List<(character)>
public static "of"<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character): $List<(character)>
public static "of"<E>(...arg0: (character)[]): $List<(character)>
set "elements"(value: (character)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCharList$Type = ($AbstractCharList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractCharList_ = $AbstractCharList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $ByteIterator extends $PrimitiveIterator<(byte), ($ByteConsumer)> {

 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextByte"(): byte
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ByteIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteIterator$Type = ($ByteIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteIterator_ = $ByteIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $BooleanConsumer extends $Consumer<(boolean)> {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: boolean): void
 "accept"(arg0: boolean): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(boolean)>
 "andThen"(arg0: $BooleanConsumer$Type): $BooleanConsumer

(arg0: boolean): void
}

export namespace $BooleanConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanConsumer$Type = ($BooleanConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanConsumer_ = $BooleanConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2IntFunction<K> extends $Function$0<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeInt"(arg0: any): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2IntFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Int2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>

(arg0: any): integer
}

export namespace $Reference2IntFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntFunction$Type<K> = ($Reference2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntFunction_<K> = $Reference2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2LongFunction<K> extends $Function$0<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeLong"(arg0: any): long
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2LongFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Long2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>

(arg0: any): long
}

export namespace $Reference2LongFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2LongFunction$Type<K> = ($Reference2LongFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2LongFunction_<K> = $Reference2LongFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2IntMap$Entry extends $Map$Entry<(long), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntValue"(): integer
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Long2IntMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (integer)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (integer)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntMap$Entry$Type = ($Long2IntMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntMap$Entry_ = $Long2IntMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"

export interface $ReferenceList<K> extends $List<(K)>, $ReferenceCollection<(K)> {

 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $ReferenceList<(K)>
 "addAll"(arg0: $ReferenceList$Type<(any)>): boolean
 "addAll"(arg0: integer, arg1: $ReferenceList$Type<(any)>): boolean
 "sort"(arg0: $Comparator$Type<(any)>): void
 "listIterator"(arg0: integer): $ObjectListIterator<(K)>
 "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (K)[]): void
 "setElements"(arg0: (K)[]): void
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (K)[]): void
 "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "add"(arg0: integer, arg1: K): void
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): K
 "get"(arg0: integer): K
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: K): K
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ReferenceList {
function of<K>(...arg0: (K)[]): $ReferenceList<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ReferenceList<(K)>
function of<K>(arg0: K, arg1: K): $ReferenceList<(K)>
function of<K>(): $ReferenceList<(K)>
function of<K>(arg0: K): $ReferenceList<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceList$Type<K> = ($ReferenceList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceList_<K> = $ReferenceList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $FloatStack extends $Stack<(float)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): float
 "push"(arg0: float): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: float): void
 "popFloat"(): float
 "topFloat"(): float
 "peekFloat"(arg0: integer): float
 "isEmpty"(): boolean
}

export namespace $FloatStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatStack$Type = ($FloatStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatStack_ = $FloatStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $ObjectListIterator<K> extends $ObjectBidirectionalIterator<(K)>, $ListIterator<(K)> {

 "add"(arg0: K): void
 "remove"(): void
 "set"(arg0: K): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasNext"(): boolean
 "next"(): K
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectListIterator$Type<K> = ($ObjectListIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectListIterator_<K> = $ObjectListIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$Type as $DoubleBinaryOperator$0$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $DoubleBinaryOperator extends $BinaryOperator<(double)>, $DoubleBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: double, arg1: double): double
 "apply"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(double), (double), (V)>

(arg0: double, arg1: double): double
}

export namespace $DoubleBinaryOperator {
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(double)>
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBinaryOperator$Type = ($DoubleBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBinaryOperator_ = $DoubleBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2FloatMap$Entry<K> extends $Map$Entry<(K), (float)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): float
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: float): float
 "setValue"(arg0: float): float
 "getFloatValue"(): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2FloatMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (float)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (float)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$Entry$Type<K> = ($Object2FloatMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap$Entry_<K> = $Object2FloatMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Boolean2ShortFunction extends $Function$0<(boolean), (short)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
 "remove"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: boolean): short
 "put"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: short): short
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): short

(arg0: any): short
}

export namespace $Boolean2ShortFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ShortFunction$Type = ($Boolean2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ShortFunction_ = $Boolean2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2DoubleFunction extends $Function$0<(integer), (double)>, $IntToDoubleFunction {

 "remove"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): double

(arg0: integer): double
}

export namespace $Int2DoubleFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleFunction$Type = ($Int2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleFunction_ = $Int2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntConsumer extends $Consumer<(integer)>, $IntConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(integer)>
 "andThen"(arg0: $IntConsumer$Type): $IntConsumer
 "accept"(arg0: integer): void

(arg0: integer): void
}

export namespace $IntConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntConsumer$Type = ($IntConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntConsumer_ = $IntConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction" {
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$LongUnaryOperator, $LongUnaryOperator$Type} from "packages/java/util/function/$LongUnaryOperator"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"

export interface $Long2LongFunction extends $Function<(long), (long)>, $LongUnaryOperator {

 "remove"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
 "get"(arg0: long): long
 "put"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: long, arg1: long): long
 "applyAsLong"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(long), (T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator
 "andThen"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator

(arg0: long): long
}

export namespace $Long2LongFunction {
function identity(): $Long2LongFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2LongFunction$Type = ($Long2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2LongFunction_ = $Long2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Double2ShortFunction extends $Function$0<(double), (short)>, $DoubleToIntFunction {

 "remove"(arg0: double): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: double): short
 "put"(arg0: double, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: double, arg1: short): short
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): short

(arg0: double): short
}

export namespace $Double2ShortFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ShortFunction$Type = ($Double2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ShortFunction_ = $Double2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Float2IntFunction extends $Function$0<(float), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: float): integer
 "put"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): integer

(arg0: float): integer
}

export namespace $Float2IntFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2IntFunction$Type = ($Float2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2IntFunction_ = $Float2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2ObjectSortedMap<K, V> extends $Object2ObjectMap<(K), (V)>, $SortedMap<(K), (V)> {

 "comparator"(): $Comparator<(any)>
 "object2ObjectEntrySet"(): $ObjectSortedSet<($Object2ObjectMap$Entry<(K), (V)>)>
 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "firstKey"(): K
 "lastKey"(): K
 "get"(arg0: any): V
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Object2ObjectSortedMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectSortedMap$Type<K, V> = ($Object2ObjectSortedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectSortedMap_<K, V> = $Object2ObjectSortedMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ObjectBidirectionalIterable, $ObjectBidirectionalIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterable"

export interface $ObjectSortedSet<K> extends $ObjectSet<(K)>, $SortedSet<(K)>, $ObjectBidirectionalIterable<(K)> {

 "iterator"(arg0: K): $ObjectBidirectionalIterator<(K)>
 "last"(): K
 "first"(): K
 "comparator"(): $Comparator<(any)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectSortedSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSortedSet$Type<K> = ($ObjectSortedSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSortedSet_<K> = $ObjectSortedSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2LongMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Long2LongMap$Entry, $Long2LongMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongMap$Entry"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$LongBinaryOperator, $LongBinaryOperator$Type} from "packages/java/util/function/$LongBinaryOperator"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$LongUnaryOperator, $LongUnaryOperator$Type} from "packages/java/util/function/$LongUnaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$LongBinaryOperator as $LongBinaryOperator$0, $LongBinaryOperator$Type as $LongBinaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBinaryOperator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2LongMap extends $Long2LongFunction, $Map<(long), (long)> {

 "remove"(arg0: long, arg1: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: long): long
 "clear"(): void
 "replace"(arg0: long, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: long): long
 "replace"(arg0: long, arg1: long): long
 "size"(): integer
 "merge"(arg0: long, arg1: long, arg2: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "merge"(arg0: long, arg1: long, arg2: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (long)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: long, arg1: long): long
 "putIfAbsent"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): long
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): long
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $LongUnaryOperator$Type): long
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): long
 "computeIfAbsent"(arg0: long, arg1: $Long2LongFunction$Type): long
 "containsValue"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2LongFunction$Type): long
 "computeIfAbsentNullable"(arg0: long, arg1: $LongFunction$Type<(any)>): long
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "long2LongEntrySet"(): $ObjectSet<($Long2LongMap$Entry)>
 "mergeLong"(arg0: long, arg1: long, arg2: $LongBinaryOperator$Type): long
 "mergeLong"(arg0: long, arg1: long, arg2: $LongBinaryOperator$0$Type): long
 "remove"(arg0: long): long
 "get"(arg0: long): long
 "put"(arg0: long, arg1: long): long
 "applyAsLong"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2LongFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator
 "andThen"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator
}

export namespace $Long2LongMap {
function identity(): $Long2LongFunction
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Map<(long), (long)>
function of<K, V>(): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long, arg10: long, arg11: long, arg12: long, arg13: long, arg14: long, arg15: long, arg16: long, arg17: long, arg18: long, arg19: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long, arg10: long, arg11: long, arg12: long, arg13: long, arg14: long, arg15: long, arg16: long, arg17: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long, arg10: long, arg11: long, arg12: long, arg13: long, arg14: long, arg15: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long, arg10: long, arg11: long, arg12: long, arg13: long): $Map<(long), (long)>
function of<K, V>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long, arg10: long, arg11: long): $Map<(long), (long)>
function entry<K, V>(arg0: long, arg1: long): $Map$Entry<(long), (long)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2LongMap$Type = ($Long2LongMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2LongMap_ = $Long2LongMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2ObjectMap$Entry, $Char2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$Entry"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Char2ObjectMap<V> extends $Char2ObjectFunction<(V)>, $Map<(character), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: character, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
 "clear"(): void
 "replace"(arg0: character, arg1: V, arg2: V): boolean
 "replace"(arg0: character, arg1: V): V
 "size"(): integer
 "merge"(arg0: character, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(character), (V)>)>
 "putIfAbsent"(arg0: character, arg1: V): V
 "compute"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: character, arg1: $Char2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: character, arg1: $IntFunction$Type<(any)>): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "char2ObjectEntrySet"(): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: character, arg1: $Char2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: character): V
 "get"(arg0: character): V
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Char2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Char2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Char2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: character, arg1: V): V
 "replace"(arg0: character, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: character, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: character, arg1: V): V
 "compute"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: character, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>
}

export namespace $Char2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V): $Map<(character), (V)>
function of<K, V>(): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V, arg16: character, arg17: V, arg18: character, arg19: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V, arg16: character, arg17: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V): $Map<(character), (V)>
function of<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V): $Map<(character), (V)>
function entry<K, V>(arg0: character, arg1: V): $Map$Entry<(character), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(character), (V)>
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectMap$Type<V> = ($Char2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectMap_<V> = $Char2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2IntFunction<K> extends $Function$0<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeInt"(arg0: any): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>

(arg0: any): integer
}

export namespace $Object2IntFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntFunction$Type<K> = ($Object2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntFunction_<K> = $Object2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ReferenceCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ReferenceCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceCollection$Type<K> = ($ReferenceCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceCollection_<K> = $ReferenceCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2BooleanFunction extends $Function$0<(short), (boolean)>, $IntPredicate {

 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate

(arg0: short): boolean
}

export namespace $Short2BooleanFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2BooleanFunction$Type = ($Short2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2BooleanFunction_ = $Short2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $FloatPredicate extends $Predicate<(float)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: float): boolean
 "test"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
 "or"(arg0: $FloatPredicate$Type): $FloatPredicate
 "or"(arg0: $DoublePredicate$Type): $FloatPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(float)>
 "and"(arg0: $FloatPredicate$Type): $FloatPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(float)>

(arg0: float): boolean
}

export namespace $FloatPredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(float)>
function isEqual<T>(arg0: any): $Predicate<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatPredicate$Type = ($FloatPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatPredicate_ = $FloatPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $BooleanIterable extends $Iterable<(boolean)> {

 "forEach"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $BooleanIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanIterable$Type = ($BooleanIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanIterable_ = $BooleanIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$BooleanIterator, $BooleanIterator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanIterator"

export interface $BooleanBidirectionalIterator extends $BooleanIterator, $ObjectBidirectionalIterator<(boolean)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): boolean
 "back"(arg0: integer): integer
 "previousBoolean"(): boolean
 "forEachRemaining"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextBoolean"(): boolean
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $BooleanBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanBidirectionalIterator$Type = ($BooleanBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanBidirectionalIterator_ = $BooleanBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $ShortComparator extends $Comparator<(short)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: short, arg1: short): integer
 "compare"(arg0: short, arg1: short): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
 "thenComparing"(arg0: $ShortComparator$Type): $ShortComparator
 "reversed"(): $ShortComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(short)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(short)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(short)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(short)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(short)>
}

export namespace $ShortComparator {
function reverseOrder<T>(): $Comparator<(short)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(short)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(short)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(short)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(short)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(short)>
function naturalOrder<T>(): $Comparator<(short)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortComparator$Type = ($ShortComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortComparator_ = $ShortComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2ObjectMap$Entry<V> extends $Map$Entry<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): long
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Long2ObjectMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$Entry$Type<V> = ($Long2ObjectMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap$Entry_<V> = $Long2ObjectMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2CharFunction extends $Function$0<(byte), (character)>, $IntUnaryOperator {

 "remove"(arg0: byte): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: byte): character
 "put"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): character
}

export namespace $Byte2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2CharFunction$Type = ($Byte2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2CharFunction_ = $Byte2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$ShortComparator, $ShortComparator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortComparator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ShortSpliterator, $ShortSpliterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortListIterator, $ShortListIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortListIterator"
import {$ShortUnaryOperator, $ShortUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortUnaryOperator"
import {$ShortCollection, $ShortCollection$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection"

export interface $ShortList extends $List<(short)>, $Comparable<($List<(any)>)>, $ShortCollection {

 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: short): void
 "add"(arg0: integer, arg1: short): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): short
 "indexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getShort"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: short): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $ShortUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(short)>): void
 "size"(arg0: integer): void
 "iterator"(): $ShortListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
 "addAll"(arg0: $ShortList$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortCollection$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortList$Type): boolean
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "sort"(arg0: $ShortComparator$Type): void
 "getElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (short)[]): void
 "setElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (short)[]): void
 "removeShort"(arg0: integer): short
 "unstableSort"(arg0: $ShortComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (short)[]): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortList {
function of(): $ShortList
function of(arg0: short): $ShortList
function of(arg0: short, arg1: short): $ShortList
function of(arg0: short, arg1: short, arg2: short): $ShortList
function of(...arg0: (short)[]): $ShortList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $List<(short)>
function of<E>(arg0: short, arg1: short): $List<(short)>
function of<E>(arg0: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $List<(short)>
function of<E>(...arg0: (short)[]): $List<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortList$Type = ($ShortList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortList_ = $ShortList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$AbstractReference2IntMap, $AbstractReference2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2IntMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$ReferenceSet, $ReferenceSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceSet"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Reference2IntMap, $Reference2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Reference2IntOpenHashMap<K> extends $AbstractReference2IntMap<(K)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Reference2IntMap$Type<(K)>, arg1: float)
constructor(arg0: $Reference2IntMap$Type<(K)>)
constructor(arg0: (K)[], arg1: (integer)[], arg2: float)
constructor(arg0: (K)[], arg1: (integer)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: integer): boolean
public "put"(arg0: K, arg1: integer): integer
public "hashCode"(): integer
public "getInt"(arg0: any): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer): integer
public "size"(): integer
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Reference2IntFunction$Type<(any)>): integer
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
public "keySet"(): $ReferenceSet<(K)>
public "containsValue"(arg0: integer): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
public "addTo"(arg0: K, arg1: integer): integer
public "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "removeInt"(arg0: any): integer
public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntOpenHashMap$Type<K> = ($Reference2IntOpenHashMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntOpenHashMap_<K> = $Reference2IntOpenHashMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongListIterator" {
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $LongListIterator extends $LongBidirectionalIterator, $ListIterator<(long)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: long): void
 "add"(arg0: long): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: long): void
 "set"(arg0: long): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousLong"(): long
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
}

export namespace $LongListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongListIterator$Type = ($LongListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongListIterator_ = $LongListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$AbstractBooleanList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$BooleanListIterator, $BooleanListIterator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanListIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BooleanCollection, $BooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$AbstractBooleanCollection, $AbstractBooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$AbstractBooleanCollection"
import {$BooleanStack, $BooleanStack$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanStack"
import {$BooleanComparator, $BooleanComparator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanComparator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BooleanList, $BooleanList$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanList"
import {$BooleanUnaryOperator, $BooleanUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanUnaryOperator"

export class $AbstractBooleanList extends $AbstractBooleanCollection implements $BooleanList, $BooleanStack {


public "add"(arg0: boolean): boolean
public "add"(arg0: integer, arg1: boolean): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: boolean): integer
public "clear"(): void
public "lastIndexOf"(arg0: boolean): integer
public "size"(arg0: integer): void
public "toArray"(arg0: (boolean)[]): (boolean)[]
public "iterator"(): $BooleanListIterator
public "contains"(arg0: boolean): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $BooleanCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $BooleanCollection$Type): boolean
public "set"(arg0: integer, arg1: boolean): boolean
public "forEach"(arg0: $BooleanConsumer$Type): void
public "listIterator"(): $BooleanListIterator
public "listIterator"(arg0: integer): $BooleanListIterator
public "rem"(arg0: boolean): boolean
public "push"(arg0: boolean): void
public "getElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
public "toBooleanArray"(): (boolean)[]
public "setElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
public "removeBoolean"(arg0: integer): boolean
public "popBoolean"(): boolean
public "topBoolean"(): boolean
public "peekBoolean"(arg0: integer): boolean
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (boolean)[]): void
public "addElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: boolean): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getBoolean"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(boolean)>): void
public "replaceAll"(arg0: $BooleanUnaryOperator$Type): void
public static "of"(...arg0: (boolean)[]): $BooleanList
public static "of"(): $BooleanList
public static "of"(arg0: boolean, arg1: boolean): $BooleanList
public static "of"(arg0: boolean): $BooleanList
public static "of"(arg0: boolean, arg1: boolean, arg2: boolean): $BooleanList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $BooleanList$Type): boolean
public "addAll"(arg0: integer, arg1: $BooleanList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: boolean): boolean
public "sort"(arg0: $BooleanComparator$Type): void
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (boolean)[]): void
public "setElements"(arg0: (boolean)[]): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "unstableSort"(arg0: $BooleanComparator$Type): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "push"(arg0: boolean): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(boolean)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean): $List<(boolean)>
public static "of"<E>(...arg0: (boolean)[]): $List<(boolean)>
set "elements"(value: (boolean)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBooleanList$Type = ($AbstractBooleanList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractBooleanList_ = $AbstractBooleanList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceArrayList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ReferenceList, $ReferenceList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceList"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractReferenceList, $AbstractReferenceList$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReferenceList"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ReferenceArrayList<K> extends $AbstractReferenceList<(K)> implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $ReferenceCollection$Type<(any)>)
constructor(arg0: $ReferenceList$Type<(any)>)
constructor(arg0: (K)[])
constructor(arg0: (K)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $ObjectIterator$Type<(any)>)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: K): void
public "add"(arg0: K): boolean
public "remove"(arg0: any): boolean
public "remove"(arg0: integer): K
public "get"(arg0: integer): K
public "equals"(arg0: any): boolean
public "equals"(arg0: $ReferenceArrayList$Type<(K)>): boolean
public "indexOf"(arg0: any): integer
public "clear"(): void
public static "wrap"<K>(arg0: (K)[]): $ReferenceArrayList<(K)>
public static "wrap"<K>(arg0: (K)[], arg1: integer): $ReferenceArrayList<(K)>
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "size"(arg0: integer): void
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<K>(arg0: (K)[]): (K)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "toList"<K>(): $Collector<(K), (any), ($ReferenceArrayList<(K)>)>
public static "of"<K>(...arg0: (K)[]): $ReferenceArrayList<(K)>
public static "of"<K>(): $ReferenceArrayList<(K)>
public "elements"(): (K)[]
public "addAll"(arg0: integer, arg1: $ReferenceList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $Comparator$Type<(any)>): void
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "toListWithExpectedSize"<K>(arg0: integer): $Collector<(K), (any), ($ReferenceArrayList<(K)>)>
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ReferenceList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ReferenceList<(K)>
public static "of"<K>(arg0: K): $ReferenceList<(K)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceArrayList$Type<K> = ($ReferenceArrayList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceArrayList_<K> = $ReferenceArrayList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$BooleanListIterator, $BooleanListIterator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanListIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BooleanCollection, $BooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$BooleanPredicate, $BooleanPredicate$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanPredicate"
import {$BooleanComparator, $BooleanComparator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanComparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BooleanUnaryOperator, $BooleanUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanUnaryOperator"

export interface $BooleanList extends $List<(boolean)>, $Comparable<($List<(any)>)>, $BooleanCollection {

 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: boolean): void
 "add"(arg0: integer, arg1: boolean): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): boolean
 "indexOf"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getBoolean"(arg0: integer): boolean
 "lastIndexOf"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(boolean)>): void
 "replaceAll"(arg0: $BooleanUnaryOperator$Type): void
 "size"(arg0: integer): void
 "iterator"(): $BooleanListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $BooleanCollection$Type): boolean
 "addAll"(arg0: $BooleanList$Type): boolean
 "addAll"(arg0: integer, arg1: $BooleanList$Type): boolean
 "set"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: boolean): boolean
 "sort"(arg0: $BooleanComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "getElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (boolean)[]): void
 "setElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (boolean)[]): void
 "removeBoolean"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $BooleanComparator$Type): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (boolean)[]): void
 "addElements"(arg0: integer, arg1: (boolean)[], arg2: integer, arg3: integer): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (boolean)[]): (boolean)[]
 "contains"(arg0: boolean): boolean
 "addAll"(arg0: $BooleanCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $BooleanPredicate$Type): boolean
 "removeAll"(arg0: $BooleanCollection$Type): boolean
 "retainAll"(arg0: $BooleanCollection$Type): boolean
 "containsAll"(arg0: $BooleanCollection$Type): boolean
 "rem"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
 "toBooleanArray"(): (boolean)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(boolean)>
 "parallelStream"(): $Stream<(boolean)>
 "forEach"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $BooleanList {
function of(...arg0: (boolean)[]): $BooleanList
function of(): $BooleanList
function of(arg0: boolean, arg1: boolean): $BooleanList
function of(arg0: boolean): $BooleanList
function of(arg0: boolean, arg1: boolean, arg2: boolean): $BooleanList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean): $List<(boolean)>
function of<E>(arg0: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean): $List<(boolean)>
function of<E>(...arg0: (boolean)[]): $List<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanList$Type = ($BooleanList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanList_ = $BooleanList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharPredicate" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $CharPredicate extends $Predicate<(character)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: character): boolean
 "test"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $CharPredicate$Type): $CharPredicate
 "or"(arg0: $IntPredicate$Type): $CharPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(character)>
 "and"(arg0: $CharPredicate$Type): $CharPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(character)>

(arg0: character): boolean
}

export namespace $CharPredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(character)>
function isEqual<T>(arg0: any): $Predicate<(character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharPredicate$Type = ($CharPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharPredicate_ = $CharPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/$Pair" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"

export interface $Pair<L, R> {

 "value"(): R
 "value"(arg0: R): $Pair<(L), (R)>
 "first"(arg0: L): $Pair<(L), (R)>
 "first"(): L
 "second"(): R
 "second"(arg0: R): $Pair<(L), (R)>
 "key"(): L
 "key"(arg0: L): $Pair<(L), (R)>
 "left"(): L
 "left"(arg0: L): $Pair<(L), (R)>
 "right"(): R
 "right"(arg0: R): $Pair<(L), (R)>
}

export namespace $Pair {
function of<L, R>(arg0: L, arg1: R): $Pair<(L), (R)>
function lexComparator<L, R>(): $Comparator<($Pair<(L), (R)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pair$Type<L, R> = ($Pair<(L), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pair_<L, R> = $Pair$Type<(L), (R)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectLinkedOpenHashMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$AbstractObject2ObjectSortedMap, $AbstractObject2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectSortedMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2ObjectSortedMap, $Object2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectLinkedOpenHashMap<K, V> extends $AbstractObject2ObjectSortedMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "clone"(): $Object2ObjectLinkedOpenHashMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "comparator"(): $Comparator<(any)>
public "removeFirst"(): V
public "removeLast"(): V
public "firstKey"(): K
public "headMap"(arg0: K): $Object2ObjectSortedMap<(K), (V)>
public "tailMap"(arg0: K): $Object2ObjectSortedMap<(K), (V)>
public "lastKey"(): K
public "getAndMoveToFirst"(arg0: K): V
public "putAndMoveToLast"(arg0: K, arg1: V): V
public "getAndMoveToLast"(arg0: K): V
public "putAndMoveToFirst"(arg0: K, arg1: V): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectLinkedOpenHashMap$Type<K, V> = ($Object2ObjectLinkedOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectLinkedOpenHashMap_<K, V> = $Object2ObjectLinkedOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export class $AbstractLong2IntFunction implements $Long2IntFunction, $Serializable {


public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public "remove"(arg0: long): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): integer
public "get"(arg0: long): integer
public "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "getOrDefault"(arg0: long, arg1: integer): integer
public "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
public "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
public "composeInt"(arg0: $Int2LongFunction$Type): $Int2IntFunction
public "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2IntFunction
public "andThenByte"(arg0: $Int2ByteFunction$Type): $Long2ByteFunction
public "andThenShort"(arg0: $Int2ShortFunction$Type): $Long2ShortFunction
public "composeShort"(arg0: $Short2LongFunction$Type): $Short2IntFunction
public "andThenInt"(arg0: $Int2IntFunction$Type): $Long2IntFunction
public "andThenLong"(arg0: $Int2LongFunction$Type): $Long2LongFunction
public "composeLong"(arg0: $Long2LongFunction$Type): $Long2IntFunction
public "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2IntFunction<(T)>
public "andThenChar"(arg0: $Int2CharFunction$Type): $Long2CharFunction
public "composeFloat"(arg0: $Float2LongFunction$Type): $Float2IntFunction
public "andThenFloat"(arg0: $Int2FloatFunction$Type): $Long2FloatFunction
public "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Long2DoubleFunction
public "composeDouble"(arg0: $Double2LongFunction$Type): $Double2IntFunction
public "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
public "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2IntFunction<(T)>
public "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
public "composeChar"(arg0: $Char2LongFunction$Type): $Char2IntFunction
public "clear"(): void
public "size"(): integer
public "apply"(arg0: long): integer
public static "identity"<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2IntFunction$Type = ($AbstractLong2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2IntFunction_ = $AbstractLong2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$CharBidirectionalIterator, $CharBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharBidirectionalIterator"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $CharListIterator extends $CharBidirectionalIterator, $ListIterator<(character)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: character): void
 "add"(arg0: character): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: character): void
 "set"(arg0: character): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousChar"(): character
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextChar"(): character
}

export namespace $CharListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharListIterator$Type = ($CharListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharListIterator_ = $CharListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap$FastEntrySet" {
import {$Long2IntMap$Entry, $Long2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap$Entry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Long2IntMap$FastEntrySet extends $ObjectSet<($Long2IntMap$Entry)> {

 "fastIterator"(): $ObjectIterator<($Long2IntMap$Entry)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Long2IntMap$Entry$Type): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Long2IntMap$Entry)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Long2IntMap$Entry)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Long2IntMap$FastEntrySet {
function of<K>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type): $ObjectSet<($Long2IntMap$Entry)>
function of<K>(...arg0: ($Long2IntMap$Entry$Type)[]): $ObjectSet<($Long2IntMap$Entry)>
function of<K>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type): $ObjectSet<($Long2IntMap$Entry)>
function of<K>(): $ObjectSet<($Long2IntMap$Entry)>
function of<K>(arg0: $Long2IntMap$Entry$Type): $ObjectSet<($Long2IntMap$Entry)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type, arg5: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type, arg5: $Long2IntMap$Entry$Type, arg6: $Long2IntMap$Entry$Type, arg7: $Long2IntMap$Entry$Type, arg8: $Long2IntMap$Entry$Type, arg9: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type, arg5: $Long2IntMap$Entry$Type, arg6: $Long2IntMap$Entry$Type, arg7: $Long2IntMap$Entry$Type, arg8: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type, arg5: $Long2IntMap$Entry$Type, arg6: $Long2IntMap$Entry$Type, arg7: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
function of<E>(arg0: $Long2IntMap$Entry$Type, arg1: $Long2IntMap$Entry$Type, arg2: $Long2IntMap$Entry$Type, arg3: $Long2IntMap$Entry$Type, arg4: $Long2IntMap$Entry$Type, arg5: $Long2IntMap$Entry$Type, arg6: $Long2IntMap$Entry$Type): $Set<($Long2IntMap$Entry)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntMap$FastEntrySet$Type = ($Long2IntMap$FastEntrySet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntMap$FastEntrySet_ = $Long2IntMap$FastEntrySet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Reference2ReferenceMap$Entry, $Reference2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Reference2ReferenceMap<K, V> extends $Reference2ReferenceFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "values"(): $ReferenceCollection<(V)>
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "reference2ReferenceEntrySet"(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "get"(arg0: any): V
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Reference2ReferenceMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$Type<K, V> = ($Reference2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap_<K, V> = $Reference2ReferenceMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $IntBidirectionalIterator extends $IntIterator, $ObjectBidirectionalIterator<(integer)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBidirectionalIterator$Type = ($IntBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBidirectionalIterator_ = $IntBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Float2CharFunction extends $Function$0<(float), (character)>, $DoubleToIntFunction {

 "remove"(arg0: float): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: float): character
 "put"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): character

(arg0: float): character
}

export namespace $Float2CharFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2CharFunction$Type = ($Float2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2CharFunction_ = $Float2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction" {
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Boolean2ByteFunction extends $Function$0<(boolean), (byte)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
 "remove"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: boolean): byte
 "put"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: byte): byte
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): byte

(arg0: any): byte
}

export namespace $Boolean2ByteFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ByteFunction$Type = ($Boolean2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ByteFunction_ = $Boolean2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $IntBinaryOperator extends $BinaryOperator<(integer)>, $IntBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer, arg1: integer): integer
 "apply"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer, arg1: integer): integer
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(integer), (integer), (V)>

(arg0: integer, arg1: integer): integer
}

export namespace $IntBinaryOperator {
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(integer)>
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBinaryOperator$Type = ($IntBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBinaryOperator_ = $IntBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractIntSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$AbstractIntCollection, $AbstractIntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntCollection"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntSet, $IntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSet"

export class $AbstractIntSet extends $AbstractIntCollection implements $Cloneable, $IntSet {


public "remove"(arg0: integer): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
public "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: integer, arg1: integer): $IntSet
public static "of"(): $IntSet
public static "of"(...arg0: (integer)[]): $IntSet
public static "of"(arg0: integer): $IntSet
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntSet
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $IntSpliterator
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(integer)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
public static "of"<E>(arg0: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
public static "of"<E>(...arg0: (integer)[]): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $Set<(integer)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIntSet$Type = ($AbstractIntSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIntSet_ = $AbstractIntSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToLongFunction, $DoubleToLongFunction$Type} from "packages/java/util/function/$DoubleToLongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"

export interface $Float2LongFunction extends $Function$0<(float), (long)>, $DoubleToLongFunction {

 "remove"(arg0: float): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: float): long
 "put"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): long

(arg0: float): long
}

export namespace $Float2LongFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2LongFunction$Type = ($Float2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2LongFunction_ = $Float2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$ShortBidirectionalIterator, $ShortBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortBidirectionalIterator"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $ShortListIterator extends $ShortBidirectionalIterator, $ListIterator<(short)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: short): void
 "add"(arg0: short): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: short): void
 "set"(arg0: short): void
 "previousShort"(): short
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextShort"(): short
}

export namespace $ShortListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortListIterator$Type = ($ShortListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortListIterator_ = $ShortListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleMap" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Object2DoubleMap$Entry, $Object2DoubleMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleMap$Entry"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$Type as $DoubleBinaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleBinaryOperator"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$DoubleCollection, $DoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2DoubleMap<K> extends $Object2DoubleFunction<(K)>, $Map<(K), (double)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: double): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "values"(): $DoubleCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double, arg2: double): boolean
 "replace"(arg0: K, arg1: double, arg2: double): boolean
 "replace"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double): double
 "size"(): integer
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (double)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: double): double
 "putIfAbsent"(arg0: K, arg1: double): double
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): double
 "computeIfAbsent"(arg0: K, arg1: $Object2DoubleFunction$Type<(any)>): double
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: double): boolean
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "object2DoubleEntrySet"(): $ObjectSet<($Object2DoubleMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "mergeDouble"(arg0: K, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$0$Type): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$Type): double
 "computeDouble"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsentPartial"(arg0: K, arg1: $Object2DoubleFunction$Type<(any)>): double
 "computeDoubleIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): double
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Double2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2DoubleFunction
 "removeDouble"(arg0: any): double
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): double
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "apply"(arg0: K): double
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>
}

export namespace $Object2DoubleMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double): $Map<(K), (double)>
function of<K, V>(): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double, arg18: K, arg19: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double): $Map<(K), (double)>
function entry<K, V>(arg0: K, arg1: double): $Map$Entry<(K), (double)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (double)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleMap$Type<K> = ($Object2DoubleMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleMap_<K> = $Object2DoubleMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntOpenHashSet" {
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$AbstractIntSet, $AbstractIntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $IntOpenHashSet extends $AbstractIntSet implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>, arg1: float)
constructor(arg0: $IntIterator$Type)
constructor(arg0: $IntIterator$Type, arg1: float)
constructor(arg0: (integer)[])
constructor(arg0: (integer)[], arg1: float)
constructor(arg0: (integer)[], arg1: integer, arg2: integer)
constructor(arg0: (integer)[], arg1: integer, arg2: integer, arg3: float)
constructor(arg0: $Collection$Type<(any)>, arg1: float)
constructor()
constructor(arg0: integer)
constructor(arg0: integer, arg1: float)
constructor(arg0: $IntCollection$Type)
constructor(arg0: $IntCollection$Type, arg1: float)
constructor(arg0: $Collection$Type<(any)>)

public "add"(arg0: integer): boolean
public "remove"(arg0: integer): boolean
public "hashCode"(): integer
public "clone"(): $IntOpenHashSet
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $IntIterator
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public static "of"(): $IntOpenHashSet
public static "of"(arg0: integer): $IntOpenHashSet
public static "of"(arg0: integer, arg1: integer): $IntOpenHashSet
public static "of"(...arg0: (integer)[]): $IntOpenHashSet
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntOpenHashSet
public "contains"(arg0: integer): boolean
public "addAll"(arg0: $IntCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $IntConsumer$Type): void
public static "toSet"(arg0: $IntStream$Type): $IntOpenHashSet
public static "toSetWithExpectedSize"(arg0: $IntStream$Type, arg1: integer): $IntOpenHashSet
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntOpenHashSet$Type = ($IntOpenHashSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntOpenHashSet_ = $IntOpenHashSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $LongComparator extends $Comparator<(long)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: long, arg1: long): integer
 "compare"(arg0: long, arg1: long): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
 "thenComparing"(arg0: $LongComparator$Type): $LongComparator
 "reversed"(): $LongComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(long)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(long)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(long)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(long)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(long)>
}

export namespace $LongComparator {
function reverseOrder<T>(): $Comparator<(long)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(long)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(long)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(long)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(long)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(long)>
function naturalOrder<T>(): $Comparator<(long)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongComparator$Type = ($LongComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongComparator_ = $LongComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Long2ReferenceMap$Entry, $Long2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceMap$Entry"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ReferenceMap<V> extends $Long2ReferenceFunction<(V)>, $Map<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "size"(): integer
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (V)>)>
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ReferenceFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ReferenceFunction$Type<(any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "long2ReferenceEntrySet"(): $ObjectSet<($Long2ReferenceMap$Entry<(V)>)>
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Long2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Long2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ReferenceFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V): V
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}

export namespace $Long2ReferenceMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ReferenceMap$Type<V> = ($Long2ReferenceMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ReferenceMap_<V> = $Long2ReferenceMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Function" {
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"

export interface $Function<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Function {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$Type<K, V> = ($Function<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_<K, V> = $Function$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $ByteBinaryOperator extends $BinaryOperator<(byte)>, $IntBinaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: byte, arg1: byte): byte
 "apply"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer, arg1: integer): integer
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(byte), (byte), (V)>

(arg0: byte, arg1: byte): byte
}

export namespace $ByteBinaryOperator {
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(byte)>
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBinaryOperator$Type = ($ByteBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBinaryOperator_ = $ByteBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction" {
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"

export interface $Short2ShortFunction extends $Function<(short), (short)>, $IntUnaryOperator {

 "remove"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
 "get"(arg0: short): short
 "put"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(short), (T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): short
}

export namespace $Short2ShortFunction {
function identity(): $Short2ShortFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ShortFunction$Type = ($Short2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ShortFunction_ = $Short2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Boolean2ObjectFunction<V> extends $Function$0<(boolean), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Boolean2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Boolean2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (V)>

(arg0: any): V
}

export namespace $Boolean2ObjectFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ObjectFunction$Type<V> = ($Boolean2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ObjectFunction_<V> = $Boolean2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteList" {
import {$ByteListIterator, $ByteListIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteListIterator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ByteSpliterator, $ByteSpliterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteSpliterator"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$ByteCollection, $ByteCollection$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteCollection"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ByteUnaryOperator, $ByteUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteUnaryOperator"
import {$ByteComparator, $ByteComparator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteComparator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$BytePredicate, $BytePredicate$Type} from "packages/it/unimi/dsi/fastutil/bytes/$BytePredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ByteList extends $List<(byte)>, $Comparable<($List<(any)>)>, $ByteCollection {

 "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: byte): void
 "add"(arg0: integer, arg1: byte): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): byte
 "indexOf"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getByte"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: byte): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $ByteUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(byte)>): void
 "size"(arg0: integer): void
 "iterator"(): $ByteListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ByteSpliterator
 "addAll"(arg0: $ByteList$Type): boolean
 "addAll"(arg0: integer, arg1: $ByteCollection$Type): boolean
 "addAll"(arg0: integer, arg1: $ByteList$Type): boolean
 "set"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "sort"(arg0: $ByteComparator$Type): void
 "getElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (byte)[]): void
 "setElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (byte)[]): void
 "removeByte"(arg0: integer): byte
 "unstableSort"(arg0: $ByteComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (byte)[]): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (byte)[]): (byte)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(byte)>
 "intStream"(): $IntStream
 "contains"(arg0: byte): boolean
 "addAll"(arg0: $ByteCollection$Type): boolean
 "toByteArray"(): (byte)[]
/**
 * 
 * @deprecated
 */
 "toByteArray"(arg0: (byte)[]): (byte)[]
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $BytePredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ByteCollection$Type): boolean
 "retainAll"(arg0: $ByteCollection$Type): boolean
 "containsAll"(arg0: $ByteCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(byte)>
 "rem"(arg0: byte): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ByteConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ByteList {
function of(): $ByteList
function of(arg0: byte): $ByteList
function of(arg0: byte, arg1: byte): $ByteList
function of(arg0: byte, arg1: byte, arg2: byte): $ByteList
function of(...arg0: (byte)[]): $ByteList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte): $List<(byte)>
function of<E>(arg0: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte, arg8: byte, arg9: byte): $List<(byte)>
function of<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte, arg8: byte): $List<(byte)>
function of<E>(...arg0: (byte)[]): $List<(byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteList$Type = ($ByteList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteList_ = $ByteList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2IntMap$Entry extends $Map$Entry<(integer), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntKey"(): integer
 "getIntValue"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Int2IntMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (integer)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntMap$Entry$Type = ($Int2IntMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntMap$Entry_ = $Int2IntMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Char2ObjectMap$Entry<V> extends $Map$Entry<(character), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): character
 "getCharKey"(): character
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Char2ObjectMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(character), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(character), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(character), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(character), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(character), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectMap$Entry$Type<V> = ($Char2ObjectMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectMap$Entry_<V> = $Char2ObjectMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanMap" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$BooleanCollection, $BooleanCollection$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Object2BooleanMap$Entry, $Object2BooleanMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanMap$Entry"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2BooleanMap<K> extends $Object2BooleanFunction<(K)>, $Map<(K), (boolean)> {

 "remove"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
 "values"(): $BooleanCollection
 "clear"(): void
 "replace"(arg0: K, arg1: boolean, arg2: boolean): boolean
 "replace"(arg0: K, arg1: boolean): boolean
 "size"(): integer
 "merge"(arg0: K, arg1: boolean, arg2: $BiFunction$Type<(any), (any), (any)>): boolean
 "putIfAbsent"(arg0: K, arg1: boolean): boolean
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2BooleanFunction$Type<(any)>): boolean
 "computeIfAbsent"(arg0: K, arg1: $Predicate$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "object2BooleanEntrySet"(): $ObjectSet<($Object2BooleanMap$Entry<(K)>)>
 "computeBooleanIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): boolean
/**
 * 
 * @deprecated
 */
 "computeBooleanIfAbsent"(arg0: K, arg1: $Predicate$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
 "computeBooleanIfAbsentPartial"(arg0: K, arg1: $Object2BooleanFunction$Type<(any)>): boolean
 "computeBoolean"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): boolean
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeBoolean"(arg0: any): boolean
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2BooleanFunction
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: K, arg1: boolean): boolean
 "replace"(arg0: K, arg1: boolean, arg2: boolean): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: K, arg1: boolean, arg2: $BiFunction$Type<(any), (any), (any)>): boolean
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: K, arg1: boolean): boolean
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): boolean
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): boolean
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): boolean
 "apply"(arg0: K): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>
}

export namespace $Object2BooleanMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean): $Map<(K), (boolean)>
function of<K, V>(): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean, arg10: K, arg11: boolean, arg12: K, arg13: boolean, arg14: K, arg15: boolean, arg16: K, arg17: boolean, arg18: K, arg19: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean, arg10: K, arg11: boolean, arg12: K, arg13: boolean, arg14: K, arg15: boolean, arg16: K, arg17: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean, arg10: K, arg11: boolean, arg12: K, arg13: boolean, arg14: K, arg15: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean, arg10: K, arg11: boolean, arg12: K, arg13: boolean): $Map<(K), (boolean)>
function of<K, V>(arg0: K, arg1: boolean, arg2: K, arg3: boolean, arg4: K, arg5: boolean, arg6: K, arg7: boolean, arg8: K, arg9: boolean, arg10: K, arg11: boolean): $Map<(K), (boolean)>
function entry<K, V>(arg0: K, arg1: boolean): $Map$Entry<(K), (boolean)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (boolean)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2BooleanMap$Type<K> = ($Object2BooleanMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2BooleanMap_<K> = $Object2BooleanMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $IntComparator extends $Comparator<(integer)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: integer, arg1: integer): integer
 "compare"(arg0: integer, arg1: integer): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
 "thenComparing"(arg0: $IntComparator$Type): $IntComparator
 "reversed"(): $IntComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(integer)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(integer)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(integer)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(integer)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(integer)>
}

export namespace $IntComparator {
function reverseOrder<T>(): $Comparator<(integer)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(integer)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(integer)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(integer)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(integer)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(integer)>
function naturalOrder<T>(): $Comparator<(integer)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntComparator$Type = ($IntComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntComparator_ = $IntComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"

export interface $LongBidirectionalIterator extends $LongIterator, $ObjectBidirectionalIterator<(long)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): long
 "back"(arg0: integer): integer
 "previousLong"(): long
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterator$Type = ($LongBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterator_ = $LongBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$AbstractChar2ObjectFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export class $AbstractChar2ObjectFunction<V> implements $Char2ObjectFunction<(V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
public "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: character, arg1: V): V
public "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
public "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: character): boolean
public "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
public "composeInt"(arg0: $Int2CharFunction$Type): $Int2ObjectFunction<(V)>
public "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ObjectFunction<(V)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Char2ByteFunction
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Char2ShortFunction
public "composeShort"(arg0: $Short2CharFunction$Type): $Short2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Char2IntFunction
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Char2LongFunction
public "composeLong"(arg0: $Long2CharFunction$Type): $Long2ObjectFunction<(V)>
public "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Char2CharFunction
public "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Char2FloatFunction
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Char2DoubleFunction
public "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ObjectFunction<(V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
public "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
public "composeChar"(arg0: $Char2CharFunction$Type): $Char2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: character): V
public static "identity"<T>(): $Function<(character), (character)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChar2ObjectFunction$Type<V> = ($AbstractChar2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractChar2ObjectFunction_<V> = $AbstractChar2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2DoubleFunction extends $Function$0<(boolean), (double)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
 "remove"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: boolean): double
 "put"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: double): double
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): double

(arg0: any): double
}

export namespace $Boolean2DoubleFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2DoubleFunction$Type = ($Boolean2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2DoubleFunction_ = $Boolean2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Byte2ObjectFunction<V> extends $Function$0<(byte), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Byte2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Byte2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Byte2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (V)>

(arg0: any): V
}

export namespace $Byte2ObjectFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ObjectFunction$Type<V> = ($Byte2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ObjectFunction_<V> = $Byte2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Object2ByteFunction<K> extends $Function$0<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
 "put"(arg0: K, arg1: byte): byte
 "getByte"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeByte"(arg0: any): byte
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (byte)>

(arg0: any): byte
}

export namespace $Object2ByteFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ByteFunction$Type<K> = ($Object2ByteFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ByteFunction_<K> = $Object2ByteFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2ReferenceMap" {
import {$Reference2ReferenceMap$Entry, $Reference2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Reference2ReferenceMap, $Reference2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractReference2ReferenceFunction, $AbstractReference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2ReferenceFunction"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractReference2ReferenceMap<K, V> extends $AbstractReference2ReferenceFunction<(K), (V)> implements $Reference2ReferenceMap<(K), (V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ReferenceCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "put"(arg0: K, arg1: V): V
public "clear"(): void
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "reference2ReferenceEntrySet"(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
public "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2ReferenceMap$Type<K, V> = ($AbstractReference2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2ReferenceMap_<K, V> = $AbstractReference2ReferenceMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Object2ReferenceFunction<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>

(arg0: any): V
}

export namespace $Object2ReferenceFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceFunction$Type<K, V> = ($Object2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceFunction_<K, V> = $Object2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Float2DoubleFunction extends $Function$0<(float), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: float): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: float): double
 "put"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Float2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Float2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Float2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Float2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Float2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): double
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: float): double
}

export namespace $Float2DoubleFunction {
function identity(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2DoubleFunction$Type = ($Float2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2DoubleFunction_ = $Float2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2DoubleFunction<K> extends $Function$0<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Double2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2DoubleFunction
 "removeDouble"(arg0: any): double
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>

(arg0: any): double
}

export namespace $Reference2DoubleFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2DoubleFunction$Type<K> = ($Reference2DoubleFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2DoubleFunction_<K> = $Reference2DoubleFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $IntIterable extends $Iterable<(integer)> {

 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $IntIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterable$Type = ($IntIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterable_ = $IntIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharIterator, $CharIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharIterator"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $CharBidirectionalIterator extends $CharIterator, $ObjectBidirectionalIterator<(character)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): character
 "back"(arg0: integer): integer
 "previousChar"(): character
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextChar"(): character
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $CharBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharBidirectionalIterator$Type = ($CharBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharBidirectionalIterator_ = $CharBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanPredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $BooleanPredicate extends $Predicate<(boolean)> {

/**
 * 
 * @deprecated
 */
 "test"(arg0: boolean): boolean
 "test"(arg0: boolean): boolean
 "or"(arg0: $BooleanPredicate$Type): $BooleanPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(boolean)>
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(boolean)>
 "and"(arg0: $BooleanPredicate$Type): $BooleanPredicate

(arg0: boolean): boolean
}

export namespace $BooleanPredicate {
function identity(): $BooleanPredicate
function negation(): $BooleanPredicate
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(boolean)>
function isEqual<T>(arg0: any): $Predicate<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanPredicate$Type = ($BooleanPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanPredicate_ = $BooleanPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2IntMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2IntMap$Entry, $Reference2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap$Entry"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractReference2IntFunction, $AbstractReference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2IntFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Reference2IntMap, $Reference2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntMap"

export class $AbstractReference2IntMap<K> extends $AbstractReference2IntFunction<(K)> implements $Reference2IntMap<(K)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: integer): boolean
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
public "clear"(): void
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer): integer
public "size"(): integer
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
public "computeIfAbsent"(arg0: K, arg1: $Reference2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
public "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
public "reference2IntEntrySet"(): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsentPartial"(arg0: K, arg1: $Reference2IntFunction$Type<(any)>): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
public static "of"<K, V>(): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
public static "identity"<T>(): $Function<(K), (K)>
[index: string | number]: integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2IntMap$Type<K> = ($AbstractReference2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2IntMap_<K> = $AbstractReference2IntMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$AbstractLong2IntMap, $AbstractLong2IntMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2IntMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Long2IntMap, $Long2IntMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Long2IntOpenHashMap extends $AbstractLong2IntMap implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Long2IntMap$Type, arg1: float)
constructor(arg0: $Long2IntMap$Type)
constructor(arg0: (long)[], arg1: (integer)[], arg2: float)
constructor(arg0: (long)[], arg1: (integer)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: long, arg1: integer): boolean
public "remove"(arg0: long): integer
public "get"(arg0: long): integer
public "put"(arg0: long, arg1: integer): integer
public "hashCode"(): integer
public "clone"(): $Long2IntOpenHashMap
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: integer, arg2: integer): boolean
public "replace"(arg0: long, arg1: integer): integer
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: long, arg1: integer): integer
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $LongToIntFunction$Type): integer
public "computeIfAbsent"(arg0: long, arg1: $Long2IntFunction$Type): integer
public "containsValue"(arg0: integer): boolean
public "getOrDefault"(arg0: long, arg1: integer): integer
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "addTo"(arg0: long, arg1: integer): integer
public "computeIfAbsentNullable"(arg0: long, arg1: $LongFunction$Type<(any)>): integer
public "defaultReturnValue"(): integer
public "defaultReturnValue"(arg0: integer): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntOpenHashMap$Type = ($Long2IntOpenHashMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntOpenHashMap_ = $Long2IntOpenHashMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectCollection" {
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export class $AbstractObjectCollection<K> extends $AbstractCollection<(K)> implements $ObjectCollection<(K)> {


public "toString"(): string
public "iterator"(): $ObjectIterator<(K)>
public "spliterator"(): $ObjectSpliterator<(K)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectCollection$Type<K> = ($AbstractObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectCollection_<K> = $AbstractObjectCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"

export interface $FloatUnaryOperator extends $UnaryOperator<(float)>, $DoubleUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: float): float
 "apply"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(float), (V)>

(arg0: float): float
}

export namespace $FloatUnaryOperator {
function identity(): $FloatUnaryOperator
function negation(): $FloatUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatUnaryOperator$Type = ($FloatUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatUnaryOperator_ = $FloatUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"

export interface $Double2DoubleFunction extends $Function<(double), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
 "get"(arg0: double): double
 "put"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: double, arg1: double): double
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(double), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: double): double
}

export namespace $Double2DoubleFunction {
function identity(): $Double2DoubleFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2DoubleFunction$Type = ($Double2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2DoubleFunction_ = $Double2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"

export interface $CharSpliterator extends $Spliterator$OfPrimitive<(character), ($CharConsumer), ($CharSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $CharConsumer$Type): void
 "tryAdvance"(arg0: $CharConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $CharSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharSpliterator$Type = ($CharSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharSpliterator_ = $CharSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectOpenHashMap" {
import {$AbstractLong2ObjectMap, $AbstractLong2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Long2ObjectOpenHashMap<V> extends $AbstractLong2ObjectMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Long2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: long, arg1: any): boolean
public "remove"(arg0: long): V
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "keySet"(): $LongSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectOpenHashMap$Type<V> = ($Long2ObjectOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectOpenHashMap_<V> = $Long2ObjectOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatArrayList" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractFloatList, $AbstractFloatList$Type} from "packages/it/unimi/dsi/fastutil/floats/$AbstractFloatList"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$FloatIterator, $FloatIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$FloatList, $FloatList$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatList"
import {$FloatComparator, $FloatComparator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatComparator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $FloatArrayList extends $AbstractFloatList implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $FloatCollection$Type)
constructor(arg0: $FloatList$Type)
constructor(arg0: (float)[])
constructor(arg0: (float)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $FloatIterator$Type)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: float): void
public "add"(arg0: float): boolean
public "equals"(arg0: $FloatArrayList$Type): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $FloatArrayList$Type): integer
public "indexOf"(arg0: float): integer
public "getFloat"(arg0: integer): float
public "clear"(): void
public static "wrap"(arg0: (float)[], arg1: integer): $FloatArrayList
public static "wrap"(arg0: (float)[]): $FloatArrayList
public "lastIndexOf"(arg0: float): integer
public "isEmpty"(): boolean
public "size"(): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $FloatList
public "toArray"(arg0: (float)[]): (float)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "of"(...arg0: (float)[]): $FloatArrayList
public static "of"(): $FloatArrayList
public "elements"(): (float)[]
public "addAll"(arg0: integer, arg1: $FloatList$Type): boolean
public "addAll"(arg0: integer, arg1: $FloatCollection$Type): boolean
public "set"(arg0: integer, arg1: float): float
public "forEach"(arg0: $FloatConsumer$Type): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $FloatComparator$Type): void
public "removeAll"(arg0: $FloatCollection$Type): boolean
public "rem"(arg0: float): boolean
public "getElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
public "unstableSort"(arg0: $FloatComparator$Type): void
public "removeFloat"(arg0: integer): float
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: float): $FloatList
public static "of"(arg0: float, arg1: float): $FloatList
public static "of"(arg0: float, arg1: float, arg2: float): $FloatList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatArrayList$Type = ($FloatArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatArrayList_ = $FloatArrayList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2IntFunction extends $Function$0<(boolean), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "remove"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: boolean): integer
 "put"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: integer): integer
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Boolean2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Boolean2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Boolean2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Boolean2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Boolean2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): integer

(arg0: any): integer
}

export namespace $Boolean2IntFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2IntFunction$Type = ($Boolean2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2IntFunction_ = $Boolean2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectSortedMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Object2ObjectSortedMap, $Object2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2ObjectSortedMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Object2ObjectSortedMap<(K), (V)> {


public "comparator"(): $Comparator<(any)>
public "object2ObjectEntrySet"(): $ObjectSortedSet<($Object2ObjectMap$Entry<(K), (V)>)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "firstKey"(): K
public "lastKey"(): K
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectSortedMap$Type<K, V> = ($AbstractObject2ObjectSortedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectSortedMap_<K, V> = $AbstractObject2ObjectSortedMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReferenceCollection" {
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export class $AbstractReferenceCollection<K> extends $AbstractCollection<(K)> implements $ReferenceCollection<(K)> {


public "toString"(): string
public "iterator"(): $ObjectIterator<(K)>
public "spliterator"(): $ObjectSpliterator<(K)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReferenceCollection$Type<K> = ($AbstractReferenceCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReferenceCollection_<K> = $AbstractReferenceCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"

export interface $Long2FloatFunction extends $Function$0<(long), (float)>, $LongToDoubleFunction {

 "remove"(arg0: long): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: long): float
 "put"(arg0: long, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: long, arg1: float): float
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): float

(arg0: long): float
}

export namespace $Long2FloatFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2FloatFunction$Type = ($Long2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2FloatFunction_ = $Long2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$LongSortedSet, $LongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ObjectSortedMap<V> extends $Long2ObjectMap<(V)>, $SortedMap<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSortedSet<($Map$Entry<(long), (V)>)>
 "keySet"(): $LongSortedSet
 "comparator"(): $LongComparator
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
 "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
 "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
 "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
 "firstLongKey"(): long
 "lastLongKey"(): long
 "long2ObjectEntrySet"(): $ObjectSortedSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "size"(): integer
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V): V
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}

export namespace $Long2ObjectSortedMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectSortedMap$Type<V> = ($Long2ObjectSortedMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectSortedMap_<V> = $Long2ObjectSortedMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Hash" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash {

}

export namespace $Hash {
const DEFAULT_INITIAL_SIZE: integer
const DEFAULT_LOAD_FACTOR: float
const FAST_LOAD_FACTOR: float
const VERY_FAST_LOAD_FACTOR: float
const DEFAULT_GROWTH_FACTOR: integer
const FREE: byte
const OCCUPIED: byte
const REMOVED: byte
const PRIMES: (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$Type = ($Hash);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash_ = $Hash$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Long2CharFunction extends $Function$0<(long), (character)>, $LongToIntFunction {

 "remove"(arg0: long): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: long): character
 "put"(arg0: long, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: long, arg1: character): character
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): character

(arg0: long): character
}

export namespace $Long2CharFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2CharFunction$Type = ($Long2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2CharFunction_ = $Long2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export class $AbstractReference2IntFunction<K> implements $Reference2IntFunction<(K)>, $Serializable {


public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
public "put"(arg0: K, arg1: integer): integer
public "getInt"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "getOrDefault"(arg0: any, arg1: integer): integer
public "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
public "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
public "removeInt"(arg0: any): integer
public "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2IntFunction
public "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2IntFunction
public "andThenByte"(arg0: $Int2ByteFunction$Type): $Reference2ByteFunction<(K)>
public "andThenShort"(arg0: $Int2ShortFunction$Type): $Reference2ShortFunction<(K)>
public "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2IntFunction
public "andThenInt"(arg0: $Int2IntFunction$Type): $Reference2IntFunction<(K)>
public "andThenLong"(arg0: $Int2LongFunction$Type): $Reference2LongFunction<(K)>
public "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2IntFunction
public "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
public "andThenChar"(arg0: $Int2CharFunction$Type): $Reference2CharFunction<(K)>
public "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2IntFunction
public "andThenFloat"(arg0: $Int2FloatFunction$Type): $Reference2FloatFunction<(K)>
public "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
public "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2IntFunction
public "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
public "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
public "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2IntFunction
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): integer
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2IntFunction$Type<K> = ($AbstractReference2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2IntFunction_<K> = $AbstractReference2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Int2CharFunction extends $Function$0<(integer), (character)>, $IntUnaryOperator {

 "remove"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: integer): character
 "put"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: integer, arg1: character): character
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): character
}

export namespace $Int2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2CharFunction$Type = ($Int2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2CharFunction_ = $Int2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2ObjectMap<K, V> extends $Object2ObjectFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "get"(arg0: any): V
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Object2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$Type<K, V> = ($Object2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap_<K, V> = $Object2ObjectMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2BooleanFunction extends $Function$0<(character), (boolean)>, $IntPredicate {

 "remove"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: boolean): boolean
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate

(arg0: character): boolean
}

export namespace $Char2BooleanFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2BooleanFunction$Type = ($Char2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2BooleanFunction_ = $Char2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"

export interface $BooleanUnaryOperator extends $UnaryOperator<(boolean)> {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: boolean): boolean
 "apply"(arg0: boolean): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (V)>

(arg0: boolean): boolean
}

export namespace $BooleanUnaryOperator {
function identity(): $BooleanUnaryOperator
function negation(): $BooleanUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanUnaryOperator$Type = ($BooleanUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanUnaryOperator_ = $BooleanUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Reference2ByteFunction<K> extends $Function$0<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
 "put"(arg0: K, arg1: byte): byte
 "getByte"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeByte"(arg0: any): byte
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ByteFunction
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ByteFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ByteFunction<(T)>
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ByteFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (byte)>

(arg0: any): byte
}

export namespace $Reference2ByteFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ByteFunction$Type<K> = ($Reference2ByteFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ByteFunction_<K> = $Reference2ByteFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Stack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Stack<K> {

 "isEmpty"(): boolean
 "top"(): K
 "peek"(arg0: integer): K
 "push"(arg0: K): void
 "pop"(): K
}

export namespace $Stack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stack$Type<K> = ($Stack<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Stack_<K> = $Stack$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"

export interface $LongIterable extends $Iterable<(long)> {

 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
}

export namespace $LongIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterable$Type = ($LongIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterable_ = $LongIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Double2CharFunction extends $Function$0<(double), (character)>, $DoubleToIntFunction {

 "remove"(arg0: double): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: double): character
 "put"(arg0: double, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: double, arg1: character): character
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2CharFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2CharFunction
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenChar"(arg0: $Char2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2CharFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): character

(arg0: double): character
}

export namespace $Double2CharFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2CharFunction$Type = ($Double2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2CharFunction_ = $Double2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2FloatFunction<K> extends $Function$0<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2FloatFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Float2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>

(arg0: any): float
}

export namespace $Reference2FloatFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2FloatFunction$Type<K> = ($Reference2FloatFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2FloatFunction_<K> = $Reference2FloatFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Long2IntFunction extends $Function$0<(long), (integer)>, $LongToIntFunction {

 "remove"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: long): integer
 "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: long, arg1: integer): integer
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): integer

(arg0: long): integer
}

export namespace $Long2IntFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntFunction$Type = ($Long2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntFunction_ = $Long2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntIterable, $IntIterable$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterable"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntCollection extends $Collection<(integer)>, $IntIterable {

 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
 "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntCollection$Type = ($IntCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntCollection_ = $IntCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$Type as $DoubleUnaryOperator$0$Type} from "packages/java/util/function/$DoubleUnaryOperator"

export interface $DoubleUnaryOperator extends $UnaryOperator<(double)>, $DoubleUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): double
 "apply"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$0$Type): $DoubleUnaryOperator$0
 "andThen"(arg0: $DoubleUnaryOperator$0$Type): $DoubleUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: double): double
}

export namespace $DoubleUnaryOperator {
function identity(): $DoubleUnaryOperator
function negation(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleUnaryOperator$Type = ($DoubleUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleUnaryOperator_ = $DoubleUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanCollection" {
import {$BooleanIterable, $BooleanIterable$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanIterable"
import {$BooleanPredicate, $BooleanPredicate$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"

export interface $BooleanCollection extends $Collection<(boolean)>, $BooleanIterable {

 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (boolean)[]): (boolean)[]
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: boolean): boolean
 "addAll"(arg0: $BooleanCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $BooleanPredicate$Type): boolean
 "removeAll"(arg0: $BooleanCollection$Type): boolean
 "retainAll"(arg0: $BooleanCollection$Type): boolean
 "containsAll"(arg0: $BooleanCollection$Type): boolean
 "rem"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
 "toBooleanArray"(): (boolean)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(boolean)>
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<(boolean)>
 "forEach"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $BooleanCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanCollection$Type = ($BooleanCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanCollection_ = $BooleanCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2ReferenceMap$Entry<V> extends $Map$Entry<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): integer
 "getIntKey"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Int2ReferenceMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ReferenceMap$Entry$Type<V> = ($Int2ReferenceMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ReferenceMap$Entry_<V> = $Int2ReferenceMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2LongFunction extends $Function$0<(byte), (long)>, $IntToLongFunction {

 "remove"(arg0: byte): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: byte): long
 "put"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): long

(arg0: byte): long
}

export namespace $Byte2LongFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2LongFunction$Type = ($Byte2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2LongFunction_ = $Byte2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$ObjectList, $ObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectList"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractObjectCollection, $AbstractObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectCollection"
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export class $AbstractObjectList<K> extends $AbstractObjectCollection<(K)> implements $ObjectList<(K)>, $Stack<(K)> {


public "add"(arg0: K): boolean
public "add"(arg0: integer, arg1: K): void
public "remove"(arg0: integer): K
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "size"(arg0: integer): void
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "contains"(arg0: any): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "top"(): K
public "peek"(arg0: integer): K
public "listIterator"(): $ObjectListIterator<(K)>
public "push"(arg0: K): void
public "pop"(): K
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (K)[]): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "of"<K>(...arg0: (K)[]): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public "addAll"(arg0: $ObjectList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
public "sort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (K)[]): void
public "setElements"(arg0: (K)[]): void
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "isEmpty"(): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): K
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(K)>
public "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
public "size"(): integer
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
set "elements"(value: (K)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectList$Type<K> = ($AbstractObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectList_<K> = $AbstractObjectList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractReference2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export class $AbstractReference2ReferenceFunction<K, V> implements $Reference2ReferenceFunction<(K), (V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "getOrDefault"(arg0: any, arg1: V): V
public "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
public "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
public "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
public "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
public "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
public "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
public "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
public "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
public "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
public "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
public "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
public "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
public "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
public "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
public "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
public "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): V
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2ReferenceFunction$Type<K, V> = ($AbstractReference2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2ReferenceFunction_<K, V> = $AbstractReference2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LongBidirectionalIterable, $LongBidirectionalIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterable"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongSortedSet extends $LongSet, $SortedSet<(long)>, $LongBidirectionalIterable {

 "iterator"(arg0: long): $LongBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "first"(): long
 "subSet"(arg0: long, arg1: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: long, arg1: long): $LongSortedSet
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: long): $LongSortedSet
 "tailSet"(arg0: long): $LongSortedSet
 "lastLong"(): long
 "firstLong"(): long
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longParallelStream"(): $LongStream
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
}

export namespace $LongSortedSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSortedSet$Type = ($LongSortedSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSortedSet_ = $LongSortedSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLongCollection" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export class $AbstractLongCollection extends $AbstractCollection<(long)> implements $LongCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: long): boolean
public "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (long)[]): (long)[]
public "contains"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $LongCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $LongConsumer$0$Type): void
public "removeIf"(arg0: $LongPredicate$Type): boolean
public "removeAll"(arg0: $LongCollection$Type): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $LongCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $LongCollection$Type): boolean
public "rem"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "toLongArray"(arg0: (long)[]): (long)[]
public "toLongArray"(): (long)[]
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(long)>
public "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(long)>
public "longStream"(): $LongStream
public "longParallelStream"(): $LongStream
public "longIterator"(): $LongIterator
public "longSpliterator"(): $LongSpliterator
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLongCollection$Type = ($AbstractLongCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLongCollection_ = $AbstractLongCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $DoubleBidirectionalIterator extends $DoubleIterator, $ObjectBidirectionalIterator<(double)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): double
 "back"(arg0: integer): integer
 "previousDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "nextDouble"(): double
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBidirectionalIterator$Type = ($DoubleBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBidirectionalIterator_ = $DoubleBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharSet" {
import {$CharPredicate, $CharPredicate$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharPredicate"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharSpliterator, $CharSpliterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$CharCollection, $CharCollection$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharCollection"

export interface $CharSet extends $CharCollection, $Set<(character)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: character): boolean
 "remove"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $CharSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: character): boolean
 "add"(arg0: character): boolean
 "toArray"(arg0: (character)[]): (character)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(character)>
 "toCharArray"(): (character)[]
/**
 * 
 * @deprecated
 */
 "toCharArray"(arg0: (character)[]): (character)[]
 "intStream"(): $IntStream
 "contains"(arg0: character): boolean
 "addAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $CharPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $CharCollection$Type): boolean
 "retainAll"(arg0: $CharCollection$Type): boolean
 "containsAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(character)>
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $CharSet {
function of(arg0: character, arg1: character): $CharSet
function of(): $CharSet
function of(...arg0: (character)[]): $CharSet
function of(arg0: character): $CharSet
function of(arg0: character, arg1: character, arg2: character): $CharSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character): $Set<(character)>
function of<E>(arg0: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character, arg9: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character, arg8: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character, arg7: character): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character, arg3: character, arg4: character, arg5: character, arg6: character): $Set<(character)>
function of<E>(...arg0: (character)[]): $Set<(character)>
function of<E>(arg0: character, arg1: character, arg2: character): $Set<(character)>
function of<E>(arg0: character, arg1: character): $Set<(character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharSet$Type = ($CharSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharSet_ = $CharSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Char2ShortFunction extends $Function$0<(character), (short)>, $IntUnaryOperator {

 "remove"(arg0: character): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: character): short
 "put"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Char2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Char2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Char2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Char2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Char2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): short
}

export namespace $Char2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ShortFunction$Type = ($Char2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ShortFunction_ = $Char2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap$FastSortedEntrySet" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$Long2ObjectMap$FastEntrySet, $Long2ObjectMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$FastEntrySet"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Long2ObjectSortedMap$FastSortedEntrySet<V> extends $ObjectSortedSet<($Long2ObjectMap$Entry<(V)>)>, $Long2ObjectMap$FastEntrySet<(V)> {

 "fastIterator"(): $ObjectBidirectionalIterator<($Long2ObjectMap$Entry<(V)>)>
 "fastIterator"(arg0: $Long2ObjectMap$Entry$Type<(V)>): $ObjectBidirectionalIterator<($Long2ObjectMap$Entry<(V)>)>
 "iterator"(arg0: $Long2ObjectMap$Entry$Type<(V)>): $ObjectBidirectionalIterator<($Long2ObjectMap$Entry<(V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "last"(): $Long2ObjectMap$Entry<(V)>
 "first"(): $Long2ObjectMap$Entry<(V)>
 "comparator"(): $Comparator<(any)>
 "add"(arg0: $Long2ObjectMap$Entry$Type<(V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Long2ObjectSortedMap$FastSortedEntrySet {
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(...arg0: ($Long2ObjectMap$Entry$Type<(V)>)[]): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>, arg9: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectSortedMap$FastSortedEntrySet$Type<V> = ($Long2ObjectSortedMap$FastSortedEntrySet<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectSortedMap$FastSortedEntrySet_<V> = $Long2ObjectSortedMap$FastSortedEntrySet$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectFunction" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"

export class $AbstractObject2ObjectFunction<K, V> implements $Object2ObjectFunction<(K), (V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "getOrDefault"(arg0: any, arg1: V): V
public "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
public "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
public "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
public "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
public "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
public "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
public "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): V
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectFunction$Type<K, V> = ($AbstractObject2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectFunction_<K, V> = $AbstractObject2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$LongBinaryOperator as $LongBinaryOperator$0, $LongBinaryOperator$Type as $LongBinaryOperator$0$Type} from "packages/java/util/function/$LongBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $LongBinaryOperator extends $BinaryOperator<(long)>, $LongBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: long, arg1: long): long
 "apply"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long, arg1: long): long
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(long), (long), (V)>

(arg0: long, arg1: long): long
}

export namespace $LongBinaryOperator {
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(long)>
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBinaryOperator$Type = ($LongBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBinaryOperator_ = $LongBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2LongFunction<K> extends $Function$0<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeLong"(arg0: any): long
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2LongFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Long2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>

(arg0: any): long
}

export namespace $Object2LongFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongFunction$Type<K> = ($Object2LongFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongFunction_<K> = $Object2LongFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortBidirectionalIterator" {
import {$ShortIterator, $ShortIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $ShortBidirectionalIterator extends $ShortIterator, $ObjectBidirectionalIterator<(short)> {

 "previousShort"(): short
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextShort"(): short
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortBidirectionalIterator$Type = ($ShortBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortBidirectionalIterator_ = $ShortBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ByteConsumer extends $Consumer<(byte)>, $IntConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: byte): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: byte): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(byte)>
 "andThen"(arg0: $ByteConsumer$Type): $ByteConsumer

(arg0: byte): void
}

export namespace $ByteConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteConsumer$Type = ($ByteConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteConsumer_ = $ByteConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$AbstractChar2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$AbstractChar2ObjectFunction, $AbstractChar2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$AbstractChar2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Char2ObjectMap$Entry, $Char2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$Entry"
import {$Char2ObjectMap, $Char2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractChar2ObjectMap<V> extends $AbstractChar2ObjectFunction<(V)> implements $Char2ObjectMap<(V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: character): boolean
public "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: character, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: character, arg1: V): V
public "clear"(): void
public "replace"(arg0: character, arg1: V, arg2: V): boolean
public "replace"(arg0: character, arg1: V): V
public "size"(): integer
public "merge"(arg0: character, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(character), (V)>)>
public "putIfAbsent"(arg0: character, arg1: V): V
public "compute"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: character, arg1: $Char2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: character, arg1: $IntFunction$Type<(any)>): V
public "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "char2ObjectEntrySet"(): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: character, arg1: $Char2ObjectFunction$Type<(any)>): V
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(character), (V)>
public "replace"(arg0: character, arg1: V): V
public "replace"(arg0: character, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V): $Map<(character), (V)>
public static "of"<K, V>(): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V, arg16: character, arg17: V, arg18: character, arg19: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V, arg16: character, arg17: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V, arg14: character, arg15: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V, arg12: character, arg13: V): $Map<(character), (V)>
public static "of"<K, V>(arg0: character, arg1: V, arg2: character, arg3: V, arg4: character, arg5: V, arg6: character, arg7: V, arg8: character, arg9: V, arg10: character, arg11: V): $Map<(character), (V)>
public "merge"(arg0: character, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: character, arg1: V): V
public "compute"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: character, arg1: V): $Map$Entry<(character), (V)>
public "computeIfAbsent"(arg0: character, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: character, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(character), (V)>
public static "identity"<T>(): $Function<(character), (character)>
[index: string | number]: V
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChar2ObjectMap$Type<V> = ($AbstractChar2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractChar2ObjectMap_<V> = $AbstractChar2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLongSortedSet" {
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$LongSortedSet, $LongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AbstractLongSet, $AbstractLongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLongSet"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"

export class $AbstractLongSortedSet extends $AbstractLongSet implements $LongSortedSet {


public "iterator"(arg0: long): $LongBidirectionalIterator
/**
 * 
 * @deprecated
 */
public "first"(): long
public "subSet"(arg0: long, arg1: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
public "subSet"(arg0: long, arg1: long): $LongSortedSet
public "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
public "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
public "tailSet"(arg0: long): $LongSortedSet
public "tailSet"(arg0: long): $LongSortedSet
public "lastLong"(): long
public "firstLong"(): long
/**
 * 
 * @deprecated
 */
public "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: long, arg1: long): $LongSet
public static "of"(): $LongSet
public static "of"(...arg0: (long)[]): $LongSet
public static "of"(arg0: long): $LongSet
public static "of"(arg0: long, arg1: long, arg2: long): $LongSet
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
public static "of"<E>(arg0: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
public static "of"<E>(...arg0: (long)[]): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long): $Set<(long)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLongSortedSet$Type = ($AbstractLongSortedSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLongSortedSet_ = $AbstractLongSortedSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $BooleanComparator extends $Comparator<(boolean)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: boolean, arg1: boolean): integer
 "compare"(arg0: boolean, arg1: boolean): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(boolean)>
 "thenComparing"(arg0: $BooleanComparator$Type): $BooleanComparator
 "reversed"(): $BooleanComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(boolean)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(boolean)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(boolean)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(boolean)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(boolean)>
}

export namespace $BooleanComparator {
function reverseOrder<T>(): $Comparator<(boolean)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(boolean)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(boolean)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(boolean)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(boolean)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(boolean)>
function naturalOrder<T>(): $Comparator<(boolean)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(boolean)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanComparator$Type = ($BooleanComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanComparator_ = $BooleanComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLongSet" {
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$AbstractLongCollection, $AbstractLongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLongCollection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"

export class $AbstractLongSet extends $AbstractLongCollection implements $Cloneable, $LongSet {


public "remove"(arg0: long): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "iterator"(): $LongIterator
/**
 * 
 * @deprecated
 */
public "rem"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: long, arg1: long): $LongSet
public static "of"(): $LongSet
public static "of"(...arg0: (long)[]): $LongSet
public static "of"(arg0: long): $LongSet
public static "of"(arg0: long, arg1: long, arg2: long): $LongSet
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $LongSpliterator
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
public static "of"<E>(arg0: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
public static "of"<E>(...arg0: (long)[]): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
public static "of"<E>(arg0: long, arg1: long): $Set<(long)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLongSet$Type = ($AbstractLongSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLongSet_ = $AbstractLongSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterable" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ObjectBidirectionalIterable<K> extends $ObjectIterable<(K)> {

 "iterator"(): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void

(): $ObjectBidirectionalIterator<(K)>
}

export namespace $ObjectBidirectionalIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterable$Type<K> = ($ObjectBidirectionalIterable<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterable_<K> = $ObjectBidirectionalIterable$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Long2DoubleFunction extends $Function$0<(long), (double)>, $LongToDoubleFunction {

 "remove"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: long): double
 "put"(arg0: long, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: long, arg1: double): double
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2DoubleFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2DoubleFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenChar"(arg0: $Double2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2DoubleFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): double

(arg0: long): double
}

export namespace $Long2DoubleFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2DoubleFunction$Type = ($Long2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2DoubleFunction_ = $Long2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$PrimitiveIterator$OfDouble, $PrimitiveIterator$OfDouble$Type} from "packages/java/util/$PrimitiveIterator$OfDouble"

export interface $DoubleIterator extends $PrimitiveIterator$OfDouble {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "skip"(arg0: integer): integer
 "nextDouble"(): double
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterator$Type = ($DoubleIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterator_ = $DoubleIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractIntCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export class $AbstractIntCollection extends $AbstractCollection<(integer)> implements $IntCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (integer)[]): (integer)[]
public "contains"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $IntCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $IntConsumer$Type): void
public "removeIf"(arg0: $IntPredicate$Type): boolean
public "removeAll"(arg0: $IntCollection$Type): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $IntCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $IntCollection$Type): boolean
public "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "toIntArray"(arg0: (integer)[]): (integer)[]
public "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(integer)>
public "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $IntPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(integer)>
public "intSpliterator"(): $IntSpliterator
public "intIterator"(): $IntIterator
public "intParallelStream"(): $IntStream
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIntCollection$Type = ($AbstractIntCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIntCollection_ = $AbstractIntCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Long2ObjectFunction<V> extends $Function$0<(long), (V)>, $LongFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: any): V
}

export namespace $Long2ObjectFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectFunction$Type<V> = ($Long2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectFunction_<V> = $Long2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectSortedMap" {
import {$AbstractLong2ObjectMap, $AbstractLong2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Long2ObjectSortedMap, $Long2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AbstractLong2ObjectSortedMap<V> extends $AbstractLong2ObjectMap<(V)> implements $Long2ObjectSortedMap<(V)> {


/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSortedSet<($Map$Entry<(long), (V)>)>
public "comparator"(): $LongComparator
/**
 * 
 * @deprecated
 */
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "firstLongKey"(): long
public "lastLongKey"(): long
public "long2ObjectEntrySet"(): $ObjectSortedSet<($Long2ObjectMap$Entry<(V)>)>
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
public static "of"<K, V>(): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
public static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
public static "identity"<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectSortedMap$Type<V> = ($AbstractLong2ObjectSortedMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectSortedMap_<V> = $AbstractLong2ObjectSortedMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntArrayList" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$AbstractIntList, $AbstractIntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntList"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $IntArrayList extends $AbstractIntList implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $IntCollection$Type)
constructor(arg0: $IntList$Type)
constructor(arg0: (integer)[])
constructor(arg0: (integer)[], arg1: integer, arg2: integer)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $IntIterator$Type)
constructor(arg0: integer)

public "add"(arg0: integer): boolean
public "add"(arg0: integer, arg1: integer): void
public "equals"(arg0: $IntArrayList$Type): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $IntArrayList$Type): integer
public "indexOf"(arg0: integer): integer
public "getInt"(arg0: integer): integer
public "clear"(): void
public static "wrap"(arg0: (integer)[], arg1: integer): $IntArrayList
public static "wrap"(arg0: (integer)[]): $IntArrayList
public "lastIndexOf"(arg0: integer): integer
public "isEmpty"(): boolean
public "size"(arg0: integer): void
public "size"(): integer
public "toArray"(arg0: (integer)[]): (integer)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "toList"(arg0: $IntStream$Type): $IntArrayList
public static "of"(...arg0: (integer)[]): $IntArrayList
public static "of"(): $IntArrayList
public "elements"(): (integer)[]
public "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $IntList$Type): boolean
public "set"(arg0: integer, arg1: integer): integer
public "forEach"(arg0: $IntConsumer$Type): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $IntComparator$Type): void
public "removeAll"(arg0: $IntCollection$Type): boolean
public "rem"(arg0: integer): boolean
public "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "removeInt"(arg0: integer): integer
public "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public static "toListWithExpectedSize"(arg0: $IntStream$Type, arg1: integer): $IntArrayList
public "unstableSort"(arg0: $IntComparator$Type): void
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: integer, arg1: integer): $IntList
public static "of"(arg0: integer): $IntList
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntArrayList$Type = ($IntArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntArrayList_ = $IntArrayList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$Spliterator$OfInt, $Spliterator$OfInt$Type} from "packages/java/util/$Spliterator$OfInt"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntSpliterator extends $Spliterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $IntConsumer$Type): boolean
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "tryAdvance"(arg0: $IntConsumer$0$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $IntSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSpliterator$Type = ($IntSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSpliterator_ = $IntSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap$FastSortedEntrySet" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Object2ObjectMap$FastEntrySet, $Object2ObjectMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$FastEntrySet"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Object2ObjectSortedMap$FastSortedEntrySet<K, V> extends $ObjectSortedSet<($Object2ObjectMap$Entry<(K), (V)>)>, $Object2ObjectMap$FastEntrySet<(K), (V)> {

 "fastIterator"(): $ObjectBidirectionalIterator<($Object2ObjectMap$Entry<(K), (V)>)>
 "fastIterator"(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectBidirectionalIterator<($Object2ObjectMap$Entry<(K), (V)>)>
 "iterator"(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectBidirectionalIterator<($Object2ObjectMap$Entry<(K), (V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "last"(): $Object2ObjectMap$Entry<(K), (V)>
 "first"(): $Object2ObjectMap$Entry<(K), (V)>
 "comparator"(): $Comparator<(any)>
 "add"(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Object2ObjectMap$Entry<(K), (V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Object2ObjectMap$Entry<(K), (V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Object2ObjectSortedMap$FastSortedEntrySet {
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(...arg0: ($Object2ObjectMap$Entry$Type<(K), (V)>)[]): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function of<K>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>, arg8: $Object2ObjectMap$Entry$Type<(K), (V)>, arg9: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>, arg8: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>, arg7: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
function of<E>(arg0: $Object2ObjectMap$Entry$Type<(K), (V)>, arg1: $Object2ObjectMap$Entry$Type<(K), (V)>, arg2: $Object2ObjectMap$Entry$Type<(K), (V)>, arg3: $Object2ObjectMap$Entry$Type<(K), (V)>, arg4: $Object2ObjectMap$Entry$Type<(K), (V)>, arg5: $Object2ObjectMap$Entry$Type<(K), (V)>, arg6: $Object2ObjectMap$Entry$Type<(K), (V)>): $Set<($Object2ObjectMap$Entry<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectSortedMap$FastSortedEntrySet$Type<K, V> = ($Object2ObjectSortedMap$FastSortedEntrySet<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectSortedMap$FastSortedEntrySet_<K, V> = $Object2ObjectSortedMap$FastSortedEntrySet$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $ShortIterable extends $Iterable<(short)> {

 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $ShortIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterable$Type = ($ShortIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterable_ = $ShortIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $FloatBinaryOperator extends $BinaryOperator<(float)>, $DoubleBinaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: float, arg1: float): float
 "apply"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(float), (float), (V)>

(arg0: float, arg1: float): float
}

export namespace $FloatBinaryOperator {
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(float)>
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatBinaryOperator$Type = ($FloatBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatBinaryOperator_ = $FloatBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction" {
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Int2ReferenceFunction<V> extends $Function$0<(integer), (V)>, $IntFunction<(V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Int2ByteFunction
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Int2IntFunction
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: any): V
}

export namespace $Int2ReferenceFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ReferenceFunction$Type<V> = ($Int2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ReferenceFunction_<V> = $Int2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractIntList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$AbstractIntCollection, $AbstractIntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntListIterator, $IntListIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntStack, $IntStack$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntStack"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export class $AbstractIntList extends $AbstractIntCollection implements $IntList, $IntStack {


public "add"(arg0: integer): boolean
public "add"(arg0: integer, arg1: integer): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: integer): integer
public "clear"(): void
public "lastIndexOf"(arg0: integer): integer
public "replaceAll"(arg0: $IntUnaryOperator$Type): void
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $IntList
public "toArray"(arg0: (integer)[]): (integer)[]
public "contains"(arg0: integer): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $IntCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: integer): integer
public "forEach"(arg0: $IntConsumer$Type): void
public "listIterator"(arg0: integer): $IntListIterator
public "rem"(arg0: integer): boolean
public "push"(arg0: integer): void
public "toIntArray"(): (integer)[]
public "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "removeInt"(arg0: integer): integer
public "popInt"(): integer
public "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "peekInt"(arg0: integer): integer
public "topInt"(): integer
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (integer)[]): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
public "replaceAll"(arg0: $IntUnaryOperator$0$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
public static "of"(...arg0: (integer)[]): $IntList
public static "of"(): $IntList
public static "of"(arg0: integer, arg1: integer): $IntList
public static "of"(arg0: integer): $IntList
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $IntList$Type): boolean
public "addAll"(arg0: integer, arg1: $IntList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: integer): integer
public "sort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (integer)[]): void
public "setElements"(arg0: (integer)[]): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "unstableSort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public "push"(arg0: integer): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $List<(integer)>
public static "of"<E>(arg0: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
public static "of"<E>(...arg0: (integer)[]): $List<(integer)>
set "elements"(value: (integer)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIntList$Type = ($AbstractIntList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIntList_ = $AbstractIntList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongSet extends $LongCollection, $Set<(long)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $LongSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longParallelStream"(): $LongStream
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSet$Type = ($LongSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSet_ = $LongSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$PrimitiveIterator$OfInt, $PrimitiveIterator$OfInt$Type} from "packages/java/util/$PrimitiveIterator$OfInt"

export interface $IntIterator extends $PrimitiveIterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "skip"(arg0: integer): integer
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterator$Type = ($IntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterator_ = $IntIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharStack" {
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export interface $CharStack extends $Stack<(character)> {

/**
 * 
 * @deprecated
 */
 "peek"(arg0: integer): character
 "push"(arg0: character): void
/**
 * 
 * @deprecated
 */
 "push"(arg0: character): void
 "peekChar"(arg0: integer): character
 "popChar"(): character
 "topChar"(): character
 "isEmpty"(): boolean
}

export namespace $CharStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharStack$Type = ($CharStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharStack_ = $CharStack$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2LongFunction extends $Function$0<(integer), (long)>, $IntToLongFunction {

 "remove"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: integer): long
 "put"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: integer, arg1: long): long
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): long

(arg0: integer): long
}

export namespace $Int2LongFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2LongFunction$Type = ($Int2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2LongFunction_ = $Int2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2IntMap$Entry, $Long2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntMap$Entry"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2IntMap extends $Long2IntFunction, $Map<(long), (integer)> {

 "remove"(arg0: long, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: integer): integer
 "clear"(): void
 "replace"(arg0: long, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: long, arg1: integer): integer
 "replace"(arg0: long, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: long, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: long, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: long, arg1: integer): integer
 "putIfAbsent"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $LongToIntFunction$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): integer
 "computeIfAbsent"(arg0: long, arg1: $Long2IntFunction$Type): integer
 "containsValue"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: long, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: long, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
 "long2IntEntrySet"(): $ObjectSet<($Long2IntMap$Entry)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2IntFunction$Type): integer
 "computeIfAbsentNullable"(arg0: long, arg1: $LongFunction$Type<(any)>): integer
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "remove"(arg0: long): integer
 "get"(arg0: long): integer
 "put"(arg0: long, arg1: integer): integer
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2IntFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2IntFunction
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Long2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Long2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Long2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2IntFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenChar"(arg0: $Int2CharFunction$Type): $Long2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Long2FloatFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Long2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2IntFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: long): integer
}

export namespace $Long2IntMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer): $Map<(long), (integer)>
function of<K, V>(): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer, arg16: long, arg17: integer, arg18: long, arg19: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer, arg16: long, arg17: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer, arg14: long, arg15: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer, arg12: long, arg13: integer): $Map<(long), (integer)>
function of<K, V>(arg0: long, arg1: integer, arg2: long, arg3: integer, arg4: long, arg5: integer, arg6: long, arg7: integer, arg8: long, arg9: integer, arg10: long, arg11: integer): $Map<(long), (integer)>
function entry<K, V>(arg0: long, arg1: integer): $Map$Entry<(long), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (integer)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntMap$Type = ($Long2IntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntMap_ = $Long2IntMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2DoubleMap$Entry extends $Map$Entry<(integer), (double)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): double
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: double): double
 "setValue"(arg0: double): double
 "getIntKey"(): integer
 "getDoubleValue"(): double
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Int2DoubleMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (double)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (double)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleMap$Entry$Type = ($Int2DoubleMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleMap$Entry_ = $Int2DoubleMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharCollection" {
import {$CharPredicate, $CharPredicate$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharPredicate"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$CharIterator, $CharIterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharIterator"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CharSpliterator, $CharSpliterator$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharSpliterator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$CharConsumer, $CharConsumer$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharConsumer"
import {$CharIterable, $CharIterable$Type} from "packages/it/unimi/dsi/fastutil/chars/$CharIterable"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $CharCollection extends $Collection<(character)>, $CharIterable {

/**
 * 
 * @deprecated
 */
 "add"(arg0: character): boolean
 "add"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (character)[]): (character)[]
 "iterator"(): $CharIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(character)>
 "toCharArray"(): (character)[]
/**
 * 
 * @deprecated
 */
 "toCharArray"(arg0: (character)[]): (character)[]
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: character): boolean
 "spliterator"(): $CharSpliterator
 "addAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $CharPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $CharCollection$Type): boolean
 "retainAll"(arg0: $CharCollection$Type): boolean
 "containsAll"(arg0: $CharCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(character)>
 "rem"(arg0: character): boolean
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $CharConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $CharCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharCollection$Type = ($CharCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharCollection_ = $CharCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$BooleanListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$BooleanConsumer, $BooleanConsumer$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanConsumer"
import {$BooleanBidirectionalIterator, $BooleanBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/booleans/$BooleanBidirectionalIterator"

export interface $BooleanListIterator extends $BooleanBidirectionalIterator, $ListIterator<(boolean)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: boolean): void
 "add"(arg0: boolean): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: boolean): void
 "set"(arg0: boolean): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousBoolean"(): boolean
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $BooleanConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextBoolean"(): boolean
}

export namespace $BooleanListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanListIterator$Type = ($BooleanListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanListIterator_ = $BooleanListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$FastEntrySet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Char2ObjectMap$Entry, $Char2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectMap$Entry"

export interface $Char2ObjectMap$FastEntrySet<V> extends $ObjectSet<($Char2ObjectMap$Entry<(V)>)> {

 "fastIterator"(): $ObjectIterator<($Char2ObjectMap$Entry<(V)>)>
 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "add"(arg0: $Char2ObjectMap$Entry$Type<(V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Char2ObjectMap$Entry<(V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Char2ObjectMap$Entry<(V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Char2ObjectMap$FastEntrySet {
function of<K>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
function of<K>(...arg0: ($Char2ObjectMap$Entry$Type<(V)>)[]): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
function of<K>(): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Char2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Char2ObjectMap$Entry<(V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>, arg5: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>, arg5: $Char2ObjectMap$Entry$Type<(V)>, arg6: $Char2ObjectMap$Entry$Type<(V)>, arg7: $Char2ObjectMap$Entry$Type<(V)>, arg8: $Char2ObjectMap$Entry$Type<(V)>, arg9: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>, arg5: $Char2ObjectMap$Entry$Type<(V)>, arg6: $Char2ObjectMap$Entry$Type<(V)>, arg7: $Char2ObjectMap$Entry$Type<(V)>, arg8: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>, arg5: $Char2ObjectMap$Entry$Type<(V)>, arg6: $Char2ObjectMap$Entry$Type<(V)>, arg7: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Char2ObjectMap$Entry$Type<(V)>, arg1: $Char2ObjectMap$Entry$Type<(V)>, arg2: $Char2ObjectMap$Entry$Type<(V)>, arg3: $Char2ObjectMap$Entry$Type<(V)>, arg4: $Char2ObjectMap$Entry$Type<(V)>, arg5: $Char2ObjectMap$Entry$Type<(V)>, arg6: $Char2ObjectMap$Entry$Type<(V)>): $Set<($Char2ObjectMap$Entry<(V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectMap$FastEntrySet$Type<V> = ($Char2ObjectMap$FastEntrySet<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectMap$FastEntrySet_<V> = $Char2ObjectMap$FastEntrySet$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ShortFunction extends $Function$0<(byte), (short)>, $IntUnaryOperator {

 "remove"(arg0: byte): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: byte): short
 "put"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ShortFunction
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Byte2ByteFunction
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Byte2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Byte2IntFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ShortFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenChar"(arg0: $Short2CharFunction$Type): $Byte2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Byte2FloatFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): short
}

export namespace $Byte2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ShortFunction$Type = ($Byte2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ShortFunction_ = $Byte2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $Double2BooleanFunction extends $Function$0<(double), (boolean)>, $DoublePredicate {

 "remove"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: boolean): boolean
 "put"(arg0: double, arg1: boolean): boolean
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Double2ByteFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Double2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Double2IntFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Double2FloatFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Double2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): boolean
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate

(arg0: double): boolean
}

export namespace $Double2BooleanFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2BooleanFunction$Type = ($Double2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2BooleanFunction_ = $Double2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2FloatFunction<K> extends $Function$0<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2FloatFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Float2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>

(arg0: any): float
}

export namespace $Object2FloatFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatFunction$Type<K> = ($Object2FloatFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatFunction_<K> = $Object2FloatFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntListIterator, $IntListIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntList extends $List<(integer)>, $Comparable<($List<(any)>)>, $IntCollection {

 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: integer): void
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): integer
 "indexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: integer): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $IntUnaryOperator$0$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $IntList
 "iterator"(): $IntListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
 "addAll"(arg0: $IntList$Type): boolean
 "addAll"(arg0: integer, arg1: $IntList$Type): boolean
 "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: integer): integer
 "sort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "removeInt"(arg0: integer): integer
 "setElements"(arg0: integer, arg1: (integer)[]): void
 "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (integer)[]): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $IntComparator$Type): void
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (integer)[]): void
 "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntList {
function of(...arg0: (integer)[]): $IntList
function of(): $IntList
function of(arg0: integer, arg1: integer): $IntList
function of(arg0: integer): $IntList
function of(arg0: integer, arg1: integer, arg2: integer): $IntList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer): $List<(integer)>
function of<E>(arg0: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
function of<E>(...arg0: (integer)[]): $List<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntList$Type = ($IntList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntList_ = $IntList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$AbstractByteList" {
import {$ByteListIterator, $ByteListIterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteListIterator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$ByteSpliterator, $ByteSpliterator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteSpliterator"
import {$ByteCollection, $ByteCollection$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ByteUnaryOperator, $ByteUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteUnaryOperator"
import {$ByteComparator, $ByteComparator$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteComparator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$AbstractByteCollection, $AbstractByteCollection$Type} from "packages/it/unimi/dsi/fastutil/bytes/$AbstractByteCollection"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteList, $ByteList$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteList"
import {$ByteConsumer, $ByteConsumer$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteConsumer"
import {$ByteStack, $ByteStack$Type} from "packages/it/unimi/dsi/fastutil/bytes/$ByteStack"

export class $AbstractByteList extends $AbstractByteCollection implements $ByteList, $ByteStack {


public "add"(arg0: byte): boolean
public "add"(arg0: integer, arg1: byte): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: byte): integer
public "clear"(): void
public "lastIndexOf"(arg0: byte): integer
public "size"(arg0: integer): void
public "subList"(arg0: integer, arg1: integer): $ByteList
public "toArray"(arg0: (byte)[]): (byte)[]
public "iterator"(): $ByteListIterator
public "contains"(arg0: byte): boolean
public "addAll"(arg0: $ByteCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $ByteCollection$Type): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: byte): byte
public "forEach"(arg0: $ByteConsumer$Type): void
public "toByteArray"(): (byte)[]
public "listIterator"(): $ByteListIterator
public "listIterator"(arg0: integer): $ByteListIterator
public "rem"(arg0: byte): boolean
public "push"(arg0: byte): void
public "peekByte"(arg0: integer): byte
public "getElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
public "removeByte"(arg0: integer): byte
public "popByte"(): byte
public "topByte"(): byte
public "removeElements"(arg0: integer, arg1: integer): void
public "addElements"(arg0: integer, arg1: (byte)[]): void
public "addElements"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
/**
 * 
 * @deprecated
 */
public "add"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer, arg1: byte): void
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
public "indexOf"(arg0: any): integer
public "getByte"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
public "lastIndexOf"(arg0: any): integer
public "replaceAll"(arg0: $IntUnaryOperator$Type): void
public "replaceAll"(arg0: $ByteUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
public "replaceAll"(arg0: $UnaryOperator$Type<(byte)>): void
public static "of"(): $ByteList
public static "of"(arg0: byte): $ByteList
public static "of"(arg0: byte, arg1: byte): $ByteList
public static "of"(arg0: byte, arg1: byte, arg2: byte): $ByteList
public static "of"(...arg0: (byte)[]): $ByteList
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $ByteSpliterator
public "addAll"(arg0: $ByteList$Type): boolean
public "addAll"(arg0: integer, arg1: $ByteList$Type): boolean
/**
 * 
 * @deprecated
 */
public "set"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
public "sort"(arg0: $Comparator$Type<(any)>): void
public "sort"(arg0: $ByteComparator$Type): void
public "setElements"(arg0: (byte)[]): void
public "setElements"(arg0: integer, arg1: (byte)[]): void
public "unstableSort"(arg0: $ByteComparator$Type): void
/**
 * 
 * @deprecated
 */
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "peek"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
public "push"(arg0: byte): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(byte)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte): $List<(byte)>
public static "of"<E>(arg0: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte, arg8: byte, arg9: byte): $List<(byte)>
public static "of"<E>(arg0: byte, arg1: byte, arg2: byte, arg3: byte, arg4: byte, arg5: byte, arg6: byte, arg7: byte, arg8: byte): $List<(byte)>
public static "of"<E>(...arg0: (byte)[]): $List<(byte)>
set "elements"(value: (byte)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractByteList$Type = ($AbstractByteList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractByteList_ = $AbstractByteList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoublePredicate extends $Predicate<(double)>, $DoublePredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
 "or"(arg0: $DoublePredicate$0$Type): $DoublePredicate
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
 "test"(arg0: double): boolean

(arg0: double): boolean
}

export namespace $DoublePredicate {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
function isEqual<T>(arg0: any): $Predicate<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoublePredicate$Type = ($DoublePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoublePredicate_ = $DoublePredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2LongFunction extends $Function$0<(short), (long)>, $IntToLongFunction {

 "remove"(arg0: short): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: short): long
 "put"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2LongFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Short2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Short2IntFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Short2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Short2FloatFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Short2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): long

(arg0: short): long
}

export namespace $Short2LongFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2LongFunction$Type = ($Short2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2LongFunction_ = $Short2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2FloatFunction extends $Function$0<(integer), (float)>, $IntToDoubleFunction {

 "remove"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: integer): float
 "put"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: integer, arg1: float): float
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2FloatFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2FloatFunction
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Int2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Int2IntFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenChar"(arg0: $Float2CharFunction$Type): $Int2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Int2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2FloatFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): float

(arg0: integer): float
}

export namespace $Int2FloatFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2FloatFunction$Type = ($Int2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2FloatFunction_ = $Int2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2BooleanFunction<K> extends $Function$0<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeBoolean"(arg0: any): boolean
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2BooleanFunction
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2BooleanFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2BooleanFunction
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2BooleanFunction<(T)>
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2BooleanFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Reference2BooleanFunction {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2BooleanFunction$Type<K> = ($Reference2BooleanFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2BooleanFunction_<K> = $Reference2BooleanFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"

export interface $Reference2ReferenceFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ReferenceFunction {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceFunction$Type<K, V> = ($Reference2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceFunction_<K, V> = $Reference2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$LongBinaryOperator, $LongBinaryOperator$Type} from "packages/java/util/function/$LongBinaryOperator"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Object2LongMap$Entry, $Object2LongMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap$Entry"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$LongBinaryOperator as $LongBinaryOperator$0, $LongBinaryOperator$Type as $LongBinaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBinaryOperator"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2LongMap<K> extends $Object2LongFunction<(K)>, $Map<(K), (long)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: long): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "values"(): $LongCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long, arg2: long): boolean
 "replace"(arg0: K, arg1: long, arg2: long): boolean
 "replace"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long): long
 "size"(): integer
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (long)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: long): long
 "putIfAbsent"(arg0: K, arg1: long): long
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToLongFunction$Type<(any)>): long
 "computeIfAbsent"(arg0: K, arg1: $Object2LongFunction$Type<(any)>): long
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: long): boolean
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "object2LongEntrySet"(): $ObjectSet<($Object2LongMap$Entry<(K)>)>
 "computeLongIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsent"(arg0: K, arg1: $ToLongFunction$Type<(any)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsentPartial"(arg0: K, arg1: $Object2LongFunction$Type<(any)>): long
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "computeLong"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$0$Type): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$Type): long
/**
 * 
 * @deprecated
 */
 "mergeLong"(arg0: K, arg1: long, arg2: $BiFunction$Type<(any), (any), (any)>): long
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeLong"(arg0: any): long
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2LongFunction
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2LongFunction
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Object2IntFunction<(K)>
 "andThenLong"(arg0: $Long2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2LongFunction
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2LongFunction<(T)>
 "andThenChar"(arg0: $Long2CharFunction$Type): $Object2CharFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Object2FloatFunction<(K)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2LongFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2LongFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): long
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): long
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): long
 "apply"(arg0: K): long
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>
}

export namespace $Object2LongMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long): $Map<(K), (long)>
function of<K, V>(): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long, arg18: K, arg19: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long): $Map<(K), (long)>
function entry<K, V>(arg0: K, arg1: long): $Map$Entry<(K), (long)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (long)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongMap$Type<K> = ($Object2LongMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongMap_<K> = $Object2LongMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$CharUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $CharUnaryOperator extends $UnaryOperator<(character)>, $IntUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: character): character
 "apply"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (character)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>

(arg0: character): character
}

export namespace $CharUnaryOperator {
function identity(): $CharUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharUnaryOperator$Type = ($CharUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharUnaryOperator_ = $CharUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$FloatListIterator, $FloatListIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatListIterator"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$FloatComparator, $FloatComparator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatComparator"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$FloatUnaryOperator, $FloatUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatUnaryOperator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatPredicate, $FloatPredicate$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FloatSpliterator, $FloatSpliterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatSpliterator"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $FloatList extends $List<(float)>, $Comparable<($List<(any)>)>, $FloatCollection {

 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: float): void
 "add"(arg0: integer, arg1: float): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): float
 "indexOf"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getFloat"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: float): integer
 "replaceAll"(arg0: $DoubleUnaryOperator$Type): void
 "replaceAll"(arg0: $FloatUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(float)>): void
 "size"(arg0: integer): void
 "iterator"(): $FloatListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $FloatSpliterator
 "addAll"(arg0: $FloatList$Type): boolean
 "addAll"(arg0: integer, arg1: $FloatCollection$Type): boolean
 "addAll"(arg0: integer, arg1: $FloatList$Type): boolean
 "set"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "sort"(arg0: $FloatComparator$Type): void
 "getElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (float)[]): void
 "setElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (float)[]): void
 "unstableSort"(arg0: $FloatComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "removeFloat"(arg0: integer): float
 "removeElements"(arg0: integer, arg1: integer): void
 "addElements"(arg0: integer, arg1: (float)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (float)[]): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (float)[]): (float)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(float)>
 "contains"(arg0: float): boolean
 "addAll"(arg0: $FloatCollection$Type): boolean
 "removeIf"(arg0: $FloatPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $FloatCollection$Type): boolean
 "retainAll"(arg0: $FloatCollection$Type): boolean
 "containsAll"(arg0: $FloatCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(float)>
 "rem"(arg0: float): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toFloatArray"(arg0: (float)[]): (float)[]
 "toFloatArray"(): (float)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $FloatList {
function of(): $FloatList
function of(arg0: float): $FloatList
function of(arg0: float, arg1: float): $FloatList
function of(arg0: float, arg1: float, arg2: float): $FloatList
function of(...arg0: (float)[]): $FloatList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float): $List<(float)>
function of<E>(arg0: float, arg1: float): $List<(float)>
function of<E>(arg0: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): $List<(float)>
function of<E>(...arg0: (float)[]): $List<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatList$Type = ($FloatList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatList_ = $FloatList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2ObjectMap$Entry<K, V> extends $Map$Entry<(K), (V)> {

 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "getKey"(): K
 "setValue"(arg0: V): V
}

export namespace $Object2ObjectMap$Entry {
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$Entry$Type<K, V> = ($Object2ObjectMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap$Entry_<K, V> = $Object2ObjectMap$Entry$Type<(K), (V)>;
}}
