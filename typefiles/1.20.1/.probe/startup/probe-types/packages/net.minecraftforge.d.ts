declare module "packages/net/minecraftforge/event/server/$ServerStoppingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLifecycleEvent, $ServerLifecycleEvent$Type} from "packages/net/minecraftforge/event/server/$ServerLifecycleEvent"

export class $ServerStoppingEvent extends $ServerLifecycleEvent {

constructor(arg0: $MinecraftServer$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStoppingEvent$Type = ($ServerStoppingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStoppingEvent_ = $ServerStoppingEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$ColorResolverManager" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$BlockTintCache, $BlockTintCache$Type} from "packages/net/minecraft/client/color/block/$BlockTintCache"
import {$ColorResolver, $ColorResolver$Type} from "packages/net/minecraft/world/level/$ColorResolver"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ColorResolverManager {


public static "init"(): void
public static "registerBlockTintCaches"(arg0: $ClientLevel$Type, arg1: $Map$Type<($ColorResolver$Type), ($BlockTintCache$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorResolverManager$Type = ($ColorResolverManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColorResolverManager_ = $ColorResolverManager$Type;
}}
declare module "packages/net/minecraftforge/server/command/$ConfigCommand" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $ConfigCommand {

constructor()

public static "register"(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigCommand$Type = ($ConfigCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigCommand_ = $ConfigCommand$Type;
}}
declare module "packages/net/minecraftforge/common/data/$DatapackBuiltinEntriesProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$RegistriesDatapackGenerator, $RegistriesDatapackGenerator$Type} from "packages/net/minecraft/data/registries/$RegistriesDatapackGenerator"
import {$RegistrySetBuilder, $RegistrySetBuilder$Type} from "packages/net/minecraft/core/$RegistrySetBuilder"

export class $DatapackBuiltinEntriesProvider extends $RegistriesDatapackGenerator {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $Set$Type<(string)>)
constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $RegistrySetBuilder$Type, arg3: $Set$Type<(string)>)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DatapackBuiltinEntriesProvider$Type = ($DatapackBuiltinEntriesProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DatapackBuiltinEntriesProvider_ = $DatapackBuiltinEntriesProvider$Type;
}}
declare module "packages/net/minecraftforge/gametest/$BlockPosValueConverter" {
import {$ValueConverter, $ValueConverter$Type} from "packages/joptsimple/$ValueConverter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPosValueConverter implements $ValueConverter<($BlockPos)> {

constructor()

public "valueType"(): $Class<($BlockPos)>
public "valuePattern"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPosValueConverter$Type = ($BlockPosValueConverter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPosValueConverter_ = $BlockPosValueConverter$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderHandEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $RenderHandEvent extends $Event {

constructor(arg0: $InteractionHand$Type, arg1: $PoseStack$Type, arg2: $MultiBufferSource$Type, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float, arg8: $ItemStack$Type)
constructor()

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getHand"(): $InteractionHand
public "getItemStack"(): $ItemStack
public "getSwingProgress"(): float
public "getPackedLight"(): integer
public "getEquipProgress"(): float
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getInterpolatedPitch"(): float
get "partialTick"(): float
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "hand"(): $InteractionHand
get "itemStack"(): $ItemStack
get "swingProgress"(): float
get "packedLight"(): integer
get "equipProgress"(): float
get "listenerList"(): $ListenerList
get "interpolatedPitch"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderHandEvent$Type = ($RenderHandEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderHandEvent_ = $RenderHandEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$IModLoadingState" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ModList, $ModList$Type} from "packages/net/minecraftforge/fml/$ModList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ProgressMeter, $ProgressMeter$Type} from "packages/net/minecraftforge/fml/loading/progress/$ProgressMeter"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ModLoadingPhase, $ModLoadingPhase$Type} from "packages/net/minecraftforge/fml/$ModLoadingPhase"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IModLoadingState {

 "name"(): string
 "size"(): $ToIntFunction<($ModList)>
 "message"(): $Function<($ModList), (string)>
 "previous"(): string
 "phase"(): $ModLoadingPhase
 "inlineRunnable"(): $Optional<($Consumer<($ModList)>)>
 "buildTransition"<T extends ($Event) & ($IModBusEvent)>(arg0: $Executor$Type, arg1: $Executor$Type, arg2: $ProgressMeter$Type, arg3: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>, arg4: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>): $Optional<($CompletableFuture<(void)>)>
 "buildTransition"<T extends ($Event) & ($IModBusEvent)>(arg0: $Executor$Type, arg1: $Executor$Type, arg2: $ProgressMeter$Type): $Optional<($CompletableFuture<(void)>)>
}

export namespace $IModLoadingState {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModLoadingState$Type = ($IModLoadingState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModLoadingState_ = $IModLoadingState$Type;
}}
declare module "packages/net/minecraftforge/common/loot/$LootTableIdCondition$Builder" {
import {$AllOfCondition$Builder, $AllOfCondition$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$AllOfCondition$Builder"
import {$AnyOfCondition$Builder, $AnyOfCondition$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$AnyOfCondition$Builder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$LootItemCondition$Builder, $LootItemCondition$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition$Builder"

export class $LootTableIdCondition$Builder implements $LootItemCondition$Builder {

constructor(arg0: $ResourceLocation$Type)

public "build"(): $LootItemCondition
public "and"(arg0: $LootItemCondition$Builder$Type): $AllOfCondition$Builder
public "invert"(): $LootItemCondition$Builder
public "or"(arg0: $LootItemCondition$Builder$Type): $AnyOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableIdCondition$Builder$Type = ($LootTableIdCondition$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableIdCondition$Builder_ = $LootTableIdCondition$Builder$Type;
}}
declare module "packages/net/minecraftforge/event/$ModMismatchEvent$MismatchedVersionInfo" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"

export class $ModMismatchEvent$MismatchedVersionInfo extends $Record {

constructor(oldVersion: $ArtifactVersion$Type, newVersion: $ArtifactVersion$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "oldVersion"(): $ArtifactVersion
public "wasUpgrade"(): boolean
public "newVersion"(): $ArtifactVersion
public "isMissing"(): boolean
get "missing"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModMismatchEvent$MismatchedVersionInfo$Type = ($ModMismatchEvent$MismatchedVersionInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModMismatchEvent$MismatchedVersionInfo_ = $ModMismatchEvent$MismatchedVersionInfo$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$OrCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $OrCondition implements $ICondition {

constructor(...arg0: ($ICondition$Type)[])

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrCondition$Type = ($OrCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrCondition_ = $OrCondition$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FogShape, $FogShape$Type} from "packages/com/mojang/blaze3d/shaders/$FogShape"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$FogRenderer$FogMode, $FogRenderer$FogMode$Type} from "packages/net/minecraft/client/renderer/$FogRenderer$FogMode"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $IClientFluidTypeExtensions {

 "modifyFogColor"(arg0: $Camera$Type, arg1: float, arg2: $ClientLevel$Type, arg3: integer, arg4: float, arg5: $Vector3f$Type): $Vector3f
 "modifyFogRender"(arg0: $Camera$Type, arg1: $FogRenderer$FogMode$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: $FogShape$Type): void
 "getFlowingTexture"(): $ResourceLocation
 "getFlowingTexture"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): $ResourceLocation
 "getFlowingTexture"(arg0: $FluidStack$Type): $ResourceLocation
 "getOverlayTexture"(arg0: $FluidStack$Type): $ResourceLocation
 "getOverlayTexture"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): $ResourceLocation
 "getOverlayTexture"(): $ResourceLocation
 "getRenderOverlayTexture"(arg0: $Minecraft$Type): $ResourceLocation
 "getTintColor"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): integer
 "getTintColor"(arg0: $FluidStack$Type): integer
 "getTintColor"(): integer
 "getStillTexture"(): $ResourceLocation
 "getStillTexture"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): $ResourceLocation
 "getStillTexture"(arg0: $FluidStack$Type): $ResourceLocation
 "renderOverlay"(arg0: $Minecraft$Type, arg1: $PoseStack$Type): void
}

export namespace $IClientFluidTypeExtensions {
const DEFAULT: $IClientFluidTypeExtensions
function of(arg0: $FluidState$Type): $IClientFluidTypeExtensions
function of(arg0: $FluidType$Type): $IClientFluidTypeExtensions
function of(arg0: $Fluid$Type): $IClientFluidTypeExtensions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IClientFluidTypeExtensions$Type = ($IClientFluidTypeExtensions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IClientFluidTypeExtensions_ = $IClientFluidTypeExtensions$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketTracker" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ForgeChunkManager$TicketOwner, $ForgeChunkManager$TicketOwner$Type} from "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketOwner"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeChunkManager$TicketTracker<T extends $Comparable<(any)>> {

constructor()

public "isEmpty"(): boolean
public "getChunks"(): $Map<($ForgeChunkManager$TicketOwner<(T)>), ($LongSet)>
public "getTickingChunks"(): $Map<($ForgeChunkManager$TicketOwner<(T)>), ($LongSet)>
get "empty"(): boolean
get "chunks"(): $Map<($ForgeChunkManager$TicketOwner<(T)>), ($LongSet)>
get "tickingChunks"(): $Map<($ForgeChunkManager$TicketOwner<(T)>), ($LongSet)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeChunkManager$TicketTracker$Type<T> = ($ForgeChunkManager$TicketTracker<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeChunkManager$TicketTracker_<T> = $ForgeChunkManager$TicketTracker$Type<(T)>;
}}
declare module "packages/net/minecraftforge/registries/$RegistryObject" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $RegistryObject<T> implements $Supplier<(T)> {


public "get"(): any
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "map"<U>(arg0: $Function$Type<(any), (any)>): $Optional<(U)>
public "stream"(): $Stream<(T)>
public "filter"(arg0: $Predicate$Type<(any)>): $RegistryObject<(T)>
public "getKey"(): $ResourceKey<(T)>
public "flatMap"<U>(arg0: $Function$Type<(any), ($Optional$Type<(U)>)>): $Optional<(U)>
public "isPresent"(): boolean
public "getId"(): $ResourceLocation
public "orElse"(arg0: T): T
public "orElseThrow"<X extends $Throwable>(arg0: $Supplier$Type<(any)>): T
public static "create"<T, U extends T>(arg0: $ResourceLocation$Type, arg1: $ResourceLocation$Type, arg2: string): $RegistryObject<(U)>
public static "create"<T, U extends T>(arg0: $ResourceLocation$Type, arg1: $IForgeRegistry$Type<(T)>): $RegistryObject<(U)>
public static "create"<T, U extends T>(arg0: $ResourceLocation$Type, arg1: $ResourceKey$Type<(any)>, arg2: string): $RegistryObject<(U)>
public "ifPresent"(arg0: $Consumer$Type<(any)>): void
public "orElseGet"(arg0: $Supplier$Type<(any)>): T
public static "createOptional"<T, U extends T>(arg0: $ResourceLocation$Type, arg1: $ResourceLocation$Type, arg2: string): $RegistryObject<(U)>
public static "createOptional"<T, U extends T>(arg0: $ResourceLocation$Type, arg1: $ResourceKey$Type<(any)>, arg2: string): $RegistryObject<(U)>
public "lazyMap"<U>(arg0: $Function$Type<(any), (any)>): $Supplier<(U)>
public "getHolder"(): $Optional<($Holder<(T)>)>
get "key"(): $ResourceKey<(T)>
get "present"(): boolean
get "id"(): $ResourceLocation
get "holder"(): $Optional<($Holder<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryObject$Type<T> = ($RegistryObject<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryObject_<T> = $RegistryObject$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/world/$NoneBiomeModifier" {
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $NoneBiomeModifier implements $BiomeModifier {
static readonly "INSTANCE": $NoneBiomeModifier

constructor()

public "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoneBiomeModifier$Type = ($NoneBiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoneBiomeModifier_ = $NoneBiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfig$Client" {
import {$ForgeConfigSpec$BooleanValue, $ForgeConfigSpec$BooleanValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue"

export class $ForgeConfig$Client {
readonly "alwaysSetupTerrainOffThread": $ForgeConfigSpec$BooleanValue
readonly "experimentalForgeLightPipelineEnabled": $ForgeConfigSpec$BooleanValue
readonly "showLoadWarnings": $ForgeConfigSpec$BooleanValue
readonly "useCombinedDepthStencilAttachment": $ForgeConfigSpec$BooleanValue
/**
 * 
 * @deprecated
 */
readonly "compressLanIPv6Addresses": $ForgeConfigSpec$BooleanValue
readonly "calculateAllNormals": $ForgeConfigSpec$BooleanValue
readonly "stabilizeDirectionGetNearest": $ForgeConfigSpec$BooleanValue


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfig$Client$Type = ($ForgeConfig$Client);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfig$Client_ = $ForgeConfig$Client$Type;
}}
declare module "packages/net/minecraftforge/event/$PlayLevelSoundEvent$AtEntity" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$PlayLevelSoundEvent, $PlayLevelSoundEvent$Type} from "packages/net/minecraftforge/event/$PlayLevelSoundEvent"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayLevelSoundEvent$AtEntity extends $PlayLevelSoundEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Holder$Type<($SoundEvent$Type)>, arg2: $SoundSource$Type, arg3: float, arg4: float)

public "getEntity"(): $Entity
public "getListenerList"(): $ListenerList
get "entity"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayLevelSoundEvent$AtEntity$Type = ($PlayLevelSoundEvent$AtEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayLevelSoundEvent$AtEntity_ = $PlayLevelSoundEvent$AtEntity$Type;
}}
declare module "packages/net/minecraftforge/network/$ConnectionData" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ConnectionData {


public "getModData"(): $ImmutableMap<(string), ($Pair<(string), (string)>)>
public "getChannels"(): $ImmutableMap<($ResourceLocation), (string)>
public "getModList"(): $ImmutableList<(string)>
get "modData"(): $ImmutableMap<(string), ($Pair<(string), (string)>)>
get "channels"(): $ImmutableMap<($ResourceLocation), (string)>
get "modList"(): $ImmutableList<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionData$Type = ($ConnectionData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionData_ = $ConnectionData$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$CapabilityToken" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CapabilityToken<T> {

constructor()

public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityToken$Type<T> = ($CapabilityToken<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityToken_<T> = $CapabilityToken$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/util/$TransformationHelper" {
import {$Vector4f, $Vector4f$Type} from "packages/org/joml/$Vector4f"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$Quaternionfc, $Quaternionfc$Type} from "packages/org/joml/$Quaternionfc"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $TransformationHelper {

constructor()

public static "slerp"(arg0: $Transformation$Type, arg1: $Transformation$Type, arg2: float): $Transformation
public static "slerp"(arg0: $Quaternionfc$Type, arg1: $Quaternionfc$Type, arg2: float): $Quaternionf
public static "quatFromXYZ"(arg0: (float)[], arg1: boolean): $Quaternionf
public static "quatFromXYZ"(arg0: $Vector3f$Type, arg1: boolean): $Quaternionf
public static "quatFromXYZ"(arg0: float, arg1: float, arg2: float, arg3: boolean): $Quaternionf
public static "makeQuaternion"(arg0: (float)[]): $Quaternionf
public static "epsilonEquals"(arg0: $Vector4f$Type, arg1: $Vector4f$Type, arg2: float): boolean
public static "lerp"(arg0: $Vector3f$Type, arg1: $Vector3f$Type, arg2: float): $Vector3f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformationHelper$Type = ($TransformationHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformationHelper_ = $TransformationHelper$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$EventPriority" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IEventListener, $IEventListener$Type} from "packages/net/minecraftforge/eventbus/api/$IEventListener"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $EventPriority extends $Enum<($EventPriority)> implements $IEventListener {
static readonly "HIGHEST": $EventPriority
static readonly "HIGH": $EventPriority
static readonly "NORMAL": $EventPriority
static readonly "LOW": $EventPriority
static readonly "LOWEST": $EventPriority


public "invoke"(arg0: $Event$Type): void
public static "values"(): ($EventPriority)[]
public static "valueOf"(arg0: string): $EventPriority
public "listenerName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventPriority$Type = (("normal") | ("high") | ("highest") | ("low") | ("lowest")) | ($EventPriority);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventPriority_ = $EventPriority$Type;
}}
declare module "packages/net/minecraftforge/common/$ToolAction" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $ToolAction {


public "name"(): string
public static "get"(arg0: string): $ToolAction
public "toString"(): string
public static "getActions"(): $Collection<($ToolAction)>
get "actions"(): $Collection<($ToolAction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolAction$Type = ($ToolAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolAction_ = $ToolAction$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$VanillaConnectionNetworkFilter" {
import {$VanillaPacketFilter, $VanillaPacketFilter$Type} from "packages/net/minecraftforge/network/filters/$VanillaPacketFilter"

export class $VanillaConnectionNetworkFilter extends $VanillaPacketFilter {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaConnectionNetworkFilter$Type = ($VanillaConnectionNetworkFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaConnectionNetworkFilter_ = $VanillaConnectionNetworkFilter$Type;
}}
declare module "packages/net/minecraftforge/fluids/$FluidInteractionRegistry" {
import {$FluidInteractionRegistry$InteractionInformation, $FluidInteractionRegistry$InteractionInformation$Type} from "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$InteractionInformation"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"

export class $FluidInteractionRegistry {

constructor()

public static "addInteraction"(arg0: $FluidType$Type, arg1: $FluidInteractionRegistry$InteractionInformation$Type): void
public static "canInteract"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInteractionRegistry$Type = ($FluidInteractionRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInteractionRegistry_ = $FluidInteractionRegistry$Type;
}}
declare module "packages/net/minecraftforge/network/$ICustomPacket" {
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ICustomPacket<T extends $Packet<(any)>> {

 "getName"(): $ResourceLocation
 "getIndex"(): integer
 "getDirection"(): $NetworkDirection
 "getThis"(): T
 "getInternalData"(): $FriendlyByteBuf
}

export namespace $ICustomPacket {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICustomPacket$Type<T> = ($ICustomPacket<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICustomPacket_<T> = $ICustomPacket$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export interface $IForgeRecipeSerializer<T extends $Recipe<(any)>> {

 "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): T
}

export namespace $IForgeRecipeSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRecipeSerializer$Type<T> = ($IForgeRecipeSerializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRecipeSerializer_<T> = $IForgeRecipeSerializer$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock$Action" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ServerboundPlayerActionPacket$Action, $ServerboundPlayerActionPacket$Action$Type} from "packages/net/minecraft/network/protocol/game/$ServerboundPlayerActionPacket$Action"

export class $PlayerInteractEvent$LeftClickBlock$Action extends $Enum<($PlayerInteractEvent$LeftClickBlock$Action)> {
static readonly "START": $PlayerInteractEvent$LeftClickBlock$Action
static readonly "STOP": $PlayerInteractEvent$LeftClickBlock$Action
static readonly "ABORT": $PlayerInteractEvent$LeftClickBlock$Action
static readonly "CLIENT_HOLD": $PlayerInteractEvent$LeftClickBlock$Action


public static "values"(): ($PlayerInteractEvent$LeftClickBlock$Action)[]
public static "convert"(arg0: $ServerboundPlayerActionPacket$Action$Type): $PlayerInteractEvent$LeftClickBlock$Action
public static "valueOf"(arg0: string): $PlayerInteractEvent$LeftClickBlock$Action
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$LeftClickBlock$Action$Type = (("client_hold") | ("stop") | ("abort") | ("start")) | ($PlayerInteractEvent$LeftClickBlock$Action);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$LeftClickBlock$Action_ = $PlayerInteractEvent$LeftClickBlock$Action$Type;
}}
declare module "packages/net/minecraftforge/common/$DungeonHooks" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"

export class $DungeonHooks {

constructor()

public static "getRandomDungeonMob"(arg0: $RandomSource$Type): $EntityType<(any)>
public static "removeDungeonMob"(arg0: $EntityType$Type<(any)>): integer
public static "addDungeonMob"(arg0: $EntityType$Type<(any)>, arg1: integer): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DungeonHooks$Type = ($DungeonHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DungeonHooks_ = $DungeonHooks$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$ColourScheme$Colour" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ColourScheme$Colour extends $Record {

constructor(red: integer, green: integer, blue: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "red"(): integer
public "greenf"(): float
public "redf"(): float
public "bluef"(): float
public "packedint"(arg0: integer): integer
public "blue"(): integer
public "green"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColourScheme$Colour$Type = ($ColourScheme$Colour);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColourScheme$Colour_ = $ColourScheme$Colour$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTravelToDimensionEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityTravelToDimensionEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $ResourceKey$Type<($Level$Type)>)

public "getDimension"(): $ResourceKey<($Level)>
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "dimension"(): $ResourceKey<($Level)>
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTravelToDimensionEvent$Type = ($EntityTravelToDimensionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTravelToDimensionEvent_ = $EntityTravelToDimensionEvent$Type;
}}
declare module "packages/net/minecraftforge/server/permission/$PermissionAPI" {
import {$PermissionDynamicContext, $PermissionDynamicContext$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $PermissionAPI {


public static "getPermission"<T>(arg0: $ServerPlayer$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
public static "getActivePermissionHandler"(): $ResourceLocation
public static "getOfflinePermission"<T>(arg0: $UUID$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
public static "initializePermissionAPI"(): void
public static "getRegisteredNodes"(): $Collection<($PermissionNode<(any)>)>
get "activePermissionHandler"(): $ResourceLocation
get "registeredNodes"(): $Collection<($PermissionNode<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionAPI$Type = ($PermissionAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionAPI_ = $PermissionAPI$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityTeleportEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: double, arg2: double, arg3: double)

public "getTarget"(): $Vec3
public "isCancelable"(): boolean
public "setTargetZ"(arg0: double): void
public "getTargetX"(): double
public "getTargetZ"(): double
public "getTargetY"(): double
public "setTargetX"(arg0: double): void
public "setTargetY"(arg0: double): void
public "getPrev"(): $Vec3
public "getPrevY"(): double
public "getPrevZ"(): double
public "getPrevX"(): double
public "getListenerList"(): $ListenerList
get "target"(): $Vec3
get "cancelable"(): boolean
set "targetZ"(value: double)
get "targetX"(): double
get "targetZ"(): double
get "targetY"(): double
set "targetX"(value: double)
set "targetY"(value: double)
get "prev"(): $Vec3
get "prevY"(): double
get "prevZ"(): double
get "prevX"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$Type = ($EntityTeleportEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent_ = $EntityTeleportEvent$Type;
}}
declare module "packages/net/minecraftforge/server/command/$TagsCommand" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ArgumentBuilder, $ArgumentBuilder$Type} from "packages/com/mojang/brigadier/builder/$ArgumentBuilder"

export class $TagsCommand {


public static "register"(): $ArgumentBuilder<($CommandSourceStack), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagsCommand$Type = ($TagsCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagsCommand_ = $TagsCommand$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityAttributeCreationEvent" {
import {$AttributeSupplier, $AttributeSupplier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeSupplier"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EntityAttributeCreationEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($EntityType$Type<(any)>), ($AttributeSupplier$Type)>)

public "put"(arg0: $EntityType$Type<(any)>, arg1: $AttributeSupplier$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityAttributeCreationEvent$Type = ($EntityAttributeCreationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityAttributeCreationEvent_ = $EntityAttributeCreationEvent$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketOwner" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"

export class $ForgeChunkManager$TicketOwner<T extends $Comparable<(any)>> implements $Comparable<($ForgeChunkManager$TicketOwner<(T)>)> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "compareTo"(arg0: $ForgeChunkManager$TicketOwner$Type<(T)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeChunkManager$TicketOwner$Type<T> = ($ForgeChunkManager$TicketOwner<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeChunkManager$TicketOwner_<T> = $ForgeChunkManager$TicketOwner$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$MouseButton" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InputEvent, $InputEvent$Type} from "packages/net/minecraftforge/client/event/$InputEvent"

export class $InputEvent$MouseButton extends $InputEvent {

constructor()

public "getModifiers"(): integer
public "getButton"(): integer
public "getAction"(): integer
public "getListenerList"(): $ListenerList
get "modifiers"(): integer
get "button"(): integer
get "action"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$MouseButton$Type = ($InputEvent$MouseButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$MouseButton_ = $InputEvent$MouseButton$Type;
}}
declare module "packages/net/minecraftforge/client/gui/overlay/$GuiOverlayManager" {
import {$NamedGuiOverlay, $NamedGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GuiOverlayManager {


public static "init"(): void
public static "getOverlays"(): $ImmutableList<($NamedGuiOverlay)>
public static "findOverlay"(arg0: $ResourceLocation$Type): $NamedGuiOverlay
get "overlays"(): $ImmutableList<($NamedGuiOverlay)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiOverlayManager$Type = ($GuiOverlayManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiOverlayManager_ = $GuiOverlayManager$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$IIngredientSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export interface $IIngredientSerializer<T extends $Ingredient> {

 "write"(arg0: $FriendlyByteBuf$Type, arg1: T): void
 "parse"(arg0: $JsonObject$Type): T
 "parse"(arg0: $FriendlyByteBuf$Type): T
}

export namespace $IIngredientSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IIngredientSerializer$Type<T> = ($IIngredientSerializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IIngredientSerializer_<T> = $IIngredientSerializer$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec" {
import {$IConfigSpec, $IConfigSpec$Type} from "packages/net/minecraftforge/fml/config/$IConfigSpec"
import {$ConfigSpec$CorrectionListener, $ConfigSpec$CorrectionListener$Type} from "packages/com/electronwill/nightconfig/core/$ConfigSpec$CorrectionListener"
import {$List, $List$Type} from "packages/java/util/$List"
import {$UnmodifiableConfigWrapper, $UnmodifiableConfigWrapper$Type} from "packages/com/electronwill/nightconfig/core/utils/$UnmodifiableConfigWrapper"
import {$CommentedConfig, $CommentedConfig$Type} from "packages/com/electronwill/nightconfig/core/$CommentedConfig"
import {$UnmodifiableConfig, $UnmodifiableConfig$Type} from "packages/com/electronwill/nightconfig/core/$UnmodifiableConfig"

export class $ForgeConfigSpec extends $UnmodifiableConfigWrapper<($UnmodifiableConfig)> implements $IConfigSpec<($ForgeConfigSpec)> {


public "save"(): void
public "isLoaded"(): boolean
public "isCorrect"(arg0: $CommentedConfig$Type): boolean
public "correct"(arg0: $CommentedConfig$Type, arg1: $ConfigSpec$CorrectionListener$Type, arg2: $ConfigSpec$CorrectionListener$Type): integer
public "correct"(arg0: $CommentedConfig$Type): integer
public "correct"(arg0: $CommentedConfig$Type, arg1: $ConfigSpec$CorrectionListener$Type): integer
public "getSpec"(): $UnmodifiableConfig
public "setConfig"(arg0: $CommentedConfig$Type): void
public "acceptConfig"(arg0: $CommentedConfig$Type): void
public "getLevelComment"(arg0: $List$Type<(string)>): string
public "isCorrecting"(): boolean
public "afterReload"(): void
public "getLevelTranslationKey"(arg0: $List$Type<(string)>): string
public "getValues"(): $UnmodifiableConfig
public "self"(): $ForgeConfigSpec
get "loaded"(): boolean
get "spec"(): $UnmodifiableConfig
set "config"(value: $CommentedConfig$Type)
get "correcting"(): boolean
get "values"(): $UnmodifiableConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$Type = ($ForgeConfigSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec_ = $ForgeConfigSpec$Type;
}}
declare module "packages/net/minecraftforge/fml/$ThreadSelector" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ThreadSelector extends $Enum<($ThreadSelector)> implements $BinaryOperator<($Executor)> {
static readonly "SYNC": $ThreadSelector
static readonly "PARALLEL": $ThreadSelector


public static "values"(): ($ThreadSelector)[]
public static "valueOf"(arg0: string): $ThreadSelector
public "apply"(arg0: $Executor$Type, arg1: $Executor$Type): $Executor
public static "minBy"<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<($Executor)>
public static "maxBy"<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<($Executor)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<($Executor), ($Executor), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadSelector$Type = (("parallel") | ("sync")) | ($ThreadSelector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadSelector_ = $ThreadSelector$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeFriendlyByteBuf" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IForgeFriendlyByteBuf {

 "readRegistryId"<T>(): T
 "readFluidStack"(): $FluidStack
 "readRegistryIdSafe"<T>(arg0: $Class$Type<(any)>): T
 "writeRegistryId"<T>(arg0: $IForgeRegistry$Type<(T)>, arg1: T): void
 "writeFluidStack"(arg0: $FluidStack$Type): void
 "writeRegistryIdUnsafe"<T>(arg0: $IForgeRegistry$Type<(T)>, arg1: T): void
 "writeRegistryIdUnsafe"(arg0: $IForgeRegistry$Type<(any)>, arg1: $ResourceLocation$Type): void
 "readRegistryIdUnsafe"<T>(arg0: $IForgeRegistry$Type<(T)>): T
}

export namespace $IForgeFriendlyByteBuf {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeFriendlyByteBuf$Type = ($IForgeFriendlyByteBuf);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeFriendlyByteBuf_ = $IForgeFriendlyByteBuf$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ExistingFileHelper" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$File, $File$Type} from "packages/java/io/$File"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Resource, $Resource$Type} from "packages/net/minecraft/server/packs/resources/$Resource"
import {$ExistingFileHelper$IResourceType, $ExistingFileHelper$IResourceType$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper$IResourceType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ExistingFileHelper {

constructor(arg0: $Collection$Type<($Path$Type)>, arg1: $Set$Type<(string)>, arg2: boolean, arg3: string, arg4: $File$Type)

public "getResource"(arg0: $ResourceLocation$Type, arg1: $PackType$Type, arg2: string, arg3: string): $Resource
public "getResource"(arg0: $ResourceLocation$Type, arg1: $PackType$Type): $Resource
public "exists"(arg0: $ResourceLocation$Type, arg1: $PackType$Type, arg2: string, arg3: string): boolean
public "exists"(arg0: $ResourceLocation$Type, arg1: $PackType$Type): boolean
public "exists"(arg0: $ResourceLocation$Type, arg1: $ExistingFileHelper$IResourceType$Type): boolean
public "isEnabled"(): boolean
public "trackGenerated"(arg0: $ResourceLocation$Type, arg1: $ExistingFileHelper$IResourceType$Type): void
public "trackGenerated"(arg0: $ResourceLocation$Type, arg1: $PackType$Type, arg2: string, arg3: string): void
public "getResourceStack"(arg0: $ResourceLocation$Type, arg1: $PackType$Type): $List<($Resource)>
get "enabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExistingFileHelper$Type = ($ExistingFileHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExistingFileHelper_ = $ExistingFileHelper$Type;
}}
declare module "packages/net/minecraftforge/common/util/$TransformationHelper$TransformOrigin" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $TransformationHelper$TransformOrigin extends $Enum<($TransformationHelper$TransformOrigin)> implements $StringRepresentable {
static readonly "CENTER": $TransformationHelper$TransformOrigin
static readonly "CORNER": $TransformationHelper$TransformOrigin
static readonly "OPPOSING_CORNER": $TransformationHelper$TransformOrigin


public static "values"(): ($TransformationHelper$TransformOrigin)[]
public static "valueOf"(arg0: string): $TransformationHelper$TransformOrigin
public static "fromString"(arg0: string): $TransformationHelper$TransformOrigin
public "getSerializedName"(): string
public "getVector"(): $Vector3f
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "vector"(): $Vector3f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformationHelper$TransformOrigin$Type = (("corner") | ("center") | ("opposing_corner")) | ($TransformationHelper$TransformOrigin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformationHelper$TransformOrigin_ = $TransformationHelper$TransformOrigin$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$ModListWidget" {
import {$ModListScreen, $ModListScreen$Type} from "packages/net/minecraftforge/client/gui/$ModListScreen"
import {$ObjectSelectionList, $ObjectSelectionList$Type} from "packages/net/minecraft/client/gui/components/$ObjectSelectionList"
import {$AbstractSelectionList$Entry, $AbstractSelectionList$Entry$Type} from "packages/net/minecraft/client/gui/components/$AbstractSelectionList$Entry"
import {$ModListWidget$ModEntry, $ModListWidget$ModEntry$Type} from "packages/net/minecraftforge/client/gui/widget/$ModListWidget$ModEntry"

export class $ModListWidget extends $ObjectSelectionList<($ModListWidget$ModEntry)> {
 "scrolling": boolean
 "hovered": E

constructor(arg0: $ModListScreen$Type, arg1: integer, arg2: integer, arg3: integer)

public "refreshList"(): void
public "getRowWidth"(): integer
get "rowWidth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModListWidget$Type = ($ModListWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModListWidget_ = $ModListWidget$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBoat" {
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IForgeBoat {

 "canBoatInFluid"(arg0: $FluidType$Type): boolean
 "canBoatInFluid"(arg0: $FluidState$Type): boolean
 "shouldUpdateFluidWhileRiding"(arg0: $FluidState$Type, arg1: $Entity$Type): boolean
}

export namespace $IForgeBoat {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBoat$Type = ($IForgeBoat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBoat_ = $IForgeBoat$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$IntValue" {
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfigSpec$IntValue extends $ForgeConfigSpec$ConfigValue<(integer)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$IntValue$Type = ($ForgeConfigSpec$IntValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$IntValue_ = $ForgeConfigSpec$IntValue$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$FalseCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $FalseCondition implements $ICondition {
static readonly "INSTANCE": $FalseCondition


public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FalseCondition$Type = ($FalseCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FalseCondition_ = $FalseCondition$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeKeyMapping" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$IKeyConflictContext, $IKeyConflictContext$Type} from "packages/net/minecraftforge/client/settings/$IKeyConflictContext"
import {$KeyModifier, $KeyModifier$Type} from "packages/net/minecraftforge/client/settings/$KeyModifier"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"

export interface $IForgeKeyMapping {

 "getKey"(): $InputConstants$Key
 "hasKeyModifierConflict"(arg0: $KeyMapping$Type): boolean
 "getKeyConflictContext"(): $IKeyConflictContext
 "setKeyConflictContext"(arg0: $IKeyConflictContext$Type): void
 "setKeyModifierAndCode"(arg0: $KeyModifier$Type, arg1: $InputConstants$Key$Type): void
 "isConflictContextAndModifierActive"(): boolean
 "getDefaultKeyModifier"(): $KeyModifier
 "setToDefault"(): void
 "isActiveAndMatches"(arg0: $InputConstants$Key$Type): boolean
 "getKeyModifier"(): $KeyModifier
}

export namespace $IForgeKeyMapping {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeKeyMapping$Type = ($IForgeKeyMapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeKeyMapping_ = $IForgeKeyMapping$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ViewportEvent$ComputeCameraAngles" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$GameRenderer, $GameRenderer$Type} from "packages/net/minecraft/client/renderer/$GameRenderer"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$ViewportEvent, $ViewportEvent$Type} from "packages/net/minecraftforge/client/event/$ViewportEvent"

export class $ViewportEvent$ComputeCameraAngles extends $ViewportEvent {

constructor()
constructor(arg0: $GameRenderer$Type, arg1: $Camera$Type, arg2: double, arg3: float, arg4: float, arg5: float)

public "setRoll"(arg0: float): void
public "getRoll"(): float
public "setPitch"(arg0: float): void
public "setYaw"(arg0: float): void
public "getPitch"(): float
public "getYaw"(): float
public "getListenerList"(): $ListenerList
set "roll"(value: float)
get "roll"(): float
set "pitch"(value: float)
set "yaw"(value: float)
get "pitch"(): float
get "yaw"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewportEvent$ComputeCameraAngles$Type = ($ViewportEvent$ComputeCameraAngles);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewportEvent$ComputeCameraAngles_ = $ViewportEvent$ComputeCameraAngles$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$IEventExceptionHandler" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$IEventListener, $IEventListener$Type} from "packages/net/minecraftforge/eventbus/api/$IEventListener"

export interface $IEventExceptionHandler {

 "handleException"(arg0: $IEventBus$Type, arg1: $Event$Type, arg2: ($IEventListener$Type)[], arg3: integer, arg4: $Throwable$Type): void

(arg0: $IEventBus$Type, arg1: $Event$Type, arg2: ($IEventListener$Type)[], arg3: integer, arg4: $Throwable$Type): void
}

export namespace $IEventExceptionHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventExceptionHandler$Type = ($IEventExceptionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventExceptionHandler_ = $IEventExceptionHandler$Type;
}}
declare module "packages/net/minecraftforge/network/simple/$IndexedMessageCodec" {
import {$IndexedMessageCodec$MessageHandler, $IndexedMessageCodec$MessageHandler$Type} from "packages/net/minecraftforge/network/simple/$IndexedMessageCodec$MessageHandler"
import {$NetworkInstance, $NetworkInstance$Type} from "packages/net/minecraftforge/network/$NetworkInstance"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export class $IndexedMessageCodec {

constructor()
constructor(arg0: $NetworkInstance$Type)

public "build"<MSG>(arg0: MSG, arg1: $FriendlyByteBuf$Type): integer
public "findMessageType"<MSG>(arg0: MSG): $IndexedMessageCodec$MessageHandler<(MSG)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexedMessageCodec$Type = ($IndexedMessageCodec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexedMessageCodec_ = $IndexedMessageCodec$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$AndCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $AndCondition implements $ICondition {

constructor(...arg0: ($ICondition$Type)[])

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndCondition$Type = ($AndCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndCondition_ = $AndCondition$Type;
}}
declare module "packages/net/minecraftforge/event/server/$ServerAboutToStartEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLifecycleEvent, $ServerLifecycleEvent$Type} from "packages/net/minecraftforge/event/server/$ServerLifecycleEvent"

export class $ServerAboutToStartEvent extends $ServerLifecycleEvent {

constructor(arg0: $MinecraftServer$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerAboutToStartEvent$Type = ($ServerAboutToStartEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerAboutToStartEvent_ = $ServerAboutToStartEvent$Type;
}}
declare module "packages/net/minecraftforge/server/$LanguageHook" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LanguageHook {

constructor()

public static "loadForgeAndMCLangs"(): void
public static "captureLanguageMap"(arg0: $Map$Type<(string), (string)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LanguageHook$Type = ($LanguageHook);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LanguageHook_ = $LanguageHook$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent$Operation" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SpawnPlacementRegisterEvent$Operation extends $Enum<($SpawnPlacementRegisterEvent$Operation)> {
static readonly "AND": $SpawnPlacementRegisterEvent$Operation
static readonly "OR": $SpawnPlacementRegisterEvent$Operation
static readonly "REPLACE": $SpawnPlacementRegisterEvent$Operation


public static "values"(): ($SpawnPlacementRegisterEvent$Operation)[]
public static "valueOf"(arg0: string): $SpawnPlacementRegisterEvent$Operation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnPlacementRegisterEvent$Operation$Type = (("or") | ("and") | ("replace")) | ($SpawnPlacementRegisterEvent$Operation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpawnPlacementRegisterEvent$Operation_ = $SpawnPlacementRegisterEvent$Operation$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeHolderSet" {
import {$IForgeHolderSet$SerializationType, $IForgeHolderSet$SerializationType$Type} from "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $IForgeHolderSet<T> {

 "addInvalidationListener"(arg0: $Runnable$Type): void
 "serializationType"(): $IForgeHolderSet$SerializationType
}

export namespace $IForgeHolderSet {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeHolderSet$Type<T> = ($IForgeHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeHolderSet_<T> = $IForgeHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeTagAppender" {
import {$TagsProvider$TagAppender, $TagsProvider$TagAppender$Type} from "packages/net/minecraft/data/tags/$TagsProvider$TagAppender"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $IForgeTagAppender<T> {

 "remove"(arg0: $TagKey$Type<(T)>, ...arg1: ($TagKey$Type<(T)>)[]): $TagsProvider$TagAppender<(T)>
 "remove"(arg0: $ResourceLocation$Type, ...arg1: ($ResourceLocation$Type)[]): $TagsProvider$TagAppender<(T)>
 "remove"(arg0: $ResourceKey$Type<(T)>): $TagsProvider$TagAppender<(T)>
 "remove"(arg0: $ResourceKey$Type<(T)>, ...arg1: ($ResourceKey$Type<(T)>)[]): $TagsProvider$TagAppender<(T)>
 "remove"(arg0: $TagKey$Type<(T)>): $TagsProvider$TagAppender<(T)>
 "remove"(arg0: $ResourceLocation$Type): $TagsProvider$TagAppender<(T)>
 "replace"(arg0: boolean): $TagsProvider$TagAppender<(T)>
 "replace"(): $TagsProvider$TagAppender<(T)>
 "addOptionalTags"(...arg0: ($TagKey$Type<(T)>)[]): $TagsProvider$TagAppender<(T)>
 "addOptionalTag"(arg0: $TagKey$Type<(T)>): $TagsProvider$TagAppender<(T)>
 "addTags"(...arg0: ($TagKey$Type<(T)>)[]): $TagsProvider$TagAppender<(T)>
}

export namespace $IForgeTagAppender {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeTagAppender$Type<T> = ($IForgeTagAppender<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeTagAppender_<T> = $IForgeTagAppender$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$FMLDedicatedServerSetupEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $FMLDedicatedServerSetupEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FMLDedicatedServerSetupEvent$Type = ($FMLDedicatedServerSetupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FMLDedicatedServerSetupEvent_ = $FMLDedicatedServerSetupEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$ItemPickupEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $PlayerEvent$ItemPickupEvent extends $PlayerEvent {

constructor(arg0: $Player$Type, arg1: $ItemEntity$Type, arg2: $ItemStack$Type)
constructor()

public "getStack"(): $ItemStack
public "getOriginalEntity"(): $ItemEntity
public "getListenerList"(): $ListenerList
get "stack"(): $ItemStack
get "originalEntity"(): $ItemEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$ItemPickupEvent$Type = ($PlayerEvent$ItemPickupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$ItemPickupEvent_ = $PlayerEvent$ItemPickupEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$LenientUnboundedMapCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$MapCodec, $MapCodec$Type} from "packages/com/mojang/serialization/$MapCodec"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/com/mojang/serialization/codecs/$UnboundedMapCodec"
import {$MapEncoder, $MapEncoder$Type} from "packages/com/mojang/serialization/$MapEncoder"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Encoder, $Encoder$Type} from "packages/com/mojang/serialization/$Encoder"
import {$Codec$ResultFunction, $Codec$ResultFunction$Type} from "packages/com/mojang/serialization/$Codec$ResultFunction"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Decoder, $Decoder$Type} from "packages/com/mojang/serialization/$Decoder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Lifecycle, $Lifecycle$Type} from "packages/com/mojang/serialization/$Lifecycle"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$BaseMapCodec, $BaseMapCodec$Type} from "packages/com/mojang/serialization/codecs/$BaseMapCodec"
import {$Decoder$Boxed, $Decoder$Boxed$Type} from "packages/com/mojang/serialization/$Decoder$Boxed"
import {$MapDecoder, $MapDecoder$Type} from "packages/com/mojang/serialization/$MapDecoder"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Decoder$Simple, $Decoder$Simple$Type} from "packages/com/mojang/serialization/$Decoder$Simple"
import {$SimpleMapCodec, $SimpleMapCodec$Type} from "packages/com/mojang/serialization/codecs/$SimpleMapCodec"
import {$Decoder$Terminal, $Decoder$Terminal$Type} from "packages/com/mojang/serialization/$Decoder$Terminal"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LenientUnboundedMapCodec<K, V> implements $BaseMapCodec<(K), (V)>, $Codec<($Map<(K), (V)>)> {

constructor(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "decode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $MapLike$Type<(T)>): $DataResult<($Map<(K), (V)>)>
public "decode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<($Pair<($Map<(K), (V)>), (T)>)>
public "encode"<T>(arg0: $Map$Type<(K), (V)>, arg1: $DynamicOps$Type<(T)>, arg2: T): $DataResult<(T)>
public "elementCodec"(): $Codec<(V)>
public "keyCodec"(): $Codec<(K)>
public "encode"<T>(arg0: $Map$Type<(K), (V)>, arg1: $DynamicOps$Type<(T)>, arg2: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public "dispatch"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $Codec<(E)>
public "dispatch"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(E)>
public static "of"<A>(arg0: $MapEncoder$Type<($Map$Type<(K), (V)>)>, arg1: $MapDecoder$Type<($Map$Type<(K), (V)>)>, arg2: $Supplier$Type<(string)>): $MapCodec<($Map<(K), (V)>)>
public static "of"<A>(arg0: $MapEncoder$Type<($Map$Type<(K), (V)>)>, arg1: $MapDecoder$Type<($Map$Type<(K), (V)>)>): $MapCodec<($Map<(K), (V)>)>
public static "of"<A>(arg0: $Encoder$Type<($Map$Type<(K), (V)>)>, arg1: $Decoder$Type<($Map$Type<(K), (V)>)>, arg2: string): $Codec<($Map<(K), (V)>)>
public static "of"<A>(arg0: $Encoder$Type<($Map$Type<(K), (V)>)>, arg1: $Decoder$Type<($Map$Type<(K), (V)>)>): $Codec<($Map<(K), (V)>)>
public static "list"<E>(arg0: $Codec$Type<(E)>): $Codec<($List<(E)>)>
public "orElse"(arg0: $Map$Type<(K), (V)>): $Codec<($Map<(K), (V)>)>
public "orElse"(arg0: $UnaryOperator$Type<(string)>, arg1: $Map$Type<(K), (V)>): $Codec<($Map<(K), (V)>)>
public "orElse"(arg0: $Consumer$Type<(string)>, arg1: $Map$Type<(K), (V)>): $Codec<($Map<(K), (V)>)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(arg0: N, arg1: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(arg0: $Map$Type<(K), (V)>): $Codec<($Map<(K), (V)>)>
public static "unit"<A>(arg0: $Supplier$Type<($Map$Type<(K), (V)>)>): $Codec<($Map<(K), (V)>)>
public "orElseGet"(arg0: $Supplier$Type<(any)>): $Codec<($Map<(K), (V)>)>
public "orElseGet"(arg0: $Consumer$Type<(string)>, arg1: $Supplier$Type<(any)>): $Codec<($Map<(K), (V)>)>
public "orElseGet"(arg0: $UnaryOperator$Type<(string)>, arg1: $Supplier$Type<(any)>): $Codec<($Map<(K), (V)>)>
public static "pair"<F, S>(arg0: $Codec$Type<(F)>, arg1: $Codec$Type<(S)>): $Codec<($Pair<(F), (S)>)>
public "xmap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "optionalField"<F>(arg0: string, arg1: $Codec$Type<(F)>): $MapCodec<($Optional<(F)>)>
public "deprecated"(arg0: integer): $Codec<($Map<(K), (V)>)>
public "withLifecycle"(arg0: $Lifecycle$Type): $Codec<($Map<(K), (V)>)>
public "optionalFieldOf"(arg0: string): $MapCodec<($Optional<($Map<(K), (V)>)>)>
public "optionalFieldOf"(arg0: string, arg1: $Map$Type<(K), (V)>, arg2: $Lifecycle$Type): $MapCodec<($Map<(K), (V)>)>
public "optionalFieldOf"(arg0: string, arg1: $Lifecycle$Type, arg2: $Map$Type<(K), (V)>, arg3: $Lifecycle$Type): $MapCodec<($Map<(K), (V)>)>
public "optionalFieldOf"(arg0: string, arg1: $Map$Type<(K), (V)>): $MapCodec<($Map<(K), (V)>)>
public "mapResult"(arg0: $Codec$ResultFunction$Type<($Map$Type<(K), (V)>)>): $Codec<($Map<(K), (V)>)>
public "flatXmap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public "promotePartial"(arg0: $Consumer$Type<(string)>): $Codec<($Map<(K), (V)>)>
public "partialDispatch"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $Codec<(E)>
public "dispatchMap"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $MapCodec<(E)>
public "dispatchMap"<E>(arg0: string, arg1: $Function$Type<(any), (any)>, arg2: $Function$Type<(any), (any)>): $MapCodec<(E)>
public static "compoundList"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>): $Codec<($List<($Pair<(K), (V)>)>)>
public static "either"<F, S>(arg0: $Codec$Type<(F)>, arg1: $Codec$Type<(S)>): $Codec<($Either<(F), (S)>)>
public static "mapPair"<F, S>(arg0: $MapCodec$Type<(F)>, arg1: $MapCodec$Type<(S)>): $MapCodec<($Pair<(F), (S)>)>
public static "mapEither"<F, S>(arg0: $MapCodec$Type<(F)>, arg1: $MapCodec$Type<(S)>): $MapCodec<($Either<(F), (S)>)>
public "dispatchStable"<E>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(E)>
public "comapFlatMap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "unboundedMap"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(arg0: $Function$Type<(any), (any)>, arg1: $Function$Type<(any), (any)>): $Codec<(S)>
public static "simpleMap"<K, V>(arg0: $Codec$Type<(K)>, arg1: $Codec$Type<(V)>, arg2: $Keyable$Type): $SimpleMapCodec<(K), (V)>
public static "doubleRange"(arg0: double, arg1: double): $Codec<(double)>
public static "floatRange"(arg0: float, arg1: float): $Codec<(float)>
public static "intRange"(arg0: integer, arg1: integer): $Codec<(integer)>
public "listOf"(): $Codec<($List<($Map<(K), (V)>)>)>
public "stable"(): $Codec<($Map<(K), (V)>)>
public static "empty"<A>(): $MapEncoder<($Map<(K), (V)>)>
public static "error"<A>(arg0: string): $Encoder<($Map<(K), (V)>)>
public "flatComap"<B>(arg0: $Function$Type<(any), (any)>): $Encoder<(B)>
public "comap"<B>(arg0: $Function$Type<(any), (any)>): $Encoder<(B)>
public "encodeStart"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $Map$Type<(K), (V)>): $DataResult<(T)>
public "decode"<T>(arg0: $Dynamic$Type<(T)>): $DataResult<($Pair<($Map<(K), (V)>), (T)>)>
public "map"<B>(arg0: $Function$Type<(any), (any)>): $Decoder<(B)>
public "flatMap"<B>(arg0: $Function$Type<(any), (any)>): $Decoder<(B)>
public "parse"<T>(arg0: $Dynamic$Type<(T)>): $DataResult<($Map<(K), (V)>)>
public "parse"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<($Map<(K), (V)>)>
public "boxed"(): $Decoder$Boxed<($Map<(K), (V)>)>
public "simple"(): $Decoder$Simple<($Map<(K), (V)>)>
public static "ofBoxed"<A>(arg0: $Decoder$Boxed$Type<(any)>): $Decoder<($Map<(K), (V)>)>
public static "ofTerminal"<A>(arg0: $Decoder$Terminal$Type<(any)>): $Decoder<($Map<(K), (V)>)>
public static "ofSimple"<A>(arg0: $Decoder$Simple$Type<(any)>): $Decoder<($Map<(K), (V)>)>
public "terminal"(): $Decoder$Terminal<($Map<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LenientUnboundedMapCodec$Type<K, V> = ($LenientUnboundedMapCodec<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LenientUnboundedMapCodec_<K, V> = $LenientUnboundedMapCodec$Type<(K), (V)>;
}}
declare module "packages/net/minecraftforge/common/util/$Lazy" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $Lazy<T> extends $Supplier<(T)> {

 "get"(): T

(arg0: $Supplier$Type<(T)>): $Lazy<(T)>
}

export namespace $Lazy {
function of<T>(arg0: $Supplier$Type<(T)>): $Lazy<(T)>
function concurrentOf<T>(arg0: $Supplier$Type<(T)>): $Lazy<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$Type<T> = ($Lazy<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lazy_<T> = $Lazy$Type<(T)>;
}}
declare module "packages/net/minecraftforge/registries/$IdMappingEvent$IdRemapping" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $IdMappingEvent$IdRemapping extends $Record {

constructor(currId: integer, newId: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "newId"(): integer
public "currId"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdMappingEvent$IdRemapping$Type = ($IdMappingEvent$IdRemapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdMappingEvent$IdRemapping_ = $IdMappingEvent$IdRemapping$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$TransformsBuilder" {
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$ModelBuilder$TransformsBuilder$TransformVecBuilder, $ModelBuilder$TransformsBuilder$TransformVecBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$TransformsBuilder$TransformVecBuilder"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $ModelBuilder$TransformsBuilder {

constructor(arg0: $ModelBuilder$Type<(any)>)

public "end"(): T
public "transform"(arg0: $ItemDisplayContext$Type): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$TransformsBuilder$Type = ($ModelBuilder$TransformsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$TransformsBuilder_ = $ModelBuilder$TransformsBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderPlayerEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$PlayerRenderer, $PlayerRenderer$Type} from "packages/net/minecraft/client/renderer/entity/player/$PlayerRenderer"
import {$RenderPlayerEvent, $RenderPlayerEvent$Type} from "packages/net/minecraftforge/client/event/$RenderPlayerEvent"

export class $RenderPlayerEvent$Post extends $RenderPlayerEvent {

constructor(arg0: $Player$Type, arg1: $PlayerRenderer$Type, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderPlayerEvent$Post$Type = ($RenderPlayerEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderPlayerEvent$Post_ = $RenderPlayerEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/common/property/$Properties" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $Properties {
static readonly "StaticProperty": $BooleanProperty
static readonly "AnimationProperty": $ModelProperty<($ModelState)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Properties$Type = ($Properties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Properties_ = $Properties$Type;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $InputEvent extends $Event {


public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$Type = ($InputEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent_ = $InputEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerContainerEvent$Close" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$PlayerContainerEvent, $PlayerContainerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerContainerEvent"

export class $PlayerContainerEvent$Close extends $PlayerContainerEvent {

constructor(arg0: $Player$Type, arg1: $AbstractContainerMenu$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerContainerEvent$Close$Type = ($PlayerContainerEvent$Close);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerContainerEvent$Close_ = $PlayerContainerEvent$Close$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkDataEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$ChunkEvent, $ChunkEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkEvent"

export class $ChunkDataEvent extends $ChunkEvent {

constructor()
constructor(arg0: $ChunkAccess$Type, arg1: $LevelAccessor$Type, arg2: $CompoundTag$Type)
constructor(arg0: $ChunkAccess$Type, arg1: $CompoundTag$Type)

public "getData"(): $CompoundTag
public "getListenerList"(): $ListenerList
get "data"(): $CompoundTag
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkDataEvent$Type = ($ChunkDataEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkDataEvent_ = $ChunkDataEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$PistonEvent$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PistonEvent$PistonMoveType, $PistonEvent$PistonMoveType$Type} from "packages/net/minecraftforge/event/level/$PistonEvent$PistonMoveType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PistonEvent, $PistonEvent$Type} from "packages/net/minecraftforge/event/level/$PistonEvent"

export class $PistonEvent$Pre extends $PistonEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $PistonEvent$PistonMoveType$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonEvent$Pre$Type = ($PistonEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PistonEvent$Pre_ = $PistonEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$ModFileScanData" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ModFileScanData$AnnotationData, $ModFileScanData$AnnotationData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData$AnnotationData"
import {$Type, $Type$Type} from "packages/org/objectweb/asm/$Type"
import {$ModFileScanData$ClassData, $ModFileScanData$ClassData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData$ClassData"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"

export class $ModFileScanData {

constructor()

public "getClasses"(): $Set<($ModFileScanData$ClassData)>
public "getAnnotations"(): $Set<($ModFileScanData$AnnotationData)>
public "getTargets"(): $Map<(string), (any)>
public "addModFileInfo"(arg0: $IModFileInfo$Type): void
public "addLanguageLoader"(arg0: $Map$Type<(string), (any)>): void
public "getIModInfoData"(): $List<($IModFileInfo)>
public static "interestingAnnotations"(): $Predicate<($Type)>
get "classes"(): $Set<($ModFileScanData$ClassData)>
get "annotations"(): $Set<($ModFileScanData$AnnotationData)>
get "targets"(): $Map<(string), (any)>
get "iModInfoData"(): $List<($IModFileInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFileScanData$Type = ($ModFileScanData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFileScanData_ = $ModFileScanData$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$VanillaPacketSplitter" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConnectionProtocol, $ConnectionProtocol$Type} from "packages/net/minecraft/network/$ConnectionProtocol"
import {$PacketFlow, $PacketFlow$Type} from "packages/net/minecraft/network/protocol/$PacketFlow"
import {$VanillaPacketSplitter$RemoteCompatibility, $VanillaPacketSplitter$RemoteCompatibility$Type} from "packages/net/minecraftforge/network/filters/$VanillaPacketSplitter$RemoteCompatibility"

export class $VanillaPacketSplitter {

constructor()

public static "register"(): void
public static "isRemoteCompatible"(arg0: $Connection$Type): boolean
public static "appendPackets"(arg0: $ConnectionProtocol$Type, arg1: $PacketFlow$Type, arg2: $Packet$Type<(any)>, arg3: $List$Type<(any)>): void
public static "getRemoteCompatibility"(arg0: $Connection$Type): $VanillaPacketSplitter$RemoteCompatibility
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaPacketSplitter$Type = ($VanillaPacketSplitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaPacketSplitter_ = $VanillaPacketSplitter$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeRegistryTag" {
import {$ITag, $ITag$Type} from "packages/net/minecraftforge/registries/tags/$ITag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $ForgeRegistryTag<V> implements $ITag<(V)> {


public "toString"(): string
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $Iterator<(V)>
public "stream"(): $Stream<(V)>
public "contains"(arg0: V): boolean
public "spliterator"(): $Spliterator<(V)>
public "getKey"(): $TagKey<(V)>
public "isBound"(): boolean
public "getRandomElement"(arg0: $RandomSource$Type): $Optional<(V)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<V>;
get "empty"(): boolean
get "key"(): $TagKey<(V)>
get "bound"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRegistryTag$Type<V> = ($ForgeRegistryTag<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRegistryTag_<V> = $ForgeRegistryTag$Type<(V)>;
}}
declare module "packages/net/minecraftforge/client/model/$IDynamicBakedModel" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ChunkRenderTypeSet, $ChunkRenderTypeSet$Type} from "packages/net/minecraftforge/client/$ChunkRenderTypeSet"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $IDynamicBakedModel extends $BakedModel {

 "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type): $List<($BakedQuad)>
 "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type, arg3: $ModelData$Type, arg4: $RenderType$Type): $List<($BakedQuad)>
 "usesBlockLight"(): boolean
 "isGui3d"(): boolean
/**
 * 
 * @deprecated
 */
 "getParticleIcon"(): $TextureAtlasSprite
 "isCustomRenderer"(): boolean
 "getOverrides"(): $ItemOverrides
/**
 * 
 * @deprecated
 */
 "getTransforms"(): $ItemTransforms
 "useAmbientOcclusion"(): boolean
 "useAmbientOcclusion"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
 "useAmbientOcclusion"(arg0: $BlockState$Type): boolean
 "getRenderTypes"(arg0: $ItemStack$Type, arg1: boolean): $List<($RenderType)>
 "getRenderTypes"(arg0: $BlockState$Type, arg1: $RandomSource$Type, arg2: $ModelData$Type): $ChunkRenderTypeSet
 "getRenderPasses"(arg0: $ItemStack$Type, arg1: boolean): $List<($BakedModel)>
 "applyTransform"(arg0: $ItemDisplayContext$Type, arg1: $PoseStack$Type, arg2: boolean): $BakedModel
 "getParticleIcon"(arg0: $ModelData$Type): $TextureAtlasSprite
 "getModelData"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ModelData$Type): $ModelData
 "useAmbientOcclusionWithLightEmission"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
}

export namespace $IDynamicBakedModel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDynamicBakedModel$Type = ($IDynamicBakedModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDynamicBakedModel_ = $IDynamicBakedModel$Type;
}}
declare module "packages/net/minecraftforge/event/$CommandEvent" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ParseResults, $ParseResults$Type} from "packages/com/mojang/brigadier/$ParseResults"

export class $CommandEvent extends $Event {

constructor()
constructor(arg0: $ParseResults$Type<($CommandSourceStack$Type)>)

public "getException"(): $Throwable
public "isCancelable"(): boolean
public "setException"(arg0: $Throwable$Type): void
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "setParseResults"(arg0: $ParseResults$Type<($CommandSourceStack$Type)>): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "exception"(): $Throwable
get "cancelable"(): boolean
set "exception"(value: $Throwable$Type)
get "parseResults"(): $ParseResults<($CommandSourceStack)>
set "parseResults"(value: $ParseResults$Type<($CommandSourceStack$Type)>)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandEvent$Type = ($CommandEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandEvent_ = $CommandEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingKnockBackEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingKnockBackEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: float, arg2: double, arg3: double)
constructor()

public "getOriginalStrength"(): float
public "isCancelable"(): boolean
public "getRatioX"(): double
public "getRatioZ"(): double
public "getStrength"(): float
public "setStrength"(arg0: float): void
public "setRatioX"(arg0: double): void
public "getOriginalRatioZ"(): double
public "getOriginalRatioX"(): double
public "setRatioZ"(arg0: double): void
public "getListenerList"(): $ListenerList
get "originalStrength"(): float
get "cancelable"(): boolean
get "ratioX"(): double
get "ratioZ"(): double
get "strength"(): float
set "strength"(value: float)
set "ratioX"(value: double)
get "originalRatioZ"(): double
get "originalRatioX"(): double
set "ratioZ"(value: double)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingKnockBackEvent$Type = ($LivingKnockBackEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingKnockBackEvent_ = $LivingKnockBackEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderItemInFrameEvent" {
import {$ItemFrame, $ItemFrame$Type} from "packages/net/minecraft/world/entity/decoration/$ItemFrame"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$ItemFrameRenderer, $ItemFrameRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$ItemFrameRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $RenderItemInFrameEvent extends $Event {

constructor()
constructor(arg0: $ItemFrame$Type, arg1: $ItemFrameRenderer$Type<(any)>, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: integer)

public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getItemStack"(): $ItemStack
public "getPackedLight"(): integer
public "getRenderer"(): $ItemFrameRenderer<(any)>
public "getItemFrameEntity"(): $ItemFrame
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "itemStack"(): $ItemStack
get "packedLight"(): integer
get "renderer"(): $ItemFrameRenderer<(any)>
get "itemFrameEntity"(): $ItemFrame
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderItemInFrameEvent$Type = ($RenderItemInFrameEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderItemInFrameEvent_ = $RenderItemInFrameEvent$Type;
}}
declare module "packages/net/minecraftforge/fluids/$FluidType" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Boat, $Boat$Type} from "packages/net/minecraft/world/entity/vehicle/$Boat"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$SoundAction, $SoundAction$Type} from "packages/net/minecraftforge/common/$SoundAction"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $FluidType {
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(arg0: $FluidType$Properties$Type)

public "toString"(): string
public "move"(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
public "getDescription"(arg0: $FluidStack$Type): $Component
public "getDescription"(): $Component
public "getBlockPathType"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type, arg4: boolean): $BlockPathTypes
public "initializeClient"(arg0: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
public "getRenderPropertiesInternal"(): any
public "getAdjacentBlockPathType"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type, arg4: $BlockPathTypes$Type): $BlockPathTypes
public "shouldUpdateWhileBoating"(arg0: $FluidState$Type, arg1: $Boat$Type, arg2: $Entity$Type): boolean
public "isAir"(): boolean
public "getTemperature"(): integer
public "getTemperature"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): integer
public "getTemperature"(arg0: $FluidStack$Type): integer
public "getBucket"(arg0: $FluidStack$Type): $ItemStack
public "getViscosity"(arg0: $FluidStack$Type): integer
public "getViscosity"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): integer
public "getViscosity"(): integer
public "getLightLevel"(arg0: $FluidStack$Type): integer
public "getLightLevel"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): integer
public "getLightLevel"(): integer
public "getDensity"(arg0: $FluidStack$Type): integer
public "getDensity"(arg0: $FluidState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type): integer
public "getDensity"(): integer
public "getDescriptionId"(arg0: $FluidStack$Type): string
public "getDescriptionId"(): string
public "isLighterThanAir"(): boolean
public "canBePlacedInLevel"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidState$Type): boolean
public "canBePlacedInLevel"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidStack$Type): boolean
public "isVanilla"(): boolean
public "canRideVehicleUnder"(arg0: $Entity$Type, arg1: $Entity$Type): boolean
public "getFallDistanceModifier"(arg0: $Entity$Type): float
public "getStateForPlacement"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidStack$Type): $FluidState
public "getBlockForFluidState"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidState$Type): $BlockState
public "isVaporizedOnPlacement"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $FluidStack$Type): boolean
public "getRarity"(arg0: $FluidStack$Type): $Rarity
public "getRarity"(): $Rarity
public "onVaporize"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $FluidStack$Type): void
public "setItemMovement"(arg0: $ItemEntity$Type): void
public "supportsBoating"(arg0: $FluidState$Type, arg1: $Boat$Type): boolean
public "supportsBoating"(arg0: $Boat$Type): boolean
public "canConvertToSource"(arg0: $FluidState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
public "canConvertToSource"(arg0: $FluidStack$Type): boolean
public "canDrownIn"(arg0: $LivingEntity$Type): boolean
public "canSwim"(arg0: $Entity$Type): boolean
public "canExtinguish"(arg0: $Entity$Type): boolean
public "canExtinguish"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
public "canHydrate"(arg0: $FluidStack$Type): boolean
public "canHydrate"(arg0: $Entity$Type): boolean
public "canHydrate"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type): boolean
public "canPushEntity"(arg0: $Entity$Type): boolean
public "motionScale"(arg0: $Entity$Type): double
public "getSound"(arg0: $Entity$Type, arg1: $SoundAction$Type): $SoundEvent
public "getSound"(arg0: $Player$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $SoundAction$Type): $SoundEvent
public "getSound"(arg0: $FluidStack$Type, arg1: $SoundAction$Type): $SoundEvent
public "getSound"(arg0: $SoundAction$Type): $SoundEvent
get "description"(): $Component
get "renderPropertiesInternal"(): any
get "air"(): boolean
get "temperature"(): integer
get "viscosity"(): integer
get "lightLevel"(): integer
get "density"(): integer
get "descriptionId"(): string
get "lighterThanAir"(): boolean
get "vanilla"(): boolean
get "rarity"(): $Rarity
set "itemMovement"(value: $ItemEntity$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidType$Type = ($FluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidType_ = $FluidType$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityMountEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityMountEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Entity$Type, arg2: $Level$Type, arg3: boolean)

public "getLevel"(): $Level
public "isCancelable"(): boolean
public "getEntityMounting"(): $Entity
public "isDismounting"(): boolean
public "isMounting"(): boolean
public "getEntityBeingMounted"(): $Entity
public "getListenerList"(): $ListenerList
get "level"(): $Level
get "cancelable"(): boolean
get "entityMounting"(): $Entity
get "dismounting"(): boolean
get "mounting"(): boolean
get "entityBeingMounted"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityMountEvent$Type = ($EntityMountEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityMountEvent_ = $EntityMountEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$VariantBlockStateBuilder$PartialBlockstate" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$VariantBlockStateBuilder, $VariantBlockStateBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$VariantBlockStateBuilder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$ConfiguredModel$Builder, $ConfiguredModel$Builder$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel$Builder"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ConfiguredModel, $ConfiguredModel$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel"

export class $VariantBlockStateBuilder$PartialBlockstate implements $Predicate<($BlockState)> {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(arg0: $BlockState$Type): boolean
public "getOwner"(): $Block
public "with"<T extends $Comparable<(T)>>(arg0: $Property$Type<(T)>, arg1: T): $VariantBlockStateBuilder$PartialBlockstate
public "setModels"(...arg0: ($ConfiguredModel$Type)[]): $VariantBlockStateBuilder
public "modelForState"(): $ConfiguredModel$Builder<($VariantBlockStateBuilder)>
public "addModels"(...arg0: ($ConfiguredModel$Type)[]): $VariantBlockStateBuilder$PartialBlockstate
public "partialState"(): $VariantBlockStateBuilder$PartialBlockstate
public "getSetStates"(): $SortedMap<($Property<(any)>), ($Comparable<(any)>)>
public static "comparingByProperties"(): $Comparator<($VariantBlockStateBuilder$PartialBlockstate)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public "negate"(): $Predicate<($BlockState)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
public static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
get "owner"(): $Block
set "models"(value: ($ConfiguredModel$Type)[])
get "setStates"(): $SortedMap<($Property<(any)>), ($Comparable<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateBuilder$PartialBlockstate$Type = ($VariantBlockStateBuilder$PartialBlockstate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateBuilder$PartialBlockstate_ = $VariantBlockStateBuilder$PartialBlockstate$Type;
}}
declare module "packages/net/minecraftforge/entity/$PartEntity" {
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PartEntity<T extends $Entity> extends $Entity {
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: T)

public "getParent"(): T
public "getAddEntityPacket"(): $Packet<($ClientGamePacketListener)>
get "parent"(): T
get "addEntityPacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PartEntity$Type<T> = ($PartEntity<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PartEntity_<T> = $PartEntity$Type<(T)>;
}}
declare module "packages/net/minecraftforge/gametest/$GameTestHolder" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $GameTestHolder extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $GameTestHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameTestHolder$Type = ($GameTestHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameTestHolder_ = $GameTestHolder$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Init$Post" {
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$Init, $ScreenEvent$Init$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$Init"

export class $ScreenEvent$Init$Post extends $ScreenEvent$Init {

constructor(arg0: $Screen$Type, arg1: $List$Type<($GuiEventListener$Type)>, arg2: $Consumer$Type<($GuiEventListener$Type)>, arg3: $Consumer$Type<($GuiEventListener$Type)>)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Init$Post$Type = ($ScreenEvent$Init$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Init$Post_ = $ScreenEvent$Init$Post$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$ProjectileImpactEvent$ImpactResult, $ProjectileImpactEvent$ImpactResult$Type} from "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent$ImpactResult"

export class $ProjectileImpactEvent extends $EntityEvent {

constructor(arg0: $Projectile$Type, arg1: $HitResult$Type)
constructor()

public "getRayTraceResult"(): $HitResult
public "getProjectile"(): $Projectile
/**
 * 
 * @deprecated
 */
public "setCanceled"(arg0: boolean): void
public "isCancelable"(): boolean
public "getImpactResult"(): $ProjectileImpactEvent$ImpactResult
public "setImpactResult"(arg0: $ProjectileImpactEvent$ImpactResult$Type): void
public "getListenerList"(): $ListenerList
get "rayTraceResult"(): $HitResult
get "projectile"(): $Projectile
set "canceled"(value: boolean)
get "cancelable"(): boolean
get "impactResult"(): $ProjectileImpactEvent$ImpactResult
set "impactResult"(value: $ProjectileImpactEvent$ImpactResult$Type)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProjectileImpactEvent$Type = ($ProjectileImpactEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProjectileImpactEvent_ = $ProjectileImpactEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$CropGrowEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent$CropGrowEvent extends $BlockEvent {

constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$CropGrowEvent$Type = ($BlockEvent$CropGrowEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$CropGrowEvent_ = $BlockEvent$CropGrowEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModLoadingPhase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLoadingPhase extends $Enum<($ModLoadingPhase)> {
static readonly "ERROR": $ModLoadingPhase
static readonly "GATHER": $ModLoadingPhase
static readonly "LOAD": $ModLoadingPhase
static readonly "COMPLETE": $ModLoadingPhase
static readonly "DONE": $ModLoadingPhase


public static "values"(): ($ModLoadingPhase)[]
public static "valueOf"(arg0: string): $ModLoadingPhase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadingPhase$Type = (("load") | ("gather") | ("error") | ("complete") | ("done")) | ($ModLoadingPhase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadingPhase_ = $ModLoadingPhase$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$SidedInvWrapper" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$WorldlyContainer, $WorldlyContainer$Type} from "packages/net/minecraft/world/$WorldlyContainer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $SidedInvWrapper implements $IItemHandlerModifiable {

constructor(arg0: $WorldlyContainer$Type, arg1: $Direction$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "getSlot"(arg0: $WorldlyContainer$Type, arg1: integer, arg2: $Direction$Type): integer
public static "create"(arg0: $WorldlyContainer$Type, ...arg1: ($Direction$Type)[]): ($LazyOptional<($IItemHandlerModifiable)>)[]
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedInvWrapper$Type = ($SidedInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedInvWrapper_ = $SidedInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$NotCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $NotCondition implements $ICondition {

constructor(arg0: $ICondition$Type)

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotCondition$Type = ($NotCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotCondition_ = $NotCondition$Type;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$MouseScrollingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InputEvent, $InputEvent$Type} from "packages/net/minecraftforge/client/event/$InputEvent"

export class $InputEvent$MouseScrollingEvent extends $InputEvent {

constructor()
constructor(arg0: double, arg1: boolean, arg2: boolean, arg3: boolean, arg4: double, arg5: double)

public "isCancelable"(): boolean
public "getMouseX"(): double
public "getMouseY"(): double
public "isLeftDown"(): boolean
public "isRightDown"(): boolean
public "isMiddleDown"(): boolean
public "getScrollDelta"(): double
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "mouseX"(): double
get "mouseY"(): double
get "leftDown"(): boolean
get "rightDown"(): boolean
get "middleDown"(): boolean
get "scrollDelta"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$MouseScrollingEvent$Type = ($InputEvent$MouseScrollingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$MouseScrollingEvent_ = $InputEvent$MouseScrollingEvent$Type;
}}
declare module "packages/net/minecraftforge/data/event/$GatherDataEvent" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$GatherDataEvent$DataGeneratorConfig, $GatherDataEvent$DataGeneratorConfig$Type} from "packages/net/minecraftforge/data/event/$GatherDataEvent$DataGeneratorConfig"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DataGenerator, $DataGenerator$Type} from "packages/net/minecraft/data/$DataGenerator"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"

export class $GatherDataEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $ModContainer$Type, arg1: $DataGenerator$Type, arg2: $GatherDataEvent$DataGeneratorConfig$Type, arg3: $ExistingFileHelper$Type)

public "validate"(): boolean
public "isCancelable"(): boolean
public "includeServer"(): boolean
public "getLookupProvider"(): $CompletableFuture<($HolderLookup$Provider)>
public "getGenerator"(): $DataGenerator
public "includeReports"(): boolean
public "includeDev"(): boolean
public "includeClient"(): boolean
public "getInputs"(): $Collection<($Path)>
public "getModContainer"(): $ModContainer
public "getExistingFileHelper"(): $ExistingFileHelper
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "lookupProvider"(): $CompletableFuture<($HolderLookup$Provider)>
get "generator"(): $DataGenerator
get "inputs"(): $Collection<($Path)>
get "modContainer"(): $ModContainer
get "existingFileHelper"(): $ExistingFileHelper
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GatherDataEvent$Type = ($GatherDataEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GatherDataEvent_ = $GatherDataEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$PotionColorCalculationEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $PotionColorCalculationEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: integer, arg2: boolean, arg3: $Collection$Type<($MobEffectInstance$Type)>)

public "setColor"(arg0: integer): void
public "areParticlesHidden"(): boolean
public "getColor"(): integer
public "getEffects"(): $Collection<($MobEffectInstance)>
public "getListenerList"(): $ListenerList
public "shouldHideParticles"(arg0: boolean): void
set "color"(value: integer)
get "color"(): integer
get "effects"(): $Collection<($MobEffectInstance)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionColorCalculationEvent$Type = ($PotionColorCalculationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionColorCalculationEvent_ = $PotionColorCalculationEvent$Type;
}}
declare module "packages/net/minecraftforge/client/textures/$UnitTextureAtlasSprite" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $UnitTextureAtlasSprite extends $TextureAtlasSprite {
static readonly "LOCATION": $ResourceLocation
static readonly "INSTANCE": $UnitTextureAtlasSprite


public "getU"(arg0: double): float
public "getV"(arg0: double): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitTextureAtlasSprite$Type = ($UnitTextureAtlasSprite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitTextureAtlasSprite_ = $UnitTextureAtlasSprite$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$EnderManAngerEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"

export class $EnderManAngerEvent extends $LivingEvent {

constructor(arg0: $EnderMan$Type, arg1: $Player$Type)
constructor()

public "isCancelable"(): boolean
public "getPlayer"(): $Player
public "getEntity"(): $EnderMan
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "player"(): $Player
get "entity"(): $EnderMan
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnderManAngerEvent$Type = ($EnderManAngerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnderManAngerEvent_ = $EnderManAngerEvent$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$AutoRegisterCapability" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $AutoRegisterCapability extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $AutoRegisterCapability {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutoRegisterCapability$Type = ($AutoRegisterCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutoRegisterCapability_ = $AutoRegisterCapability$Type;
}}
declare module "packages/net/minecraftforge/forgespi/locating/$IModFile" {
import {$SecureJar, $SecureJar$Type} from "packages/cpw/mods/jarhandling/$SecureJar"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$IModFile$Type, $IModFile$Type$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile$Type"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$ModFileScanData, $ModFileScanData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData"
import {$IModLanguageProvider, $IModLanguageProvider$Type} from "packages/net/minecraftforge/forgespi/language/$IModLanguageProvider"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModProvider, $IModProvider$Type} from "packages/net/minecraftforge/forgespi/locating/$IModProvider"
import {$SecureJar$Status, $SecureJar$Status$Type} from "packages/cpw/mods/jarhandling/$SecureJar$Status"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IModFile {

 "findResource"(...arg0: (string)[]): $Path
 "getType"(): $IModFile$Type
 "getFileName"(): string
 "getProvider"(): $IModProvider
 "getFilePath"(): $Path
 "getSubstitutionMap"(): $Supplier<($Map<(string), (any)>)>
 "getLoaders"(): $List<($IModLanguageProvider)>
 "getModFileInfo"(): $IModFileInfo
 "getSecureJar"(): $SecureJar
 "setSecurityStatus"(arg0: $SecureJar$Status$Type): void
 "getModInfos"(): $List<($IModInfo)>
 "getScanResult"(): $ModFileScanData
}

export namespace $IModFile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModFile$Type = ($IModFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModFile_ = $IModFile$Type;
}}
declare module "packages/net/minecraftforge/server/command/$CommandHelper" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Command, $Command$Type} from "packages/com/mojang/brigadier/$Command"
import {$CommandNode, $CommandNode$Type} from "packages/com/mojang/brigadier/tree/$CommandNode"
import {$SuggestionProvider, $SuggestionProvider$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CommandHelper {


public static "mergeCommandNode"<S, T>(arg0: $CommandNode$Type<(S)>, arg1: $CommandNode$Type<(T)>, arg2: $Map$Type<($CommandNode$Type<(S)>), ($CommandNode$Type<(T)>)>, arg3: S, arg4: $Command$Type<(T)>, arg5: $Function$Type<($SuggestionProvider$Type<(S)>), ($SuggestionProvider$Type<(T)>)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandHelper$Type = ($CommandHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandHelper_ = $CommandHelper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyPressed$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$KeyPressed, $ScreenEvent$KeyPressed$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyPressed"

export class $ScreenEvent$KeyPressed$Post extends $ScreenEvent$KeyPressed {

constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)
constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyPressed$Post$Type = ($ScreenEvent$KeyPressed$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyPressed$Post_ = $ScreenEvent$KeyPressed$Post$Type;
}}
declare module "packages/net/minecraftforge/client/model/data/$ModelProperty" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $ModelProperty<T> implements $Predicate<(T)> {

constructor()
constructor(arg0: $Predicate$Type<(T)>)

public "test"(arg0: T): boolean
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public "negate"(): $Predicate<(T)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelProperty$Type<T> = ($ModelProperty<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelProperty_<T> = $ModelProperty$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fml/loading/progress/$Message$MessageType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $Message$MessageType extends $Enum<($Message$MessageType)> {
static readonly "MC": $Message$MessageType
static readonly "ML": $Message$MessageType
static readonly "LOC": $Message$MessageType
static readonly "MOD": $Message$MessageType


public static "values"(): ($Message$MessageType)[]
public static "valueOf"(arg0: string): $Message$MessageType
public "colour"(): (float)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Message$MessageType$Type = (("loc") | ("mod") | ("mc") | ("ml")) | ($Message$MessageType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Message$MessageType_ = $Message$MessageType$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeCommandSourceStack" {
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$Scoreboard, $Scoreboard$Type} from "packages/net/minecraft/world/scores/$Scoreboard"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export interface $IForgeCommandSourceStack {

 "getScoreboard"(): $Scoreboard
 "getUnsidedLevel"(): $Level
 "getRecipeManager"(): $RecipeManager
 "getAdvancement"(arg0: $ResourceLocation$Type): $Advancement
}

export namespace $IForgeCommandSourceStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeCommandSourceStack$Type = ($IForgeCommandSourceStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeCommandSourceStack_ = $IForgeCommandSourceStack$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/loaders/$SeparateTransformsModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $SeparateTransformsModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public "base"(arg0: T): $SeparateTransformsModelBuilder<(T)>
public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $SeparateTransformsModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "perspective"(arg0: $ItemDisplayContext$Type, arg1: T): $SeparateTransformsModelBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeparateTransformsModelBuilder$Type<T> = ($SeparateTransformsModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeparateTransformsModelBuilder_<T> = $SeparateTransformsModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$ItemSmeltedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PlayerEvent$ItemSmeltedEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type)

public "getSmelting"(): $ItemStack
public "getListenerList"(): $ListenerList
get "smelting"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$ItemSmeltedEvent$Type = ($PlayerEvent$ItemSmeltedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$ItemSmeltedEvent_ = $PlayerEvent$ItemSmeltedEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderNameTagEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $RenderNameTagEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Component$Type, arg2: $EntityRenderer$Type<(any)>, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer, arg6: float)

public "getContent"(): $Component
public "getPartialTick"(): float
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getEntityRenderer"(): $EntityRenderer<(any)>
public "getOriginalContent"(): $Component
public "setContent"(arg0: $Component$Type): void
public "getPackedLight"(): integer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "content"(): $Component
get "partialTick"(): float
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "entityRenderer"(): $EntityRenderer<(any)>
get "originalContent"(): $Component
set "content"(value: $Component$Type)
get "packedLight"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderNameTagEvent$Type = ($RenderNameTagEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderNameTagEvent_ = $RenderNameTagEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/lighting/$QuadLighter" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$PoseStack$Pose, $PoseStack$Pose$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack$Pose"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $QuadLighter {


public "setup"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public "reset"(): void
public "process"(arg0: $VertexConsumer$Type, arg1: $PoseStack$Pose$Type, arg2: $BakedQuad$Type, arg3: integer): void
public static "calculateShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadLighter$Type = ($QuadLighter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadLighter_ = $QuadLighter$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$LevelTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent$LevelTickEvent extends $TickEvent {
readonly "level": $Level
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor()
constructor(arg0: $LogicalSide$Type, arg1: $TickEvent$Phase$Type, arg2: $Level$Type, arg3: $BooleanSupplier$Type)

public "haveTime"(): boolean
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$LevelTickEvent$Type = ($TickEvent$LevelTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$LevelTickEvent_ = $TickEvent$LevelTickEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$CenterChunkPosComparator" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export class $CenterChunkPosComparator implements $Comparator<($ChunkPos)> {

constructor(arg0: $ServerPlayer$Type)

public "compare"(arg0: $ChunkPos$Type, arg1: $ChunkPos$Type): integer
public "equals"(arg0: any): boolean
public static "reverseOrder"<T extends $Comparable<(any)>>(): $Comparator<($ChunkPos)>
public static "comparing"<T, U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($ChunkPos)>
public static "comparing"<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($ChunkPos)>
public "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<($ChunkPos)>
public "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<($ChunkPos)>
public "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<($ChunkPos)>
public static "comparingInt"<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<($ChunkPos)>
public static "comparingLong"<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<($ChunkPos)>
public static "comparingDouble"<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($ChunkPos)>
public "reversed"(): $Comparator<($ChunkPos)>
public "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<($ChunkPos)>
public "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<($ChunkPos)>
public "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<($ChunkPos)>
public static "naturalOrder"<T extends $Comparable<(any)>>(): $Comparator<($ChunkPos)>
public static "nullsFirst"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($ChunkPos)>
public static "nullsLast"<T>(arg0: $Comparator$Type<(any)>): $Comparator<($ChunkPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CenterChunkPosComparator$Type = ($CenterChunkPosComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CenterChunkPosComparator_ = $CenterChunkPosComparator$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$AdvancementEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export class $AdvancementEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Advancement$Type)

public "getAdvancement"(): $Advancement
public "getListenerList"(): $ListenerList
get "advancement"(): $Advancement
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementEvent$Type = ($AdvancementEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdvancementEvent_ = $AdvancementEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$ZombieEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Zombie, $Zombie$Type} from "packages/net/minecraft/world/entity/monster/$Zombie"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"

export class $ZombieEvent extends $EntityEvent {

constructor()
constructor(arg0: $Zombie$Type)

public "getEntity"(): $Zombie
public "getListenerList"(): $ListenerList
get "entity"(): $Zombie
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ZombieEvent$Type = ($ZombieEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ZombieEvent_ = $ZombieEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/progress/$ProgressMeter" {
import {$Message, $Message$Type} from "packages/net/minecraftforge/fml/loading/progress/$Message"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ProgressMeter {

constructor(arg0: string, arg1: integer, arg2: integer, arg3: $Message$Type)

public "name"(): string
public "increment"(): void
public "current"(): integer
public "label"(arg0: string): void
public "label"(): $Message
public "steps"(): integer
public "complete"(): void
public "setAbsolute"(arg0: integer): void
public "progress"(): float
set "absolute"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressMeter$Type = ($ProgressMeter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressMeter_ = $ProgressMeter$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$InvWrapper" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $InvWrapper implements $IItemHandlerModifiable {

constructor(arg0: $Container$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "getInv"(): $Container
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "inv"(): $Container
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvWrapper$Type = ($InvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvWrapper_ = $InvWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjMaterialLibrary$Material" {
import {$Vector4f, $Vector4f$Type} from "packages/org/joml/$Vector4f"

export class $ObjMaterialLibrary$Material {
readonly "name": string
 "ambientColor": $Vector4f
 "ambientColorMap": string
 "diffuseColor": $Vector4f
 "diffuseColorMap": string
 "specularColor": $Vector4f
 "specularHighlight": float
 "specularColorMap": string
 "dissolve": float
 "transparency": float
 "diffuseTintIndex": integer

constructor(arg0: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjMaterialLibrary$Material$Type = ($ObjMaterialLibrary$Material);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjMaterialLibrary$Material_ = $ObjMaterialLibrary$Material$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$StopTracking" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayerEvent$StopTracking extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Entity$Type)

public "getTarget"(): $Entity
public "getListenerList"(): $ListenerList
get "target"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$StopTracking$Type = ($PlayerEvent$StopTracking);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$StopTracking_ = $PlayerEvent$StopTracking$Type;
}}
declare module "packages/net/minecraftforge/data/event/$GatherDataEvent$DataGeneratorConfig" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DataGenerator, $DataGenerator$Type} from "packages/net/minecraft/data/$DataGenerator"

export class $GatherDataEvent$DataGeneratorConfig {

constructor(arg0: $Set$Type<(string)>, arg1: $Path$Type, arg2: $Collection$Type<($Path$Type)>, arg3: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean)

public "getMods"(): $Set<(string)>
public "getInputs"(): $Collection<($Path)>
public "makeGenerator"(arg0: $Function$Type<($Path$Type), ($Path$Type)>, arg1: boolean): $DataGenerator
public "isFlat"(): boolean
public "runAll"(): void
get "mods"(): $Set<(string)>
get "inputs"(): $Collection<($Path)>
get "flat"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GatherDataEvent$DataGeneratorConfig$Type = ($GatherDataEvent$DataGeneratorConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GatherDataEvent$DataGeneratorConfig_ = $GatherDataEvent$DataGeneratorConfig$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

export class $RegisterColorHandlersEvent extends $Event implements $IModBusEvent {


public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterColorHandlersEvent$Type = ($RegisterColorHandlersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterColorHandlersEvent_ = $RegisterColorHandlersEvent$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeItemTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$TagsProvider$TagLookup, $TagsProvider$TagLookup$Type} from "packages/net/minecraft/data/tags/$TagsProvider$TagLookup"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemTagsProvider, $ItemTagsProvider$Type} from "packages/net/minecraft/data/tags/$ItemTagsProvider"

export class $ForgeItemTagsProvider extends $ItemTagsProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $CompletableFuture$Type<($TagsProvider$TagLookup$Type<($Block$Type)>)>, arg3: $ExistingFileHelper$Type)

public "m_6577_"(arg0: $HolderLookup$Provider$Type): void
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeItemTagsProvider$Type = ($ForgeItemTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeItemTagsProvider_ = $ForgeItemTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$SoundEvent$SoundSourceEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Channel, $Channel$Type} from "packages/com/mojang/blaze3d/audio/$Channel"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraftforge/client/event/sound/$SoundEvent"

export class $SoundEvent$SoundSourceEvent extends $SoundEvent {

constructor()

public "getName"(): string
public "getChannel"(): $Channel
public "getSound"(): $SoundInstance
public "getListenerList"(): $ListenerList
get "name"(): string
get "channel"(): $Channel
get "sound"(): $SoundInstance
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEvent$SoundSourceEvent$Type = ($SoundEvent$SoundSourceEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEvent$SoundSourceEvent_ = $SoundEvent$SoundSourceEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$GrindstoneEvent$OnPlaceItem" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GrindstoneEvent, $GrindstoneEvent$Type} from "packages/net/minecraftforge/event/$GrindstoneEvent"

export class $GrindstoneEvent$OnPlaceItem extends $GrindstoneEvent {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer)

public "isCancelable"(): boolean
public "setOutput"(arg0: $ItemStack$Type): void
public "getOutput"(): $ItemStack
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
set "output"(value: $ItemStack$Type)
get "output"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrindstoneEvent$OnPlaceItem$Type = ($GrindstoneEvent$OnPlaceItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GrindstoneEvent$OnPlaceItem_ = $GrindstoneEvent$OnPlaceItem$Type;
}}
declare module "packages/net/minecraftforge/common/util/$ConcatenatedListView" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $ConcatenatedListView<T> implements $List<(T)> {


public "add"(arg0: T): boolean
public "add"(arg0: integer, arg1: T): void
public "remove"(arg0: integer): T
public "remove"(arg0: any): boolean
public "get"(arg0: integer): T
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "size"(): integer
public "subList"(arg0: integer, arg1: integer): $List<(T)>
public "toArray"<T1>(arg0: (T1)[]): (T1)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(T)>
public static "of"<T>(...arg0: ($List$Type<(T)>)[]): $ConcatenatedListView<(T)>
public static "of"<T>(arg0: $List$Type<(any)>): $List<(T)>
public "contains"(arg0: any): boolean
public "spliterator"(): $Spliterator<(T)>
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: T): T
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "listIterator"(arg0: integer): $ListIterator<(T)>
public "listIterator"(): $ListIterator<(T)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(T)>
public "replaceAll"(arg0: $UnaryOperator$Type<(T)>): void
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T): $List<(T)>
public static "of"<E>(arg0: T): $List<(T)>
public static "of"<E>(): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, arg7: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, arg7: T, arg8: T, arg9: T): $List<(T)>
public static "of"<E>(arg0: T, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, arg7: T, arg8: T): $List<(T)>
public static "of"<E>(...arg0: (T)[]): $List<(T)>
public "sort"(arg0: $Comparator$Type<(any)>): void
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(T)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(T)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<T>;
[index: number]: T
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConcatenatedListView$Type<T> = ($ConcatenatedListView<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConcatenatedListView_<T> = $ConcatenatedListView$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/$ForgeTier" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $ForgeTier implements $Tier {

constructor(arg0: integer, arg1: integer, arg2: float, arg3: float, arg4: integer, arg5: $TagKey$Type<($Block$Type)>, arg6: $Supplier$Type<($Ingredient$Type)>)

public "toString"(): string
public "getTag"(): $TagKey<($Block)>
public "getEnchantmentValue"(): integer
public "getSpeed"(): float
public "getUses"(): integer
public "getAttackDamageBonus"(): float
public "getLevel"(): integer
public "getRepairIngredient"(): $Ingredient
get "tag"(): $TagKey<($Block)>
get "enchantmentValue"(): integer
get "speed"(): float
get "uses"(): integer
get "attackDamageBonus"(): float
get "level"(): integer
get "repairIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeTier$Type = ($ForgeTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeTier_ = $ForgeTier$Type;
}}
declare module "packages/net/minecraftforge/network/$IContainerFactory" {
import {$MenuType$MenuSupplier, $MenuType$MenuSupplier$Type} from "packages/net/minecraft/world/inventory/$MenuType$MenuSupplier"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export interface $IContainerFactory<T extends $AbstractContainerMenu> extends $MenuType$MenuSupplier<(T)> {

 "create"(arg0: integer, arg1: $Inventory$Type, arg2: $FriendlyByteBuf$Type): T
 "create"(arg0: integer, arg1: $Inventory$Type): T

(arg0: integer, arg1: $Inventory$Type, arg2: $FriendlyByteBuf$Type): T
}

export namespace $IContainerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IContainerFactory$Type<T> = ($IContainerFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IContainerFactory_<T> = $IContainerFactory$Type<(T)>;
}}
declare module "packages/net/minecraftforge/network/$PlayMessages" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PlayMessages {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayMessages$Type = ($PlayMessages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayMessages_ = $PlayMessages$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeChunkManager$LoadingValidationCallback" {
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$ForgeChunkManager$TicketHelper, $ForgeChunkManager$TicketHelper$Type} from "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketHelper"

export interface $ForgeChunkManager$LoadingValidationCallback {

 "validateTickets"(arg0: $ServerLevel$Type, arg1: $ForgeChunkManager$TicketHelper$Type): void

(arg0: $ServerLevel$Type, arg1: $ForgeChunkManager$TicketHelper$Type): void
}

export namespace $ForgeChunkManager$LoadingValidationCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeChunkManager$LoadingValidationCallback$Type = ($ForgeChunkManager$LoadingValidationCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeChunkManager$LoadingValidationCallback_ = $ForgeChunkManager$LoadingValidationCallback$Type;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContextKey" {
import {$PermissionDynamicContext, $PermissionDynamicContext$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $PermissionDynamicContextKey<T> extends $Record {

constructor(typeToken: $Class$Type<(T)>, name: string, serializer: $Function$Type<(T), (string)>)

public "name"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "typeToken"(): $Class<(T)>
public "serializer"(): $Function<(T), (string)>
public "createContext"(arg0: T): $PermissionDynamicContext<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionDynamicContextKey$Type<T> = ($PermissionDynamicContextKey<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionDynamicContextKey_<T> = $PermissionDynamicContextKey$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonReleased" {
import {$ScreenEvent$MouseInput, $ScreenEvent$MouseInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonReleased extends $ScreenEvent$MouseInput {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer)

public "getButton"(): integer
public "getListenerList"(): $ListenerList
get "button"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonReleased$Type = ($ScreenEvent$MouseButtonReleased);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonReleased_ = $ScreenEvent$MouseButtonReleased$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingConversionEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingConversionEvent, $LivingConversionEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingConversionEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingConversionEvent$Post extends $LivingConversionEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $LivingEntity$Type)

public "getOutcome"(): $LivingEntity
public "getListenerList"(): $ListenerList
get "outcome"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingConversionEvent$Post$Type = ($LivingConversionEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingConversionEvent$Post_ = $LivingConversionEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyReleased" {
import {$ScreenEvent$KeyInput, $ScreenEvent$KeyInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$KeyReleased extends $ScreenEvent$KeyInput {

constructor()
constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyReleased$Type = ($ScreenEvent$KeyReleased);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyReleased_ = $ScreenEvent$KeyReleased$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$IntersectionIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $IntersectionIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public static "of"(...arg0: ($Ingredient$Type)[]): $Ingredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getStackingIds"(): $IntList
public "isEmpty"(): boolean
public "getSerializer"(): $IIngredientSerializer<($IntersectionIngredient)>
public "canBeUsedForMatching"(): boolean
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "stackingIds"(): $IntList
get "empty"(): boolean
get "serializer"(): $IIngredientSerializer<($IntersectionIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntersectionIngredient$Type = ($IntersectionIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntersectionIngredient_ = $IntersectionIngredient$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent$ILivingTargetType" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $LivingChangeTargetEvent$ILivingTargetType {

}

export namespace $LivingChangeTargetEvent$ILivingTargetType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingChangeTargetEvent$ILivingTargetType$Type = ($LivingChangeTargetEvent$ILivingTargetType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingChangeTargetEvent$ILivingTargetType_ = $LivingChangeTargetEvent$ILivingTargetType$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$IEventBusInvokeDispatcher" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IEventListener, $IEventListener$Type} from "packages/net/minecraftforge/eventbus/api/$IEventListener"

export interface $IEventBusInvokeDispatcher {

 "invoke"(arg0: $IEventListener$Type, arg1: $Event$Type): void

(arg0: $IEventListener$Type, arg1: $Event$Type): void
}

export namespace $IEventBusInvokeDispatcher {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventBusInvokeDispatcher$Type = ($IEventBusInvokeDispatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventBusInvokeDispatcher_ = $IEventBusInvokeDispatcher$Type;
}}
declare module "packages/net/minecraftforge/server/command/$EntityCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EntityCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityCommand$Type = ($EntityCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityCommand_ = $EntityCommand$Type;
}}
declare module "packages/net/minecraftforge/network/$ServerStatusPing$ChannelData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ServerStatusPing$ChannelData extends $Record {
static readonly "CODEC": $Codec<($ServerStatusPing$ChannelData)>

constructor(res: $ResourceLocation$Type, version: string, required: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "version"(): string
public "hashCode"(): integer
public "res"(): $ResourceLocation
public "required"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStatusPing$ChannelData$Type = ($ServerStatusPing$ChannelData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStatusPing$ChannelData_ = $ServerStatusPing$ChannelData$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyReleased$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$KeyReleased, $ScreenEvent$KeyReleased$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyReleased"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$KeyReleased$Pre extends $ScreenEvent$KeyReleased {

constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)
constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyReleased$Pre$Type = ($ScreenEvent$KeyReleased$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyReleased$Pre_ = $ScreenEvent$KeyReleased$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/settings/$KeyMappingLookup" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"

export class $KeyMappingLookup {

constructor()

public "remove"(arg0: $KeyMapping$Type): void
/**
 * 
 * @deprecated
 */
public "get"(arg0: $InputConstants$Key$Type): $KeyMapping
public "put"(arg0: $InputConstants$Key$Type, arg1: $KeyMapping$Type): void
public "clear"(): void
public "getAll"(arg0: $InputConstants$Key$Type): $List<($KeyMapping)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyMappingLookup$Type = ($KeyMappingLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyMappingLookup_ = $KeyMappingLookup$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$ConditionalRecipe$Builder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ConditionalAdvancement$Builder, $ConditionalAdvancement$Builder$Type} from "packages/net/minecraftforge/common/crafting/$ConditionalAdvancement$Builder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $ConditionalRecipe$Builder {

constructor()

public "build"(arg0: $Consumer$Type<($FinishedRecipe$Type)>, arg1: string, arg2: string): void
public "build"(arg0: $Consumer$Type<($FinishedRecipe$Type)>, arg1: $ResourceLocation$Type): void
public "addCondition"(arg0: $ICondition$Type): $ConditionalRecipe$Builder
public "setAdvancement"(arg0: $ConditionalAdvancement$Builder$Type): $ConditionalRecipe$Builder
public "setAdvancement"(arg0: $ResourceLocation$Type, arg1: $ConditionalAdvancement$Builder$Type): $ConditionalRecipe$Builder
public "setAdvancement"(arg0: string, arg1: string, arg2: $ConditionalAdvancement$Builder$Type): $ConditionalRecipe$Builder
public "generateAdvancement"(arg0: $ResourceLocation$Type): $ConditionalRecipe$Builder
public "generateAdvancement"(): $ConditionalRecipe$Builder
public "addRecipe"(arg0: $Consumer$Type<($Consumer$Type<($FinishedRecipe$Type)>)>): $ConditionalRecipe$Builder
public "addRecipe"(arg0: $FinishedRecipe$Type): $ConditionalRecipe$Builder
set "advancement"(value: $ConditionalAdvancement$Builder$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalRecipe$Builder$Type = ($ConditionalRecipe$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalRecipe$Builder_ = $ConditionalRecipe$Builder$Type;
}}
declare module "packages/net/minecraftforge/client/model/$SimpleModelState" {
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"

export class $SimpleModelState implements $ModelState {

constructor(arg0: $Transformation$Type, arg1: boolean)
constructor(arg0: $Transformation$Type)

public "getRotation"(): $Transformation
public "isUvLocked"(): boolean
get "rotation"(): $Transformation
get "uvLocked"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleModelState$Type = ($SimpleModelState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleModelState_ = $SimpleModelState$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$BreakSpeed" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlayerEvent$BreakSpeed extends $PlayerEvent {

constructor(arg0: $Player$Type, arg1: $BlockState$Type, arg2: float, arg3: $BlockPos$Type)
constructor()

public "getState"(): $BlockState
public "getPosition"(): $Optional<($BlockPos)>
public "getNewSpeed"(): float
public "setNewSpeed"(arg0: float): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "getOriginalSpeed"(): float
get "state"(): $BlockState
get "position"(): $Optional<($BlockPos)>
get "newSpeed"(): float
set "newSpeed"(value: float)
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "originalSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$BreakSpeed$Type = ($PlayerEvent$BreakSpeed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$BreakSpeed_ = $PlayerEvent$BreakSpeed$Type;
}}
declare module "packages/net/minecraftforge/client/$StencilManager" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $StencilManager {


public static "releaseBit"(arg0: integer): void
public static "reserveBit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StencilManager$Type = ($StencilManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StencilManager_ = $StencilManager$Type;
}}
declare module "packages/net/minecraftforge/common/$SoundActions" {
import {$SoundAction, $SoundAction$Type} from "packages/net/minecraftforge/common/$SoundAction"

export class $SoundActions {
static readonly "BUCKET_FILL": $SoundAction
static readonly "BUCKET_EMPTY": $SoundAction
static readonly "FLUID_VAPORIZE": $SoundAction


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundActions$Type = ($SoundActions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundActions_ = $SoundActions$Type;
}}
declare module "packages/net/minecraftforge/event/brewing/$PlayerBrewedPotionEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PlayerBrewedPotionEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type)

public "getStack"(): $ItemStack
public "getListenerList"(): $ListenerList
get "stack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerBrewedPotionEvent$Type = ($PlayerBrewedPotionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerBrewedPotionEvent_ = $PlayerBrewedPotionEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$AndHolderSet" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$CompositeHolderSet, $CompositeHolderSet$Type} from "packages/net/minecraftforge/registries/holdersets/$CompositeHolderSet"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $AndHolderSet<T> extends $CompositeHolderSet<(T)> {

constructor(arg0: $List$Type<($HolderSet$Type<(T)>)>)

public "type"(): $HolderSetType
public "toString"(): string
public static "codec"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>
public static "direct"<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
public static "direct"<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
/**
 * 
 * @deprecated
 */
public static "emptyNamed"<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndHolderSet$Type<T> = ($AndHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndHolderSet_<T> = $AndHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$MissingFactory" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IForgeRegistry$MissingFactory<V> {

 "createMissing"(arg0: $ResourceLocation$Type, arg1: boolean): V

(arg0: $ResourceLocation$Type, arg1: boolean): V
}

export namespace $IForgeRegistry$MissingFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$MissingFactory$Type<V> = ($IForgeRegistry$MissingFactory<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$MissingFactory_<V> = $IForgeRegistry$MissingFactory$Type<(V)>;
}}
declare module "packages/net/minecraftforge/network/filters/$VanillaPacketSplitter$RemoteCompatibility" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $VanillaPacketSplitter$RemoteCompatibility extends $Enum<($VanillaPacketSplitter$RemoteCompatibility)> {
static readonly "ABSENT": $VanillaPacketSplitter$RemoteCompatibility
static readonly "PRESENT": $VanillaPacketSplitter$RemoteCompatibility


public static "values"(): ($VanillaPacketSplitter$RemoteCompatibility)[]
public static "valueOf"(arg0: string): $VanillaPacketSplitter$RemoteCompatibility
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaPacketSplitter$RemoteCompatibility$Type = (("absent") | ("present")) | ($VanillaPacketSplitter$RemoteCompatibility);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaPacketSplitter$RemoteCompatibility_ = $VanillaPacketSplitter$RemoteCompatibility$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeHooks" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$LivingKnockBackEvent, $LivingKnockBackEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingKnockBackEvent"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$Difficulty, $Difficulty$Type} from "packages/net/minecraft/world/$Difficulty"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$TagEntry, $TagEntry$Type} from "packages/net/minecraft/tags/$TagEntry"
import {$GameEvent$Context, $GameEvent$Context$Type} from "packages/net/minecraft/world/level/gameevent/$GameEvent$Context"
import {$ServerboundPlayerActionPacket$Action, $ServerboundPlayerActionPacket$Action$Type} from "packages/net/minecraft/network/protocol/game/$ServerboundPlayerActionPacket$Action"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$StructuresBecomeConfiguredFix$Conversion, $StructuresBecomeConfiguredFix$Conversion$Type} from "packages/net/minecraft/util/datafix/fixes/$StructuresBecomeConfiguredFix$Conversion"
import {$Lifecycle, $Lifecycle$Type} from "packages/com/mojang/serialization/$Lifecycle"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeModeTab$ItemDisplayParameters, $CreativeModeTab$ItemDisplayParameters$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$ItemDisplayParameters"
import {$AnvilMenu, $AnvilMenu$Type} from "packages/net/minecraft/world/inventory/$AnvilMenu"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ChatDecorator, $ChatDecorator$Type} from "packages/net/minecraft/network/chat/$ChatDecorator"
import {$Brain, $Brain$Type} from "packages/net/minecraft/world/entity/ai/$Brain"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Tiers, $Tiers$Type} from "packages/net/minecraft/world/item/$Tiers"
import {$WorldData, $WorldData$Type} from "packages/net/minecraft/world/level/storage/$WorldData"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$CrudeIncrementalIntIdentityHashBiMap, $CrudeIncrementalIntIdentityHashBiMap$Type} from "packages/net/minecraft/util/$CrudeIncrementalIntIdentityHashBiMap"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$PlayerInteractEvent$LeftClickBlock, $PlayerInteractEvent$LeftClickBlock$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock"
import {$LivingChangeTargetEvent$ILivingTargetType, $LivingChangeTargetEvent$ILivingTargetType$Type} from "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent$ILivingTargetType"
import {$LevelStorageSource$LevelDirectory, $LevelStorageSource$LevelDirectory$Type} from "packages/net/minecraft/world/level/storage/$LevelStorageSource$LevelDirectory"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$SharedSuggestionProvider, $SharedSuggestionProvider$Type} from "packages/net/minecraft/commands/$SharedSuggestionProvider"
import {$LivingChangeTargetEvent, $LivingChangeTargetEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$EntityDataSerializer, $EntityDataSerializer$Type} from "packages/net/minecraft/network/syncher/$EntityDataSerializer"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CreativeModeTab$DisplayItemsGenerator, $CreativeModeTab$DisplayItemsGenerator$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$DisplayItemsGenerator"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CriticalHitEvent, $CriticalHitEvent$Type} from "packages/net/minecraftforge/event/entity/player/$CriticalHitEvent"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$ClickAction, $ClickAction$Type} from "packages/net/minecraft/world/inventory/$ClickAction"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ShieldBlockEvent, $ShieldBlockEvent$Type} from "packages/net/minecraftforge/event/entity/living/$ShieldBlockEvent"
import {$GameType, $GameType$Type} from "packages/net/minecraft/world/level/$GameType"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AttributeSupplier, $AttributeSupplier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeSupplier"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$Type} from "packages/net/minecraft/core/$HolderLookup$RegistryLookup"
import {$LivingSwapItemsEvent$Hands, $LivingSwapItemsEvent$Hands$Type} from "packages/net/minecraftforge/event/entity/living/$LivingSwapItemsEvent$Hands"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$PlayerInteractEvent$RightClickBlock, $PlayerInteractEvent$RightClickBlock$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickBlock"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$ContainerLevelAccess, $ContainerLevelAccess$Type} from "packages/net/minecraft/world/inventory/$ContainerLevelAccess"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$GameEvent, $GameEvent$Type} from "packages/net/minecraft/world/level/gameevent/$GameEvent"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SlotAccess, $SlotAccess$Type} from "packages/net/minecraft/world/entity/$SlotAccess"
import {$PackMetadataSection, $PackMetadataSection$Type} from "packages/net/minecraft/server/packs/metadata/pack/$PackMetadataSection"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$LootTable, $LootTable$Type} from "packages/net/minecraft/world/level/storage/loot/$LootTable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeHooks {

constructor()

public static "readAdditionalLevelSaveData"(arg0: $CompoundTag$Type, arg1: $LevelStorageSource$LevelDirectory$Type): void
public static "writeAdditionalLevelSaveData"(arg0: $WorldData$Type, arg1: $CompoundTag$Type): void
public static "writeTypedPackFormats"(arg0: $JsonObject$Type, arg1: $PackMetadataSection$Type): void
public static "readTypedPackFormats"(arg0: $JsonObject$Type): $Map<($PackType), (integer)>
public static "canUseEntitySelectors"(arg0: $SharedSuggestionProvider$Type): boolean
public static "getProjectile"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type): $ItemStack
public static "onLivingDamage"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float): float
public static "onLivingMakeBrain"(arg0: $LivingEntity$Type, arg1: $Brain$Type<(any)>, arg2: $Dynamic$Type<(any)>): $Brain<(any)>
public static "onLivingBreathe"(arg0: $LivingEntity$Type, arg1: integer, arg2: integer): void
public static "prefixNamespace"(arg0: $ResourceLocation$Type): string
public static "onItemRightClick"(arg0: $Player$Type, arg1: $InteractionHand$Type): $InteractionResult
public static "shouldSuppressEnderManAnger"(arg0: $EnderMan$Type, arg1: $Player$Type, arg2: $ItemStack$Type): boolean
public static "getSerializer"(arg0: integer, arg1: $CrudeIncrementalIntIdentityHashBiMap$Type<($EntityDataSerializer$Type<(any)>)>): $EntityDataSerializer<(any)>
public static "getSerializerId"(arg0: $EntityDataSerializer$Type<(any)>, arg1: $CrudeIncrementalIntIdentityHashBiMap$Type<($EntityDataSerializer$Type<(any)>)>): integer
public static "loadLootTable"(arg0: $Gson$Type, arg1: $ResourceLocation$Type, arg2: $JsonElement$Type, arg3: boolean): $LootTable
public static "getModPacks"(): $List<(string)>
public static "onRightClickBlock"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $BlockPos$Type, arg3: $BlockHitResult$Type): $PlayerInteractEvent$RightClickBlock
public static "onLivingDeath"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type): boolean
public static "onPlayerTossEvent"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: boolean): $ItemEntity
public static "onPlayerAttack"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float): boolean
public static "onLivingHurt"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float): float
public static "onInteractEntity"(arg0: $Player$Type, arg1: $Entity$Type, arg2: $InteractionHand$Type): $InteractionResult
public static "getCriticalHit"(arg0: $Player$Type, arg1: $Entity$Type, arg2: boolean, arg3: float): $CriticalHitEvent
public static "isCorrectToolForDrops"(arg0: $BlockState$Type, arg1: $Player$Type): boolean
public static "getVanillaFluidType"(arg0: $Fluid$Type): $FluidType
public static "getDefaultCreatorModId"(arg0: $ItemStack$Type): string
public static "getCraftingRemainingItem"(arg0: $ItemStack$Type): $ItemStack
public static "getAttributeModifiers"(arg0: $ItemStack$Type, arg1: $EquipmentSlot$Type, arg2: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): $Multimap<($Attribute), ($AttributeModifier)>
public static "onShieldBlock"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float): $ShieldBlockEvent
public static "onLivingAttack"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float): boolean
public static "onLivingUseTotem"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $ItemStack$Type, arg3: $InteractionHand$Type): boolean
public static "onLivingDrops"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $Collection$Type<($ItemEntity$Type)>, arg3: integer, arg4: boolean): boolean
public static "getLootingLevel"(arg0: $Entity$Type, arg1: $Entity$Type, arg2: $DamageSource$Type): integer
public static "getLootingLevel"(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: integer): integer
public static "onLivingKnockBack"(arg0: $LivingEntity$Type, arg1: float, arg2: double, arg3: double): $LivingKnockBackEvent
public static "isLivingOnLadder"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $LivingEntity$Type): $Optional<($BlockPos)>
public static "onLivingFall"(arg0: $LivingEntity$Type, arg1: float, arg2: float): (float)[]
public static "onLivingJump"(arg0: $LivingEntity$Type): void
public static "onLivingTick"(arg0: $LivingEntity$Type): boolean
public static "canContinueUsing"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public static "onChangeGameType"(arg0: $Player$Type, arg1: $GameType$Type, arg2: $GameType$Type): $GameType
public static "onGrindstoneChange"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Container$Type, arg3: integer): integer
public static "onEmptyLeftClick"(arg0: $Player$Type): void
public static "onEmptyClick"(arg0: $Player$Type, arg1: $InteractionHand$Type): void
public static "onPlayerAttackTarget"(arg0: $Player$Type, arg1: $Entity$Type): boolean
public static "getEntityVisibilityMultiplier"(arg0: $LivingEntity$Type, arg1: $Entity$Type, arg2: double): double
public static "onLivingSwapHandItems"(arg0: $LivingEntity$Type): $LivingSwapItemsEvent$Hands
public static "getBurnTime"(arg0: $ItemStack$Type, arg1: $RecipeType$Type<(any)>): integer
public static "hasNoElements"(arg0: $Ingredient$Type): boolean
public static "setCraftingPlayer"(arg0: $Player$Type): void
public static "onGrindstoneTake"(arg0: $Container$Type, arg1: $ContainerLevelAccess$Type, arg2: $Function$Type<($Level$Type), (integer)>): boolean
public static "onBlockBreakEvent"(arg0: $Level$Type, arg1: $GameType$Type, arg2: $ServerPlayer$Type, arg3: $BlockPos$Type): integer
public static "onServerChatSubmittedEvent"(arg0: $ServerPlayer$Type, arg1: string, arg2: $Component$Type): $Component
public static "onCheckCreativeTabs"(...arg0: ($CreativeModeTab$Type)[]): $Collection<($CreativeModeTab)>
/**
 * 
 * @deprecated
 */
public static "deserializeTagAdditions"<T>(arg0: $List$Type<($TagEntry$Type)>, arg1: $JsonObject$Type, arg2: $List$Type<($TagEntry$Type)>): void
public static "getLootTableDeserializer"(arg0: $Gson$Type, arg1: string): $TriFunction<($ResourceLocation), ($JsonElement), ($ResourceManager), ($Optional<($LootTable)>)>
/**
 * 
 * @deprecated
 */
public static "onLeftClickBlock"(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): $PlayerInteractEvent$LeftClickBlock
public static "onLeftClickBlock"(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $ServerboundPlayerActionPacket$Action$Type): $PlayerInteractEvent$LeftClickBlock
public static "getModPacksWithVanilla"(): $List<(string)>
public static "onEntityEnterSection"(arg0: $Entity$Type, arg1: long, arg2: long): void
public static "canEntityDestroy"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $LivingEntity$Type): boolean
public static "dropXpForBlock"(arg0: $BlockState$Type, arg1: $ServerLevel$Type, arg2: $BlockPos$Type, arg3: $ItemStack$Type): void
public static "onVanillaGameEvent"(arg0: $Level$Type, arg1: $GameEvent$Type, arg2: $Vec3$Type, arg3: $GameEvent$Context$Type): boolean
public static "onCreativeModeTabBuildContents"(arg0: $CreativeModeTab$Type, arg1: $ResourceKey$Type<($CreativeModeTab$Type)>, arg2: $CreativeModeTab$DisplayItemsGenerator$Type, arg3: $CreativeModeTab$ItemDisplayParameters$Type, arg4: $CreativeModeTab$Output$Type): void
public static "modifyLoot"(arg0: $ResourceLocation$Type, arg1: $ObjectArrayList$Type<($ItemStack$Type)>, arg2: $LootContext$Type): $ObjectArrayList<($ItemStack)>
/**
 * 
 * @deprecated
 */
public static "modifyLoot"(arg0: $List$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $List<($ItemStack)>
public static "onCropsGrowPost"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
public static "onCropsGrowPre"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: boolean): boolean
public static "onInteractEntityAt"(arg0: $Player$Type, arg1: $Entity$Type, arg2: $HitResult$Type, arg3: $InteractionHand$Type): $InteractionResult
public static "onInteractEntityAt"(arg0: $Player$Type, arg1: $Entity$Type, arg2: $Vec3$Type, arg3: $InteractionHand$Type): $InteractionResult
public static "onClientMineHold"(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): $PlayerInteractEvent$LeftClickBlock
public static "onFarmlandTrample"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: float, arg4: $Entity$Type): boolean
public static "onLivingChangeTarget"(arg0: $LivingEntity$Type, arg1: $LivingEntity$Type, arg2: $LivingChangeTargetEvent$ILivingTargetType$Type): $LivingChangeTargetEvent
public static "onPlaceItemIntoWorld"(arg0: $UseOnContext$Type): $InteractionResult
public static "saveMobEffect"(arg0: $CompoundTag$Type, arg1: string, arg2: $MobEffect$Type): void
public static "loadMobEffect"(arg0: $CompoundTag$Type, arg1: string, arg2: $MobEffect$Type): $MobEffect
public static "updateBurns"(): void
public static "checkStructureNamespace"(arg0: string): boolean
public static "getStructureConversion"(arg0: string): $StructuresBecomeConfiguredFix$Conversion
public static "onDifficultyChange"(arg0: $Difficulty$Type, arg1: $Difficulty$Type): void
public static "newChatWithLinks"(arg0: string): $Component
public static "newChatWithLinks"(arg0: string, arg1: boolean): $Component
public static "getCraftingPlayer"(): $Player
/**
 * 
 * @deprecated
 */
public static "getAttributesView"(): $Map<($EntityType<(any)>), ($AttributeSupplier)>
public static "readPoolName"(arg0: $JsonObject$Type): string
public static "parseLifecycle"(arg0: string): $Lifecycle
public static "encodeLifecycle"(arg0: $Lifecycle$Type): string
public static "wrapRegistryLookup"<T>(arg0: $HolderLookup$RegistryLookup$Type<(T)>): $HolderLookup$RegistryLookup<(T)>
public static "onAnvilRepair"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $ItemStack$Type): float
public static "onAnvilChange"(arg0: $AnvilMenu$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $Container$Type, arg4: string, arg5: integer, arg6: $Player$Type): boolean
public static "onItemStackedOn"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Slot$Type, arg3: $ClickAction$Type, arg4: $Player$Type, arg5: $SlotAccess$Type): boolean
public static "onTravelToDimension"(arg0: $Entity$Type, arg1: $ResourceKey$Type<($Level$Type)>): boolean
public static "getTagFromVanillaTier"(arg0: $Tiers$Type): $TagKey<($Block)>
public static "getServerChatSubmittedDecorator"(): $ChatDecorator
/**
 * 
 * @deprecated
 */
public static "modifyAttributes"(): void
public static "onNoteChange"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: integer, arg4: integer): integer
get "modPacks"(): $List<(string)>
set "craftingPlayer"(value: $Player$Type)
get "modPacksWithVanilla"(): $List<(string)>
get "craftingPlayer"(): $Player
get "attributesView"(): $Map<($EntityType<(any)>), ($AttributeSupplier)>
get "serverChatSubmittedDecorator"(): $ChatDecorator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeHooks$Type = ($ForgeHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeHooks_ = $ForgeHooks$Type;
}}
declare module "packages/net/minecraftforge/common/$TierSortingRegistry" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $TierSortingRegistry {

constructor()

public static "getName"(arg0: $Tier$Type): $ResourceLocation
public static "getSortedTiers"(): $List<($Tier)>
public static "getTiersLowerThan"(arg0: $Tier$Type): $List<($Tier)>
public static "isCorrectTierForDrops"(arg0: $Tier$Type, arg1: $BlockState$Type): boolean
public static "byName"(arg0: $ResourceLocation$Type): $Tier
public static "registerTier"(arg0: $Tier$Type, arg1: $ResourceLocation$Type, arg2: $List$Type<(any)>, arg3: $List$Type<(any)>): $Tier
public static "isTierSorted"(arg0: $Tier$Type): boolean
get "sortedTiers"(): $List<($Tier)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TierSortingRegistry$Type = ($TierSortingRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TierSortingRegistry_ = $TierSortingRegistry$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$PlayStreamingSourceEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Channel, $Channel$Type} from "packages/com/mojang/blaze3d/audio/$Channel"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"
import {$SoundEvent$SoundSourceEvent, $SoundEvent$SoundSourceEvent$Type} from "packages/net/minecraftforge/client/event/sound/$SoundEvent$SoundSourceEvent"

export class $PlayStreamingSourceEvent extends $SoundEvent$SoundSourceEvent {

constructor(arg0: $SoundEngine$Type, arg1: $SoundInstance$Type, arg2: $Channel$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayStreamingSourceEvent$Type = ($PlayStreamingSourceEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayStreamingSourceEvent_ = $PlayStreamingSourceEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Render" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$Render extends $ScreenEvent {

constructor()

public "getPartialTick"(): float
public "getMouseX"(): integer
public "getMouseY"(): integer
public "getGuiGraphics"(): $GuiGraphics
public "getListenerList"(): $ListenerList
get "partialTick"(): float
get "mouseX"(): integer
get "mouseY"(): integer
get "guiGraphics"(): $GuiGraphics
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Render$Type = ($ScreenEvent$Render);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Render_ = $ScreenEvent$Render$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ViewportEvent$ComputeFov" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$GameRenderer, $GameRenderer$Type} from "packages/net/minecraft/client/renderer/$GameRenderer"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$ViewportEvent, $ViewportEvent$Type} from "packages/net/minecraftforge/client/event/$ViewportEvent"

export class $ViewportEvent$ComputeFov extends $ViewportEvent {

constructor()
constructor(arg0: $GameRenderer$Type, arg1: $Camera$Type, arg2: double, arg3: double, arg4: boolean)

public "usedConfiguredFov"(): boolean
public "getFOV"(): double
public "setFOV"(arg0: double): void
public "getListenerList"(): $ListenerList
get "fOV"(): double
set "fOV"(value: double)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewportEvent$ComputeFov$Type = ($ViewportEvent$ComputeFov);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewportEvent$ComputeFov_ = $ViewportEvent$ComputeFov$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLevelStageEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Frustum, $Frustum$Type} from "packages/net/minecraft/client/renderer/culling/$Frustum"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"
import {$RenderLevelStageEvent$Stage, $RenderLevelStageEvent$Stage$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent$Stage"

export class $RenderLevelStageEvent extends $Event {

constructor()
constructor(arg0: $RenderLevelStageEvent$Stage$Type, arg1: $LevelRenderer$Type, arg2: $PoseStack$Type, arg3: $Matrix4f$Type, arg4: integer, arg5: float, arg6: $Camera$Type, arg7: $Frustum$Type)

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getFrustum"(): $Frustum
public "getRenderTick"(): integer
public "getCamera"(): $Camera
public "getLevelRenderer"(): $LevelRenderer
public "getStage"(): $RenderLevelStageEvent$Stage
public "getProjectionMatrix"(): $Matrix4f
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): float
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "frustum"(): $Frustum
get "renderTick"(): integer
get "camera"(): $Camera
get "levelRenderer"(): $LevelRenderer
get "stage"(): $RenderLevelStageEvent$Stage
get "projectionMatrix"(): $Matrix4f
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLevelStageEvent$Type = ($RenderLevelStageEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLevelStageEvent_ = $RenderLevelStageEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$Key" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InputEvent, $InputEvent$Type} from "packages/net/minecraftforge/client/event/$InputEvent"

export class $InputEvent$Key extends $InputEvent {

constructor()
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "getModifiers"(): integer
public "getKey"(): integer
public "getAction"(): integer
public "getScanCode"(): integer
public "getListenerList"(): $ListenerList
get "modifiers"(): integer
get "key"(): integer
get "action"(): integer
get "scanCode"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$Key$Type = ($InputEvent$Key);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$Key_ = $InputEvent$Key$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeSpriteSourceProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$SpriteSourceProvider, $SpriteSourceProvider$Type} from "packages/net/minecraftforge/common/data/$SpriteSourceProvider"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"

export class $ForgeSpriteSourceProvider extends $SpriteSourceProvider {

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSpriteSourceProvider$Type = ($ForgeSpriteSourceProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSpriteSourceProvider_ = $ForgeSpriteSourceProvider$Type;
}}
declare module "packages/net/minecraftforge/common/util/$TextTable$Alignment" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TextTable$Alignment extends $Enum<($TextTable$Alignment)> {
static readonly "LEFT": $TextTable$Alignment
static readonly "CENTER": $TextTable$Alignment
static readonly "RIGHT": $TextTable$Alignment


public static "values"(): ($TextTable$Alignment)[]
public static "valueOf"(arg0: string): $TextTable$Alignment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextTable$Alignment$Type = (("left") | ("center") | ("right")) | ($TextTable$Alignment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextTable$Alignment_ = $TextTable$Alignment$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerWakeUpEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerWakeUpEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: boolean, arg2: boolean)

public "wakeImmediately"(): boolean
public "updateLevel"(): boolean
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerWakeUpEvent$Type = ($PlayerWakeUpEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerWakeUpEvent_ = $PlayerWakeUpEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistryInternal" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ITagManager, $ITagManager$Type} from "packages/net/minecraftforge/registries/tags/$ITagManager"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $IForgeRegistryInternal<V> extends $IForgeRegistry<(V)> {

 "getValue"(arg0: integer): V
 "register"(arg0: integer, arg1: $ResourceLocation$Type, arg2: V): void
 "setSlaveMap"(arg0: $ResourceLocation$Type, arg1: any): void
 "getValue"(arg0: $ResourceLocation$Type): V
 "isEmpty"(): boolean
 "getKey"(arg0: V): $ResourceLocation
 "register"(arg0: $ResourceLocation$Type, arg1: V): void
 "register"(arg0: string, arg1: V): void
 "containsKey"(arg0: $ResourceLocation$Type): boolean
 "containsValue"(arg0: V): boolean
 "getEntries"(): $Set<($Map$Entry<($ResourceKey<(V)>), (V)>)>
 "getKeys"(): $Set<($ResourceLocation)>
 "tags"(): $ITagManager<(V)>
 "getDelegate"(arg0: V): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceLocation$Type): $Optional<($Holder$Reference<(V)>)>
 "getResourceKey"(arg0: V): $Optional<($ResourceKey<(V)>)>
 "getCodec"(): $Codec<(V)>
 "getSlaveMap"<T>(arg0: $ResourceLocation$Type, arg1: $Class$Type<(T)>): T
 "getRegistryKey"(): $ResourceKey<($Registry<(V)>)>
 "getRegistryName"(): $ResourceLocation
 "getDelegateOrThrow"(arg0: $ResourceKey$Type<(V)>): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: $ResourceLocation$Type): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: V): $Holder$Reference<(V)>
 "getHolder"(arg0: $ResourceLocation$Type): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: V): $Optional<($Holder<(V)>)>
 "getDefaultKey"(): $ResourceLocation
 "getValues"(): $Collection<(V)>
 "iterator"(): $Iterator<(V)>
 "spliterator"(): $Spliterator<(V)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $IForgeRegistryInternal {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistryInternal$Type<V> = ($IForgeRegistryInternal<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistryInternal_<V> = $IForgeRegistryInternal$Type<(V)>;
}}
declare module "packages/net/minecraftforge/client/event/$ContainerScreenEvent$Render$Foreground" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ContainerScreenEvent$Render, $ContainerScreenEvent$Render$Type} from "packages/net/minecraftforge/client/event/$ContainerScreenEvent$Render"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"

export class $ContainerScreenEvent$Render$Foreground extends $ContainerScreenEvent$Render {

constructor(arg0: $AbstractContainerScreen$Type<(any)>, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerScreenEvent$Render$Foreground$Type = ($ContainerScreenEvent$Render$Foreground);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerScreenEvent$Render$Foreground_ = $ContainerScreenEvent$Render$Foreground$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$ModelFile$ExistingModelFile, $ModelFile$ExistingModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile$ExistingModelFile"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModelProvider<T extends $ModelBuilder<(T)>> implements $DataProvider {
static readonly "BLOCK_FOLDER": string
static readonly "ITEM_FOLDER": string
readonly "generatedModels": $Map<($ResourceLocation), (T)>
readonly "existingFileHelper": $ExistingFileHelper

constructor(arg0: $PackOutput$Type, arg1: string, arg2: string, arg3: $BiFunction$Type<($ResourceLocation$Type), ($ExistingFileHelper$Type), (T)>, arg4: $ExistingFileHelper$Type)
constructor(arg0: $PackOutput$Type, arg1: string, arg2: string, arg3: $Function$Type<($ResourceLocation$Type), (T)>, arg4: $ExistingFileHelper$Type)

public "sign"(arg0: string, arg1: $ResourceLocation$Type): T
public "nested"(): T
public "cube"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type, arg5: $ResourceLocation$Type, arg6: $ResourceLocation$Type): T
public "cubeAll"(arg0: string, arg1: $ResourceLocation$Type): T
public "mcLoc"(arg0: string): $ResourceLocation
public "orientable"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "cubeColumn"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "getExistingFile"(arg0: $ResourceLocation$Type): $ModelFile$ExistingModelFile
public "pressurePlateDown"(arg0: string, arg1: $ResourceLocation$Type): T
public "stairsInner"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "stairsOuter"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "slabTop"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "buttonPressed"(arg0: string, arg1: $ResourceLocation$Type): T
public "fenceGateOpen"(arg0: string, arg1: $ResourceLocation$Type): T
public "fenceGateWallOpen"(arg0: string, arg1: $ResourceLocation$Type): T
public "fenceSide"(arg0: string, arg1: $ResourceLocation$Type): T
public "fencePost"(arg0: string, arg1: $ResourceLocation$Type): T
public "fenceGateWall"(arg0: string, arg1: $ResourceLocation$Type): T
public "wallSide"(arg0: string, arg1: $ResourceLocation$Type): T
public "panePost"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "wallSideTall"(arg0: string, arg1: $ResourceLocation$Type): T
public "paneSide"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "paneSideAlt"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "paneNoSide"(arg0: string, arg1: $ResourceLocation$Type): T
public "wallPost"(arg0: string, arg1: $ResourceLocation$Type): T
public "paneNoSideAlt"(arg0: string, arg1: $ResourceLocation$Type): T
public "doorBottomLeftOpen"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorBottomRight"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorTopRight"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorBottomLeft"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorTopRightOpen"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorTopLeftOpen"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "doorTopLeft"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "trapdoorBottom"(arg0: string, arg1: $ResourceLocation$Type): T
public "trapdoorTop"(arg0: string, arg1: $ResourceLocation$Type): T
public "trapdoorOpen"(arg0: string, arg1: $ResourceLocation$Type): T
public "carpet"(arg0: string, arg1: $ResourceLocation$Type): T
public "getBuilder"(arg0: string): T
public "button"(arg0: string, arg1: $ResourceLocation$Type): T
public "singleTexture"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "singleTexture"(arg0: string, arg1: $ResourceLocation$Type, arg2: string, arg3: $ResourceLocation$Type): T
public "cubeTop"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "buttonInventory"(arg0: string, arg1: $ResourceLocation$Type): T
public "cubeBottomTop"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "fenceInventory"(arg0: string, arg1: $ResourceLocation$Type): T
public "orientableVertical"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "wallInventory"(arg0: string, arg1: $ResourceLocation$Type): T
public "torchWall"(arg0: string, arg1: $ResourceLocation$Type): T
public "crop"(arg0: string, arg1: $ResourceLocation$Type): T
public "stairs"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "trapdoorOrientableBottom"(arg0: string, arg1: $ResourceLocation$Type): T
public "trapdoorOrientableTop"(arg0: string, arg1: $ResourceLocation$Type): T
public "cubeColumnHorizontal"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "trapdoorOrientableOpen"(arg0: string, arg1: $ResourceLocation$Type): T
public "doorBottomRightOpen"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): T
public "modLoc"(arg0: string): $ResourceLocation
public "withExistingParent"(arg0: string, arg1: string): T
public "withExistingParent"(arg0: string, arg1: $ResourceLocation$Type): T
public "orientableWithBottom"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): T
public "fenceGate"(arg0: string, arg1: $ResourceLocation$Type): T
public "slab"(arg0: string, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): T
public "pressurePlate"(arg0: string, arg1: $ResourceLocation$Type): T
public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "torch"(arg0: string, arg1: $ResourceLocation$Type): T
public "cross"(arg0: string, arg1: $ResourceLocation$Type): T
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
public "getName"(): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelProvider$Type<T> = ($ModelProvider<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelProvider_<T> = $ModelProvider$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/capabilities/$ForgeCapabilities" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$IFluidHandlerItem, $IFluidHandlerItem$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem"
import {$IEnergyStorage, $IEnergyStorage$Type} from "packages/net/minecraftforge/energy/$IEnergyStorage"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ForgeCapabilities {
static readonly "ENERGY": $Capability<($IEnergyStorage)>
static readonly "FLUID_HANDLER": $Capability<($IFluidHandler)>
static readonly "FLUID_HANDLER_ITEM": $Capability<($IFluidHandlerItem)>
static readonly "ITEM_HANDLER": $Capability<($IItemHandler)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeCapabilities$Type = ($ForgeCapabilities);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeCapabilities_ = $ForgeCapabilities$Type;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$InteractionKeyMappingTriggered" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$InputEvent, $InputEvent$Type} from "packages/net/minecraftforge/client/event/$InputEvent"

export class $InputEvent$InteractionKeyMappingTriggered extends $InputEvent {

constructor()
constructor(arg0: integer, arg1: $KeyMapping$Type, arg2: $InteractionHand$Type)

public "isCancelable"(): boolean
public "getKeyMapping"(): $KeyMapping
public "getHand"(): $InteractionHand
public "shouldSwingHand"(): boolean
public "setSwingHand"(arg0: boolean): void
public "isUseItem"(): boolean
public "isAttack"(): boolean
public "isPickBlock"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "keyMapping"(): $KeyMapping
get "hand"(): $InteractionHand
set "swingHand"(value: boolean)
get "useItem"(): boolean
get "attack"(): boolean
get "pickBlock"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$InteractionKeyMappingTriggered$Type = ($InputEvent$InteractionKeyMappingTriggered);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$InteractionKeyMappingTriggered_ = $InputEvent$InteractionKeyMappingTriggered$Type;
}}
declare module "packages/net/minecraftforge/server/permission/events/$PermissionGatherEvent$Nodes" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$PermissionGatherEvent, $PermissionGatherEvent$Type} from "packages/net/minecraftforge/server/permission/events/$PermissionGatherEvent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $PermissionGatherEvent$Nodes extends $PermissionGatherEvent {

constructor()

public "addNodes"(arg0: $Iterable$Type<($PermissionNode$Type<(any)>)>): void
public "addNodes"(...arg0: ($PermissionNode$Type<(any)>)[]): void
public "getNodes"(): $Collection<($PermissionNode<(any)>)>
public "getListenerList"(): $ListenerList
get "nodes"(): $Collection<($PermissionNode<(any)>)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionGatherEvent$Nodes$Type = ($PermissionGatherEvent$Nodes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionGatherEvent$Nodes_ = $PermissionGatherEvent$Nodes$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$CommandTreeCleaner" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ArgumentType, $ArgumentType$Type} from "packages/com/mojang/brigadier/arguments/$ArgumentType"
import {$RootCommandNode, $RootCommandNode$Type} from "packages/com/mojang/brigadier/tree/$RootCommandNode"

export class $CommandTreeCleaner {


public static "cleanArgumentTypes"<S>(arg0: $RootCommandNode$Type<(S)>, arg1: $Predicate$Type<($ArgumentType$Type<(any)>)>): $RootCommandNode<(S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandTreeCleaner$Type = ($CommandTreeCleaner);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandTreeCleaner_ = $CommandTreeCleaner$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$PlayerArmorInvWrapper" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$RangedWrapper, $RangedWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RangedWrapper"

export class $PlayerArmorInvWrapper extends $RangedWrapper {

constructor(arg0: $Inventory$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getInventoryPlayer"(): $Inventory
get "inventoryPlayer"(): $Inventory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerArmorInvWrapper$Type = ($PlayerArmorInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerArmorInvWrapper_ = $PlayerArmorInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickBlock" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event$Result, $Event$Result$Type} from "packages/net/minecraftforge/eventbus/api/$Event$Result"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlayerInteractEvent$RightClickBlock extends $PlayerInteractEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $BlockPos$Type, arg3: $BlockHitResult$Type)

public "setCanceled"(arg0: boolean): void
public "isCancelable"(): boolean
public "getHitVec"(): $BlockHitResult
public "setUseItem"(arg0: $Event$Result$Type): void
public "setUseBlock"(arg0: $Event$Result$Type): void
public "getUseItem"(): $Event$Result
public "getUseBlock"(): $Event$Result
public "getListenerList"(): $ListenerList
set "canceled"(value: boolean)
get "cancelable"(): boolean
get "hitVec"(): $BlockHitResult
set "useItem"(value: $Event$Result$Type)
set "useBlock"(value: $Event$Result$Type)
get "useItem"(): $Event$Result
get "useBlock"(): $Event$Result
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$RightClickBlock$Type = ($PlayerInteractEvent$RightClickBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$RightClickBlock_ = $PlayerInteractEvent$RightClickBlock$Type;
}}
declare module "packages/net/minecraftforge/server/timings/$ForgeTimings" {
import {$WeakReference, $WeakReference$Type} from "packages/java/lang/ref/$WeakReference"

export class $ForgeTimings<T> {

constructor(arg0: T, arg1: (integer)[])

public "getObject"(): $WeakReference<(T)>
public "getAverageTimings"(): double
get "object"(): $WeakReference<(T)>
get "averageTimings"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeTimings$Type<T> = ($ForgeTimings<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeTimings_<T> = $ForgeTimings$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/ticket/$ITicketManager" {
import {$SimpleTicket, $SimpleTicket$Type} from "packages/net/minecraftforge/common/ticket/$SimpleTicket"

export interface $ITicketManager<T> {

 "add"(arg0: $SimpleTicket$Type<(T)>): void
 "remove"(arg0: $SimpleTicket$Type<(T)>): void
}

export namespace $ITicketManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITicketManager$Type<T> = ($ITicketManager<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITicketManager_<T> = $ITicketManager$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fml/$IModStateProvider" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModLoadingState, $IModLoadingState$Type} from "packages/net/minecraftforge/fml/$IModLoadingState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IModStateProvider {

 "getAllStates"(): $List<($IModLoadingState)>

(): $List<($IModLoadingState)>
}

export namespace $IModStateProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModStateProvider$Type = ($IModStateProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModStateProvider_ = $IModStateProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingHealEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingHealEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: float)

public "isCancelable"(): boolean
public "setAmount"(arg0: float): void
public "getAmount"(): float
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
set "amount"(value: float)
get "amount"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingHealEvent$Type = ($LivingHealEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingHealEvent_ = $LivingHealEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeEnchantment" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$MobType, $MobType$Type} from "packages/net/minecraft/world/entity/$MobType"

export interface $IForgeEnchantment {

 "allowedInCreativeTab"(arg0: $Item$Type, arg1: $Set$Type<($EnchantmentCategory$Type)>): boolean
 "getDamageBonus"(arg0: integer, arg1: $MobType$Type, arg2: $ItemStack$Type): float
}

export namespace $IForgeEnchantment {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeEnchantment$Type = ($IForgeEnchantment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeEnchantment_ = $IForgeEnchantment$Type;
}}
declare module "packages/net/minecraftforge/registries/$NewRegistryEvent" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$RegistryBuilder, $RegistryBuilder$Type} from "packages/net/minecraftforge/registries/$RegistryBuilder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $NewRegistryEvent extends $Event implements $IModBusEvent {

constructor()

public "toString"(): string
public "create"<V>(arg0: $RegistryBuilder$Type<(V)>): $Supplier<($IForgeRegistry<(V)>)>
public "create"<V>(arg0: $RegistryBuilder$Type<(V)>, arg1: $Consumer$Type<($IForgeRegistry$Type<(V)>)>): $Supplier<($IForgeRegistry<(V)>)>
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NewRegistryEvent$Type = ($NewRegistryEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NewRegistryEvent_ = $NewRegistryEvent$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$Capability" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export class $Capability<T> {


public "getName"(): string
public "isRegistered"(): boolean
public "orEmpty"<R>(arg0: $Capability$Type<(R)>, arg1: $LazyOptional$Type<(T)>): $LazyOptional<(R)>
public "addListener"(arg0: $Consumer$Type<($Capability$Type<(T)>)>): $Capability<(T)>
get "name"(): string
get "registered"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Capability$Type<T> = ($Capability<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Capability_<T> = $Capability$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/model/generators/$BlockStateProvider$ConfiguredModelList" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ConfiguredModel, $ConfiguredModel$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel"

export class $BlockStateProvider$ConfiguredModelList {

constructor(...arg0: ($ConfiguredModel$Type)[])
constructor(arg0: $ConfiguredModel$Type)

public "append"(...arg0: ($ConfiguredModel$Type)[]): $BlockStateProvider$ConfiguredModelList
public "toJSON"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProvider$ConfiguredModelList$Type = ($BlockStateProvider$ConfiguredModelList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateProvider$ConfiguredModelList_ = $BlockStateProvider$ConfiguredModelList$Type;
}}
declare module "packages/net/minecraftforge/client/model/$CompositeModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $CompositeModel implements $IUnbakedGeometry<($CompositeModel)> {

constructor(arg0: $ImmutableMap$Type<(string), ($BlockModel$Type)>, arg1: $ImmutableList$Type<(string)>)

public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeModel$Type = ($CompositeModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeModel_ = $CompositeModel$Type;
}}
declare module "packages/net/minecraftforge/client/model/$QuadTransformers" {
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$IQuadTransformer, $IQuadTransformer$Type} from "packages/net/minecraftforge/client/model/$IQuadTransformer"

export class $QuadTransformers {


public static "empty"(): $IQuadTransformer
public static "settingMaxEmissivity"(): $IQuadTransformer
public static "settingEmissivity"(arg0: integer): $IQuadTransformer
public static "applying"(arg0: $Transformation$Type): $IQuadTransformer
public static "applyingLightmap"(arg0: integer, arg1: integer): $IQuadTransformer
public static "applyingLightmap"(arg0: integer): $IQuadTransformer
public static "applyingColor"(arg0: integer, arg1: integer, arg2: integer): $IQuadTransformer
public static "applyingColor"(arg0: integer): $IQuadTransformer
public static "applyingColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $IQuadTransformer
public static "toABGR"(arg0: integer): integer
set "tingEmissivity"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadTransformers$Type = ($QuadTransformers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadTransformers_ = $QuadTransformers$Type;
}}
declare module "packages/net/minecraftforge/registries/$ObjectHolder" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ObjectHolder extends $Annotation {

 "value"(): string
 "registryName"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ObjectHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectHolder$Type = ($ObjectHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectHolder_ = $ObjectHolder$Type;
}}
declare module "packages/net/minecraftforge/event/village/$VillageSiegeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$VillageSiege, $VillageSiege$Type} from "packages/net/minecraft/world/entity/ai/village/$VillageSiege"

export class $VillageSiegeEvent extends $Event {

constructor()
constructor(arg0: $VillageSiege$Type, arg1: $Level$Type, arg2: $Player$Type, arg3: $Vec3$Type)

public "getSiege"(): $VillageSiege
public "getLevel"(): $Level
public "isCancelable"(): boolean
public "getPlayer"(): $Player
public "getAttemptedSpawnPos"(): $Vec3
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "siege"(): $VillageSiege
get "level"(): $Level
get "cancelable"(): boolean
get "player"(): $Player
get "attemptedSpawnPos"(): $Vec3
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillageSiegeEvent$Type = ($VillageSiegeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillageSiegeEvent_ = $VillageSiegeEvent$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$CapabilityProvider" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CapabilityDispatcher, $CapabilityDispatcher$Type} from "packages/net/minecraftforge/common/capabilities/$CapabilityDispatcher"
import {$ICapabilityProviderImpl, $ICapabilityProviderImpl$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProviderImpl"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CapabilityProvider<B extends $ICapabilityProviderImpl<(B)>> implements $ICapabilityProviderImpl<(B)> {


public "reviveCaps"(): void
public "invalidateCaps"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "areCapsCompatible"(arg0: $CapabilityProvider$Type<(B)>): boolean
public "areCapsCompatible"(arg0: $CapabilityDispatcher$Type): boolean
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityProvider$Type<B> = ($CapabilityProvider<(B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityProvider_<B> = $CapabilityProvider$Type<(B)>;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo" {
import {$ModifiableBiomeInfo$BiomeInfo, $ModifiableBiomeInfo$BiomeInfo$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"

export class $ModifiableBiomeInfo {

constructor(arg0: $ModifiableBiomeInfo$BiomeInfo$Type)

public "getModifiedBiomeInfo"(): $ModifiableBiomeInfo$BiomeInfo
public "get"(): $ModifiableBiomeInfo$BiomeInfo
public "getOriginalBiomeInfo"(): $ModifiableBiomeInfo$BiomeInfo
public "applyBiomeModifiers"(arg0: $Holder$Type<($Biome$Type)>, arg1: $List$Type<($BiomeModifier$Type)>): void
get "modifiedBiomeInfo"(): $ModifiableBiomeInfo$BiomeInfo
get "originalBiomeInfo"(): $ModifiableBiomeInfo$BiomeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableBiomeInfo$Type = ($ModifiableBiomeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableBiomeInfo_ = $ModifiableBiomeInfo$Type;
}}
declare module "packages/net/minecraftforge/common/$IExtensibleEnum" {
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $IExtensibleEnum {

/**
 * 
 * @deprecated
 */
 "init"(): void
}

export namespace $IExtensibleEnum {
function createCodecForExtensibleEnum<E>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(any), (any)>): $Codec<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtensibleEnum$Type = ($IExtensibleEnum);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtensibleEnum_ = $IExtensibleEnum$Type;
}}
declare module "packages/net/minecraftforge/client/loading/$ClientModLoader" {
import {$PackRepository, $PackRepository$Type} from "packages/net/minecraft/server/packs/repository/$PackRepository"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$VersionChecker$Status, $VersionChecker$Status$Type} from "packages/net/minecraftforge/fml/$VersionChecker$Status"
import {$ReloadableResourceManager, $ReloadableResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ReloadableResourceManager"

export class $ClientModLoader {

constructor()

public static "begin"(arg0: $Minecraft$Type, arg1: $PackRepository$Type, arg2: $ReloadableResourceManager$Type): void
public static "isLoading"(): boolean
public static "completeModLoading"(): boolean
public static "checkForUpdates"(): $VersionChecker$Status
get "loading"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientModLoader$Type = ($ClientModLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientModLoader_ = $ClientModLoader$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerXpEvent$PickupXp" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerXpEvent, $PlayerXpEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerXpEvent"
import {$ExperienceOrb, $ExperienceOrb$Type} from "packages/net/minecraft/world/entity/$ExperienceOrb"

export class $PlayerXpEvent$PickupXp extends $PlayerXpEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ExperienceOrb$Type)

public "isCancelable"(): boolean
public "getOrb"(): $ExperienceOrb
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "orb"(): $ExperienceOrb
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerXpEvent$PickupXp$Type = ($PlayerXpEvent$PickupXp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerXpEvent$PickupXp_ = $PlayerXpEvent$PickupXp$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeChunkManager" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ForgeChunkManager$LoadingValidationCallback, $ForgeChunkManager$LoadingValidationCallback$Type} from "packages/net/minecraftforge/common/world/$ForgeChunkManager$LoadingValidationCallback"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ForcedChunksSavedData, $ForcedChunksSavedData$Type} from "packages/net/minecraft/world/level/$ForcedChunksSavedData"
import {$ForgeChunkManager$TicketTracker, $ForgeChunkManager$TicketTracker$Type} from "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketTracker"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ForgeChunkManager {

constructor()

public static "readForgeForcedChunks"(arg0: $CompoundTag$Type, arg1: $ForgeChunkManager$TicketTracker$Type<($BlockPos$Type)>, arg2: $ForgeChunkManager$TicketTracker$Type<($UUID$Type)>): void
public static "writeForgeForcedChunks"(arg0: $CompoundTag$Type, arg1: $ForgeChunkManager$TicketTracker$Type<($BlockPos$Type)>, arg2: $ForgeChunkManager$TicketTracker$Type<($UUID$Type)>): void
public static "setForcedChunkLoadingCallback"(arg0: string, arg1: $ForgeChunkManager$LoadingValidationCallback$Type): void
public static "hasForcedChunks"(arg0: $ServerLevel$Type): boolean
public static "forceChunk"(arg0: $ServerLevel$Type, arg1: string, arg2: $BlockPos$Type, arg3: integer, arg4: integer, arg5: boolean, arg6: boolean): boolean
public static "forceChunk"(arg0: $ServerLevel$Type, arg1: string, arg2: $Entity$Type, arg3: integer, arg4: integer, arg5: boolean, arg6: boolean): boolean
public static "forceChunk"(arg0: $ServerLevel$Type, arg1: string, arg2: $UUID$Type, arg3: integer, arg4: integer, arg5: boolean, arg6: boolean): boolean
public static "reinstatePersistentChunks"(arg0: $ServerLevel$Type, arg1: $ForcedChunksSavedData$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeChunkManager$Type = ($ForgeChunkManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeChunkManager_ = $ForgeChunkManager$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeRecipeProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$VanillaRecipeProvider, $VanillaRecipeProvider$Type} from "packages/net/minecraft/data/recipes/packs/$VanillaRecipeProvider"

export class $ForgeRecipeProvider extends $VanillaRecipeProvider {
static readonly "COAL_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "IRON_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "COPPER_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "GOLD_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "DIAMOND_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "LAPIS_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "REDSTONE_SMELTABLES": $ImmutableList<($ItemLike)>
static readonly "EMERALD_SMELTABLES": $ImmutableList<($ItemLike)>

constructor(arg0: $PackOutput$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRecipeProvider$Type = ($ForgeRecipeProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRecipeProvider_ = $ForgeRecipeProvider$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$ICapabilitySerializable" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $ICapabilitySerializable<T extends $Tag> extends $ICapabilityProvider, $INBTSerializable<(T)> {

 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
 "deserializeNBT"(arg0: T): void
 "serializeNBT"(): T
}

export namespace $ICapabilitySerializable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilitySerializable$Type<T> = ($ICapabilitySerializable<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilitySerializable_<T> = $ICapabilitySerializable$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/world/$StructureModifier$Phase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $StructureModifier$Phase extends $Enum<($StructureModifier$Phase)> {
static readonly "BEFORE_EVERYTHING": $StructureModifier$Phase
static readonly "ADD": $StructureModifier$Phase
static readonly "REMOVE": $StructureModifier$Phase
static readonly "MODIFY": $StructureModifier$Phase
static readonly "AFTER_EVERYTHING": $StructureModifier$Phase


public static "values"(): ($StructureModifier$Phase)[]
public static "valueOf"(arg0: string): $StructureModifier$Phase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureModifier$Phase$Type = (("add") | ("modify") | ("before_everything") | ("after_everything") | ("remove")) | ($StructureModifier$Phase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureModifier$Phase_ = $StructureModifier$Phase$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseInput" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$MouseInput extends $ScreenEvent {

constructor()

public "getMouseX"(): double
public "getMouseY"(): double
public "getListenerList"(): $ListenerList
get "mouseX"(): double
get "mouseY"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseInput$Type = ($ScreenEvent$MouseInput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseInput_ = $ScreenEvent$MouseInput$Type;
}}
declare module "packages/net/minecraftforge/event/$AddPackFindersEvent" {
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RepositorySource, $RepositorySource$Type} from "packages/net/minecraft/server/packs/repository/$RepositorySource"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

export class $AddPackFindersEvent extends $Event implements $IModBusEvent {

constructor(arg0: $PackType$Type, arg1: $Consumer$Type<($RepositorySource$Type)>)
constructor()

public "getPackType"(): $PackType
public "isCancelable"(): boolean
public "addRepositorySource"(arg0: $RepositorySource$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "packType"(): $PackType
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddPackFindersEvent$Type = ($AddPackFindersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddPackFindersEvent_ = $AddPackFindersEvent$Type;
}}
declare module "packages/net/minecraftforge/common/loot/$LootTableIdCondition" {
import {$LootContextParam, $LootContextParam$Type} from "packages/net/minecraft/world/level/storage/loot/parameters/$LootContextParam"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ValidationContext, $ValidationContext$Type} from "packages/net/minecraft/world/level/storage/loot/$ValidationContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LootTableIdCondition$Builder, $LootTableIdCondition$Builder$Type} from "packages/net/minecraftforge/common/loot/$LootTableIdCondition$Builder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"

export class $LootTableIdCondition implements $LootItemCondition {
static readonly "LOOT_TABLE_ID": $LootItemConditionType
static readonly "UNKNOWN_LOOT_TABLE": $ResourceLocation


public "test"(arg0: $LootContext$Type): boolean
public static "builder"(arg0: $ResourceLocation$Type): $LootTableIdCondition$Builder
public "getType"(): $LootItemConditionType
public "validate"(arg0: $ValidationContext$Type): void
public "getReferencedContextParams"(): $Set<($LootContextParam<(any)>)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public "negate"(): $Predicate<($LootContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
public "applyLootHandler"(context: $LootContext$Type, loot: $List$Type<($ItemStack$Type)>): boolean
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableIdCondition$Type = ($LootTableIdCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableIdCondition_ = $LootTableIdCondition$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$RemoveSpawnsBiomeModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ForgeBiomeModifiers$RemoveSpawnsBiomeModifier extends $Record implements $BiomeModifier {

constructor(biomes: $HolderSet$Type<($Biome$Type)>, entityTypes: $HolderSet$Type<($EntityType$Type<(any)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "biomes"(): $HolderSet<($Biome)>
public "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
public "entityTypes"(): $HolderSet<($EntityType<(any)>)>
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeModifiers$RemoveSpawnsBiomeModifier$Type = ($ForgeBiomeModifiers$RemoveSpawnsBiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeModifiers$RemoveSpawnsBiomeModifier_ = $ForgeBiomeModifiers$RemoveSpawnsBiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/common/util/$TablePrinter" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export class $TablePrinter<T> {

constructor()

public "add"(arg0: T): $TablePrinter<(T)>
public "add"(arg0: T, ...arg1: (T)[]): $TablePrinter<(T)>
public "add"(arg0: $Collection$Type<(any)>): $TablePrinter<(T)>
public "toString"(): string
public "build"(arg0: $StringBuilder$Type): void
public "header"(arg0: string, arg1: $Function$Type<(T), (string)>, arg2: boolean): $TablePrinter<(T)>
public "header"(arg0: string, arg1: $Function$Type<(T), (string)>): $TablePrinter<(T)>
public "clearRows"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TablePrinter$Type<T> = ($TablePrinter<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TablePrinter_<T> = $TablePrinter$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$ItemFishedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FishingHook, $FishingHook$Type} from "packages/net/minecraft/world/entity/projectile/$FishingHook"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemFishedEvent extends $PlayerEvent {

constructor(arg0: $List$Type<($ItemStack$Type)>, arg1: integer, arg2: $FishingHook$Type)
constructor()

public "isCancelable"(): boolean
public "getRodDamage"(): integer
public "damageRodBy"(arg0: integer): void
public "getHookEntity"(): $FishingHook
public "getDrops"(): $NonNullList<($ItemStack)>
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "rodDamage"(): integer
get "hookEntity"(): $FishingHook
get "drops"(): $NonNullList<($ItemStack)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFishedEvent$Type = ($ItemFishedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFishedEvent_ = $ItemFishedEvent$Type;
}}
declare module "packages/net/minecraftforge/client/textures/$ForgeTextureMetadata" {
import {$ITextureAtlasSpriteLoader, $ITextureAtlasSpriteLoader$Type} from "packages/net/minecraftforge/client/textures/$ITextureAtlasSpriteLoader"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$Type} from "packages/net/minecraft/server/packs/metadata/$MetadataSectionSerializer"
import {$Resource, $Resource$Type} from "packages/net/minecraft/server/packs/resources/$Resource"

export class $ForgeTextureMetadata {
static readonly "EMPTY": $ForgeTextureMetadata
static readonly "SERIALIZER": $MetadataSectionSerializer<($ForgeTextureMetadata)>

constructor(arg0: $ITextureAtlasSpriteLoader$Type)

public "getLoader"(): $ITextureAtlasSpriteLoader
public static "forResource"(arg0: $Resource$Type): $ForgeTextureMetadata
get "loader"(): $ITextureAtlasSpriteLoader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeTextureMetadata$Type = ($ForgeTextureMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeTextureMetadata_ = $ForgeTextureMetadata$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterGuiOverlaysEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterGuiOverlaysEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($IGuiOverlay$Type)>, arg1: $List$Type<($ResourceLocation$Type)>)

public "isCancelable"(): boolean
public "registerAboveAll"(arg0: string, arg1: $IGuiOverlay$Type): void
public "registerBelowAll"(arg0: string, arg1: $IGuiOverlay$Type): void
public "registerBelow"(arg0: $ResourceLocation$Type, arg1: string, arg2: $IGuiOverlay$Type): void
public "registerAbove"(arg0: $ResourceLocation$Type, arg1: string, arg2: $IGuiOverlay$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiOverlaysEvent$Type = ($RegisterGuiOverlaysEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiOverlaysEvent_ = $RegisterGuiOverlaysEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$MinecraftForge" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"

export class $MinecraftForge {
static readonly "EVENT_BUS": $IEventBus

constructor()

public static "initialize"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftForge$Type = ($MinecraftForge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftForge_ = $MinecraftForge$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityAttributeModificationEvent" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeSupplier$Builder, $AttributeSupplier$Builder$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeSupplier$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EntityAttributeModificationEvent extends $Event implements $IModBusEvent {

constructor(arg0: $Map$Type<($EntityType$Type<(any)>), ($AttributeSupplier$Builder$Type)>)
constructor()

public "add"(arg0: $EntityType$Type<(any)>, arg1: $Attribute$Type): void
public "add"(arg0: $EntityType$Type<(any)>, arg1: $Attribute$Type, arg2: double): void
public "has"(arg0: $EntityType$Type<(any)>, arg1: $Attribute$Type): boolean
public "isCancelable"(): boolean
public "getTypes"(): $List<($EntityType<(any)>)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "types"(): $List<($EntityType<(any)>)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityAttributeModificationEvent$Type = ($EntityAttributeModificationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityAttributeModificationEvent_ = $EntityAttributeModificationEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerChangeGameModeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$GameType, $GameType$Type} from "packages/net/minecraft/world/level/$GameType"

export class $PlayerEvent$PlayerChangeGameModeEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $GameType$Type, arg2: $GameType$Type)

public "isCancelable"(): boolean
public "getNewGameMode"(): $GameType
public "setNewGameMode"(arg0: $GameType$Type): void
public "getCurrentGameMode"(): $GameType
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "newGameMode"(): $GameType
set "newGameMode"(value: $GameType$Type)
get "currentGameMode"(): $GameType
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$PlayerChangeGameModeEvent$Type = ($PlayerEvent$PlayerChangeGameModeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$PlayerChangeGameModeEvent_ = $PlayerEvent$PlayerChangeGameModeEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LootingLevelEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LootingLevelEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: integer)

public "getDamageSource"(): $DamageSource
public "getLootingLevel"(): integer
public "setLootingLevel"(arg0: integer): void
public "getListenerList"(): $ListenerList
get "damageSource"(): $DamageSource
get "lootingLevel"(): integer
set "lootingLevel"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootingLevelEvent$Type = ($LootingLevelEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootingLevelEvent_ = $LootingLevelEvent$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$EmptyHandler" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $EmptyHandler implements $IItemHandlerModifiable {
static readonly "INSTANCE": $IItemHandler

constructor()

public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyHandler$Type = ($EmptyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyHandler_ = $EmptyHandler$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderArmEvent" {
import {$AbstractClientPlayer, $AbstractClientPlayer$Type} from "packages/net/minecraft/client/player/$AbstractClientPlayer"
import {$HumanoidArm, $HumanoidArm$Type} from "packages/net/minecraft/world/entity/$HumanoidArm"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"

export class $RenderArmEvent extends $Event {

constructor(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: integer, arg3: $AbstractClientPlayer$Type, arg4: $HumanoidArm$Type)
constructor()

public "isCancelable"(): boolean
public "getArm"(): $HumanoidArm
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getPlayer"(): $AbstractClientPlayer
public "getPackedLight"(): integer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "arm"(): $HumanoidArm
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "player"(): $AbstractClientPlayer
get "packedLight"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderArmEvent$Type = ($RenderArmEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderArmEvent_ = $RenderArmEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/data/$MultipartModelData" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$MultipartModelData$Builder, $MultipartModelData$Builder$Type} from "packages/net/minecraftforge/client/model/data/$MultipartModelData$Builder"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $MultipartModelData {
static readonly "PROPERTY": $ModelProperty<($MultipartModelData)>


public "get"(arg0: $BakedModel$Type): $ModelData
public static "builder"(): $MultipartModelData$Builder
public static "resolve"(arg0: $ModelData$Type, arg1: $BakedModel$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartModelData$Type = ($MultipartModelData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartModelData_ = $MultipartModelData$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MultiPartBlockStateBuilder$PartBuilder, $MultiPartBlockStateBuilder$PartBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder$PartBuilder"
import {$IGeneratedBlockState, $IGeneratedBlockState$Type} from "packages/net/minecraftforge/client/model/generators/$IGeneratedBlockState"
import {$ConfiguredModel$Builder, $ConfiguredModel$Builder$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel$Builder"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MultiPartBlockStateBuilder implements $IGeneratedBlockState {

constructor(arg0: $Block$Type)

public "part"(): $ConfiguredModel$Builder<($MultiPartBlockStateBuilder$PartBuilder)>
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiPartBlockStateBuilder$Type = ($MultiPartBlockStateBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiPartBlockStateBuilder_ = $MultiPartBlockStateBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$IConditionSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export interface $IConditionSerializer<T extends $ICondition> {

 "write"(arg0: $JsonObject$Type, arg1: T): void
 "read"(arg0: $JsonObject$Type): T
 "getID"(): $ResourceLocation
 "getJson"(arg0: T): $JsonObject
}

export namespace $IConditionSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConditionSerializer$Type<T> = ($IConditionSerializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConditionSerializer_<T> = $IConditionSerializer$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo" {
import {$MobSpawnSettings, $MobSpawnSettings$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$Type} from "packages/net/minecraft/world/level/biome/$BiomeGenerationSettings"
import {$Biome$ClimateSettings, $Biome$ClimateSettings$Type} from "packages/net/minecraft/world/level/biome/$Biome$ClimateSettings"
import {$BiomeSpecialEffects, $BiomeSpecialEffects$Type} from "packages/net/minecraft/world/level/biome/$BiomeSpecialEffects"

export class $ModifiableBiomeInfo$BiomeInfo extends $Record {

constructor(climateSettings: $Biome$ClimateSettings$Type, effects: $BiomeSpecialEffects$Type, generationSettings: $BiomeGenerationSettings$Type, mobSpawnSettings: $MobSpawnSettings$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "mobSpawnSettings"(): $MobSpawnSettings
public "generationSettings"(): $BiomeGenerationSettings
public "climateSettings"(): $Biome$ClimateSettings
public "effects"(): $BiomeSpecialEffects
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableBiomeInfo$BiomeInfo$Type = ($ModifiableBiomeInfo$BiomeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableBiomeInfo$BiomeInfo_ = $ModifiableBiomeInfo$BiomeInfo$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder$FaceBuilder" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ModelBuilder$FaceRotation, $ModelBuilder$FaceRotation$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$FaceRotation"
import {$ModelBuilder$ElementBuilder, $ModelBuilder$ElementBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder"

export class $ModelBuilder$ElementBuilder$FaceBuilder {


public "end"(): $ModelBuilder$ElementBuilder<>
public "ao"(arg0: boolean): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "color"(arg0: integer): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "calculateNormals"(arg0: boolean): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "cullface"(arg0: $Direction$Type): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "tintindex"(arg0: integer): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "rotation"(arg0: $ModelBuilder$FaceRotation$Type): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "texture"(arg0: string): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "emissivity"(arg0: integer, arg1: integer): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "uvs"(arg0: float, arg1: float, arg2: float, arg3: float): $ModelBuilder$ElementBuilder$FaceBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$ElementBuilder$FaceBuilder$Type = ($ModelBuilder$ElementBuilder$FaceBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$ElementBuilder$FaceBuilder_ = $ModelBuilder$ElementBuilder$FaceBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $ICapabilityProvider {

 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>

(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}

export namespace $ICapabilityProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityProvider$Type = ($ICapabilityProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityProvider_ = $ICapabilityProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerDestroyItemEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PlayerDestroyItemEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $InteractionHand$Type)

public "getOriginal"(): $ItemStack
public "getHand"(): $InteractionHand
public "getListenerList"(): $ListenerList
get "original"(): $ItemStack
get "hand"(): $InteractionHand
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDestroyItemEvent$Type = ($PlayerDestroyItemEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerDestroyItemEvent_ = $PlayerDestroyItemEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$TagEmptyCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $TagEmptyCondition implements $ICondition {

constructor(arg0: $ResourceLocation$Type)
constructor(arg0: string, arg1: string)
constructor(arg0: string)

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagEmptyCondition$Type = ($TagEmptyCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagEmptyCondition_ = $TagEmptyCondition$Type;
}}
declare module "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Reloading" {
import {$ModConfigEvent, $ModConfigEvent$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent, $IConfigEvent$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModConfigEvent$Reloading extends $ModConfigEvent {

constructor(arg0: $ModConfig$Type)
constructor()

public "getListenerList"(): $ListenerList
public static "reloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "unloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "loading"(arg0: $ModConfig$Type): $IConfigEvent
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModConfigEvent$Reloading$Type = ($ModConfigEvent$Reloading);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModConfigEvent$Reloading_ = $ModConfigEvent$Reloading$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent$Tick" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityUseItemEvent, $LivingEntityUseItemEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEntityUseItemEvent$Tick extends $LivingEntityUseItemEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityUseItemEvent$Tick$Type = ($LivingEntityUseItemEvent$Tick);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityUseItemEvent$Tick_ = $LivingEntityUseItemEvent$Tick$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseScrolled" {
import {$ScreenEvent$MouseInput, $ScreenEvent$MouseInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseScrolled extends $ScreenEvent$MouseInput {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: double)

public "getScrollDelta"(): double
public "getListenerList"(): $ListenerList
get "scrollDelta"(): double
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseScrolled$Type = ($ScreenEvent$MouseScrolled);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseScrolled_ = $ScreenEvent$MouseScrolled$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeI18n" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeI18n {

constructor()

public static "getPattern"(arg0: string): string
public static "stripControlCodes"(arg0: string): string
public static "parseMessage"(arg0: string, ...arg1: (any)[]): string
public static "parseFormat"(arg0: string, ...arg1: (any)[]): string
public static "loadLanguageData"(arg0: $Map$Type<(string), (string)>): void
public static "stripSpecialChars"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeI18n$Type = ($ForgeI18n);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeI18n_ = $ForgeI18n$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$AddCallback" {
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export interface $IForgeRegistry$AddCallback<V> {

 "onAdd"(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type, arg2: integer, arg3: $ResourceKey$Type<(V)>, arg4: V, arg5: V): void

(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type, arg2: integer, arg3: $ResourceKey$Type<(V)>, arg4: V, arg5: V): void
}

export namespace $IForgeRegistry$AddCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$AddCallback$Type<V> = ($IForgeRegistry$AddCallback<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$AddCallback_<V> = $IForgeRegistry$AddCallback$Type<(V)>;
}}
declare module "packages/net/minecraftforge/common/util/$ForgeSoundType" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ForgeSoundType extends $SoundType {
static readonly "EMPTY": $SoundType
static readonly "WOOD": $SoundType
static readonly "GRAVEL": $SoundType
static readonly "GRASS": $SoundType
static readonly "LILY_PAD": $SoundType
static readonly "STONE": $SoundType
static readonly "METAL": $SoundType
static readonly "GLASS": $SoundType
static readonly "WOOL": $SoundType
static readonly "SAND": $SoundType
static readonly "SNOW": $SoundType
static readonly "POWDER_SNOW": $SoundType
static readonly "LADDER": $SoundType
static readonly "ANVIL": $SoundType
static readonly "SLIME_BLOCK": $SoundType
static readonly "HONEY_BLOCK": $SoundType
static readonly "WET_GRASS": $SoundType
static readonly "CORAL_BLOCK": $SoundType
static readonly "BAMBOO": $SoundType
static readonly "BAMBOO_SAPLING": $SoundType
static readonly "SCAFFOLDING": $SoundType
static readonly "SWEET_BERRY_BUSH": $SoundType
static readonly "CROP": $SoundType
static readonly "HARD_CROP": $SoundType
static readonly "VINE": $SoundType
static readonly "NETHER_WART": $SoundType
static readonly "LANTERN": $SoundType
static readonly "STEM": $SoundType
static readonly "NYLIUM": $SoundType
static readonly "FUNGUS": $SoundType
static readonly "ROOTS": $SoundType
static readonly "SHROOMLIGHT": $SoundType
static readonly "WEEPING_VINES": $SoundType
static readonly "TWISTING_VINES": $SoundType
static readonly "SOUL_SAND": $SoundType
static readonly "SOUL_SOIL": $SoundType
static readonly "BASALT": $SoundType
static readonly "WART_BLOCK": $SoundType
static readonly "NETHERRACK": $SoundType
static readonly "NETHER_BRICKS": $SoundType
static readonly "NETHER_SPROUTS": $SoundType
static readonly "NETHER_ORE": $SoundType
static readonly "BONE_BLOCK": $SoundType
static readonly "NETHERITE_BLOCK": $SoundType
static readonly "ANCIENT_DEBRIS": $SoundType
static readonly "LODESTONE": $SoundType
static readonly "CHAIN": $SoundType
static readonly "NETHER_GOLD_ORE": $SoundType
static readonly "GILDED_BLACKSTONE": $SoundType
static readonly "CANDLE": $SoundType
static readonly "AMETHYST": $SoundType
static readonly "AMETHYST_CLUSTER": $SoundType
static readonly "SMALL_AMETHYST_BUD": $SoundType
static readonly "MEDIUM_AMETHYST_BUD": $SoundType
static readonly "LARGE_AMETHYST_BUD": $SoundType
static readonly "TUFF": $SoundType
static readonly "CALCITE": $SoundType
static readonly "DRIPSTONE_BLOCK": $SoundType
static readonly "POINTED_DRIPSTONE": $SoundType
static readonly "COPPER": $SoundType
static readonly "CAVE_VINES": $SoundType
static readonly "SPORE_BLOSSOM": $SoundType
static readonly "AZALEA": $SoundType
static readonly "FLOWERING_AZALEA": $SoundType
static readonly "MOSS_CARPET": $SoundType
static readonly "PINK_PETALS": $SoundType
static readonly "MOSS": $SoundType
static readonly "BIG_DRIPLEAF": $SoundType
static readonly "SMALL_DRIPLEAF": $SoundType
static readonly "ROOTED_DIRT": $SoundType
static readonly "HANGING_ROOTS": $SoundType
static readonly "AZALEA_LEAVES": $SoundType
static readonly "SCULK_SENSOR": $SoundType
static readonly "SCULK_CATALYST": $SoundType
static readonly "SCULK": $SoundType
static readonly "SCULK_VEIN": $SoundType
static readonly "SCULK_SHRIEKER": $SoundType
static readonly "GLOW_LICHEN": $SoundType
static readonly "DEEPSLATE": $SoundType
static readonly "DEEPSLATE_BRICKS": $SoundType
static readonly "DEEPSLATE_TILES": $SoundType
static readonly "POLISHED_DEEPSLATE": $SoundType
static readonly "FROGLIGHT": $SoundType
static readonly "FROGSPAWN": $SoundType
static readonly "MANGROVE_ROOTS": $SoundType
static readonly "MUDDY_MANGROVE_ROOTS": $SoundType
static readonly "MUD": $SoundType
static readonly "MUD_BRICKS": $SoundType
static readonly "PACKED_MUD": $SoundType
static readonly "HANGING_SIGN": $SoundType
static readonly "NETHER_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD": $SoundType
static readonly "NETHER_WOOD": $SoundType
static readonly "CHERRY_WOOD": $SoundType
static readonly "CHERRY_SAPLING": $SoundType
static readonly "CHERRY_LEAVES": $SoundType
static readonly "CHERRY_WOOD_HANGING_SIGN": $SoundType
static readonly "CHISELED_BOOKSHELF": $SoundType
static readonly "SUSPICIOUS_SAND": $SoundType
static readonly "SUSPICIOUS_GRAVEL": $SoundType
static readonly "DECORATED_POT": $SoundType
static readonly "DECORATED_POT_CRACKED": $SoundType
readonly "volume": float
readonly "pitch": float

constructor(arg0: float, arg1: float, arg2: $Supplier$Type<($SoundEvent$Type)>, arg3: $Supplier$Type<($SoundEvent$Type)>, arg4: $Supplier$Type<($SoundEvent$Type)>, arg5: $Supplier$Type<($SoundEvent$Type)>, arg6: $Supplier$Type<($SoundEvent$Type)>)

public "getFallSound"(): $SoundEvent
public "getStepSound"(): $SoundEvent
public "getHitSound"(): $SoundEvent
public "getBreakSound"(): $SoundEvent
public "getPlaceSound"(): $SoundEvent
get "fallSound"(): $SoundEvent
get "stepSound"(): $SoundEvent
get "hitSound"(): $SoundEvent
get "breakSound"(): $SoundEvent
get "placeSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSoundType$Type = ($ForgeSoundType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSoundType_ = $ForgeSoundType$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgePoseStack" {
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"

export interface $IForgePoseStack {

 "pushTransformation"(arg0: $Transformation$Type): void
}

export namespace $IForgePoseStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgePoseStack$Type = ($IForgePoseStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgePoseStack_ = $IForgePoseStack$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/moddiscovery/$ModFile" {
import {$SecureJar, $SecureJar$Type} from "packages/cpw/mods/jarhandling/$SecureJar"
import {$CoreModFile, $CoreModFile$Type} from "packages/net/minecraftforge/fml/loading/moddiscovery/$CoreModFile"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ModFileFactory$ModFileInfoParser, $ModFileFactory$ModFileInfoParser$Type} from "packages/net/minecraftforge/forgespi/locating/$ModFileFactory$ModFileInfoParser"
import {$IModFile$Type, $IModFile$Type$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile$Type"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$ModFileScanData, $ModFileScanData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData"
import {$IModLanguageProvider, $IModLanguageProvider$Type} from "packages/net/minecraftforge/forgespi/language/$IModLanguageProvider"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModProvider, $IModProvider$Type} from "packages/net/minecraftforge/forgespi/locating/$IModProvider"
import {$SecureJar$Status, $SecureJar$Status$Type} from "packages/cpw/mods/jarhandling/$SecureJar$Status"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Manifest, $Manifest$Type} from "packages/java/util/jar/$Manifest"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModFile implements $IModFile {
/**
 * 
 * @deprecated
 */
static readonly "DEFAULTMANIFEST": $Manifest

constructor(arg0: $SecureJar$Type, arg1: $IModProvider$Type, arg2: $ModFileFactory$ModFileInfoParser$Type)
constructor(arg0: $SecureJar$Type, arg1: $IModProvider$Type, arg2: $ModFileFactory$ModFileInfoParser$Type, arg3: string)

public "toString"(): string
public "findResource"(...arg0: (string)[]): $Path
public "getType"(): $IModFile$Type
public "getFileName"(): string
public "getProvider"(): $IModProvider
public "getFilePath"(): $Path
public "getSubstitutionMap"(): $Supplier<($Map<(string), (any)>)>
public "getLoaders"(): $List<($IModLanguageProvider)>
public "getModFileInfo"(): $IModFileInfo
public "getSecureJar"(): $SecureJar
public "setSecurityStatus"(arg0: $SecureJar$Status$Type): void
public "scanFile"(arg0: $Consumer$Type<($Path$Type)>): void
public "getModInfos"(): $List<($IModInfo)>
public "getScanResult"(): $ModFileScanData
public "identifyMods"(): boolean
public "compileContent"(): $ModFileScanData
public "setScanResult"(arg0: $ModFileScanData$Type, arg1: $Throwable$Type): void
public "getCoreMods"(): $List<($CoreModFile)>
public "getJarVersion"(): $ArtifactVersion
public "setFileProperties"(arg0: $Map$Type<(string), (any)>): void
public "identifyLanguage"(): void
public "getAccessTransformer"(): $Optional<($Path)>
public "setFutureScanResult"(arg0: $CompletableFuture$Type<($ModFileScanData$Type)>): void
get "type"(): $IModFile$Type
get "fileName"(): string
get "provider"(): $IModProvider
get "filePath"(): $Path
get "substitutionMap"(): $Supplier<($Map<(string), (any)>)>
get "loaders"(): $List<($IModLanguageProvider)>
get "modFileInfo"(): $IModFileInfo
get "secureJar"(): $SecureJar
set "securityStatus"(value: $SecureJar$Status$Type)
get "modInfos"(): $List<($IModInfo)>
get "scanResult"(): $ModFileScanData
get "coreMods"(): $List<($CoreModFile)>
get "jarVersion"(): $ArtifactVersion
set "fileProperties"(value: $Map$Type<(string), (any)>)
get "accessTransformer"(): $Optional<($Path)>
set "futureScanResult"(value: $CompletableFuture$Type<($ModFileScanData$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFile$Type = ($ModFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFile_ = $ModFile$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$PlayerMainInvWrapper" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$RangedWrapper, $RangedWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RangedWrapper"

export class $PlayerMainInvWrapper extends $RangedWrapper {

constructor(arg0: $Inventory$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getInventoryPlayer"(): $Inventory
get "inventoryPlayer"(): $Inventory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerMainInvWrapper$Type = ($PlayerMainInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerMainInvWrapper_ = $PlayerMainInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterClientCommandsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $RegisterClientCommandsEvent extends $Event {

constructor()
constructor(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>, arg1: $CommandBuildContext$Type)

public "isCancelable"(): boolean
public "getDispatcher"(): $CommandDispatcher<($CommandSourceStack)>
public "getBuildContext"(): $CommandBuildContext
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "dispatcher"(): $CommandDispatcher<($CommandSourceStack)>
get "buildContext"(): $CommandBuildContext
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterClientCommandsEvent$Type = ($RegisterClientCommandsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterClientCommandsEvent_ = $RegisterClientCommandsEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeMobEffect" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IForgeMobEffect {

 "getCurativeItems"(): $List<($ItemStack)>
 "getSortOrder"(arg0: $MobEffectInstance$Type): integer
}

export namespace $IForgeMobEffect {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeMobEffect$Type = ($IForgeMobEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeMobEffect_ = $IForgeMobEffect$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$ElementShader" {
import {$ElementShader$RenderType, $ElementShader$RenderType$Type} from "packages/net/minecraftforge/fml/earlydisplay/$ElementShader$RenderType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ElementShader {

constructor()

public "clear"(): void
public "init"(): void
public "close"(): void
public "activate"(): void
public "updateRenderTypeUniform"(arg0: $ElementShader$RenderType$Type): void
public "updateTextureUniform"(arg0: integer): void
public "updateScreenSizeUniform"(arg0: integer, arg1: integer): void
public "program"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElementShader$Type = ($ElementShader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElementShader_ = $ElementShader$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$ConditionalAdvancement" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ConditionalAdvancement$Builder, $ConditionalAdvancement$Builder$Type} from "packages/net/minecraftforge/common/crafting/$ConditionalAdvancement$Builder"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"

export class $ConditionalAdvancement {

constructor()

public static "builder"(): $ConditionalAdvancement$Builder
public static "processConditional"(arg0: $JsonObject$Type, arg1: $ICondition$IContext$Type): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalAdvancement$Type = ($ConditionalAdvancement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalAdvancement_ = $ConditionalAdvancement$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityEvent$EnteringSection" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$SectionPos, $SectionPos$Type} from "packages/net/minecraft/core/$SectionPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityEvent$EnteringSection extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: long, arg2: long)

public "getOldPos"(): $SectionPos
public "getPackedNewPos"(): long
public "getNewPos"(): $SectionPos
public "getPackedOldPos"(): long
public "didChunkChange"(): boolean
public "getListenerList"(): $ListenerList
get "oldPos"(): $SectionPos
get "packedNewPos"(): long
get "newPos"(): $SectionPos
get "packedOldPos"(): long
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEvent$EnteringSection$Type = ($EntityEvent$EnteringSection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEvent$EnteringSection_ = $EntityEvent$EnteringSection$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$StartTracking" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayerEvent$StartTracking extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Entity$Type)

public "getTarget"(): $Entity
public "getListenerList"(): $ListenerList
get "target"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$StartTracking$Type = ($PlayerEvent$StartTracking);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$StartTracking_ = $PlayerEvent$StartTracking$Type;
}}
declare module "packages/net/minecraftforge/event/$GameShuttingDownEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $GameShuttingDownEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameShuttingDownEvent$Type = ($GameShuttingDownEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameShuttingDownEvent_ = $GameShuttingDownEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$ItemTooltipEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemTooltipEvent extends $PlayerEvent {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type)

public "getFlags"(): $TooltipFlag
public "getItemStack"(): $ItemStack
public "getToolTip"(): $List<($Component)>
public "getListenerList"(): $ListenerList
get "flags"(): $TooltipFlag
get "itemStack"(): $ItemStack
get "toolTip"(): $List<($Component)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipEvent$Type = ($ItemTooltipEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTooltipEvent_ = $ItemTooltipEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ClientChatReceivedEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/net/minecraft/network/chat/$ChatType$Bound"

export class $ClientChatReceivedEvent extends $Event {

constructor(arg0: $ChatType$Bound$Type, arg1: $Component$Type, arg2: $UUID$Type)
constructor()

public "getMessage"(): $Component
public "isSystem"(): boolean
public "isCancelable"(): boolean
public "setMessage"(arg0: $Component$Type): void
public "getBoundChatType"(): $ChatType$Bound
public "getSender"(): $UUID
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "message"(): $Component
get "system"(): boolean
get "cancelable"(): boolean
set "message"(value: $Component$Type)
get "boundChatType"(): $ChatType$Bound
get "sender"(): $UUID
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientChatReceivedEvent$Type = ($ClientChatReceivedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientChatReceivedEvent_ = $ClientChatReceivedEvent$Type;
}}
declare module "packages/net/minecraftforge/items/$VanillaInventoryCodeHooks" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Hopper, $Hopper$Type} from "packages/net/minecraft/world/level/block/entity/$Hopper"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$HopperBlockEntity, $HopperBlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$HopperBlockEntity"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DispenserBlockEntity, $DispenserBlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$DispenserBlockEntity"

export class $VanillaInventoryCodeHooks {

constructor()

public static "getItemHandler"(arg0: $Level$Type, arg1: double, arg2: double, arg3: double, arg4: $Direction$Type): $Optional<($Pair<($IItemHandler), (any)>)>
public static "insertHook"(arg0: $HopperBlockEntity$Type): boolean
public static "extractHook"(arg0: $Level$Type, arg1: $Hopper$Type): boolean
public static "dropperInsertHook"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $DispenserBlockEntity$Type, arg3: integer, arg4: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaInventoryCodeHooks$Type = ($VanillaInventoryCodeHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaInventoryCodeHooks_ = $VanillaInventoryCodeHooks$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$EntityItemPickupEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $EntityItemPickupEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemEntity$Type)

public "getItem"(): $ItemEntity
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "item"(): $ItemEntity
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityItemPickupEvent$Type = ($EntityItemPickupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityItemPickupEvent_ = $EntityItemPickupEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$AlterGroundEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$LevelSimulatedReader, $LevelSimulatedReader$Type} from "packages/net/minecraft/world/level/$LevelSimulatedReader"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $AlterGroundEvent extends $Event {

constructor()
constructor(arg0: $LevelSimulatedReader$Type, arg1: $RandomSource$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type)

public "getLevel"(): $LevelSimulatedReader
public "isCancelable"(): boolean
public "getNewAlteredState"(): $BlockState
public "setNewAlteredState"(arg0: $BlockState$Type): void
public "getPos"(): $BlockPos
public "getRandom"(): $RandomSource
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getOriginalAlteredState"(): $BlockState
get "level"(): $LevelSimulatedReader
get "cancelable"(): boolean
get "newAlteredState"(): $BlockState
set "newAlteredState"(value: $BlockState$Type)
get "pos"(): $BlockPos
get "random"(): $RandomSource
get "listenerList"(): $ListenerList
get "originalAlteredState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlterGroundEvent$Type = ($AlterGroundEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlterGroundEvent_ = $AlterGroundEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLivingEvent$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityRenderer, $LivingEntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$LivingEntityRenderer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$RenderLivingEvent, $RenderLivingEvent$Type} from "packages/net/minecraftforge/client/event/$RenderLivingEvent"
import {$EntityModel, $EntityModel$Type} from "packages/net/minecraft/client/model/$EntityModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $RenderLivingEvent$Pre<T extends $LivingEntity, M extends $EntityModel<(T)>> extends $RenderLivingEvent<(T), (M)> {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $LivingEntityRenderer$Type<(T), (M)>, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLivingEvent$Pre$Type<T, M> = ($RenderLivingEvent$Pre<(T), (M)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLivingEvent$Pre_<T, M> = $RenderLivingEvent$Pre$Type<(T), (M)>;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent$Item" {
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$RegisterColorHandlersEvent, $RegisterColorHandlersEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$ItemColors, $ItemColors$Type} from "packages/net/minecraft/client/color/item/$ItemColors"

export class $RegisterColorHandlersEvent$Item extends $RegisterColorHandlersEvent {

constructor()
constructor(arg0: $ItemColors$Type, arg1: $BlockColors$Type)

public "register"(arg0: $ItemColor$Type, ...arg1: ($ItemLike$Type)[]): void
public "getItemColors"(): $ItemColors
public "getBlockColors"(): $BlockColors
public "getListenerList"(): $ListenerList
get "itemColors"(): $ItemColors
get "blockColors"(): $BlockColors
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterColorHandlersEvent$Item$Type = ($RegisterColorHandlersEvent$Item);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterColorHandlersEvent$Item_ = $RegisterColorHandlersEvent$Item$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$ClientTooltipComponentManager" {
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"

export class $ClientTooltipComponentManager {


public static "init"(): void
public static "createClientTooltipComponent"(arg0: $TooltipComponent$Type): $ClientTooltipComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientTooltipComponentManager$Type = ($ClientTooltipComponentManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientTooltipComponentManager_ = $ClientTooltipComponentManager$Type;
}}
declare module "packages/net/minecraftforge/common/data/$SoundDefinition" {
import {$SoundDefinition$Sound, $SoundDefinition$Sound$Type} from "packages/net/minecraftforge/common/data/$SoundDefinition$Sound"

export class $SoundDefinition {


public "replace"(arg0: boolean): $SoundDefinition
public "with"(...arg0: ($SoundDefinition$Sound$Type)[]): $SoundDefinition
public "with"(arg0: $SoundDefinition$Sound$Type): $SoundDefinition
public static "definition"(): $SoundDefinition
public "subtitle"(arg0: string): $SoundDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundDefinition$Type = ($SoundDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundDefinition_ = $SoundDefinition$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$CropGrowEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BlockEvent$CropGrowEvent, $BlockEvent$CropGrowEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent$CropGrowEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent$CropGrowEvent$Post extends $BlockEvent$CropGrowEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BlockState$Type)

public "getOriginalState"(): $BlockState
public "getListenerList"(): $ListenerList
get "originalState"(): $BlockState
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$CropGrowEvent$Post$Type = ($BlockEvent$CropGrowEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$CropGrowEvent$Post_ = $BlockEvent$CropGrowEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$RenderTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent$RenderTickEvent extends $TickEvent {
readonly "renderTickTime": float
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor(arg0: $TickEvent$Phase$Type, arg1: float)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$RenderTickEvent$Type = ($TickEvent$RenderTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$RenderTickEvent_ = $TickEvent$RenderTickEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$ItemStackMap" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemStackMap {

constructor()

public static "createTypeAndTagMap"<V>(): $Map<($ItemStack), (V)>
public static "createTypeAndTagLinkedMap"<V>(): $Map<($ItemStack), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackMap$Type = ($ItemStackMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackMap_ = $ItemStackMap$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable" {
import {$IRenderable, $IRenderable$Type} from "packages/net/minecraftforge/client/model/renderable/$IRenderable"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$CompositeRenderable$Builder, $CompositeRenderable$Builder$Type} from "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$Builder"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$CompositeRenderable$Transforms, $CompositeRenderable$Transforms$Type} from "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$Transforms"
import {$ITextureRenderTypeLookup, $ITextureRenderTypeLookup$Type} from "packages/net/minecraftforge/client/model/renderable/$ITextureRenderTypeLookup"
import {$Unit, $Unit$Type} from "packages/net/minecraft/util/$Unit"

export class $CompositeRenderable implements $IRenderable<($CompositeRenderable$Transforms)> {


public static "builder"(): $CompositeRenderable$Builder
public "render"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: $ITextureRenderTypeLookup$Type, arg3: integer, arg4: integer, arg5: float, arg6: $CompositeRenderable$Transforms$Type): void
public "withContext"(arg0: $CompositeRenderable$Transforms$Type): $IRenderable<($Unit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeRenderable$Type = ($CompositeRenderable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeRenderable_ = $CompositeRenderable$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$IModFileInfo$LanguageSpec" {
import {$VersionRange, $VersionRange$Type} from "packages/org/apache/maven/artifact/versioning/$VersionRange"
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $IModFileInfo$LanguageSpec extends $Record {

constructor(languageName: string, acceptedVersions: $VersionRange$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "languageName"(): string
public "acceptedVersions"(): $VersionRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModFileInfo$LanguageSpec$Type = ($IModFileInfo$LanguageSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModFileInfo$LanguageSpec_ = $IModFileInfo$LanguageSpec$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBucketPickup" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export interface $IForgeBucketPickup {

 "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
}

export namespace $IForgeBucketPickup {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBucketPickup$Type = ($IForgeBucketPickup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBucketPickup_ = $IForgeBucketPickup$Type;
}}
declare module "packages/net/minecraftforge/server/permission/handler/$DefaultPermissionHandler" {
import {$PermissionDynamicContext, $PermissionDynamicContext$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$IPermissionHandler, $IPermissionHandler$Type} from "packages/net/minecraftforge/server/permission/handler/$IPermissionHandler"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DefaultPermissionHandler implements $IPermissionHandler {
static readonly "IDENTIFIER": $ResourceLocation

constructor(arg0: $Collection$Type<($PermissionNode$Type<(any)>)>)

public "getPermission"<T>(arg0: $ServerPlayer$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
public "getIdentifier"(): $ResourceLocation
public "getOfflinePermission"<T>(arg0: $UUID$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
public "getRegisteredNodes"(): $Set<($PermissionNode<(any)>)>
get "identifier"(): $ResourceLocation
get "registeredNodes"(): $Set<($PermissionNode<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultPermissionHandler$Type = ($DefaultPermissionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultPermissionHandler_ = $DefaultPermissionHandler$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $FMLClientSetupEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FMLClientSetupEvent$Type = ($FMLClientSetupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FMLClientSetupEvent_ = $FMLClientSetupEvent$Type;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionTypes" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$PermissionType, $PermissionType$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionType"

export class $PermissionTypes {
static readonly "BOOLEAN": $PermissionType<(boolean)>
static readonly "INTEGER": $PermissionType<(integer)>
static readonly "STRING": $PermissionType<(string)>
static readonly "COMPONENT": $PermissionType<($Component)>


public static "getTypeByName"(arg0: string): $PermissionType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionTypes$Type = ($PermissionTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionTypes_ = $PermissionTypes$Type;
}}
declare module "packages/net/minecraftforge/server/command/$ForgeCommand" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $ForgeCommand {

constructor(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeCommand$Type = ($ForgeCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeCommand_ = $ForgeCommand$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$CharacterTyped$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$CharacterTyped, $ScreenEvent$CharacterTyped$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$CharacterTyped"

export class $ScreenEvent$CharacterTyped$Post extends $ScreenEvent$CharacterTyped {

constructor(arg0: $Screen$Type, arg1: character, arg2: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$CharacterTyped$Post$Type = ($ScreenEvent$CharacterTyped$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$CharacterTyped$Post_ = $ScreenEvent$CharacterTyped$Post$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingConversionEvent$Pre" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LivingConversionEvent, $LivingConversionEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingConversionEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingConversionEvent$Pre extends $LivingConversionEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $EntityType$Type<(any)>, arg2: $Consumer$Type<(integer)>)

public "isCancelable"(): boolean
public "setConversionTimer"(arg0: integer): void
public "getOutcome"(): $EntityType<(any)>
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
set "conversionTimer"(value: integer)
get "outcome"(): $EntityType<(any)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingConversionEvent$Pre$Type = ($LivingConversionEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingConversionEvent$Pre_ = $LivingConversionEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$ValidateCallback" {
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IForgeRegistry$ValidateCallback<V> {

 "onValidate"(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type, arg2: integer, arg3: $ResourceLocation$Type, arg4: V): void

(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type, arg2: integer, arg3: $ResourceLocation$Type, arg4: V): void
}

export namespace $IForgeRegistry$ValidateCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$ValidateCallback$Type<V> = ($IForgeRegistry$ValidateCallback<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$ValidateCallback_<V> = $IForgeRegistry$ValidateCallback$Type<(V)>;
}}
declare module "packages/net/minecraftforge/forgespi/locating/$IModProvider" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IModProvider {

 "name"(): string
 "isValid"(arg0: $IModFile$Type): boolean
 "initArguments"(arg0: $Map$Type<(string), (any)>): void
 "scanFile"(arg0: $IModFile$Type, arg1: $Consumer$Type<($Path$Type)>): void
}

export namespace $IModProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModProvider$Type = ($IModProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModProvider_ = $IModProvider$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeBakedModel" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ChunkRenderTypeSet, $ChunkRenderTypeSet$Type} from "packages/net/minecraftforge/client/$ChunkRenderTypeSet"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $IForgeBakedModel {

 "useAmbientOcclusion"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
 "useAmbientOcclusion"(arg0: $BlockState$Type): boolean
 "getRenderTypes"(arg0: $ItemStack$Type, arg1: boolean): $List<($RenderType)>
 "getRenderTypes"(arg0: $BlockState$Type, arg1: $RandomSource$Type, arg2: $ModelData$Type): $ChunkRenderTypeSet
 "getRenderPasses"(arg0: $ItemStack$Type, arg1: boolean): $List<($BakedModel)>
 "applyTransform"(arg0: $ItemDisplayContext$Type, arg1: $PoseStack$Type, arg2: boolean): $BakedModel
 "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type, arg3: $ModelData$Type, arg4: $RenderType$Type): $List<($BakedQuad)>
 "getParticleIcon"(arg0: $ModelData$Type): $TextureAtlasSprite
 "getModelData"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ModelData$Type): $ModelData
}

export namespace $IForgeBakedModel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBakedModel$Type = ($IForgeBakedModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBakedModel_ = $IForgeBakedModel$Type;
}}
declare module "packages/net/minecraftforge/server/command/$TrackCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TrackCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackCommand$Type = ($TrackCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TrackCommand_ = $TrackCommand$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingSwapItemsEvent$Hands" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingSwapItemsEvent, $LivingSwapItemsEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingSwapItemsEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingSwapItemsEvent$Hands extends $LivingSwapItemsEvent {

constructor()
constructor(arg0: $LivingEntity$Type)

public "isCancelable"(): boolean
public "getItemSwappedToMainHand"(): $ItemStack
public "getItemSwappedToOffHand"(): $ItemStack
public "setItemSwappedToMainHand"(arg0: $ItemStack$Type): void
public "setItemSwappedToOffHand"(arg0: $ItemStack$Type): void
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "itemSwappedToMainHand"(): $ItemStack
get "itemSwappedToOffHand"(): $ItemStack
set "itemSwappedToMainHand"(value: $ItemStack$Type)
set "itemSwappedToOffHand"(value: $ItemStack$Type)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingSwapItemsEvent$Hands$Type = ($LivingSwapItemsEvent$Hands);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingSwapItemsEvent$Hands_ = $LivingSwapItemsEvent$Hands$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$PerformanceInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PerformanceInfo {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerformanceInfo$Type = ($PerformanceInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PerformanceInfo_ = $PerformanceInfo$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingSwapItemsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingSwapItemsEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingSwapItemsEvent$Type = ($LivingSwapItemsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingSwapItemsEvent_ = $LivingSwapItemsEvent$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeModelBaker" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $IForgeModelBaker {

 "getModelTextureGetter"(): $Function<($Material), ($TextureAtlasSprite)>
 "bake"(arg0: $ResourceLocation$Type, arg1: $ModelState$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>): $BakedModel
}

export namespace $IForgeModelBaker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeModelBaker$Type = ($IForgeModelBaker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeModelBaker_ = $IForgeModelBaker$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/loaders/$DynamicFluidContainerModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $DynamicFluidContainerModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $DynamicFluidContainerModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "flipGas"(arg0: boolean): $DynamicFluidContainerModelBuilder<(T)>
public "applyFluidLuminosity"(arg0: boolean): $DynamicFluidContainerModelBuilder<(T)>
public "coverIsMask"(arg0: boolean): $DynamicFluidContainerModelBuilder<(T)>
public "applyTint"(arg0: boolean): $DynamicFluidContainerModelBuilder<(T)>
public "fluid"(arg0: $Fluid$Type): $DynamicFluidContainerModelBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicFluidContainerModelBuilder$Type<T> = ($DynamicFluidContainerModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicFluidContainerModelBuilder_<T> = $DynamicFluidContainerModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/items/wrapper/$RecipeWrapper" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $RecipeWrapper implements $Container {

constructor(arg0: $IItemHandlerModifiable$Type)

public "setChanged"(): void
public "getItem"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "clearContent"(): void
public "isEmpty"(): boolean
public "startOpen"(arg0: $Player$Type): void
public "getMaxStackSize"(): integer
public "stillValid"(arg0: $Player$Type): boolean
public "stopOpen"(arg0: $Player$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "kjs$self"(): $Container
public "getBlock"(level: $Level$Type): $BlockContainerJS
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public "countItem"(arg0: $Item$Type): integer
public "canTakeItem"(arg0: $Container$Type, arg1: integer, arg2: $ItemStack$Type): boolean
public "hasAnyMatching"(arg0: $Predicate$Type<($ItemStack$Type)>): boolean
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public "isMutable"(): boolean
public "hasAnyOf"(arg0: $Set$Type<($Item$Type)>): boolean
public "setChanged"(): void
public "asContainer"(): $Container
public "getHeight"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getWidth"(): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "clear"(): void
public static "tryClear"(arg0: any): void
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "containerSize"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeWrapper$Type = ($RecipeWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeWrapper_ = $RecipeWrapper$Type;
}}
declare module "packages/net/minecraftforge/common/$SoundAction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SoundAction {


public "name"(): string
public static "get"(arg0: string): $SoundAction
public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundAction$Type = ($SoundAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundAction_ = $SoundAction$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$ModConfig$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModConfig$Type extends $Enum<($ModConfig$Type)> {
static readonly "COMMON": $ModConfig$Type
static readonly "CLIENT": $ModConfig$Type
static readonly "SERVER": $ModConfig$Type


public static "values"(): ($ModConfig$Type)[]
public static "valueOf"(arg0: string): $ModConfig$Type
public "extension"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModConfig$Type$Type = (("server") | ("common") | ("client")) | ($ModConfig$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModConfig$Type_ = $ModConfig$Type$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingMakeBrainEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$BrainBuilder, $BrainBuilder$Type} from "packages/net/minecraftforge/common/util/$BrainBuilder"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingMakeBrainEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $BrainBuilder$Type<(any)>)

public "getTypedBrainBuilder"<E extends $LivingEntity>(arg0: E): $BrainBuilder<(E)>
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingMakeBrainEvent$Type = ($LivingMakeBrainEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingMakeBrainEvent_ = $LivingMakeBrainEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgePackResources" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PackResources, $PackResources$Type} from "packages/net/minecraft/server/packs/$PackResources"

export interface $IForgePackResources {

 "isHidden"(): boolean
 "getChildren"(): $Collection<($PackResources)>
}

export namespace $IForgePackResources {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgePackResources$Type = ($IForgePackResources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgePackResources_ = $IForgePackResources$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingBreatheEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingBreatheEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: boolean)
/**
 * 
 * @deprecated
 */
constructor(arg0: $LivingEntity$Type, arg1: boolean, arg2: integer, arg3: integer)

public "setConsumeAirAmount"(arg0: integer): void
public "getConsumeAirAmount"(): integer
public "canRefillAir"(): boolean
public "canBreathe"(): boolean
public "getRefillAirAmount"(): integer
public "setRefillAirAmount"(arg0: integer): void
public "setCanRefillAir"(arg0: boolean): void
public "setCanBreathe"(arg0: boolean): void
public "getListenerList"(): $ListenerList
set "consumeAirAmount"(value: integer)
get "consumeAirAmount"(): integer
get "refillAirAmount"(): integer
set "refillAirAmount"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingBreatheEvent$Type = ($LivingBreatheEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingBreatheEvent_ = $LivingBreatheEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonReleased$Post" {
import {$ScreenEvent$MouseButtonReleased, $ScreenEvent$MouseButtonReleased$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonReleased"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonReleased$Post extends $ScreenEvent$MouseButtonReleased {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: boolean)

public "wasHandled"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonReleased$Post$Type = ($ScreenEvent$MouseButtonReleased$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonReleased$Post_ = $ScreenEvent$MouseButtonReleased$Post$Type;
}}
declare module "packages/net/minecraftforge/event/$DifficultyChangeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Difficulty, $Difficulty$Type} from "packages/net/minecraft/world/$Difficulty"

export class $DifficultyChangeEvent extends $Event {

constructor()
constructor(arg0: $Difficulty$Type, arg1: $Difficulty$Type)

public "isCancelable"(): boolean
public "getDifficulty"(): $Difficulty
public "getOldDifficulty"(): $Difficulty
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "difficulty"(): $Difficulty
get "oldDifficulty"(): $Difficulty
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DifficultyChangeEvent$Type = ($DifficultyChangeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DifficultyChangeEvent_ = $DifficultyChangeEvent$Type;
}}
declare module "packages/net/minecraftforge/fluids/$ForgeFlowingFluid" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$FlowingFluid, $FlowingFluid$Type} from "packages/net/minecraft/world/level/material/$FlowingFluid"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"

export class $ForgeFlowingFluid extends $FlowingFluid {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>


public "getFluidType"(): $FluidType
public "getTickDelay"(arg0: $LevelReader$Type): integer
public "getBucket"(): $Item
public "getPickupSound"(): $Optional<($SoundEvent)>
public "isSame"(arg0: $Fluid$Type): boolean
public "canConvertToSource"(arg0: $FluidState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
public "getFlowing"(): $Fluid
public "getSource"(): $Fluid
get "fluidType"(): $FluidType
get "bucket"(): $Item
get "pickupSound"(): $Optional<($SoundEvent)>
get "flowing"(): $Fluid
get "source"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFlowingFluid$Type = ($ForgeFlowingFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFlowingFluid_ = $ForgeFlowingFluid$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$ModListWidget$ModEntry" {
import {$ObjectSelectionList$Entry, $ObjectSelectionList$Entry$Type} from "packages/net/minecraft/client/gui/components/$ObjectSelectionList$Entry"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ModListWidget$ModEntry extends $ObjectSelectionList$Entry<($ModListWidget$ModEntry)> {


public "getInfo"(): $IModInfo
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: boolean, arg9: float): void
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "getNarration"(): $Component
get "info"(): $IModInfo
get "narration"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModListWidget$ModEntry$Type = ($ModListWidget$ModEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModListWidget$ModEntry_ = $ModListWidget$ModEntry$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$ArrowLooseEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ArrowLooseEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $Level$Type, arg3: integer, arg4: boolean)

public "getLevel"(): $Level
public "isCancelable"(): boolean
public "hasAmmo"(): boolean
public "getCharge"(): integer
public "setCharge"(arg0: integer): void
public "getBow"(): $ItemStack
public "getListenerList"(): $ListenerList
get "level"(): $Level
get "cancelable"(): boolean
get "charge"(): integer
set "charge"(value: integer)
get "bow"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrowLooseEvent$Type = ($ArrowLooseEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrowLooseEvent_ = $ArrowLooseEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyInput" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$KeyInput extends $ScreenEvent {

constructor()

public "getModifiers"(): integer
public "getKeyCode"(): integer
public "getScanCode"(): integer
public "getListenerList"(): $ListenerList
get "modifiers"(): integer
get "keyCode"(): integer
get "scanCode"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyInput$Type = ($ScreenEvent$KeyInput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyInput_ = $ScreenEvent$KeyInput$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$DifferenceIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $DifferenceIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public static "of"(arg0: $Ingredient$Type, arg1: $Ingredient$Type): $DifferenceIngredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getStackingIds"(): $IntList
public "isEmpty"(): boolean
public "getSerializer"(): $IIngredientSerializer<($DifferenceIngredient)>
public "canBeUsedForMatching"(): boolean
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "stackingIds"(): $IntList
get "empty"(): boolean
get "serializer"(): $IIngredientSerializer<($DifferenceIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DifferenceIngredient$Type = ($DifferenceIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DifferenceIngredient_ = $DifferenceIngredient$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/$ImmediateWindowProvider" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ModuleLayer, $ModuleLayer$Type} from "packages/java/lang/$ModuleLayer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ImmediateWindowProvider {

 "name"(): string
 "initialize"(arg0: (string)[]): $Runnable
 "updateModuleReads"(arg0: $ModuleLayer$Type): void
 "periodicTick"(): void
 "getGLVersion"(): string
 "loadingOverlay"<T>(arg0: $Supplier$Type<(any)>, arg1: $Supplier$Type<(any)>, arg2: $Consumer$Type<($Optional$Type<($Throwable$Type)>)>, arg3: boolean): $Supplier<(T)>
 "positionWindow"(arg0: $Optional$Type<(any)>, arg1: $IntConsumer$Type, arg2: $IntConsumer$Type, arg3: $IntConsumer$Type, arg4: $IntConsumer$Type): boolean
 "updateFramebufferSize"(arg0: $IntConsumer$Type, arg1: $IntConsumer$Type): void
 "setupMinecraftWindow"(arg0: $IntSupplier$Type, arg1: $IntSupplier$Type, arg2: $Supplier$Type<(string)>, arg3: $LongSupplier$Type): long
}

export namespace $ImmediateWindowProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImmediateWindowProvider$Type = ($ImmediateWindowProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImmediateWindowProvider_ = $ImmediateWindowProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event$Result, $Event$Result$Type} from "packages/net/minecraftforge/eventbus/api/$Event$Result"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PlayerInteractEvent$LeftClickBlock$Action, $PlayerInteractEvent$LeftClickBlock$Action$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickBlock$Action"

export class $PlayerInteractEvent$LeftClickBlock extends $PlayerInteractEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $PlayerInteractEvent$LeftClickBlock$Action$Type)
/**
 * 
 * @deprecated
 */
constructor(arg0: $Player$Type, arg1: $BlockPos$Type, arg2: $Direction$Type)

public "setCanceled"(arg0: boolean): void
public "isCancelable"(): boolean
public "getAction"(): $PlayerInteractEvent$LeftClickBlock$Action
public "setUseItem"(arg0: $Event$Result$Type): void
public "setUseBlock"(arg0: $Event$Result$Type): void
public "getUseItem"(): $Event$Result
public "getUseBlock"(): $Event$Result
public "getListenerList"(): $ListenerList
set "canceled"(value: boolean)
get "cancelable"(): boolean
get "action"(): $PlayerInteractEvent$LeftClickBlock$Action
set "useItem"(value: $Event$Result$Type)
set "useBlock"(value: $Event$Result$Type)
get "useItem"(): $Event$Result
get "useBlock"(): $Event$Result
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$LeftClickBlock$Type = ($PlayerInteractEvent$LeftClickBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$LeftClickBlock_ = $PlayerInteractEvent$LeftClickBlock$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$IConfigurable" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export interface $IConfigurable {

 "getConfigElement"<T>(...arg0: (string)[]): $Optional<(T)>
 "getConfigList"(...arg0: (string)[]): $List<(any)>
}

export namespace $IConfigurable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConfigurable$Type = ($IConfigurable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConfigurable_ = $IConfigurable$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$IRenderable" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$Unit, $Unit$Type} from "packages/net/minecraft/util/$Unit"
import {$ITextureRenderTypeLookup, $ITextureRenderTypeLookup$Type} from "packages/net/minecraftforge/client/model/renderable/$ITextureRenderTypeLookup"

export interface $IRenderable<T> {

 "withContext"(arg0: T): $IRenderable<($Unit)>
 "render"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: $ITextureRenderTypeLookup$Type, arg3: integer, arg4: integer, arg5: float, arg6: T): void

(arg0: T): $IRenderable<($Unit)>
}

export namespace $IRenderable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRenderable$Type<T> = ($IRenderable<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRenderable_<T> = $IRenderable$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent$ImpactResult" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ProjectileImpactEvent$ImpactResult extends $Enum<($ProjectileImpactEvent$ImpactResult)> {
static readonly "DEFAULT": $ProjectileImpactEvent$ImpactResult
static readonly "SKIP_ENTITY": $ProjectileImpactEvent$ImpactResult
static readonly "STOP_AT_CURRENT": $ProjectileImpactEvent$ImpactResult
static readonly "STOP_AT_CURRENT_NO_DAMAGE": $ProjectileImpactEvent$ImpactResult


public static "values"(): ($ProjectileImpactEvent$ImpactResult)[]
public static "valueOf"(arg0: string): $ProjectileImpactEvent$ImpactResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProjectileImpactEvent$ImpactResult$Type = (("default") | ("skip_entity") | ("stop_at_current") | ("stop_at_current_no_damage")) | ($ProjectileImpactEvent$ImpactResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProjectileImpactEvent$ImpactResult_ = $ProjectileImpactEvent$ImpactResult$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonPressed$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$MouseButtonPressed, $ScreenEvent$MouseButtonPressed$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonPressed"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonPressed$Post extends $ScreenEvent$MouseButtonPressed {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: boolean)

public "wasHandled"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonPressed$Post$Type = ($ScreenEvent$MouseButtonPressed$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonPressed$Post_ = $ScreenEvent$MouseButtonPressed$Post$Type;
}}
declare module "packages/net/minecraftforge/network/$LoginWrapper" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $LoginWrapper {
static readonly "WRAPPER": $ResourceLocation


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoginWrapper$Type = ($LoginWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoginWrapper_ = $LoginWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$RenderInventoryMobEffects" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$RenderInventoryMobEffects extends $ScreenEvent {

constructor()
constructor(arg0: $Screen$Type, arg1: integer, arg2: boolean, arg3: integer)

public "isCompact"(): boolean
public "isCancelable"(): boolean
public "addHorizontalOffset"(arg0: integer): void
public "setCompact"(arg0: boolean): void
public "getAvailableSpace"(): integer
public "getHorizontalOffset"(): integer
public "getListenerList"(): $ListenerList
public "setHorizontalOffset"(arg0: integer): void
get "compact"(): boolean
get "cancelable"(): boolean
set "compact"(value: boolean)
get "availableSpace"(): integer
get "horizontalOffset"(): integer
get "listenerList"(): $ListenerList
set "horizontalOffset"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$RenderInventoryMobEffects$Type = ($ScreenEvent$RenderInventoryMobEffects);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$RenderInventoryMobEffects_ = $ScreenEvent$RenderInventoryMobEffects$Type;
}}
declare module "packages/net/minecraftforge/common/$BiomeManager" {
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BiomeManager$BiomeEntry, $BiomeManager$BiomeEntry$Type} from "packages/net/minecraftforge/common/$BiomeManager$BiomeEntry"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BiomeManager$BiomeType, $BiomeManager$BiomeType$Type} from "packages/net/minecraftforge/common/$BiomeManager$BiomeType"

export class $BiomeManager {

constructor()

public static "getBiomes"(arg0: $BiomeManager$BiomeType$Type): $ImmutableList<($BiomeManager$BiomeEntry)>
public static "addBiome"(arg0: $BiomeManager$BiomeType$Type, arg1: $BiomeManager$BiomeEntry$Type): boolean
public static "getAdditionalOverworldBiomes"(): $List<($ResourceKey<($Biome)>)>
public static "addAdditionalOverworldBiomes"(arg0: $ResourceKey$Type<($Biome$Type)>): void
public static "isTypeListModded"(arg0: $BiomeManager$BiomeType$Type): boolean
public static "removeBiome"(arg0: $BiomeManager$BiomeType$Type, arg1: $BiomeManager$BiomeEntry$Type): boolean
get "additionalOverworldBiomes"(): $List<($ResourceKey<($Biome)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$Type = ($BiomeManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeManager_ = $BiomeManager$Type;
}}
declare module "packages/net/minecraftforge/common/data/$GlobalLootModifierProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$IGlobalLootModifier, $IGlobalLootModifier$Type} from "packages/net/minecraftforge/common/loot/$IGlobalLootModifier"

export class $GlobalLootModifierProvider implements $DataProvider {

constructor(arg0: $PackOutput$Type, arg1: string)

public "add"<T extends $IGlobalLootModifier>(arg0: string, arg1: T): void
public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalLootModifierProvider$Type = ($GlobalLootModifierProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlobalLootModifierProvider_ = $GlobalLootModifierProvider$Type;
}}
declare module "packages/net/minecraftforge/logging/$PacketDump" {
import {$ByteBuf, $ByteBuf$Type} from "packages/io/netty/buffer/$ByteBuf"

export class $PacketDump {

constructor()

public static "getContentDump"(arg0: $ByteBuf$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketDump$Type = ($PacketDump);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketDump_ = $PacketDump$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/$AccessTransformer$FinalState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $AccessTransformer$FinalState extends $Enum<($AccessTransformer$FinalState)> {
static readonly "LEAVE": $AccessTransformer$FinalState
static readonly "MAKEFINAL": $AccessTransformer$FinalState
static readonly "REMOVEFINAL": $AccessTransformer$FinalState
static readonly "CONFLICT": $AccessTransformer$FinalState


public static "values"(): ($AccessTransformer$FinalState)[]
public static "valueOf"(arg0: string): $AccessTransformer$FinalState
public "mergeWith"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccessTransformer$FinalState$Type = (("makefinal") | ("leave") | ("removefinal") | ("conflict")) | ($AccessTransformer$FinalState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AccessTransformer$FinalState_ = $AccessTransformer$FinalState$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$ForgeSlider" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractSliderButton, $AbstractSliderButton$Type} from "packages/net/minecraft/client/gui/components/$AbstractSliderButton"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ForgeSlider extends $AbstractSliderButton {
static readonly "SLIDER_LOCATION": $ResourceLocation
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Component$Type, arg5: $Component$Type, arg6: double, arg7: double, arg8: double, arg9: double, arg10: integer, arg11: boolean)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Component$Type, arg5: $Component$Type, arg6: double, arg7: double, arg8: double, arg9: boolean)

public "getValue"(): double
public "getValueString"(): string
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "renderWidget"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "onClick"(arg0: double, arg1: double): void
public "m_93611_"(arg0: double): void
public "getValueInt"(): integer
public "getValueLong"(): long
get "value"(): double
get "valueString"(): string
get "valueInt"(): integer
get "valueLong"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSlider$Type = ($ForgeSlider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSlider_ = $ForgeSlider$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$IModInfo" {
import {$VersionRange, $VersionRange$Type} from "packages/org/apache/maven/artifact/versioning/$VersionRange"
import {$IConfigurable, $IConfigurable$Type} from "packages/net/minecraftforge/forgespi/language/$IConfigurable"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IModInfo {

 "getDisplayName"(): string
 "getVersion"(): $ArtifactVersion
 "getDescription"(): string
 "getConfig"(): $IConfigurable
 "getNamespace"(): string
 "getModId"(): string
 "getForgeFeatures"(): $List<(any)>
 "getUpdateURL"(): $Optional<($URL)>
 "getDependencies"(): $List<(any)>
 "getOwningFile"(): $IModFileInfo
 "getModProperties"(): $Map<(string), (any)>
 "getLogoBlur"(): boolean
 "getLogoFile"(): $Optional<(string)>
 "getModURL"(): $Optional<($URL)>
}

export namespace $IModInfo {
const UNBOUNDED: $VersionRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModInfo$Type = ($IModInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModInfo_ = $IModInfo$Type;
}}
declare module "packages/net/minecraftforge/event/$ModMismatchEvent$MismatchResolutionResult" {
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ModMismatchEvent$MismatchedVersionInfo, $ModMismatchEvent$MismatchedVersionInfo$Type} from "packages/net/minecraftforge/event/$ModMismatchEvent$MismatchedVersionInfo"

export class $ModMismatchEvent$MismatchResolutionResult extends $Record {

constructor(modid: string, versionDifference: $ModMismatchEvent$MismatchedVersionInfo$Type, resolver: $ModContainer$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "resolver"(): $ModContainer
public "modid"(): string
public "versionDifference"(): $ModMismatchEvent$MismatchedVersionInfo
public "wasSelfResolved"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModMismatchEvent$MismatchResolutionResult$Type = ($ModMismatchEvent$MismatchResolutionResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModMismatchEvent$MismatchResolutionResult_ = $ModMismatchEvent$MismatchResolutionResult$Type;
}}
declare module "packages/net/minecraftforge/energy/$EnergyStorage" {
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$IEnergyStorage, $IEnergyStorage$Type} from "packages/net/minecraftforge/energy/$IEnergyStorage"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"

export class $EnergyStorage implements $IEnergyStorage, $INBTSerializable<($Tag)> {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer)
constructor(arg0: integer)

public "getEnergyStored"(): integer
public "getMaxEnergyStored"(): integer
public "canExtract"(): boolean
public "receiveEnergy"(arg0: integer, arg1: boolean): integer
public "canReceive"(): boolean
public "extractEnergy"(arg0: integer, arg1: boolean): integer
public "deserializeNBT"(arg0: $Tag$Type): void
public "serializeNBT"(): $Tag
get "energyStored"(): integer
get "maxEnergyStored"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyStorage$Type = ($EnergyStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyStorage_ = $EnergyStorage$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$FluidPlaceBlockEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent$FluidPlaceBlockEvent extends $BlockEvent {

constructor()
constructor(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type)

public "isCancelable"(): boolean
public "setNewState"(arg0: $BlockState$Type): void
public "getLiquidPos"(): $BlockPos
public "getNewState"(): $BlockState
public "getOriginalState"(): $BlockState
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
set "newState"(value: $BlockState$Type)
get "liquidPos"(): $BlockPos
get "newState"(): $BlockState
get "originalState"(): $BlockState
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$FluidPlaceBlockEvent$Type = ($BlockEvent$FluidPlaceBlockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$FluidPlaceBlockEvent_ = $BlockEvent$FluidPlaceBlockEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/$ForgeItemModelShaper" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemModelShaper, $ItemModelShaper$Type} from "packages/net/minecraft/client/renderer/$ItemModelShaper"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ModelResourceLocation, $ModelResourceLocation$Type} from "packages/net/minecraft/client/resources/model/$ModelResourceLocation"
import {$ModelManager, $ModelManager$Type} from "packages/net/minecraft/client/resources/model/$ModelManager"

export class $ForgeItemModelShaper extends $ItemModelShaper {
readonly "shapes": $Int2ObjectMap<($ModelResourceLocation)>

constructor(arg0: $ModelManager$Type)

public "getLocation"(arg0: $ItemStack$Type): $ModelResourceLocation
public "getItemModel"(arg0: $Item$Type): $BakedModel
public "rebuildCache"(): void
public "register"(arg0: $Item$Type, arg1: $ModelResourceLocation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeItemModelShaper$Type = ($ForgeItemModelShaper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeItemModelShaper_ = $ForgeItemModelShaper$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ITagManager, $ITagManager$Type} from "packages/net/minecraftforge/registries/tags/$ITagManager"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $IForgeRegistry<V> extends $Iterable<(V)> {

 "getValue"(arg0: $ResourceLocation$Type): V
 "isEmpty"(): boolean
 "getKey"(arg0: V): $ResourceLocation
 "register"(arg0: $ResourceLocation$Type, arg1: V): void
 "register"(arg0: string, arg1: V): void
 "containsKey"(arg0: $ResourceLocation$Type): boolean
 "containsValue"(arg0: V): boolean
 "getEntries"(): $Set<($Map$Entry<($ResourceKey<(V)>), (V)>)>
 "getKeys"(): $Set<($ResourceLocation)>
 "tags"(): $ITagManager<(V)>
 "getDelegate"(arg0: V): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceLocation$Type): $Optional<($Holder$Reference<(V)>)>
 "getResourceKey"(arg0: V): $Optional<($ResourceKey<(V)>)>
 "getCodec"(): $Codec<(V)>
 "getSlaveMap"<T>(arg0: $ResourceLocation$Type, arg1: $Class$Type<(T)>): T
 "getRegistryKey"(): $ResourceKey<($Registry<(V)>)>
 "getRegistryName"(): $ResourceLocation
 "getDelegateOrThrow"(arg0: $ResourceKey$Type<(V)>): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: $ResourceLocation$Type): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: V): $Holder$Reference<(V)>
 "getHolder"(arg0: $ResourceLocation$Type): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: V): $Optional<($Holder<(V)>)>
 "getDefaultKey"(): $ResourceLocation
 "getValues"(): $Collection<(V)>
 "iterator"(): $Iterator<(V)>
 "spliterator"(): $Spliterator<(V)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $IForgeRegistry {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$Type<V> = ($IForgeRegistry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry_<V> = $IForgeRegistry$Type<(V)>;
}}
declare module "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$FluidInteraction" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"

export interface $FluidInteractionRegistry$FluidInteraction {

 "interact"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type): void

(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type): void
}

export namespace $FluidInteractionRegistry$FluidInteraction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInteractionRegistry$FluidInteraction$Type = ($FluidInteractionRegistry$FluidInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInteractionRegistry$FluidInteraction_ = $FluidInteractionRegistry$FluidInteraction$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBlockGetter" {
import {$ModelDataManager, $ModelDataManager$Type} from "packages/net/minecraftforge/client/model/data/$ModelDataManager"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IForgeBlockGetter {

 "getExistingBlockEntity"(arg0: $BlockPos$Type): $BlockEntity
 "getModelDataManager"(): $ModelDataManager
}

export namespace $IForgeBlockGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBlockGetter$Type = ($IForgeBlockGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBlockGetter_ = $IForgeBlockGetter$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/common/$IClientMobEffectExtensions" {
import {$Gui, $Gui$Type} from "packages/net/minecraft/client/gui/$Gui"
import {$EffectRenderingInventoryScreen, $EffectRenderingInventoryScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$EffectRenderingInventoryScreen"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export interface $IClientMobEffectExtensions {

 "renderGuiIcon"(arg0: $MobEffectInstance$Type, arg1: $Gui$Type, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: float, arg6: float): boolean
 "isVisibleInGui"(arg0: $MobEffectInstance$Type): boolean
 "isVisibleInInventory"(arg0: $MobEffectInstance$Type): boolean
 "renderInventoryText"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
 "renderInventoryIcon"(arg0: $MobEffectInstance$Type, arg1: $EffectRenderingInventoryScreen$Type<(any)>, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer): boolean
}

export namespace $IClientMobEffectExtensions {
const DEFAULT: $IClientMobEffectExtensions
function of(arg0: $MobEffectInstance$Type): $IClientMobEffectExtensions
function of(arg0: $MobEffect$Type): $IClientMobEffectExtensions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IClientMobEffectExtensions$Type = ($IClientMobEffectExtensions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IClientMobEffectExtensions_ = $IClientMobEffectExtensions$Type;
}}
declare module "packages/net/minecraftforge/data/loading/$DatagenModLoader" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$File, $File$Type} from "packages/java/io/$File"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $DatagenModLoader {

constructor()

public static "begin"(arg0: $Set$Type<(string)>, arg1: $Path$Type, arg2: $Collection$Type<($Path$Type)>, arg3: $Collection$Type<($Path$Type)>, arg4: $Set$Type<(string)>, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean, arg10: boolean, arg11: string, arg12: $File$Type): void
public static "isRunningDataGen"(): boolean
get "runningDataGen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DatagenModLoader$Type = ($DatagenModLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DatagenModLoader_ = $DatagenModLoader$Type;
}}
declare module "packages/net/minecraftforge/network/$MCRegisterPacketHandler$ChannelList" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$NetworkEvent$RegistrationChangeType, $NetworkEvent$RegistrationChangeType$Type} from "packages/net/minecraftforge/network/$NetworkEvent$RegistrationChangeType"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $MCRegisterPacketHandler$ChannelList {

constructor()

public "updateFrom"(arg0: $Supplier$Type<($NetworkEvent$Context$Type)>, arg1: $FriendlyByteBuf$Type, arg2: $NetworkEvent$RegistrationChangeType$Type): void
public "getRemoteLocations"(): $Set<($ResourceLocation)>
get "remoteLocations"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MCRegisterPacketHandler$ChannelList$Type = ($MCRegisterPacketHandler$ChannelList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MCRegisterPacketHandler$ChannelList_ = $MCRegisterPacketHandler$ChannelList$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$StandaloneGeometryBakingContext" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$StandaloneGeometryBakingContext$Builder, $StandaloneGeometryBakingContext$Builder$Type} from "packages/net/minecraftforge/client/model/geometry/$StandaloneGeometryBakingContext$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StandaloneGeometryBakingContext implements $IGeometryBakingContext {
static readonly "LOCATION": $ResourceLocation
static readonly "INSTANCE": $StandaloneGeometryBakingContext


public static "builder"(): $StandaloneGeometryBakingContext$Builder
public static "builder"(arg0: $IGeometryBakingContext$Type): $StandaloneGeometryBakingContext$Builder
public static "create"(arg0: $ResourceLocation$Type): $StandaloneGeometryBakingContext
public static "create"(arg0: $ResourceLocation$Type, arg1: $Map$Type<(string), ($ResourceLocation$Type)>): $StandaloneGeometryBakingContext
public static "create"(arg0: $Map$Type<(string), ($ResourceLocation$Type)>): $StandaloneGeometryBakingContext
public "getTransforms"(): $ItemTransforms
public "useAmbientOcclusion"(): boolean
public "isGui3d"(): boolean
public "useBlockLight"(): boolean
public "getMaterial"(arg0: string): $Material
public "getRootTransform"(): $Transformation
public "getModelName"(): string
public "hasMaterial"(arg0: string): boolean
public "getRenderTypeHint"(): $ResourceLocation
public "isComponentVisible"(arg0: string, arg1: boolean): boolean
public "getRenderType"(arg0: $ResourceLocation$Type): $RenderTypeGroup
get "transforms"(): $ItemTransforms
get "gui3d"(): boolean
get "rootTransform"(): $Transformation
get "modelName"(): string
get "renderTypeHint"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandaloneGeometryBakingContext$Type = ($StandaloneGeometryBakingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StandaloneGeometryBakingContext_ = $StandaloneGeometryBakingContext$Type;
}}
declare module "packages/net/minecraftforge/common/command/$IEntitySelectorType" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$EntitySelectorParser, $EntitySelectorParser$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelectorParser"
import {$EntitySelector, $EntitySelector$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelector"

export interface $IEntitySelectorType {

 "build"(arg0: $EntitySelectorParser$Type): $EntitySelector
 "getSuggestionTooltip"(): $Component
}

export namespace $IEntitySelectorType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEntitySelectorType$Type = ($IEntitySelectorType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEntitySelectorType_ = $IEntitySelectorType$Type;
}}
declare module "packages/net/minecraftforge/client/settings/$KeyConflictContext" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IKeyConflictContext, $IKeyConflictContext$Type} from "packages/net/minecraftforge/client/settings/$IKeyConflictContext"

export class $KeyConflictContext extends $Enum<($KeyConflictContext)> implements $IKeyConflictContext {
static readonly "UNIVERSAL": $KeyConflictContext
static readonly "GUI": $KeyConflictContext
static readonly "IN_GAME": $KeyConflictContext


public static "values"(): ($KeyConflictContext)[]
public static "valueOf"(arg0: string): $KeyConflictContext
public "isActive"(): boolean
public "conflicts"(arg0: $IKeyConflictContext$Type): boolean
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyConflictContext$Type = (("in_game") | ("gui") | ("universal")) | ($KeyConflictContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyConflictContext_ = $KeyConflictContext$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeRawTagBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$TagEntry, $TagEntry$Type} from "packages/net/minecraft/tags/$TagEntry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagBuilder, $TagBuilder$Type} from "packages/net/minecraft/tags/$TagBuilder"

export interface $IForgeRawTagBuilder {

 "remove"(arg0: $TagEntry$Type, arg1: string): $TagBuilder
 "removeElement"(arg0: $ResourceLocation$Type, arg1: string): $TagBuilder
 "removeTag"(arg0: $ResourceLocation$Type, arg1: string): $TagBuilder
 "getRawBuilder"(): $TagBuilder
/**
 * 
 * @deprecated
 */
 "serializeTagAdditions"(arg0: $JsonObject$Type): void
}

export namespace $IForgeRawTagBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRawTagBuilder$Type = ($IForgeRawTagBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRawTagBuilder_ = $IForgeRawTagBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeMobEffectInstance" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IForgeMobEffectInstance {

 "writeCurativeItems"(arg0: $CompoundTag$Type): void
 "setCurativeItems"(arg0: $List$Type<($ItemStack$Type)>): void
 "addCurativeItem"(arg0: $ItemStack$Type): void
 "isCurativeItem"(arg0: $ItemStack$Type): boolean
 "getCurativeItems"(): $List<($ItemStack)>
}

export namespace $IForgeMobEffectInstance {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeMobEffectInstance$Type = ($IForgeMobEffectInstance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeMobEffectInstance_ = $IForgeMobEffectInstance$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$IConditionBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export interface $IConditionBuilder {

 "TRUE"(): $ICondition
 "FALSE"(): $ICondition
 "or"(...arg0: ($ICondition$Type)[]): $ICondition
 "and"(...arg0: ($ICondition$Type)[]): $ICondition
 "not"(arg0: $ICondition$Type): $ICondition
 "modLoaded"(arg0: string): $ICondition
 "itemExists"(arg0: string, arg1: string): $ICondition
 "tagEmpty"(arg0: $TagKey$Type<($Item$Type)>): $ICondition
}

export namespace $IConditionBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConditionBuilder$Type = ($IConditionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConditionBuilder_ = $IConditionBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ClientPlayerChangeGameTypeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$PlayerInfo, $PlayerInfo$Type} from "packages/net/minecraft/client/multiplayer/$PlayerInfo"
import {$GameType, $GameType$Type} from "packages/net/minecraft/world/level/$GameType"

export class $ClientPlayerChangeGameTypeEvent extends $Event {

constructor()
constructor(arg0: $PlayerInfo$Type, arg1: $GameType$Type, arg2: $GameType$Type)

public "getInfo"(): $PlayerInfo
public "isCancelable"(): boolean
public "getCurrentGameType"(): $GameType
public "getNewGameType"(): $GameType
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "info"(): $PlayerInfo
get "cancelable"(): boolean
get "currentGameType"(): $GameType
get "newGameType"(): $GameType
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerChangeGameTypeEvent$Type = ($ClientPlayerChangeGameTypeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerChangeGameTypeEvent_ = $ClientPlayerChangeGameTypeEvent$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$RangedWrapper" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $RangedWrapper implements $IItemHandlerModifiable {

constructor(arg0: $IItemHandlerModifiable$Type, arg1: integer, arg2: integer)

public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangedWrapper$Type = ($RangedWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangedWrapper_ = $RangedWrapper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$EntityInteract" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayerInteractEvent$EntityInteract extends $PlayerInteractEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $Entity$Type)

public "getTarget"(): $Entity
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "target"(): $Entity
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$EntityInteract$Type = ($PlayerInteractEvent$EntityInteract);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$EntityInteract_ = $PlayerInteractEvent$EntityInteract$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModLoadingException" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLoadingException extends $RuntimeException {

constructor(arg0: $IModInfo$Type, arg1: $ModLoadingStage$Type, arg2: string, arg3: $Throwable$Type, ...arg4: (any)[])

public "getMessage"(): string
public "getContext"(): (any)[]
public "formatToString"(): string
public "getI18NMessage"(): string
public "getModInfo"(): $IModInfo
public "getCleanMessage"(): string
get "message"(): string
get "context"(): (any)[]
get "i18NMessage"(): string
get "modInfo"(): $IModInfo
get "cleanMessage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadingException$Type = ($ModLoadingException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadingException_ = $ModLoadingException$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$IGeneratedBlockState" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"

export interface $IGeneratedBlockState {

 "toJson"(): $JsonObject

(): $JsonObject
}

export namespace $IGeneratedBlockState {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGeneratedBlockState$Type = ($IGeneratedBlockState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGeneratedBlockState_ = $IGeneratedBlockState$Type;
}}
declare module "packages/net/minecraftforge/forgespi/locating/$IModFile$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IModFile$Type extends $Enum<($IModFile$Type)> {
static readonly "MOD": $IModFile$Type
static readonly "LIBRARY": $IModFile$Type
static readonly "LANGPROVIDER": $IModFile$Type
static readonly "GAMELIBRARY": $IModFile$Type


public static "values"(): ($IModFile$Type)[]
public static "valueOf"(arg0: string): $IModFile$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModFile$Type$Type = (("gamelibrary") | ("mod") | ("library") | ("langprovider")) | ($IModFile$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModFile$Type_ = $IModFile$Type$Type;
}}
declare module "packages/net/minecraftforge/fml/$DeferredWorkQueue" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DeferredWorkQueue {

constructor(arg0: $ModLoadingStage$Type)

public static "lookup"(arg0: $Optional$Type<($ModLoadingStage$Type)>): $Optional<($DeferredWorkQueue)>
public "runTasks"(): void
public "enqueueWork"<T>(arg0: $ModContainer$Type, arg1: $Supplier$Type<(T)>): $CompletableFuture<(T)>
public "enqueueWork"(arg0: $ModContainer$Type, arg1: $Runnable$Type): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeferredWorkQueue$Type = ($DeferredWorkQueue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeferredWorkQueue_ = $DeferredWorkQueue$Type;
}}
declare module "packages/net/minecraftforge/common/loot/$CanToolPerformAction" {
import {$LootContextParam, $LootContextParam$Type} from "packages/net/minecraft/world/level/storage/loot/parameters/$LootContextParam"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ValidationContext, $ValidationContext$Type} from "packages/net/minecraft/world/level/storage/loot/$ValidationContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$LootItemCondition$Builder, $LootItemCondition$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition$Builder"

export class $CanToolPerformAction implements $LootItemCondition {
static readonly "LOOT_CONDITION_TYPE": $LootItemConditionType

constructor(arg0: $ToolAction$Type)

public "test"(arg0: $LootContext$Type): boolean
public "getType"(): $LootItemConditionType
public "getReferencedContextParams"(): $Set<($LootContextParam<(any)>)>
public static "canToolPerformAction"(arg0: $ToolAction$Type): $LootItemCondition$Builder
public "validate"(arg0: $ValidationContext$Type): void
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public "negate"(): $Predicate<($LootContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($LootContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
public "applyLootHandler"(context: $LootContext$Type, loot: $List$Type<($ItemStack$Type)>): boolean
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanToolPerformAction$Type = ($CanToolPerformAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CanToolPerformAction_ = $CanToolPerformAction$Type;
}}
declare module "packages/net/minecraftforge/network/$PacketDistributor$TargetPoint" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $PacketDistributor$TargetPoint {

constructor(arg0: $ServerPlayer$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: $ResourceKey$Type<($Level$Type)>)
constructor(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $ResourceKey$Type<($Level$Type)>)

public static "p"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $ResourceKey$Type<($Level$Type)>): $Supplier<($PacketDistributor$TargetPoint)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketDistributor$TargetPoint$Type = ($PacketDistributor$TargetPoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketDistributor$TargetPoint_ = $PacketDistributor$TargetPoint$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent$PacketDispatcher" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $NetworkEvent$PacketDispatcher {


public "sendPacket"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$PacketDispatcher$Type = ($NetworkEvent$PacketDispatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent$PacketDispatcher_ = $NetworkEvent$PacketDispatcher$Type;
}}
declare module "packages/net/minecraftforge/network/$PacketDistributor" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$PacketDistributor$PacketTarget, $PacketDistributor$PacketTarget$Type} from "packages/net/minecraftforge/network/$PacketDistributor$PacketTarget"
import {$PacketDistributor$TargetPoint, $PacketDistributor$TargetPoint$Type} from "packages/net/minecraftforge/network/$PacketDistributor$TargetPoint"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$LevelChunk, $LevelChunk$Type} from "packages/net/minecraft/world/level/chunk/$LevelChunk"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PacketDistributor<T> {
static readonly "PLAYER": $PacketDistributor<($ServerPlayer)>
static readonly "DIMENSION": $PacketDistributor<($ResourceKey<($Level)>)>
static readonly "NEAR": $PacketDistributor<($PacketDistributor$TargetPoint)>
static readonly "ALL": $PacketDistributor<(void)>
static readonly "SERVER": $PacketDistributor<(void)>
static readonly "TRACKING_ENTITY": $PacketDistributor<($Entity)>
static readonly "TRACKING_ENTITY_AND_SELF": $PacketDistributor<($Entity)>
static readonly "TRACKING_CHUNK": $PacketDistributor<($LevelChunk)>
static readonly "NMLIST": $PacketDistributor<($List<($Connection)>)>

constructor(arg0: $BiFunction$Type<($PacketDistributor$Type<(T)>), ($Supplier$Type<(T)>), ($Consumer$Type<($Packet$Type<(any)>)>)>, arg1: $NetworkDirection$Type)

public "with"(arg0: $Supplier$Type<(T)>): $PacketDistributor$PacketTarget
public "noArg"(): $PacketDistributor$PacketTarget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketDistributor$Type<T> = ($PacketDistributor<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketDistributor_<T> = $PacketDistributor$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/crafting/$IRecipeContainer" {
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ResultContainer, $ResultContainer$Type} from "packages/net/minecraft/world/inventory/$ResultContainer"

export interface $IRecipeContainer {

 "getCraftResult"(): $ResultContainer
 "getCraftMatrix"(): $CraftingContainer
}

export namespace $IRecipeContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeContainer$Type = ($IRecipeContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeContainer_ = $IRecipeContainer$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/moddiscovery/$ModFileInfo" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IConfigurable, $IConfigurable$Type} from "packages/net/minecraftforge/forgespi/language/$IConfigurable"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IModFileInfo$LanguageSpec, $IModFileInfo$LanguageSpec$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo$LanguageSpec"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$ModFile, $ModFile$Type} from "packages/net/minecraftforge/fml/loading/moddiscovery/$ModFile"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModFileInfo implements $IModFileInfo, $IConfigurable {

constructor(arg0: $ModFile$Type, arg1: $IConfigurable$Type, arg2: $Consumer$Type<($IModFileInfo$Type)>, arg3: $List$Type<($IModFileInfo$LanguageSpec$Type)>)

public "moduleName"(): string
public "getCodeSigningFingerprint"(): $Optional<(string)>
public "getMods"(): $List<($IModInfo)>
public "requiredLanguageLoaders"(): $List<($IModFileInfo$LanguageSpec)>
public "versionString"(): string
public "getConfig"(): $IConfigurable
public "getConfigElement"<T>(...arg0: (string)[]): $Optional<(T)>
public "getConfigList"(...arg0: (string)[]): $List<(any)>
public "showAsResourcePack"(): boolean
public "getFileProperties"(): $Map<(string), (any)>
public "usesServices"(): $List<(string)>
public "getLicense"(): string
public "getIssueURL"(): $URL
public "missingLicense"(): boolean
public "getTrustData"(): $Optional<(string)>
get "codeSigningFingerprint"(): $Optional<(string)>
get "mods"(): $List<($IModInfo)>
get "config"(): $IConfigurable
get "fileProperties"(): $Map<(string), (any)>
get "license"(): string
get "issueURL"(): $URL
get "trustData"(): $Optional<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFileInfo$Type = ($ModFileInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFileInfo_ = $ModFileInfo$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$Builder" {
import {$CompositeRenderable, $CompositeRenderable$Type} from "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable"
import {$CompositeRenderable$PartBuilder, $CompositeRenderable$PartBuilder$Type} from "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$PartBuilder"

export class $CompositeRenderable$Builder {


public "get"(): $CompositeRenderable
public "child"(arg0: string): $CompositeRenderable$PartBuilder<($CompositeRenderable$Builder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeRenderable$Builder$Type = ($CompositeRenderable$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeRenderable$Builder_ = $CompositeRenderable$Builder$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/wrappers/$BucketPickupHandlerWrapper" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$BucketPickup, $BucketPickup$Type} from "packages/net/minecraft/world/level/block/$BucketPickup"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BucketPickupHandlerWrapper implements $IFluidHandler {

constructor(arg0: $BucketPickup$Type, arg1: $Level$Type, arg2: $BlockPos$Type)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BucketPickupHandlerWrapper$Type = ($BucketPickupHandlerWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BucketPickupHandlerWrapper_ = $BucketPickupHandlerWrapper$Type;
}}
declare module "packages/net/minecraftforge/common/$WorldWorkerManager$IWorker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WorldWorkerManager$IWorker {

 "doWork"(): boolean
 "hasWork"(): boolean
}

export namespace $WorldWorkerManager$IWorker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldWorkerManager$IWorker$Type = ($WorldWorkerManager$IWorker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldWorkerManager$IWorker_ = $WorldWorkerManager$IWorker$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterClientReloadListenersEvent" {
import {$PreparableReloadListener, $PreparableReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ReloadableResourceManager, $ReloadableResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ReloadableResourceManager"

export class $RegisterClientReloadListenersEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $ReloadableResourceManager$Type)

public "isCancelable"(): boolean
public "registerReloadListener"(arg0: $PreparableReloadListener$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterClientReloadListenersEvent$Type = ($RegisterClientReloadListenersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterClientReloadListenersEvent_ = $RegisterClientReloadListenersEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$CompositeHolderSet" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$IForgeHolderSet$SerializationType, $IForgeHolderSet$SerializationType$Type} from "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$ICustomHolderSet, $ICustomHolderSet$Type} from "packages/net/minecraftforge/registries/holdersets/$ICustomHolderSet"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $CompositeHolderSet<T> implements $ICustomHolderSet<(T)> {

constructor(arg0: $List$Type<($HolderSet$Type<(T)>)>)

public "iterator"(): $Iterator<($Holder<(T)>)>
public "getSet"(): $Set<($Holder<(T)>)>
public "getList"(): $List<($Holder<(T)>)>
public "contains"(arg0: $Holder$Type<(T)>): boolean
public "homogenize"(): $List<($HolderSet<(T)>)>
public "isHomogenous"(): boolean
public "addInvalidationListener"(arg0: $Runnable$Type): void
public "getComponents"(): $List<($HolderSet<(T)>)>
public "stream"(): $Stream<($Holder<(T)>)>
public "canSerializeIn"(arg0: $HolderOwner$Type<(T)>): boolean
public "size"(): integer
public "get"(arg0: integer): $Holder<(T)>
public "unwrapKey"(): $Optional<($TagKey<(T)>)>
public "getRandomElement"(arg0: $RandomSource$Type): $Optional<($Holder<(T)>)>
public "unwrap"(): $Either<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "type"(): $HolderSetType
public "serializationType"(): $IForgeHolderSet$SerializationType
public static "direct"<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
public static "direct"<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
/**
 * 
 * @deprecated
 */
public static "emptyNamed"<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
public "spliterator"(): $Spliterator<($Holder<(T)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Holder<(T)>>;
get "set"(): $Set<($Holder<(T)>)>
get "list"(): $List<($Holder<(T)>)>
get "homogenous"(): boolean
get "components"(): $List<($HolderSet<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeHolderSet$Type<T> = ($CompositeHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeHolderSet_<T> = $CompositeHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/model/lighting/$SmoothQuadLighter" {
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$QuadLighter, $QuadLighter$Type} from "packages/net/minecraftforge/client/model/lighting/$QuadLighter"

export class $SmoothQuadLighter extends $QuadLighter {

constructor(arg0: $BlockColors$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmoothQuadLighter$Type = ($SmoothQuadLighter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmoothQuadLighter_ = $SmoothQuadLighter$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseDragged" {
import {$ScreenEvent$MouseInput, $ScreenEvent$MouseInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseDragged extends $ScreenEvent$MouseInput {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: double, arg5: double)

public "getDragX"(): double
public "getDragY"(): double
public "getMouseButton"(): integer
public "getListenerList"(): $ListenerList
get "dragX"(): double
get "dragY"(): double
get "mouseButton"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseDragged$Type = ($ScreenEvent$MouseDragged);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseDragged_ = $ScreenEvent$MouseDragged$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $IUnbakedGeometry<T extends $IUnbakedGeometry<(T)>> {

 "getConfigurableComponentNames"(): $Set<(string)>
 "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
 "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel

(): $Set<(string)>
}

export namespace $IUnbakedGeometry {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUnbakedGeometry$Type<T> = ($IUnbakedGeometry<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUnbakedGeometry_<T> = $IUnbakedGeometry$Type<(T)>;
}}
declare module "packages/net/minecraftforge/accesstransformer/$Target" {
import {$TargetType, $TargetType$Type} from "packages/net/minecraftforge/accesstransformer/$TargetType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$AccessTransformer$Modifier, $AccessTransformer$Modifier$Type} from "packages/net/minecraftforge/accesstransformer/$AccessTransformer$Modifier"
import {$Type, $Type$Type} from "packages/org/objectweb/asm/$Type"
import {$AccessTransformer$FinalState, $AccessTransformer$FinalState$Type} from "packages/net/minecraftforge/accesstransformer/$AccessTransformer$FinalState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $Target<T> {

constructor(arg0: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "apply"(arg0: T, arg1: $AccessTransformer$Modifier$Type, arg2: $AccessTransformer$FinalState$Type, arg3: $Set$Type<(string)>): void
public "getType"(): $TargetType
public "getClassName"(): string
public "targetName"(): string
public "getASMType"(): $Type
get "type"(): $TargetType
get "className"(): string
get "aSMType"(): $Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Target$Type<T> = ($Target<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Target_<T> = $Target$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fluids/$FluidStack" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $FluidStack {
static readonly "EMPTY": $FluidStack
static readonly "CODEC": $Codec<($FluidStack)>

constructor(arg0: $FluidStack$Type, arg1: integer)
constructor(arg0: $Fluid$Type, arg1: integer, arg2: $CompoundTag$Type)
constructor(arg0: $Fluid$Type, arg1: integer)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "isEmpty"(): boolean
public "copy"(): $FluidStack
public "grow"(arg0: integer): void
public "getDisplayName"(): $Component
public "getTag"(): $CompoundTag
public "setAmount"(arg0: integer): void
public "getAmount"(): integer
public static "loadFluidStackFromNBT"(arg0: $CompoundTag$Type): $FluidStack
public "hasTag"(): boolean
public static "readFromPacket"(arg0: $FriendlyByteBuf$Type): $FluidStack
public "writeToPacket"(arg0: $FriendlyByteBuf$Type): void
public "getTranslationKey"(): string
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "shrink"(arg0: integer): void
public "setTag"(arg0: $CompoundTag$Type): void
public "getFluid"(): $Fluid
public "getOrCreateChildTag"(arg0: string): $CompoundTag
public "isFluidStackIdentical"(arg0: $FluidStack$Type): boolean
public static "areFluidStackTagsEqual"(arg0: $FluidStack$Type, arg1: $FluidStack$Type): boolean
public "getChildTag"(arg0: string): $CompoundTag
public "isFluidEqual"(arg0: $ItemStack$Type): boolean
public "isFluidEqual"(arg0: $FluidStack$Type): boolean
public "getOrCreateTag"(): $CompoundTag
public "getRawFluid"(): $Fluid
public "removeChildTag"(arg0: string): void
public "containsFluid"(arg0: $FluidStack$Type): boolean
get "empty"(): boolean
get "displayName"(): $Component
get "tag"(): $CompoundTag
set "amount"(value: integer)
get "amount"(): integer
get "translationKey"(): string
set "tag"(value: $CompoundTag$Type)
get "fluid"(): $Fluid
get "orCreateTag"(): $CompoundTag
get "rawFluid"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStack$Type = ($FluidStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStack_ = $FluidStack$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$CraftingHelper" {
import {$IConditionSerializer, $IConditionSerializer$Type} from "packages/net/minecraftforge/common/crafting/conditions/$IConditionSerializer"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $CraftingHelper {

constructor()

public static "register"(arg0: $IConditionSerializer$Type<(any)>): $IConditionSerializer<(any)>
public static "register"<T extends $Ingredient>(arg0: $ResourceLocation$Type, arg1: $IIngredientSerializer$Type<(T)>): $IIngredientSerializer<(T)>
public static "write"<T extends $Ingredient>(arg0: $FriendlyByteBuf$Type, arg1: T): void
public static "getID"(arg0: $IIngredientSerializer$Type<(any)>): $ResourceLocation
public static "getItem"(arg0: string, arg1: boolean): $Item
public static "getIngredient"(arg0: $JsonElement$Type, arg1: boolean): $Ingredient
public static "getIngredient"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): $Ingredient
public static "processConditions"(arg0: $JsonObject$Type, arg1: string, arg2: $ICondition$IContext$Type): boolean
public static "processConditions"(arg0: $JsonArray$Type, arg1: $ICondition$IContext$Type): boolean
public static "serialize"<T extends $ICondition>(arg0: T): $JsonObject
public static "serialize"(...arg0: ($ICondition$Type)[]): $JsonArray
public static "getItemStack"(arg0: $JsonObject$Type, arg1: boolean): $ItemStack
public static "getItemStack"(arg0: $JsonObject$Type, arg1: boolean, arg2: boolean): $ItemStack
public static "getCondition"(arg0: $JsonObject$Type): $ICondition
public static "getNBT"(arg0: $JsonElement$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingHelper$Type = ($CraftingHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingHelper_ = $CraftingHelper$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$BlockGeometryBakingContext$VisibilityData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BlockGeometryBakingContext$VisibilityData {

constructor()

public "copyFrom"(arg0: $BlockGeometryBakingContext$VisibilityData$Type): void
public "isVisible"(arg0: string, arg1: boolean): boolean
public "hasCustomVisibility"(arg0: string): boolean
public "setVisibilityState"(arg0: string, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockGeometryBakingContext$VisibilityData$Type = ($BlockGeometryBakingContext$VisibilityData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockGeometryBakingContext$VisibilityData_ = $BlockGeometryBakingContext$VisibilityData$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingVisibilityEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $LivingEvent$LivingVisibilityEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: $Entity$Type, arg2: double)
constructor()

public "getVisibilityModifier"(): double
public "getLookingEntity"(): $Entity
public "modifyVisibility"(arg0: double): void
public "getListenerList"(): $ListenerList
get "visibilityModifier"(): double
get "lookingEntity"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEvent$LivingVisibilityEvent$Type = ($LivingEvent$LivingVisibilityEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEvent$LivingVisibilityEvent_ = $LivingEvent$LivingVisibilityEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$EnderEntity" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EntityTeleportEvent$EnderEntity extends $EntityTeleportEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: double, arg2: double, arg3: double)

public "isCancelable"(): boolean
public "getEntityLiving"(): $LivingEntity
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "entityLiving"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$EnderEntity$Type = ($EntityTeleportEvent$EnderEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent$EnderEntity_ = $EntityTeleportEvent$EnderEntity$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiOverlayEvent$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NamedGuiOverlay, $NamedGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay"
import {$RenderGuiOverlayEvent, $RenderGuiOverlayEvent$Type} from "packages/net/minecraftforge/client/event/$RenderGuiOverlayEvent"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiOverlayEvent$Pre extends $RenderGuiOverlayEvent {

constructor()
constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: $NamedGuiOverlay$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiOverlayEvent$Pre$Type = ($RenderGuiOverlayEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiOverlayEvent$Pre_ = $RenderGuiOverlayEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ModelEvent$RegisterGeometryLoaders" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$ModelEvent, $ModelEvent$Type} from "packages/net/minecraftforge/client/event/$ModelEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModelEvent$RegisterGeometryLoaders extends $ModelEvent implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($IGeometryLoader$Type<(any)>)>)

public "register"(arg0: string, arg1: $IGeometryLoader$Type<(any)>): void
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelEvent$RegisterGeometryLoaders$Type = ($ModelEvent$RegisterGeometryLoaders);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelEvent$RegisterGeometryLoaders_ = $ModelEvent$RegisterGeometryLoaders$Type;
}}
declare module "packages/net/minecraftforge/client/gui/overlay/$VanillaGuiOverlay" {
import {$NamedGuiOverlay, $NamedGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $VanillaGuiOverlay extends $Enum<($VanillaGuiOverlay)> {
static readonly "VIGNETTE": $VanillaGuiOverlay
static readonly "SPYGLASS": $VanillaGuiOverlay
static readonly "HELMET": $VanillaGuiOverlay
static readonly "FROSTBITE": $VanillaGuiOverlay
static readonly "PORTAL": $VanillaGuiOverlay
static readonly "HOTBAR": $VanillaGuiOverlay
static readonly "CROSSHAIR": $VanillaGuiOverlay
static readonly "BOSS_EVENT_PROGRESS": $VanillaGuiOverlay
static readonly "PLAYER_HEALTH": $VanillaGuiOverlay
static readonly "ARMOR_LEVEL": $VanillaGuiOverlay
static readonly "FOOD_LEVEL": $VanillaGuiOverlay
static readonly "AIR_LEVEL": $VanillaGuiOverlay
static readonly "MOUNT_HEALTH": $VanillaGuiOverlay
static readonly "JUMP_BAR": $VanillaGuiOverlay
static readonly "EXPERIENCE_BAR": $VanillaGuiOverlay
static readonly "ITEM_NAME": $VanillaGuiOverlay
static readonly "SLEEP_FADE": $VanillaGuiOverlay
static readonly "POTION_ICONS": $VanillaGuiOverlay
static readonly "DEBUG_TEXT": $VanillaGuiOverlay
static readonly "FPS_GRAPH": $VanillaGuiOverlay
static readonly "RECORD_OVERLAY": $VanillaGuiOverlay
static readonly "TITLE_TEXT": $VanillaGuiOverlay
static readonly "SUBTITLES": $VanillaGuiOverlay
static readonly "SCOREBOARD": $VanillaGuiOverlay
static readonly "CHAT_PANEL": $VanillaGuiOverlay
static readonly "PLAYER_LIST": $VanillaGuiOverlay


public "type"(): $NamedGuiOverlay
public static "values"(): ($VanillaGuiOverlay)[]
public static "valueOf"(arg0: string): $VanillaGuiOverlay
public "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaGuiOverlay$Type = (("air_level") | ("vignette") | ("debug_text") | ("fps_graph") | ("player_list") | ("jump_bar") | ("frostbite") | ("chat_panel") | ("helmet") | ("scoreboard") | ("portal") | ("food_level") | ("subtitles") | ("armor_level") | ("record_overlay") | ("experience_bar") | ("item_name") | ("hotbar") | ("mount_health") | ("crosshair") | ("potion_icons") | ("sleep_fade") | ("player_health") | ("title_text") | ("spyglass") | ("boss_event_progress")) | ($VanillaGuiOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaGuiOverlay_ = $VanillaGuiOverlay$Type;
}}
declare module "packages/net/minecraftforge/gametest/$PrefixGameTestTemplate" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $PrefixGameTestTemplate extends $Annotation {

 "value"(): boolean
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $PrefixGameTestTemplate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrefixGameTestTemplate$Type = ($PrefixGameTestTemplate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PrefixGameTestTemplate_ = $PrefixGameTestTemplate$Type;
}}
declare module "packages/net/minecraftforge/event/$ItemAttributeModifierEvent" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemAttributeModifierEvent extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $EquipmentSlot$Type, arg2: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>)

public "getModifiers"(): $Multimap<($Attribute), ($AttributeModifier)>
public "isCancelable"(): boolean
public "clearModifiers"(): void
public "removeModifier"(arg0: $Attribute$Type, arg1: $AttributeModifier$Type): boolean
public "removeAttribute"(arg0: $Attribute$Type): $Collection<($AttributeModifier)>
public "getItemStack"(): $ItemStack
public "getOriginalModifiers"(): $Multimap<($Attribute), ($AttributeModifier)>
public "getSlotType"(): $EquipmentSlot
public "addModifier"(arg0: $Attribute$Type, arg1: $AttributeModifier$Type): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "modifiers"(): $Multimap<($Attribute), ($AttributeModifier)>
get "cancelable"(): boolean
get "itemStack"(): $ItemStack
get "originalModifiers"(): $Multimap<($Attribute), ($AttributeModifier)>
get "slotType"(): $EquipmentSlot
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAttributeModifierEvent$Type = ($ItemAttributeModifierEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAttributeModifierEvent_ = $ItemAttributeModifierEvent$Type;
}}
declare module "packages/net/minecraftforge/event/server/$ServerStartingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLifecycleEvent, $ServerLifecycleEvent$Type} from "packages/net/minecraftforge/event/server/$ServerLifecycleEvent"

export class $ServerStartingEvent extends $ServerLifecycleEvent {

constructor(arg0: $MinecraftServer$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStartingEvent$Type = ($ServerStartingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStartingEvent_ = $ServerStartingEvent$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$ModListScreen" {
import {$ObjectSelectionList$Entry, $ObjectSelectionList$Entry$Type} from "packages/net/minecraft/client/gui/components/$ObjectSelectionList$Entry"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ModListWidget$ModEntry, $ModListWidget$ModEntry$Type} from "packages/net/minecraftforge/client/gui/widget/$ModListWidget$ModEntry"

export class $ModListScreen extends $Screen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $Screen$Type)

public "buildModList"<T extends $ObjectSelectionList$Entry<(T)>>(arg0: $Consumer$Type<(T)>, arg1: $Function$Type<($IModInfo$Type), (T)>): void
public "onClose"(): void
public "m_7856_"(): void
public "getFontRenderer"(): $Font
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "resize"(arg0: $Minecraft$Type, arg1: integer, arg2: integer): void
public "tick"(): void
public "setSelected"(arg0: $ModListWidget$ModEntry$Type): void
public "getMinecraftInstance"(): $Minecraft
get "fontRenderer"(): $Font
set "selected"(value: $ModListWidget$ModEntry$Type)
get "minecraftInstance"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModListScreen$Type = ($ModListScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModListScreen_ = $ModListScreen$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobEffectEvent$Remove" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$MobEffectEvent, $MobEffectEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobEffectEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $MobEffectEvent$Remove extends $MobEffectEvent {

constructor(arg0: $LivingEntity$Type, arg1: $MobEffect$Type)
constructor(arg0: $LivingEntity$Type, arg1: $MobEffectInstance$Type)
constructor()

public "isCancelable"(): boolean
public "getEffectInstance"(): $MobEffectInstance
public "getEffect"(): $MobEffect
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "effectInstance"(): $MobEffectInstance
get "effect"(): $MobEffect
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectEvent$Remove$Type = ($MobEffectEvent$Remove);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectEvent$Remove_ = $MobEffectEvent$Remove$Type;
}}
declare module "packages/net/minecraftforge/client/$EntitySpectatorShaderManager" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $EntitySpectatorShaderManager {


public static "get"(arg0: $EntityType$Type<(any)>): $ResourceLocation
public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpectatorShaderManager$Type = ($EntitySpectatorShaderManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySpectatorShaderManager_ = $EntitySpectatorShaderManager$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$ScrollPanel" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$AbstractContainerEventHandler, $AbstractContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$AbstractContainerEventHandler"
import {$NarratableEntry$NarrationPriority, $NarratableEntry$NarrationPriority$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry$NarrationPriority"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ScrollController, $ScrollController$Type} from "packages/icyllis/modernui/mc/$ScrollController"
import {$ScrollController$IListener, $ScrollController$IListener$Type} from "packages/icyllis/modernui/mc/$ScrollController$IListener"
import {$NarrationElementOutput, $NarrationElementOutput$Type} from "packages/net/minecraft/client/gui/narration/$NarrationElementOutput"

export class $ScrollPanel extends $AbstractContainerEventHandler implements $Renderable, $NarratableEntry, $ScrollController$IListener {

constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer)
constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer)
constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer)
constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer)
constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer)
constructor(arg0: $Minecraft$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer)

public "children"(): $List<(any)>
public "isMouseOver"(arg0: double, arg1: double): boolean
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
public "mouseReleased"(arg0: double, arg1: double, arg2: integer): boolean
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, scrollY: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, deltaX: double, deltaY: double): boolean
public "onScrollAmountUpdated"(controller: $ScrollController$Type, amount: float): void
public "isActive"(): boolean
public "narrationPriority"(): $NarratableEntry$NarrationPriority
public "updateNarration"(arg0: $NarrationElementOutput$Type): void
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScrollPanel$Type = ($ScrollPanel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScrollPanel_ = $ScrollPanel$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$ClearCallback" {
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"

export interface $IForgeRegistry$ClearCallback<V> {

 "onClear"(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void

(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void
}

export namespace $IForgeRegistry$ClearCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$ClearCallback$Type<V> = ($IForgeRegistry$ClearCallback<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$ClearCallback_<V> = $IForgeRegistry$ClearCallback$Type<(V)>;
}}
declare module "packages/net/minecraftforge/server/command/$DimensionsCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DimensionsCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionsCommand$Type = ($DimensionsCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionsCommand_ = $DimensionsCommand$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$UnbakedGeometryHelper" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$BlockElement, $BlockElement$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockElement"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockElementFace, $BlockElementFace$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockElementFace"
import {$IModelBuilder, $IModelBuilder$Type} from "packages/net/minecraftforge/client/model/$IModelBuilder"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SpriteContents, $SpriteContents$Type} from "packages/net/minecraft/client/renderer/texture/$SpriteContents"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ForgeFaceData, $ForgeFaceData$Type} from "packages/net/minecraftforge/client/model/$ForgeFaceData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$IQuadTransformer, $IQuadTransformer$Type} from "packages/net/minecraftforge/client/model/$IQuadTransformer"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $UnbakedGeometryHelper {

constructor()

public static "bakeElements"(arg0: $List$Type<($BlockElement$Type)>, arg1: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg2: $ModelState$Type, arg3: $ResourceLocation$Type): $List<($BakedQuad)>
public static "bakeElements"(arg0: $IModelBuilder$Type<(any)>, arg1: $List$Type<($BlockElement$Type)>, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ResourceLocation$Type): void
public static "createUnbakedItemElements"(arg0: integer, arg1: $SpriteContents$Type, arg2: $ForgeFaceData$Type): $List<($BlockElement)>
public static "createUnbakedItemElements"(arg0: integer, arg1: $SpriteContents$Type): $List<($BlockElement)>
public static "createUnbakedItemMaskElements"(arg0: integer, arg1: $SpriteContents$Type, arg2: $ForgeFaceData$Type): $List<($BlockElement)>
public static "createUnbakedItemMaskElements"(arg0: integer, arg1: $SpriteContents$Type): $List<($BlockElement)>
public static "applyRootTransform"(arg0: $ModelState$Type, arg1: $Transformation$Type): $IQuadTransformer
public static "bakeElementFace"(arg0: $BlockElement$Type, arg1: $BlockElementFace$Type, arg2: $TextureAtlasSprite$Type, arg3: $Direction$Type, arg4: $ModelState$Type, arg5: $ResourceLocation$Type): $BakedQuad
public static "composeRootTransformIntoModelState"(arg0: $ModelState$Type, arg1: $Transformation$Type): $ModelState
public static "resolveDirtyMaterial"(arg0: string, arg1: $IGeometryBakingContext$Type): $Material
public static "bake"(arg0: $BlockModel$Type, arg1: $ModelBaker$Type, arg2: $BlockModel$Type, arg3: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg4: $ModelState$Type, arg5: $ResourceLocation$Type, arg6: boolean): $BakedModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnbakedGeometryHelper$Type = ($UnbakedGeometryHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnbakedGeometryHelper_ = $UnbakedGeometryHelper$Type;
}}
declare module "packages/net/minecraftforge/common/util/$LazyOptional" {
import {$NonNullFunction, $NonNullFunction$Type} from "packages/net/minecraftforge/common/util/$NonNullFunction"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$NonNullPredicate, $NonNullPredicate$Type} from "packages/net/minecraftforge/common/util/$NonNullPredicate"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/net/minecraftforge/common/util/$NonNullSupplier"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/net/minecraftforge/common/util/$NonNullConsumer"

export class $LazyOptional<T> {


public "cast"<X>(): $LazyOptional<(X)>
public "map"<U>(arg0: $NonNullFunction$Type<(any), (any)>): $Optional<(U)>
public static "of"<T>(arg0: $NonNullSupplier$Type<(T)>): $LazyOptional<(T)>
public "filter"(arg0: $NonNullPredicate$Type<(any)>): $Optional<(T)>
public static "empty"<T>(): $LazyOptional<(T)>
public "resolve"(): $Optional<(T)>
public "isPresent"(): boolean
public "orElse"(arg0: T): T
public "orElseThrow"<X extends $Throwable>(arg0: $NonNullSupplier$Type<(any)>): T
public "ifPresent"(arg0: $NonNullConsumer$Type<(any)>): void
public "orElseGet"(arg0: $NonNullSupplier$Type<(any)>): T
public "invalidate"(): void
public "removeListener"(arg0: $NonNullConsumer$Type<($LazyOptional$Type<(T)>)>): void
public "addListener"(arg0: $NonNullConsumer$Type<($LazyOptional$Type<(T)>)>): void
public "lazyMap"<U>(arg0: $NonNullFunction$Type<(any), (any)>): $LazyOptional<(U)>
get "present"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyOptional$Type<T> = ($LazyOptional<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyOptional_<T> = $LazyOptional$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/util/$TextTable" {
import {$TextTable$Alignment, $TextTable$Alignment$Type} from "packages/net/minecraftforge/common/util/$TextTable$Alignment"
import {$List, $List$Type} from "packages/java/util/$List"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TextTable$Column, $TextTable$Column$Type} from "packages/net/minecraftforge/common/util/$TextTable$Column"

export class $TextTable {

constructor(arg0: $List$Type<($TextTable$Column$Type)>)

public "add"(...arg0: (any)[]): void
public "append"(arg0: $StringBuilder$Type, arg1: string): void
public "clear"(): void
public "build"(arg0: string): string
public static "column"(arg0: string): $TextTable$Column
public static "column"(arg0: string, arg1: $TextTable$Alignment$Type): $TextTable$Column
public "getColumns"(): $List<($TextTable$Column)>
get "columns"(): $List<($TextTable$Column)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextTable$Type = ($TextTable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextTable_ = $TextTable$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/wrappers/$FluidBucketWrapper" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IFluidHandlerItem, $IFluidHandlerItem$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $FluidBucketWrapper implements $IFluidHandlerItem, $ICapabilityProvider {

constructor(arg0: $ItemStack$Type)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "canFillFluidType"(arg0: $FluidStack$Type): boolean
public "getContainer"(): $ItemStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
public "getFluid"(): $FluidStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
get "container"(): $ItemStack
get "tanks"(): integer
get "fluid"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketWrapper$Type = ($FluidBucketWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBucketWrapper_ = $FluidBucketWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RecipesUpdatedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"

export class $RecipesUpdatedEvent extends $Event {

constructor()
constructor(arg0: $RecipeManager$Type)

public "isCancelable"(): boolean
public "getRecipeManager"(): $RecipeManager
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "recipeManager"(): $RecipeManager
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesUpdatedEvent$Type = ($RecipesUpdatedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipesUpdatedEvent_ = $RecipesUpdatedEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$BuildCreativeModeTabContentsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$CreativeModeTab$TabVisibility, $CreativeModeTab$TabVisibility$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$TabVisibility"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeModeTab$ItemDisplayParameters, $CreativeModeTab$ItemDisplayParameters$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$ItemDisplayParameters"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$MutableHashedLinkedMap, $MutableHashedLinkedMap$Type} from "packages/net/minecraftforge/common/util/$MutableHashedLinkedMap"

export class $BuildCreativeModeTabContentsEvent extends $Event implements $IModBusEvent, $CreativeModeTab$Output {

constructor(arg0: $CreativeModeTab$Type, arg1: $ResourceKey$Type<($CreativeModeTab$Type)>, arg2: $CreativeModeTab$ItemDisplayParameters$Type, arg3: $MutableHashedLinkedMap$Type<($ItemStack$Type), ($CreativeModeTab$TabVisibility$Type)>)
constructor()

public "accept"(arg0: $Supplier$Type<(any)>, arg1: $CreativeModeTab$TabVisibility$Type): void
public "accept"(arg0: $Supplier$Type<(any)>): void
public "getParameters"(): $CreativeModeTab$ItemDisplayParameters
public "getEntries"(): $MutableHashedLinkedMap<($ItemStack), ($CreativeModeTab$TabVisibility)>
public "getFlags"(): $FeatureFlagSet
public "isCancelable"(): boolean
public "getTab"(): $CreativeModeTab
public "getTabKey"(): $ResourceKey<($CreativeModeTab)>
public "hasPermissions"(): boolean
public "accept"(arg0: $ItemStack$Type, arg1: $CreativeModeTab$TabVisibility$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "accept"(arg0: $ItemLike$Type, arg1: $CreativeModeTab$TabVisibility$Type): void
public "acceptAll"(arg0: $Collection$Type<($ItemStack$Type)>, arg1: $CreativeModeTab$TabVisibility$Type): void
public "accept"(arg0: $ItemLike$Type): void
public "accept"(arg0: $ItemStack$Type): void
public "acceptAll"(arg0: $Collection$Type<($ItemStack$Type)>): void
get "parameters"(): $CreativeModeTab$ItemDisplayParameters
get "entries"(): $MutableHashedLinkedMap<($ItemStack), ($CreativeModeTab$TabVisibility)>
get "flags"(): $FeatureFlagSet
get "cancelable"(): boolean
get "tab"(): $CreativeModeTab
get "tabKey"(): $ResourceKey<($CreativeModeTab)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildCreativeModeTabContentsEvent$Type = ($BuildCreativeModeTabContentsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuildCreativeModeTabContentsEvent_ = $BuildCreativeModeTabContentsEvent$Type;
}}
declare module "packages/net/minecraftforge/server/permission/handler/$IPermissionHandlerFactory" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$IPermissionHandler, $IPermissionHandler$Type} from "packages/net/minecraftforge/server/permission/handler/$IPermissionHandler"

export interface $IPermissionHandlerFactory {

 "create"(arg0: $Collection$Type<($PermissionNode$Type<(any)>)>): $IPermissionHandler

(arg0: $Collection$Type<($PermissionNode$Type<(any)>)>): $IPermissionHandler
}

export namespace $IPermissionHandlerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPermissionHandlerFactory$Type = ($IPermissionHandlerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPermissionHandlerFactory_ = $IPermissionHandlerFactory$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ViewportEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$GameRenderer, $GameRenderer$Type} from "packages/net/minecraft/client/renderer/$GameRenderer"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"

export class $ViewportEvent extends $Event {

constructor()
constructor(arg0: $GameRenderer$Type, arg1: $Camera$Type, arg2: double)

public "getPartialTick"(): double
public "isCancelable"(): boolean
public "getCamera"(): $Camera
public "getRenderer"(): $GameRenderer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): double
get "cancelable"(): boolean
get "camera"(): $Camera
get "renderer"(): $GameRenderer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewportEvent$Type = ($ViewportEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewportEvent_ = $ViewportEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModLoadingContext" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$IConfigSpec, $IConfigSpec$Type} from "packages/net/minecraftforge/fml/config/$IConfigSpec"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IExtensionPoint$DisplayTest, $IExtensionPoint$DisplayTest$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint$DisplayTest"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IExtensionPoint, $IExtensionPoint$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint"
import {$ModConfig$Type, $ModConfig$Type$Type} from "packages/net/minecraftforge/fml/config/$ModConfig$Type"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLoadingContext {

constructor()

public static "get"(): $ModLoadingContext
public "extension"<T>(): T
public "registerConfig"(arg0: $ModConfig$Type$Type, arg1: $IConfigSpec$Type<(any)>): void
public "registerConfig"(arg0: $ModConfig$Type$Type, arg1: $IConfigSpec$Type<(any)>, arg2: string): void
public "registerExtensionPoint"<T extends ($Record) & ($IExtensionPoint<(T)>)>(arg0: $Class$Type<(any)>, arg1: $Supplier$Type<(T)>): void
public "setActiveContainer"(arg0: $ModContainer$Type): void
public "getActiveContainer"(): $ModContainer
public "registerDisplayTest"(arg0: string, arg1: $BiPredicate$Type<(string), (boolean)>): void
public "registerDisplayTest"(arg0: $IExtensionPoint$DisplayTest$Type): void
public "registerDisplayTest"(arg0: $Supplier$Type<($IExtensionPoint$DisplayTest$Type)>): void
public "registerDisplayTest"(arg0: $Supplier$Type<(string)>, arg1: $BiPredicate$Type<(string), (boolean)>): void
public "getActiveNamespace"(): string
set "activeContainer"(value: $ModContainer$Type)
get "activeContainer"(): $ModContainer
get "activeNamespace"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadingContext$Type = ($ModLoadingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadingContext_ = $ModLoadingContext$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLevelStageEvent$RegisterStageEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderLevelStageEvent$Stage, $RenderLevelStageEvent$Stage$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent$Stage"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $RenderLevelStageEvent$RegisterStageEvent extends $Event implements $IModBusEvent {

constructor()

public "register"(arg0: $ResourceLocation$Type, arg1: $RenderType$Type): $RenderLevelStageEvent$Stage
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLevelStageEvent$RegisterStageEvent$Type = ($RenderLevelStageEvent$RegisterStageEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLevelStageEvent$RegisterStageEvent_ = $RenderLevelStageEvent$RegisterStageEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ICondition$IContext {

 "getTag"<T>(arg0: $TagKey$Type<(T)>): $Collection<($Holder<(T)>)>
 "getAllTags"<T>(arg0: $ResourceKey$Type<(any)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>

(arg0: $TagKey$Type<(T)>): $Collection<($Holder<(T)>)>
}

export namespace $ICondition$IContext {
const EMPTY: $ICondition$IContext
const TAGS_INVALID: $ICondition$IContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICondition$IContext$Type = ($ICondition$IContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICondition$IContext_ = $ICondition$IContext$Type;
}}
declare module "packages/net/minecraftforge/event/brewing/$PotionBrewEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $PotionBrewEvent extends $Event {

constructor()

public "getLength"(): integer
public "getItem"(arg0: integer): $ItemStack
public "isCancelable"(): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "length"(): integer
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBrewEvent$Type = ($PotionBrewEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionBrewEvent_ = $PotionBrewEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$VillagerTradingManager" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $VillagerTradingManager {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTradingManager$Type = ($VillagerTradingManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerTradingManager_ = $VillagerTradingManager$Type;
}}
declare module "packages/net/minecraftforge/versions/forge/$ForgeVersion" {
import {$VersionChecker$Status, $VersionChecker$Status$Type} from "packages/net/minecraftforge/fml/$VersionChecker$Status"

export class $ForgeVersion {
static readonly "MOD_ID": string

constructor()

public static "getTarget"(): string
public static "getVersion"(): string
public static "getStatus"(): $VersionChecker$Status
public static "getSpec"(): string
public static "getGroup"(): string
get "target"(): string
get "version"(): string
get "status"(): $VersionChecker$Status
get "spec"(): string
get "group"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeVersion$Type = ($ForgeVersion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeVersion_ = $ForgeVersion$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$ShulkerItemStackInvWrapper" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $ShulkerItemStackInvWrapper implements $IItemHandlerModifiable, $ICapabilityProvider {


public "getSlots"(): integer
public static "createDefaultProvider"(arg0: $ItemStack$Type): $ICapabilityProvider
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerItemStackInvWrapper$Type = ($ShulkerItemStackInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShulkerItemStackInvWrapper_ = $ShulkerItemStackInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterShadersEvent" {
import {$ResourceProvider, $ResourceProvider$Type} from "packages/net/minecraft/server/packs/resources/$ResourceProvider"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ShaderInstance, $ShaderInstance$Type} from "packages/net/minecraft/client/renderer/$ShaderInstance"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"

export class $RegisterShadersEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $ResourceProvider$Type, arg1: $List$Type<($Pair$Type<($ShaderInstance$Type), ($Consumer$Type<($ShaderInstance$Type)>)>)>)

public "isCancelable"(): boolean
public "getResourceProvider"(): $ResourceProvider
public "registerShader"(arg0: $ShaderInstance$Type, arg1: $Consumer$Type<($ShaderInstance$Type)>): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "resourceProvider"(): $ResourceProvider
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterShadersEvent$Type = ($RegisterShadersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterShadersEvent_ = $RegisterShadersEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $FMLCommonSetupEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FMLCommonSetupEvent$Type = ($FMLCommonSetupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FMLCommonSetupEvent_ = $FMLCommonSetupEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderTooltipEvent$Color" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$RenderTooltipEvent, $RenderTooltipEvent$Type} from "packages/net/minecraftforge/client/event/$RenderTooltipEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"

export class $RenderTooltipEvent$Color extends $RenderTooltipEvent {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: $Font$Type, arg5: integer, arg6: integer, arg7: integer, arg8: $List$Type<($ClientTooltipComponent$Type)>)

public "getBackgroundStart"(): integer
public "getBackgroundEnd"(): integer
public "getOriginalBorderEnd"(): integer
public "getOriginalBackgroundStart"(): integer
public "getOriginalBorderStart"(): integer
public "getOriginalBackgroundEnd"(): integer
public "setBackground"(arg0: integer): void
public "setBorderEnd"(arg0: integer): void
public "setBorderStart"(arg0: integer): void
public "setBackgroundStart"(arg0: integer): void
public "setBackgroundEnd"(arg0: integer): void
public "getBorderEnd"(): integer
public "getBorderStart"(): integer
public "getListenerList"(): $ListenerList
get "backgroundStart"(): integer
get "backgroundEnd"(): integer
get "originalBorderEnd"(): integer
get "originalBackgroundStart"(): integer
get "originalBorderStart"(): integer
get "originalBackgroundEnd"(): integer
set "background"(value: integer)
set "borderEnd"(value: integer)
set "borderStart"(value: integer)
set "backgroundStart"(value: integer)
set "backgroundEnd"(value: integer)
get "borderEnd"(): integer
get "borderStart"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTooltipEvent$Color$Type = ($RenderTooltipEvent$Color);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTooltipEvent$Color_ = $RenderTooltipEvent$Color$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingHurtEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingHurtEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float)
constructor()

public "getSource"(): $DamageSource
public "isCancelable"(): boolean
public "setAmount"(arg0: float): void
public "getAmount"(): float
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "cancelable"(): boolean
set "amount"(value: float)
get "amount"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingHurtEvent$Type = ($LivingHurtEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingHurtEvent_ = $LivingHurtEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLivingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$LivingEntityRenderer, $LivingEntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$LivingEntityRenderer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$EntityModel, $EntityModel$Type} from "packages/net/minecraft/client/model/$EntityModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $RenderLivingEvent<T extends $LivingEntity, M extends $EntityModel<(T)>> extends $Event {

constructor()

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getEntity"(): $LivingEntity
public "getPackedLight"(): integer
public "getRenderer"(): $LivingEntityRenderer<(T), (M)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): float
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "entity"(): $LivingEntity
get "packedLight"(): integer
get "renderer"(): $LivingEntityRenderer<(T), (M)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLivingEvent$Type<T, M> = ($RenderLivingEvent<(T), (M)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLivingEvent_<T, M> = $RenderLivingEvent$Type<(T), (M)>;
}}
declare module "packages/net/minecraftforge/client/model/generators/$BlockModelProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$BlockModelBuilder, $BlockModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$BlockModelBuilder"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ModelProvider, $ModelProvider$Type} from "packages/net/minecraftforge/client/model/generators/$ModelProvider"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockModelProvider extends $ModelProvider<($BlockModelBuilder)> {
static readonly "BLOCK_FOLDER": string
static readonly "ITEM_FOLDER": string
readonly "generatedModels": $Map<($ResourceLocation), (T)>
readonly "existingFileHelper": $ExistingFileHelper

constructor(arg0: $PackOutput$Type, arg1: string, arg2: $ExistingFileHelper$Type)

public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModelProvider$Type = ($BlockModelProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockModelProvider_ = $BlockModelProvider$Type;
}}
declare module "packages/net/minecraftforge/registries/$IdMappingEvent" {
import {$ImmutableSet, $ImmutableSet$Type} from "packages/com/google/common/collect/$ImmutableSet"
import {$IdMappingEvent$IdRemapping, $IdMappingEvent$IdRemapping$Type} from "packages/net/minecraftforge/registries/$IdMappingEvent$IdRemapping"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IdMappingEvent$ModRemapping, $IdMappingEvent$ModRemapping$Type} from "packages/net/minecraftforge/registries/$IdMappingEvent$ModRemapping"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $IdMappingEvent extends $Event {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($Map$Type<($ResourceLocation$Type), ($IdMappingEvent$IdRemapping$Type)>)>, arg1: boolean)

public "isFrozen"(): boolean
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getRegistries"(): $ImmutableSet<($ResourceLocation)>
public "getRemaps"(arg0: $ResourceLocation$Type): $ImmutableList<($IdMappingEvent$ModRemapping)>
get "frozen"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "registries"(): $ImmutableSet<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdMappingEvent$Type = ($IdMappingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdMappingEvent_ = $IdMappingEvent$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$RegisterCapabilitiesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $RegisterCapabilitiesEvent extends $Event implements $IModBusEvent {

constructor()

public "register"<T>(arg0: $Class$Type<(T)>): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterCapabilitiesEvent$Type = ($RegisterCapabilitiesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterCapabilitiesEvent_ = $RegisterCapabilitiesEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonReleased$Pre" {
import {$ScreenEvent$MouseButtonReleased, $ScreenEvent$MouseButtonReleased$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonReleased"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonReleased$Pre extends $ScreenEvent$MouseButtonReleased {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonReleased$Pre$Type = ($ScreenEvent$MouseButtonReleased$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonReleased$Pre_ = $ScreenEvent$MouseButtonReleased$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ConfiguredModel" {
import {$ConfiguredModel$Builder, $ConfiguredModel$Builder$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel$Builder"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"

export class $ConfiguredModel {
static readonly "DEFAULT_WEIGHT": integer
readonly "model": $ModelFile
readonly "rotationX": integer
readonly "rotationY": integer
readonly "uvLock": boolean
readonly "weight": integer

constructor(arg0: $ModelFile$Type, arg1: integer, arg2: integer, arg3: boolean)
constructor(arg0: $ModelFile$Type, arg1: integer, arg2: integer, arg3: boolean, arg4: integer)
constructor(arg0: $ModelFile$Type)

public static "builder"(): $ConfiguredModel$Builder<(any)>
public static "allRotations"(arg0: $ModelFile$Type, arg1: boolean, arg2: integer): ($ConfiguredModel)[]
public static "allRotations"(arg0: $ModelFile$Type, arg1: boolean): ($ConfiguredModel)[]
public static "allYRotations"(arg0: $ModelFile$Type, arg1: integer, arg2: boolean, arg3: integer): ($ConfiguredModel)[]
public static "allYRotations"(arg0: $ModelFile$Type, arg1: integer, arg2: boolean): ($ConfiguredModel)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredModel$Type = ($ConfiguredModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfiguredModel_ = $ConfiguredModel$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$EntityHandsInvWrapper" {
import {$EntityEquipmentInvWrapper, $EntityEquipmentInvWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$EntityEquipmentInvWrapper"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EntityHandsInvWrapper extends $EntityEquipmentInvWrapper {

constructor(arg0: $LivingEntity$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityHandsInvWrapper$Type = ($EntityHandsInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityHandsInvWrapper_ = $EntityHandsInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModLoadingStage" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DeferredWorkQueue, $DeferredWorkQueue$Type} from "packages/net/minecraftforge/fml/$DeferredWorkQueue"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLoadingStage extends $Enum<($ModLoadingStage)> {
static readonly "ERROR": $ModLoadingStage
static readonly "VALIDATE": $ModLoadingStage
static readonly "CONSTRUCT": $ModLoadingStage
static readonly "COMMON_SETUP": $ModLoadingStage
static readonly "SIDED_SETUP": $ModLoadingStage
static readonly "ENQUEUE_IMC": $ModLoadingStage
static readonly "PROCESS_IMC": $ModLoadingStage
static readonly "COMPLETE": $ModLoadingStage
static readonly "DONE": $ModLoadingStage


public static "values"(): ($ModLoadingStage)[]
public static "valueOf"(arg0: string): $ModLoadingStage
public "currentState"(arg0: $Throwable$Type): $ModLoadingStage
public "getDeferredWorkQueue"(): $DeferredWorkQueue
get "deferredWorkQueue"(): $DeferredWorkQueue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadingStage$Type = (("sided_setup") | ("enqueue_imc") | ("process_imc") | ("construct") | ("error") | ("common_setup") | ("complete") | ("done") | ("validate")) | ($ModLoadingStage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadingStage_ = $ModLoadingStage$Type;
}}
declare module "packages/net/minecraftforge/client/model/lighting/$ForgeModelBlockRenderer" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ModelBlockRenderer, $ModelBlockRenderer$Type} from "packages/net/minecraft/client/renderer/block/$ModelBlockRenderer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$QuadLighter, $QuadLighter$Type} from "packages/net/minecraftforge/client/model/lighting/$QuadLighter"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $ForgeModelBlockRenderer extends $ModelBlockRenderer {

constructor(arg0: $BlockColors$Type)

public static "render"(arg0: $VertexConsumer$Type, arg1: $QuadLighter$Type, arg2: $BlockAndTintGetter$Type, arg3: $BakedModel$Type, arg4: $BlockState$Type, arg5: $BlockPos$Type, arg6: $PoseStack$Type, arg7: boolean, arg8: $RandomSource$Type, arg9: long, arg10: integer, arg11: $ModelData$Type, arg12: $RenderType$Type): boolean
public "tesselateWithAO"(arg0: $BlockAndTintGetter$Type, arg1: $BakedModel$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type, arg4: $PoseStack$Type, arg5: $VertexConsumer$Type, arg6: boolean, arg7: $RandomSource$Type, arg8: long, arg9: integer, arg10: $ModelData$Type, arg11: $RenderType$Type): void
public "tesselateWithoutAO"(arg0: $BlockAndTintGetter$Type, arg1: $BakedModel$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type, arg4: $PoseStack$Type, arg5: $VertexConsumer$Type, arg6: boolean, arg7: $RandomSource$Type, arg8: long, arg9: integer, arg10: $ModelData$Type, arg11: $RenderType$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeModelBlockRenderer$Type = ($ForgeModelBlockRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeModelBlockRenderer_ = $ForgeModelBlockRenderer$Type;
}}
declare module "packages/net/minecraftforge/internal/$TextComponentMessageFormatHandler" {
import {$TranslatableContents, $TranslatableContents$Type} from "packages/net/minecraft/network/chat/contents/$TranslatableContents"
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export class $TextComponentMessageFormatHandler {

constructor()

public static "handle"(arg0: $TranslatableContents$Type, arg1: $Consumer$Type<($FormattedText$Type)>, arg2: (any)[], arg3: string): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponentMessageFormatHandler$Type = ($TextComponentMessageFormatHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponentMessageFormatHandler_ = $TextComponentMessageFormatHandler$Type;
}}
declare module "packages/net/minecraftforge/client/$ForgeRenderTypes" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $ForgeRenderTypes extends $Enum<($ForgeRenderTypes)> {
static readonly "ITEM_LAYERED_SOLID": $ForgeRenderTypes
static readonly "ITEM_LAYERED_CUTOUT": $ForgeRenderTypes
static readonly "ITEM_LAYERED_CUTOUT_MIPPED": $ForgeRenderTypes
static readonly "ITEM_LAYERED_TRANSLUCENT": $ForgeRenderTypes
static readonly "ITEM_UNSORTED_TRANSLUCENT": $ForgeRenderTypes
static readonly "ITEM_UNLIT_TRANSLUCENT": $ForgeRenderTypes
static readonly "ITEM_UNSORTED_UNLIT_TRANSLUCENT": $ForgeRenderTypes
static readonly "TRANSLUCENT_ON_PARTICLES_TARGET": $ForgeRenderTypes
static "enableTextTextureLinearFiltering": boolean


public "get"(): $RenderType
public static "values"(): ($ForgeRenderTypes)[]
public static "valueOf"(arg0: string): $ForgeRenderTypes
public static "getText"(arg0: $ResourceLocation$Type): $RenderType
public static "getTextIntensitySeeThrough"(arg0: $ResourceLocation$Type): $RenderType
public static "getTextPolygonOffset"(arg0: $ResourceLocation$Type): $RenderType
public static "getTextIntensityPolygonOffset"(arg0: $ResourceLocation$Type): $RenderType
public static "getEntityCutoutMipped"(arg0: $ResourceLocation$Type): $RenderType
public static "getUnsortedTranslucent"(arg0: $ResourceLocation$Type): $RenderType
public static "getItemLayeredCutoutMipped"(arg0: $ResourceLocation$Type): $RenderType
public static "getItemLayeredTranslucent"(arg0: $ResourceLocation$Type): $RenderType
public static "getUnlitTranslucent"(arg0: $ResourceLocation$Type): $RenderType
public static "getUnlitTranslucent"(arg0: $ResourceLocation$Type, arg1: boolean): $RenderType
public static "getItemLayeredCutout"(arg0: $ResourceLocation$Type): $RenderType
public static "getTranslucentParticlesTarget"(arg0: $ResourceLocation$Type): $RenderType
public static "getItemLayeredSolid"(arg0: $ResourceLocation$Type): $RenderType
public static "getTextIntensity"(arg0: $ResourceLocation$Type): $RenderType
public static "getTextSeeThrough"(arg0: $ResourceLocation$Type): $RenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRenderTypes$Type = (("item_layered_solid") | ("item_unsorted_translucent") | ("item_layered_cutout_mipped") | ("item_layered_cutout") | ("item_layered_translucent") | ("item_unsorted_unlit_translucent") | ("item_unlit_translucent") | ("translucent_on_particles_target")) | ($ForgeRenderTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRenderTypes_ = $ForgeRenderTypes$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonPressed$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$MouseButtonPressed, $ScreenEvent$MouseButtonPressed$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonPressed"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonPressed$Pre extends $ScreenEvent$MouseButtonPressed {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonPressed$Pre$Type = ($ScreenEvent$MouseButtonPressed$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonPressed$Pre_ = $ScreenEvent$MouseButtonPressed$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/model/pipeline/$QuadBakingVertexConsumer" {
import {$VertexFormatElement, $VertexFormatElement$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormatElement"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PoseStack$Pose, $PoseStack$Pose$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack$Pose"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $QuadBakingVertexConsumer implements $VertexConsumer {

constructor(arg0: $Consumer$Type<($BakedQuad$Type)>)

public "vertex"(arg0: double, arg1: double, arg2: double): $VertexConsumer
public "uv"(arg0: float, arg1: float): $VertexConsumer
public "setShade"(arg0: boolean): void
public "setTintIndex"(arg0: integer): void
public "color"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $VertexConsumer
public "normal"(arg0: float, arg1: float, arg2: float): $VertexConsumer
public "overlayCoords"(arg0: integer, arg1: integer): $VertexConsumer
public "uv2"(arg0: integer, arg1: integer): $VertexConsumer
public "defaultColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "unsetDefaultColor"(): void
public "misc"(arg0: $VertexFormatElement$Type, ...arg1: (integer)[]): $VertexConsumer
public "endVertex"(): void
public "setDirection"(arg0: $Direction$Type): void
public "setHasAmbientOcclusion"(arg0: boolean): void
public "setSprite"(arg0: $TextureAtlasSprite$Type): void
public "overlayCoords"(arg0: integer): $VertexConsumer
public "uv2"(arg0: integer): $VertexConsumer
public "vertex"(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: integer, arg10: integer, arg11: float, arg12: float, arg13: float): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: integer): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: float, arg7: (integer)[], arg8: integer, arg9: boolean): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: (integer)[], arg7: integer, arg8: boolean): void
public "color"(arg0: integer): $VertexConsumer
public "normal"(arg0: $Matrix3f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "vertex"(arg0: $Matrix4f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "color"(arg0: float, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: integer, arg7: integer, arg8: boolean): void
public "applyBakedLighting"(arg0: integer, arg1: $ByteBuffer$Type): integer
public "applyBakedNormals"(arg0: $Vector3f$Type, arg1: $ByteBuffer$Type, arg2: $Matrix3f$Type): void
set "shade"(value: boolean)
set "tintIndex"(value: integer)
set "direction"(value: $Direction$Type)
set "hasAmbientOcclusion"(value: boolean)
set "sprite"(value: $TextureAtlasSprite$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QuadBakingVertexConsumer$Type = ($QuadBakingVertexConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QuadBakingVertexConsumer_ = $QuadBakingVertexConsumer$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ModelEvent$ModifyBakingResult" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ModelEvent, $ModelEvent$Type} from "packages/net/minecraftforge/client/event/$ModelEvent"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBakery, $ModelBakery$Type} from "packages/net/minecraft/client/resources/model/$ModelBakery"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModelEvent$ModifyBakingResult extends $ModelEvent implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($BakedModel$Type)>, arg1: $ModelBakery$Type)

public "getModels"(): $Map<($ResourceLocation), ($BakedModel)>
public "getModelBakery"(): $ModelBakery
public "getListenerList"(): $ListenerList
get "models"(): $Map<($ResourceLocation), ($BakedModel)>
get "modelBakery"(): $ModelBakery
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelEvent$ModifyBakingResult$Type = ($ModelEvent$ModifyBakingResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelEvent$ModifyBakingResult_ = $ModelEvent$ModifyBakingResult$Type;
}}
declare module "packages/net/minecraftforge/fml/$LogicalSide" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $LogicalSide extends $Enum<($LogicalSide)> {
static readonly "CLIENT": $LogicalSide
static readonly "SERVER": $LogicalSide


public static "values"(): ($LogicalSide)[]
public static "valueOf"(arg0: string): $LogicalSide
public "isClient"(): boolean
public "isServer"(): boolean
get "client"(): boolean
get "server"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogicalSide$Type = (("server") | ("client")) | ($LogicalSide);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogicalSide_ = $LogicalSide$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/$AccessTransformer$Modifier" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $AccessTransformer$Modifier extends $Enum<($AccessTransformer$Modifier)> {
static readonly "PUBLIC": $AccessTransformer$Modifier
static readonly "PROTECTED": $AccessTransformer$Modifier
static readonly "DEFAULT": $AccessTransformer$Modifier
static readonly "PRIVATE": $AccessTransformer$Modifier


public static "values"(): ($AccessTransformer$Modifier)[]
public static "valueOf"(arg0: string): $AccessTransformer$Modifier
public "mergeWith"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccessTransformer$Modifier$Type = (("default") | ("private") | ("public") | ("protected")) | ($AccessTransformer$Modifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AccessTransformer$Modifier_ = $AccessTransformer$Modifier$Type;
}}
declare module "packages/net/minecraftforge/registries/$RegisterEvent$RegisterHelper" {
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $RegisterEvent$RegisterHelper<T> {

 "register"(arg0: string, arg1: T): void
 "register"(arg0: $ResourceKey$Type<(T)>, arg1: T): void
 "register"(arg0: $ResourceLocation$Type, arg1: T): void

(arg0: string, arg1: T): void
}

export namespace $RegisterEvent$RegisterHelper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterEvent$RegisterHelper$Type<T> = ($RegisterEvent$RegisterHelper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterEvent$RegisterHelper_<T> = $RegisterEvent$RegisterHelper$Type<(T)>;
}}
declare module "packages/net/minecraftforge/resource/$DelegatingPackResources" {
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$Type} from "packages/net/minecraft/server/packs/$PackResources$ResourceOutput"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$Type} from "packages/net/minecraft/server/packs/metadata/$MetadataSectionSerializer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$AbstractPackResources, $AbstractPackResources$Type} from "packages/net/minecraft/server/packs/$AbstractPackResources"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$PackMetadataSection, $PackMetadataSection$Type} from "packages/net/minecraft/server/packs/metadata/pack/$PackMetadataSection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$PackResources, $PackResources$Type} from "packages/net/minecraft/server/packs/$PackResources"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"

export class $DelegatingPackResources extends $AbstractPackResources {

constructor(arg0: string, arg1: boolean, arg2: $PackMetadataSection$Type, arg3: $List$Type<(any)>)

public "close"(): void
public "getChildren"(): $Collection<($PackResources)>
public "getResource"(arg0: $PackType$Type, arg1: $ResourceLocation$Type): $IoSupplier<($InputStream)>
public "listResources"(arg0: $PackType$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$Type): void
public "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
public "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$Type<(T)>): T
public "getNamespaces"(arg0: $PackType$Type): $Set<(string)>
get "children"(): $Collection<($PackResources)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DelegatingPackResources$Type = ($DelegatingPackResources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DelegatingPackResources_ = $DelegatingPackResources$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent" {
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$MultiPlayerGameMode, $MultiPlayerGameMode$Type} from "packages/net/minecraft/client/multiplayer/$MultiPlayerGameMode"

export class $ClientPlayerNetworkEvent extends $Event {

constructor()

public "getConnection"(): $Connection
public "isCancelable"(): boolean
public "getMultiPlayerGameMode"(): $MultiPlayerGameMode
public "getPlayer"(): $LocalPlayer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "connection"(): $Connection
get "cancelable"(): boolean
get "multiPlayerGameMode"(): $MultiPlayerGameMode
get "player"(): $LocalPlayer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerNetworkEvent$Type = ($ClientPlayerNetworkEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerNetworkEvent_ = $ClientPlayerNetworkEvent$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$ScreenUtils" {
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

/**
 * 
 * @deprecated
 */
export class $ScreenUtils {
static readonly "DEFAULT_BACKGROUND_COLOR": integer
static readonly "DEFAULT_BORDER_COLOR_START": integer
static readonly "DEFAULT_BORDER_COLOR_END": integer
static readonly "UNDO_CHAR": string
static readonly "RESET_CHAR": string
static readonly "VALID": string
static readonly "INVALID": string
static "TEXT_COLOR_CODES": (integer)[]

constructor()

/**
 * 
 * @deprecated
 */
public static "drawTexturedModalRect"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: float): void
public static "getColorFromFormattingCharacter"(arg0: character, arg1: boolean): integer
/**
 * 
 * @deprecated
 */
public static "drawGradientRect"(arg0: $Matrix4f$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): void
public static "blitWithBorder"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: float): void
public static "blitWithBorder"(arg0: $GuiGraphics$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: float): void
public static "blitWithBorder"(arg0: $GuiGraphics$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: float): void
public static "blitWithBorder"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: float): void
public static "blitInscribed"(arg0: $GuiGraphics$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): void
public static "blitInscribed"(arg0: $GuiGraphics$Type, arg1: $ResourceLocation$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: boolean, arg9: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenUtils$Type = ($ScreenUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenUtils_ = $ScreenUtils$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$EntityArmorInvWrapper" {
import {$EntityEquipmentInvWrapper, $EntityEquipmentInvWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$EntityEquipmentInvWrapper"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EntityArmorInvWrapper extends $EntityEquipmentInvWrapper {

constructor(arg0: $LivingEntity$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArmorInvWrapper$Type = ($EntityArmorInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityArmorInvWrapper_ = $EntityArmorInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/$RenderTypeGroup" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $RenderTypeGroup extends $Record {
static "EMPTY": $RenderTypeGroup

constructor(block: $RenderType$Type, entity: $RenderType$Type, entityFabulous: $RenderType$Type)
constructor(arg0: $RenderType$Type, arg1: $RenderType$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "block"(): $RenderType
public "entity"(): $RenderType
public "entityFabulous"(): $RenderType
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTypeGroup$Type = ($RenderTypeGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTypeGroup_ = $RenderTypeGroup$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $CustomLoaderBuilder<T extends $ModelBuilder<(T)>> {


public "end"(): T
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "visibility"(arg0: string, arg1: boolean): $CustomLoaderBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomLoaderBuilder$Type<T> = ($CustomLoaderBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomLoaderBuilder_<T> = $CustomLoaderBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/items/$ItemHandlerHelper" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $ItemHandlerHelper {

constructor()

public static "giveItemToPlayer"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public static "giveItemToPlayer"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: integer): void
public static "copyStackWithSize"(arg0: $ItemStack$Type, arg1: integer): $ItemStack
public static "canItemStacksStackRelaxed"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public static "calcRedstoneFromInventory"(arg0: $IItemHandler$Type): integer
public static "insertItemStacked"(arg0: $IItemHandler$Type, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public static "insertItem"(arg0: $IItemHandler$Type, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public static "canItemStacksStack"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHandlerHelper$Type = ($ItemHandlerHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHandlerHelper_ = $ItemHandlerHelper$Type;
}}
declare module "packages/net/minecraftforge/common/util/$FakePlayer" {
import {$WalkAnimationState, $WalkAnimationState$Type} from "packages/net/minecraft/world/entity/$WalkAnimationState"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Stat, $Stat$Type} from "packages/net/minecraft/stats/$Stat"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Abilities, $Abilities$Type} from "packages/net/minecraft/world/entity/player/$Abilities"
import {$AttributeMap, $AttributeMap$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeMap"
import {$ServerboundClientInformationPacket, $ServerboundClientInformationPacket$Type} from "packages/net/minecraft/network/protocol/game/$ServerboundClientInformationPacket"
import {$Entity$RemovalReason, $Entity$RemovalReason$Type} from "packages/net/minecraft/world/entity/$Entity$RemovalReason"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$EntityInLevelCallback, $EntityInLevelCallback$Type} from "packages/net/minecraft/world/level/entity/$EntityInLevelCallback"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$ServerGamePacketListenerImpl, $ServerGamePacketListenerImpl$Type} from "packages/net/minecraft/server/network/$ServerGamePacketListenerImpl"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ServerPlayerGameMode, $ServerPlayerGameMode$Type} from "packages/net/minecraft/server/level/$ServerPlayerGameMode"
import {$FishingHook, $FishingHook$Type} from "packages/net/minecraft/world/entity/projectile/$FishingHook"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$InventoryMenu, $InventoryMenu$Type} from "packages/net/minecraft/world/inventory/$InventoryMenu"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FakePlayer extends $ServerPlayer {
 "connection": $ServerGamePacketListenerImpl
readonly "server": $MinecraftServer
readonly "gameMode": $ServerPlayerGameMode
 "containerCounter": integer
 "latency": integer
 "wonGame": boolean
static readonly "PERSISTED_NBT_TAG": string
static readonly "MAX_NAME_LENGTH": integer
static readonly "MAX_HEALTH": integer
static readonly "SLEEP_DURATION": integer
static readonly "WAKE_UP_DURATION": integer
static readonly "ENDER_SLOT_OFFSET": integer
static readonly "CROUCH_BB_HEIGHT": float
static readonly "SWIMMING_BB_WIDTH": float
static readonly "SWIMMING_BB_HEIGHT": float
static readonly "DEFAULT_EYE_HEIGHT": float
static readonly "STANDING_DIMENSIONS": $EntityDimensions
 "inventoryMenu": $InventoryMenu
 "containerMenu": $AbstractContainerMenu
 "oBob": float
 "bob": float
 "takeXpDelay": integer
 "xCloakO": double
 "yCloakO": double
 "zCloakO": double
 "xCloak": double
 "yCloak": double
 "zCloak": double
readonly "abilities": $Abilities
 "experienceLevel": integer
 "totalExperience": integer
 "experienceProgress": float
 "fishing": $FishingHook
readonly "animatorJS$objectPlayer": $Player
static readonly "HAND_SLOTS": integer
static readonly "ARMOR_SLOTS": integer
static readonly "EQUIPMENT_SLOT_OFFSET": integer
static readonly "ARMOR_SLOT_OFFSET": integer
static readonly "SWING_DURATION": integer
static readonly "PLAYER_HURT_EXPERIENCE_TIME": integer
static readonly "MIN_MOVEMENT_DISTANCE": double
static readonly "DEFAULT_BASE_GRAVITY": double
static readonly "DEATH_DURATION": integer
static readonly "USE_ITEM_INTERVAL": integer
static readonly "EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT": float
 "attributes": $AttributeMap
readonly "activeEffects": $Map<($MobEffect), ($MobEffectInstance)>
 "swinging": boolean
 "swingingArm": $InteractionHand
 "swingTime": integer
 "removeArrowTime": integer
 "removeStingerTime": integer
 "hurtTime": integer
 "hurtDuration": integer
 "deathTime": integer
 "oAttackAnim": float
 "attackAnim": float
 "attackStrengthTicker": integer
readonly "walkAnimation": $WalkAnimationState
readonly "invulnerableDuration": integer
readonly "timeOffs": float
readonly "rotA": float
 "yBodyRot": float
 "yBodyRotO": float
 "yHeadRot": float
 "yHeadRotO": float
 "dead": boolean
 "jumping": boolean
 "xxa": float
 "yya": float
 "zza": float
 "effectsDirty": boolean
 "noJumpDelay": integer
 "entityJs$builder": any
static readonly "ID_TAG": string
static readonly "PASSENGERS_TAG": string
static readonly "BOARDING_COOLDOWN": integer
static readonly "TOTAL_AIR_SUPPLY": integer
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
static readonly "BREATHING_DISTANCE_BELOW_EYES": float
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
static readonly "FREEZE_HURT_FREQUENCY": integer
static readonly "UUID_TAG": string
 "blocksBuilding": boolean
 "level": $Level
 "xo": double
 "yo": double
 "zo": double
 "blockPosition": $BlockPos
 "yRot": float
 "xRot": float
 "yRotO": float
 "xRotO": float
 "horizontalCollision": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "minorHorizontalCollision": boolean
 "hurtMarked": boolean
 "removalReason": $Entity$RemovalReason
static readonly "DEFAULT_BB_WIDTH": float
static readonly "DEFAULT_BB_HEIGHT": float
 "walkDistO": float
 "walkDist": float
 "moveDist": float
 "flyDist": float
 "fallDistance": float
 "xOld": double
 "yOld": double
 "zOld": double
 "noPhysics": boolean
 "age": integer
 "wasTouchingWater": boolean
 "wasEyeInWater": boolean
 "invulnerableTime": integer
 "levelCallback": $EntityInLevelCallback
 "noCulling": boolean
 "hasImpulse": boolean
 "portalCooldown": integer
 "isInsidePortal": boolean
 "dimensions": $EntityDimensions
 "eyeHeight": float
 "isInPowderSnow": boolean
 "wasInPowderSnow": boolean
 "wasOnFire": boolean
 "mainSupportingBlockPos": $Optional<($BlockPos)>

constructor(arg0: $ServerLevel$Type, arg1: $GameProfile$Type)

public "tick"(): void
public "die"(arg0: $DamageSource$Type): void
public "canHarmPlayer"(arg0: $Player$Type): boolean
public "isInvulnerableTo"(arg0: $DamageSource$Type): boolean
public "awardStat"(arg0: $Stat$Type<(any)>, arg1: integer): void
public "updateOptions"(arg0: $ServerboundClientInformationPacket$Type): void
public "displayClientMessage"(arg0: $Component$Type, arg1: boolean): void
public "getServer"(): $MinecraftServer
public "tdv$getDynamicLightX"(): double
public "tdv$getDynamicLightZ"(): double
public "tdv$getDynamicLightWorld"(): $Level
public "tdv$shouldUpdateDynamicLight"(): boolean
public "tdv$resetDynamicLight"(): void
public "tdv$getDynamicLightY"(): double
public "tdv$lambdynlights$scheduleTrackedChunksRebuild"(arg0: $LevelRenderer$Type): void
public "tdv$lambdynlights$updateDynamicLight"(arg0: $LevelRenderer$Type): boolean
public "getCachedFeetBlockState"(): $BlockState
get "server"(): $MinecraftServer
get "cachedFeetBlockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FakePlayer$Type = ($FakePlayer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FakePlayer_ = $FakePlayer$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkRegistry$LoginPayload" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $NetworkRegistry$LoginPayload {

constructor(arg0: $FriendlyByteBuf$Type, arg1: $ResourceLocation$Type, arg2: string)
constructor(arg0: $FriendlyByteBuf$Type, arg1: $ResourceLocation$Type, arg2: string, arg3: boolean)

public "getData"(): $FriendlyByteBuf
public "getChannelName"(): $ResourceLocation
public "needsResponse"(): boolean
public "getMessageContext"(): string
get "data"(): $FriendlyByteBuf
get "channelName"(): $ResourceLocation
get "messageContext"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkRegistry$LoginPayload$Type = ($NetworkRegistry$LoginPayload);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkRegistry$LoginPayload_ = $NetworkRegistry$LoginPayload$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$EntityEquipmentInvWrapper" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot$Type, $EquipmentSlot$Type$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot$Type"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EntityEquipmentInvWrapper implements $IItemHandlerModifiable {

constructor(arg0: $LivingEntity$Type, arg1: $EquipmentSlot$Type$Type)

public static "create"(arg0: $LivingEntity$Type): ($LazyOptional<($IItemHandlerModifiable)>)[]
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEquipmentInvWrapper$Type = ($EntityEquipmentInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEquipmentInvWrapper_ = $EntityEquipmentInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeBiomeTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$BiomeTagsProvider, $BiomeTagsProvider$Type} from "packages/net/minecraft/data/tags/$BiomeTagsProvider"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"

export class $ForgeBiomeTagsProvider extends $BiomeTagsProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeTagsProvider$Type = ($ForgeBiomeTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeTagsProvider_ = $ForgeBiomeTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/common/$IMinecartCollisionHandler" {
import {$AbstractMinecart, $AbstractMinecart$Type} from "packages/net/minecraft/world/entity/vehicle/$AbstractMinecart"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IMinecartCollisionHandler {

 "getBoundingBox"(arg0: $AbstractMinecart$Type): $AABB
 "onEntityCollision"(arg0: $AbstractMinecart$Type, arg1: $Entity$Type): void
 "getMinecartCollisionBox"(arg0: $AbstractMinecart$Type): $AABB
 "getCollisionBox"(arg0: $AbstractMinecart$Type, arg1: $Entity$Type): $AABB
}

export namespace $IMinecartCollisionHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMinecartCollisionHandler$Type = ($IMinecartCollisionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMinecartCollisionHandler_ = $IMinecartCollisionHandler$Type;
}}
declare module "packages/net/minecraftforge/registries/$DataPackRegistryEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

export class $DataPackRegistryEvent extends $Event implements $IModBusEvent {

constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackRegistryEvent$Type = ($DataPackRegistryEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataPackRegistryEvent_ = $DataPackRegistryEvent$Type;
}}
declare module "packages/net/minecraftforge/server/command/$ModIdArgument" {
import {$Suggestions, $Suggestions$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestions"
import {$StringReader, $StringReader$Type} from "packages/com/mojang/brigadier/$StringReader"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$ArgumentType, $ArgumentType$Type} from "packages/com/mojang/brigadier/arguments/$ArgumentType"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"

export class $ModIdArgument implements $ArgumentType<(string)> {

constructor()

public "parse"(arg0: $StringReader$Type): string
public static "modIdArgument"(): $ModIdArgument
public "getExamples"(): $Collection<(string)>
public "listSuggestions"<S>(arg0: $CommandContext$Type<(S)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
get "examples"(): $Collection<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModIdArgument$Type = ($ModIdArgument);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModIdArgument_ = $ModIdArgument$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkEvent$Load" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$ChunkEvent, $ChunkEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkEvent"

export class $ChunkEvent$Load extends $ChunkEvent {

constructor()
constructor(arg0: $ChunkAccess$Type, arg1: boolean)

public "isNewChunk"(): boolean
public "getListenerList"(): $ListenerList
get "newChunk"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkEvent$Load$Type = ($ChunkEvent$Load);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkEvent$Load_ = $ChunkEvent$Load$Type;
}}
declare module "packages/net/minecraftforge/event/$ServerChatEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"

export class $ServerChatEvent extends $Event {

constructor()
constructor(arg0: $ServerPlayer$Type, arg1: string, arg2: $Component$Type)

public "getMessage"(): $Component
public "isCancelable"(): boolean
public "getRawText"(): string
public "setMessage"(arg0: $Component$Type): void
public "getPlayer"(): $ServerPlayer
public "getUsername"(): string
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "message"(): $Component
get "cancelable"(): boolean
get "rawText"(): string
set "message"(value: $Component$Type)
get "player"(): $ServerPlayer
get "username"(): string
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerChatEvent$Type = ($ServerChatEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerChatEvent_ = $ServerChatEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeRegistry$Snapshot" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IntSet, $IntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSet"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeRegistry$Snapshot {
readonly "ids": $Object2IntMap<($ResourceLocation)>
readonly "aliases": $Map<($ResourceLocation), ($ResourceLocation)>
readonly "blocked": $IntSet
readonly "overrides": $Map<($ResourceLocation), (string)>

constructor()

public "write"(): $CompoundTag
public static "read"(arg0: $FriendlyByteBuf$Type): $ForgeRegistry$Snapshot
public static "read"(arg0: $CompoundTag$Type): $ForgeRegistry$Snapshot
public "getPacketData"(): $FriendlyByteBuf
get "packetData"(): $FriendlyByteBuf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRegistry$Snapshot$Type = ($ForgeRegistry$Snapshot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRegistry$Snapshot_ = $ForgeRegistry$Snapshot$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$IModFileInfo" {
import {$IConfigurable, $IConfigurable$Type} from "packages/net/minecraftforge/forgespi/language/$IConfigurable"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModFileInfo$LanguageSpec, $IModFileInfo$LanguageSpec$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo$LanguageSpec"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IModFileInfo {

 "moduleName"(): string
 "getFile"(): $IModFile
 "getMods"(): $List<($IModInfo)>
 "requiredLanguageLoaders"(): $List<($IModFileInfo$LanguageSpec)>
 "versionString"(): string
 "getConfig"(): $IConfigurable
 "showAsResourcePack"(): boolean
 "getFileProperties"(): $Map<(string), (any)>
 "usesServices"(): $List<(string)>
 "getLicense"(): string
}

export namespace $IModFileInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModFileInfo$Type = ($IModFileInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModFileInfo_ = $IModFileInfo$Type;
}}
declare module "packages/net/minecraftforge/server/loading/$ServerModLoader" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ServerModLoader {

constructor()

public static "load"(): void
public static "hasErrors"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerModLoader$Type = ($ServerModLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerModLoader_ = $ServerModLoader$Type;
}}
declare module "packages/net/minecraftforge/common/$ToolActions" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"

export class $ToolActions {
static readonly "AXE_DIG": $ToolAction
static readonly "PICKAXE_DIG": $ToolAction
static readonly "SHOVEL_DIG": $ToolAction
static readonly "HOE_DIG": $ToolAction
static readonly "SWORD_DIG": $ToolAction
static readonly "SHEARS_DIG": $ToolAction
static readonly "AXE_STRIP": $ToolAction
static readonly "AXE_SCRAPE": $ToolAction
static readonly "AXE_WAX_OFF": $ToolAction
static readonly "SHOVEL_FLATTEN": $ToolAction
static readonly "SWORD_SWEEP": $ToolAction
static readonly "SHEARS_HARVEST": $ToolAction
static readonly "SHEARS_CARVE": $ToolAction
static readonly "SHEARS_DISARM": $ToolAction
static readonly "HOE_TILL": $ToolAction
static readonly "SHIELD_BLOCK": $ToolAction
static readonly "FISHING_ROD_CAST": $ToolAction
static readonly "DEFAULT_AXE_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_HOE_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_SHOVEL_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_PICKAXE_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_SWORD_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_SHEARS_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_SHIELD_ACTIONS": $Set<($ToolAction)>
static readonly "DEFAULT_FISHING_ROD_ACTIONS": $Set<($ToolAction)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolActions$Type = ($ToolActions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolActions_ = $ToolActions$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$PlayerOffhandInvWrapper" {
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$RangedWrapper, $RangedWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$RangedWrapper"

export class $PlayerOffhandInvWrapper extends $RangedWrapper {

constructor(arg0: $Inventory$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerOffhandInvWrapper$Type = ($PlayerOffhandInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerOffhandInvWrapper_ = $PlayerOffhandInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$ModMismatchDisconnectedScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ConnectionData$ModMismatchData, $ConnectionData$ModMismatchData$Type} from "packages/net/minecraftforge/network/$ConnectionData$ModMismatchData"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ModMismatchDisconnectedScreen extends $Screen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $Screen$Type, arg1: $Component$Type, arg2: $Component$Type, arg3: $ConnectionData$ModMismatchData$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModMismatchDisconnectedScreen$Type = ($ModMismatchDisconnectedScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModMismatchDisconnectedScreen_ = $ModMismatchDisconnectedScreen$Type;
}}
declare module "packages/net/minecraftforge/event/$VanillaGameEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$GameEvent, $GameEvent$Type} from "packages/net/minecraft/world/level/gameevent/$GameEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$GameEvent$Context, $GameEvent$Context$Type} from "packages/net/minecraft/world/level/gameevent/$GameEvent$Context"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $VanillaGameEvent extends $Event {

constructor(arg0: $Level$Type, arg1: $GameEvent$Type, arg2: $Vec3$Type, arg3: $GameEvent$Context$Type)
constructor()

public "getCause"(): $Entity
public "getContext"(): $GameEvent$Context
public "getLevel"(): $Level
public "isCancelable"(): boolean
public "getVanillaEvent"(): $GameEvent
public "getEventPosition"(): $Vec3
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cause"(): $Entity
get "context"(): $GameEvent$Context
get "level"(): $Level
get "cancelable"(): boolean
get "vanillaEvent"(): $GameEvent
get "eventPosition"(): $Vec3
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaGameEvent$Type = ($VanillaGameEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaGameEvent_ = $VanillaGameEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$CreativeModeTabRegistry" {
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CreativeModeTabRegistry {

constructor()

public static "getName"(arg0: $CreativeModeTab$Type): $ResourceLocation
public static "getTab"(arg0: $ResourceLocation$Type): $CreativeModeTab
public static "getDefaultTabs"(): $List<($CreativeModeTab)>
public static "getSortedCreativeModeTabs"(): $List<($CreativeModeTab)>
public static "sortTabs"(): void
get "defaultTabs"(): $List<($CreativeModeTab)>
get "sortedCreativeModeTabs"(): $List<($CreativeModeTab)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabRegistry$Type = ($CreativeModeTabRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeModeTabRegistry_ = $CreativeModeTabRegistry$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityEvent$EntityConstructing" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityEvent$EntityConstructing extends $EntityEvent {

constructor(arg0: $Entity$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEvent$EntityConstructing$Type = ($EntityEvent$EntityConstructing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEvent$EntityConstructing_ = $EntityEvent$EntityConstructing$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/templates/$VoidFluidHandler" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"

export class $VoidFluidHandler implements $IFluidHandler {
static readonly "INSTANCE": $VoidFluidHandler

constructor()

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoidFluidHandler$Type = ($VoidFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoidFluidHandler_ = $VoidFluidHandler$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$ModLoadedCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $ModLoadedCondition implements $ICondition {

constructor(arg0: string)

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadedCondition$Type = ($ModLoadedCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadedCondition_ = $ModLoadedCondition$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeMessages" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $HandshakeMessages {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeMessages$Type = ($HandshakeMessages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeMessages_ = $HandshakeMessages$Type;
}}
declare module "packages/net/minecraftforge/common/$Tags" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Tags {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tags$Type = ($Tags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Tags_ = $Tags$Type;
}}
declare module "packages/net/minecraftforge/client/textures/$ITextureAtlasSpriteLoader" {
import {$ForgeTextureMetadata, $ForgeTextureMetadata$Type} from "packages/net/minecraftforge/client/textures/$ForgeTextureMetadata"
import {$AnimationMetadataSection, $AnimationMetadataSection$Type} from "packages/net/minecraft/client/resources/metadata/animation/$AnimationMetadataSection"
import {$Resource, $Resource$Type} from "packages/net/minecraft/server/packs/resources/$Resource"
import {$NativeImage, $NativeImage$Type} from "packages/com/mojang/blaze3d/platform/$NativeImage"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FrameSize, $FrameSize$Type} from "packages/net/minecraft/client/resources/metadata/animation/$FrameSize"
import {$SpriteContents, $SpriteContents$Type} from "packages/net/minecraft/client/renderer/texture/$SpriteContents"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $ITextureAtlasSpriteLoader {

 "loadContents"(arg0: $ResourceLocation$Type, arg1: $Resource$Type, arg2: $FrameSize$Type, arg3: $NativeImage$Type, arg4: $AnimationMetadataSection$Type, arg5: $ForgeTextureMetadata$Type): $SpriteContents
 "makeSprite"(arg0: $ResourceLocation$Type, arg1: $SpriteContents$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $TextureAtlasSprite
}

export namespace $ITextureAtlasSpriteLoader {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITextureAtlasSpriteLoader$Type = ($ITextureAtlasSpriteLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITextureAtlasSpriteLoader_ = $ITextureAtlasSpriteLoader$Type;
}}
declare module "packages/net/minecraftforge/common/loot/$IGlobalLootModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootItemCondition, $LootItemCondition$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemCondition"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"

export interface $IGlobalLootModifier {

 "apply"(arg0: $ObjectArrayList$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $ObjectArrayList<($ItemStack)>
 "codec"(): $Codec<(any)>
}

export namespace $IGlobalLootModifier {
const DIRECT_CODEC: $Codec<($IGlobalLootModifier)>
const LOOT_CONDITIONS_CODEC: $Codec<(($LootItemCondition)[])>
function getJson<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGlobalLootModifier$Type = ($IGlobalLootModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGlobalLootModifier_ = $IGlobalLootModifier$Type;
}}
declare module "packages/net/minecraftforge/event/$ForgeEventFactory" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$PlayerList, $PlayerList$Type} from "packages/net/minecraft/server/players/$PlayerList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Animal, $Animal$Type} from "packages/net/minecraft/world/entity/animal/$Animal"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$DifficultyInstance, $DifficultyInstance$Type} from "packages/net/minecraft/world/$DifficultyInstance"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$BlockSnapshot, $BlockSnapshot$Type} from "packages/net/minecraftforge/common/util/$BlockSnapshot"
import {$EntityEvent$Size, $EntityEvent$Size$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent$Size"
import {$Pose, $Pose$Type} from "packages/net/minecraft/world/entity/$Pose"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$SpawnData, $SpawnData$Type} from "packages/net/minecraft/world/level/$SpawnData"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$MobSpawnEvent$FinalizeSpawn, $MobSpawnEvent$FinalizeSpawn$Type} from "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent$FinalizeSpawn"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$BlockEvent$NeighborNotifyEvent, $BlockEvent$NeighborNotifyEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent$NeighborNotifyEvent"
import {$PreparableReloadListener, $PreparableReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$MobSpawnType, $MobSpawnType$Type} from "packages/net/minecraft/world/entity/$MobSpawnType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Commands$CommandSelection, $Commands$CommandSelection$Type} from "packages/net/minecraft/commands/$Commands$CommandSelection"
import {$PortalShape, $PortalShape$Type} from "packages/net/minecraft/world/level/portal/$PortalShape"
import {$EntityTeleportEvent$TeleportCommand, $EntityTeleportEvent$TeleportCommand$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$TeleportCommand"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ServerLevelData, $ServerLevelData$Type} from "packages/net/minecraft/world/level/storage/$ServerLevelData"
import {$BaseSpawner, $BaseSpawner$Type} from "packages/net/minecraft/world/level/$BaseSpawner"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$EntityTeleportEvent$EnderEntity, $EntityTeleportEvent$EnderEntity$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$EnderEntity"
import {$ThrownEnderpearl, $ThrownEnderpearl$Type} from "packages/net/minecraft/world/entity/projectile/$ThrownEnderpearl"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LevelSimulatedReader, $LevelSimulatedReader$Type} from "packages/net/minecraft/world/level/$LevelSimulatedReader"
import {$EntityTeleportEvent$ChorusFruit, $EntityTeleportEvent$ChorusFruit$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$ChorusFruit"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$LootTable, $LootTable$Type} from "packages/net/minecraft/world/level/storage/loot/$LootTable"
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$PlayLevelSoundEvent$AtPosition, $PlayLevelSoundEvent$AtPosition$Type} from "packages/net/minecraftforge/event/$PlayLevelSoundEvent$AtPosition"
import {$Projectile, $Projectile$Type} from "packages/net/minecraft/world/entity/projectile/$Projectile"
import {$AdvancementEvent$AdvancementProgressEvent$ProgressType, $AdvancementEvent$AdvancementProgressEvent$ProgressType$Type} from "packages/net/minecraftforge/event/entity/player/$AdvancementEvent$AdvancementProgressEvent$ProgressType"
import {$PlayerDataStorage, $PlayerDataStorage$Type} from "packages/net/minecraft/world/level/storage/$PlayerDataStorage"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Event$Result, $Event$Result$Type} from "packages/net/minecraftforge/eventbus/api/$Event$Result"
import {$ChunkHolder, $ChunkHolder$Type} from "packages/net/minecraft/server/level/$ChunkHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevelAccessor, $ServerLevelAccessor$Type} from "packages/net/minecraft/world/level/$ServerLevelAccessor"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$PlayLevelSoundEvent$AtEntity, $PlayLevelSoundEvent$AtEntity$Type} from "packages/net/minecraftforge/event/$PlayLevelSoundEvent$AtEntity"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EntityTeleportEvent$SpreadPlayersCommand, $EntityTeleportEvent$SpreadPlayersCommand$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$SpreadPlayersCommand"
import {$ItemTooltipEvent, $ItemTooltipEvent$Type} from "packages/net/minecraftforge/event/entity/player/$ItemTooltipEvent"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"
import {$ProjectileImpactEvent$ImpactResult, $ProjectileImpactEvent$ImpactResult$Type} from "packages/net/minecraftforge/event/entity/$ProjectileImpactEvent$ImpactResult"
import {$Zombie, $Zombie$Type} from "packages/net/minecraft/world/entity/monster/$Zombie"
import {$CapabilityDispatcher, $CapabilityDispatcher$Type} from "packages/net/minecraftforge/common/capabilities/$CapabilityDispatcher"
import {$EntityTeleportEvent$EnderPearl, $EntityTeleportEvent$EnderPearl$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$EnderPearl"
import {$SaplingGrowTreeEvent, $SaplingGrowTreeEvent$Type} from "packages/net/minecraftforge/event/level/$SaplingGrowTreeEvent"
import {$AdvancementProgress, $AdvancementProgress$Type} from "packages/net/minecraft/advancements/$AdvancementProgress"
import {$ZombieEvent$SummonAidEvent, $ZombieEvent$SummonAidEvent$Type} from "packages/net/minecraftforge/event/entity/living/$ZombieEvent$SummonAidEvent"
import {$LevelChunk, $LevelChunk$Type} from "packages/net/minecraft/world/level/chunk/$LevelChunk"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$File, $File$Type} from "packages/java/io/$File"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$Player$BedSleepingProblem, $Player$BedSleepingProblem$Type} from "packages/net/minecraft/world/entity/player/$Player$BedSleepingProblem"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$WeightedRandomList, $WeightedRandomList$Type} from "packages/net/minecraft/util/random/$WeightedRandomList"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"
import {$LightningBolt, $LightningBolt$Type} from "packages/net/minecraft/world/entity/$LightningBolt"
import {$SpawnGroupData, $SpawnGroupData$Type} from "packages/net/minecraft/world/entity/$SpawnGroupData"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"

export class $ForgeEventFactory {

constructor()

public static "onToolUse"(arg0: $BlockState$Type, arg1: $UseOnContext$Type, arg2: $ToolAction$Type, arg3: boolean): $BlockState
public static "fireZombieSummonAid"(arg0: $Zombie$Type, arg1: $Level$Type, arg2: integer, arg3: integer, arg4: integer, arg5: $LivingEntity$Type, arg6: double): $ZombieEvent$SummonAidEvent
public static "checkSpawnPositionSpawner"(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type, arg2: $MobSpawnType$Type, arg3: $SpawnData$Type, arg4: $BaseSpawner$Type): boolean
public static "onFinalizeSpawnSpawner"(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type, arg2: $DifficultyInstance$Type, arg3: $SpawnGroupData$Type, arg4: $CompoundTag$Type, arg5: $BaseSpawner$Type): $MobSpawnEvent$FinalizeSpawn
public static "onCommandRegister"(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>, arg1: $Commands$CommandSelection$Type, arg2: $CommandBuildContext$Type): void
public static "firePlayerLoggedOut"(arg0: $Player$Type): void
public static "firePlayerLoadingEvent"(arg0: $Player$Type, arg1: $PlayerDataStorage$Type, arg2: string): void
public static "firePlayerLoadingEvent"(arg0: $Player$Type, arg1: $File$Type, arg2: string): void
public static "firePlayerRespawnEvent"(arg0: $Player$Type, arg1: boolean): void
public static "onPermissionChanged"(arg0: $GameProfile$Type, arg1: integer, arg2: $PlayerList$Type): boolean
public static "onRenderTickEnd"(arg0: float): void
public static "onRenderTickStart"(arg0: float): void
public static "onMultiBlockPlace"(arg0: $Entity$Type, arg1: $List$Type<($BlockSnapshot$Type)>, arg2: $Direction$Type): boolean
public static "getItemBurnTime"(arg0: $ItemStack$Type, arg1: integer, arg2: $RecipeType$Type<(any)>): integer
public static "checkSpawnPosition"(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type, arg2: $MobSpawnType$Type): boolean
public static "loadLootTable"(arg0: $ResourceLocation$Type, arg1: $LootTable$Type): $LootTable
public static "fireChunkWatch"(arg0: $ServerPlayer$Type, arg1: $LevelChunk$Type, arg2: $ServerLevel$Type): void
public static "fireChunkUnWatch"(arg0: $ServerPlayer$Type, arg1: $ChunkPos$Type, arg2: $ServerLevel$Type): void
public static "getPotentialSpawns"(arg0: $LevelAccessor$Type, arg1: $MobCategory$Type, arg2: $BlockPos$Type, arg3: $WeightedRandomList$Type<($MobSpawnSettings$SpawnerData$Type)>): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public static "onExplosionStart"(arg0: $Level$Type, arg1: $Explosion$Type): boolean
public static "onEnderPearlLand"(arg0: $ServerPlayer$Type, arg1: double, arg2: double, arg3: double, arg4: $ThrownEnderpearl$Type, arg5: float, arg6: $HitResult$Type): $EntityTeleportEvent$EnderPearl
public static "onEnderTeleport"(arg0: $LivingEntity$Type, arg1: double, arg2: double, arg3: double): $EntityTeleportEvent$EnderEntity
public static "onBlockPlace"(arg0: $Entity$Type, arg1: $BlockSnapshot$Type, arg2: $Direction$Type): boolean
public static "onPlaySoundAtPosition"(arg0: $Level$Type, arg1: double, arg2: double, arg3: double, arg4: $Holder$Type<($SoundEvent$Type)>, arg5: $SoundSource$Type, arg6: float, arg7: float): $PlayLevelSoundEvent$AtPosition
public static "onPlayerPreTick"(arg0: $Player$Type): void
public static "onPlayerPostTick"(arg0: $Player$Type): void
public static "getBreakSpeed"(arg0: $Player$Type, arg1: $BlockState$Type, arg2: float, arg3: $BlockPos$Type): float
public static "onPlayerWakeup"(arg0: $Player$Type, arg1: boolean, arg2: boolean): void
public static "onPlayerFall"(arg0: $Player$Type, arg1: float, arg2: float): void
public static "firePlayerItemPickupEvent"(arg0: $Player$Type, arg1: $ItemEntity$Type, arg2: $ItemStack$Type): void
public static "onResourceReload"(arg0: $ReloadableServerResources$Type, arg1: $RegistryAccess$Type): $List<($PreparableReloadListener)>
public static "checkSpawnPlacements"(arg0: $EntityType$Type<(any)>, arg1: $ServerLevelAccessor$Type, arg2: $MobSpawnType$Type, arg3: $BlockPos$Type, arg4: $RandomSource$Type, arg5: boolean): boolean
public static "onLivingHeal"(arg0: $LivingEntity$Type, arg1: float): float
public static "getExperienceDrop"(arg0: $LivingEntity$Type, arg1: $Player$Type, arg2: integer): integer
public static "onItemUseStart"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): integer
public static "onItemUseTick"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): integer
public static "onItemUseFinish"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $ItemStack$Type): $ItemStack
public static "onUseItemStop"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer): boolean
public static "onPlayerSleepInBed"(arg0: $Player$Type, arg1: $Optional$Type<($BlockPos$Type)>): $Player$BedSleepingProblem
public static "onPlayerClone"(arg0: $Player$Type, arg1: $Player$Type, arg2: boolean): void
public static "onPlayerSpawnSet"(arg0: $Player$Type, arg1: $ResourceKey$Type<($Level$Type)>, arg2: $BlockPos$Type, arg3: boolean): boolean
public static "onFinalizeSpawn"(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type, arg2: $DifficultyInstance$Type, arg3: $MobSpawnType$Type, arg4: $SpawnGroupData$Type, arg5: $CompoundTag$Type): $SpawnGroupData
public static "onPreClientTick"(): void
public static "onPreLevelTick"(arg0: $Level$Type, arg1: $BooleanSupplier$Type): void
public static "onPostLevelTick"(arg0: $Level$Type, arg1: $BooleanSupplier$Type): void
public static "onPostClientTick"(): void
public static "doPlayerHarvestCheck"(arg0: $Player$Type, arg1: $BlockState$Type, arg2: boolean): boolean
public static "fireSleepingTimeCheck"(arg0: $Player$Type, arg1: $Optional$Type<($BlockPos$Type)>): boolean
public static "onPlayerDestroyItem"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $InteractionHand$Type): void
public static "getPlayerDisplayName"(arg0: $Player$Type, arg1: $Component$Type): $Component
public static "getMobGriefingEvent"(arg0: $Level$Type, arg1: $Entity$Type): boolean
public static "fireSleepingLocationCheck"(arg0: $LivingEntity$Type, arg1: $BlockPos$Type): boolean
public static "onPotionBrewed"(arg0: $NonNullList$Type<($ItemStack$Type)>): void
public static "onNeighborNotify"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EnumSet$Type<($Direction$Type)>, arg4: boolean): $BlockEvent$NeighborNotifyEvent
public static "canEntityDespawn"(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type): $Event$Result
public static "onItemTooltip"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $List$Type<($Component$Type)>, arg3: $TooltipFlag$Type): $ItemTooltipEvent
public static "onSleepFinished"(arg0: $ServerLevel$Type, arg1: long, arg2: long): long
public static "onEntityTeleportSpreadPlayersCommand"(arg0: $Entity$Type, arg1: double, arg2: double, arg3: double): $EntityTeleportEvent$SpreadPlayersCommand
public static "fireFluidPlaceBlockEvent"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): $BlockState
public static "canCreateFluidSource"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: boolean): boolean
public static "onProjectileImpactResult"(arg0: $Projectile$Type, arg1: $HitResult$Type): $ProjectileImpactEvent$ImpactResult
public static "alterGround"(arg0: $LevelSimulatedReader$Type, arg1: $RandomSource$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): $BlockState
public static "onAnimalTame"(arg0: $Animal$Type, arg1: $Player$Type): boolean
public static "onApplyBonemeal"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $ItemStack$Type): integer
public static "blockGrowFeature"(arg0: $LevelAccessor$Type, arg1: $RandomSource$Type, arg2: $BlockPos$Type, arg3: $Holder$Type<($ConfiguredFeature$Type<(any), (any)>)>): $SaplingGrowTreeEvent
public static "onExplosionDetonate"(arg0: $Level$Type, arg1: $Explosion$Type, arg2: $List$Type<($Entity$Type)>, arg3: double): void
public static "onEntityStruckByLightning"(arg0: $Entity$Type, arg1: $LightningBolt$Type): boolean
public static "onAdvancementEarnedEvent"(arg0: $Player$Type, arg1: $Advancement$Type): void
public static "onAdvancementProgressedEvent"(arg0: $Player$Type, arg1: $Advancement$Type, arg2: $AdvancementProgress$Type, arg3: string, arg4: $AdvancementEvent$AdvancementProgressEvent$ProgressType$Type): void
public static "firePlayerLoggedIn"(arg0: $Player$Type): void
public static "onArrowLoose"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Player$Type, arg3: integer, arg4: boolean): integer
public static "onArrowNock"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Player$Type, arg3: $InteractionHand$Type, arg4: boolean): $InteractionResultHolder<($ItemStack)>
public static "onBucketUse"(arg0: $Player$Type, arg1: $Level$Type, arg2: $ItemStack$Type, arg3: $HitResult$Type): $InteractionResultHolder<($ItemStack)>
public static "firePlayerChangedDimensionEvent"(arg0: $Player$Type, arg1: $ResourceKey$Type<($Level$Type)>, arg2: $ResourceKey$Type<($Level$Type)>): void
public static "getPlayerTabListDisplayName"(arg0: $Player$Type): $Component
public static "firePlayerSmeltedEvent"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public static "onPlayerBrewedPotion"(arg0: $Player$Type, arg1: $ItemStack$Type): void
public static "firePlayerCraftingEvent"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $Container$Type): void
public static "onItemExpire"(arg0: $ItemEntity$Type, arg1: $ItemStack$Type): integer
public static "onCreateWorldSpawn"(arg0: $Level$Type, arg1: $ServerLevelData$Type): boolean
public static "onProjectileImpact"(arg0: $Projectile$Type, arg1: $HitResult$Type): boolean
public static "onLivingConvert"(arg0: $LivingEntity$Type, arg1: $LivingEntity$Type): void
public static "canLivingConvert"(arg0: $LivingEntity$Type, arg1: $EntityType$Type<(any)>, arg2: $Consumer$Type<(integer)>): boolean
public static "onPlaySoundAtEntity"(arg0: $Entity$Type, arg1: $Holder$Type<($SoundEvent$Type)>, arg2: $SoundSource$Type, arg3: float, arg4: float): $PlayLevelSoundEvent$AtEntity
/**
 * 
 * @deprecated
 */
public static "getEntitySizeForge"(arg0: $Entity$Type, arg1: $Pose$Type, arg2: $EntityDimensions$Type, arg3: float): $EntityEvent$Size
/**
 * 
 * @deprecated
 */
public static "getEntitySizeForge"(arg0: $Entity$Type, arg1: $Pose$Type, arg2: $EntityDimensions$Type, arg3: $EntityDimensions$Type, arg4: float): $EntityEvent$Size
public static "gatherCapabilities"<T extends $ICapabilityProvider>(arg0: $Class$Type<(any)>, arg1: T): $CapabilityDispatcher
public static "gatherCapabilities"<T extends $ICapabilityProvider>(arg0: $Class$Type<(any)>, arg1: T, arg2: $ICapabilityProvider$Type): $CapabilityDispatcher
public static "onPreServerTick"(arg0: $BooleanSupplier$Type, arg1: $MinecraftServer$Type): void
public static "onPostServerTick"(arg0: $BooleanSupplier$Type, arg1: $MinecraftServer$Type): void
public static "onEnchantmentLevelSet"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: integer, arg3: integer, arg4: $ItemStack$Type, arg5: integer): integer
public static "onPotionAttemptBrew"(arg0: $NonNullList$Type<($ItemStack$Type)>): boolean
public static "onEntityDestroyBlock"(arg0: $LivingEntity$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): boolean
public static "onTrySpawnPortal"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $Optional$Type<($PortalShape$Type)>): $Optional<($PortalShape)>
public static "onItemPickup"(arg0: $ItemEntity$Type, arg1: $Player$Type): integer
public static "canMountEntity"(arg0: $Entity$Type, arg1: $Entity$Type, arg2: boolean): boolean
public static "onPistonMovePost"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: boolean): boolean
public static "onPistonMovePre"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: boolean): boolean
public static "onStartEntityTracking"(arg0: $Entity$Type, arg1: $Player$Type): void
public static "fireChunkTicketLevelUpdated"(arg0: $ServerLevel$Type, arg1: long, arg2: integer, arg3: integer, arg4: $ChunkHolder$Type): void
public static "onStopEntityTracking"(arg0: $Entity$Type, arg1: $Player$Type): void
public static "onEntityTeleportCommand"(arg0: $Entity$Type, arg1: double, arg2: double, arg3: double): $EntityTeleportEvent$TeleportCommand
public static "firePlayerSavingEvent"(arg0: $Player$Type, arg1: $File$Type, arg2: string): void
public static "getMaxSpawnPackSize"(arg0: $Mob$Type): integer
public static "onChorusFruitTeleport"(arg0: $LivingEntity$Type, arg1: double, arg2: double, arg3: double): $EntityTeleportEvent$ChorusFruit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEventFactory$Type = ($ForgeEventFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEventFactory_ = $ForgeEventFactory$Type;
}}
declare module "packages/net/minecraftforge/registries/$ObjectHolderRegistry" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ObjectHolderRegistry {

constructor()

public static "addHandler"(arg0: $Consumer$Type<($Predicate$Type<($ResourceLocation$Type)>)>): void
public static "removeHandler"(arg0: $Consumer$Type<($Predicate$Type<($ResourceLocation$Type)>)>): boolean
public static "findObjectHolders"(): void
public static "applyObjectHolders"(arg0: $Predicate$Type<($ResourceLocation$Type)>): void
public static "applyObjectHolders"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectHolderRegistry$Type = ($ObjectHolderRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectHolderRegistry_ = $ObjectHolderRegistry$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/loaders/$CompositeModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $CompositeModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $CompositeModelBuilder<(T)>
public "child"(arg0: string, arg1: T): $CompositeModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "itemRenderOrder"(...arg0: (string)[]): $CompositeModelBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeModelBuilder$Type<T> = ($CompositeModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeModelBuilder_<T> = $CompositeModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkDataEvent$Load" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkDataEvent, $ChunkDataEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkDataEvent"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$ChunkStatus$ChunkType, $ChunkStatus$ChunkType$Type} from "packages/net/minecraft/world/level/chunk/$ChunkStatus$ChunkType"

export class $ChunkDataEvent$Load extends $ChunkDataEvent {

constructor()
constructor(arg0: $ChunkAccess$Type, arg1: $CompoundTag$Type, arg2: $ChunkStatus$ChunkType$Type)

public "getStatus"(): $ChunkStatus$ChunkType
public "getListenerList"(): $ListenerList
get "status"(): $ChunkStatus$ChunkType
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkDataEvent$Load$Type = ($ChunkDataEvent$Load);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkDataEvent$Load_ = $ChunkDataEvent$Load$Type;
}}
declare module "packages/net/minecraftforge/registries/$NamespacedDefaultedWrapper" {
import {$DefaultedRegistry, $DefaultedRegistry$Type} from "packages/net/minecraft/core/$DefaultedRegistry"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$Type} from "packages/net/minecraft/core/$HolderLookup$RegistryLookup"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamespacedWrapper, $NamespacedWrapper$Type} from "packages/net/minecraftforge/registries/$NamespacedWrapper"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $NamespacedDefaultedWrapper<T> extends $NamespacedWrapper<(T)> implements $DefaultedRegistry<(T)> {


public "getRandom"(arg0: $RandomSource$Type): $Optional<($Holder$Reference<(T)>)>
public "get"(arg0: $ResourceLocation$Type): T
public "getDefaultKey"(): $ResourceLocation
public "getKey"(arg0: T): $ResourceLocation
public "byId"(arg0: integer): T
public "asLookup"(): $HolderLookup$RegistryLookup<(T)>
public static "register"<T>(arg0: $Registry$Type<(any)>, arg1: string, arg2: T): T
public static "register"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: $ResourceLocation$Type, arg2: T): T
public static "register"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: $ResourceKey$Type<(V)>, arg2: T): T
public "key"(): $ResourceKey<(any)>
public "holderOwner"(): $HolderOwner<(T)>
public static "registerMapping"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: integer, arg2: string, arg3: T): T
public static "registerForHolder"<T>(arg0: $Registry$Type<(T)>, arg1: $ResourceKey$Type<(T)>, arg2: T): $Holder$Reference<(T)>
public static "registerForHolder"<T>(arg0: $Registry$Type<(T)>, arg1: $ResourceLocation$Type, arg2: T): $Holder$Reference<(T)>
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
get "defaultKey"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamespacedDefaultedWrapper$Type<T> = ($NamespacedDefaultedWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamespacedDefaultedWrapper_<T> = $NamespacedDefaultedWrapper$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fml/$I18NParser" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $I18NParser {

 "stripControlCodes"(arg0: string): string
 "parseMessage"(arg0: string, ...arg1: (any)[]): string
}

export namespace $I18NParser {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $I18NParser$Type = ($I18NParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $I18NParser_ = $I18NParser$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$PlayerInvWrapper" {
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$CombinedInvWrapper, $CombinedInvWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$CombinedInvWrapper"

export class $PlayerInvWrapper extends $CombinedInvWrapper {

constructor(arg0: $Inventory$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInvWrapper$Type = ($PlayerInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInvWrapper_ = $PlayerInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$SaveToFile" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$File, $File$Type} from "packages/java/io/$File"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerEvent$SaveToFile extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $File$Type, arg2: string)

public "getPlayerFile"(arg0: string): $File
public "getPlayerDirectory"(): $File
public "getPlayerUUID"(): string
public "getListenerList"(): $ListenerList
get "playerDirectory"(): $File
get "playerUUID"(): string
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$SaveToFile$Type = ($PlayerEvent$SaveToFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$SaveToFile_ = $PlayerEvent$SaveToFile$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModelBuilder$TransformsBuilder, $ModelBuilder$TransformsBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$TransformsBuilder"
import {$BlockModel$GuiLight, $BlockModel$GuiLight$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel$GuiLight"
import {$ModelBuilder$RootTransformsBuilder, $ModelBuilder$RootTransformsBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$RootTransformsBuilder"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelBuilder$ElementBuilder, $ModelBuilder$ElementBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $ModelBuilder<T extends $ModelBuilder<(T)>> extends $ModelFile {


public "parent"(arg0: $ModelFile$Type): T
public "ao"(arg0: boolean): T
public "element"(): $ModelBuilder$ElementBuilder<>
public "element"(arg0: integer): $ModelBuilder$ElementBuilder<>
public "toJson"(): $JsonObject
public "transforms"(): $ModelBuilder$TransformsBuilder<>
public "renderType"(arg0: $ResourceLocation$Type): T
public "renderType"(arg0: string): T
public "texture"(arg0: string, arg1: string): T
public "texture"(arg0: string, arg1: $ResourceLocation$Type): T
public "rootTransforms"(): $ModelBuilder$RootTransformsBuilder<>
public "guiLight"(arg0: $BlockModel$GuiLight$Type): T
public "customLoader"<L extends $CustomLoaderBuilder<(T)>>(arg0: $BiFunction$Type<(T), ($ExistingFileHelper$Type), (L)>): L
public "getElementCount"(): integer
get "elementCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$Type<T> = ($ModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder_<T> = $ModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/items/$IItemHandler" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export interface $IItemHandler extends $InventoryKJS {

 "kjs$self"(): $IItemHandler
 "getBlock"(level: $Level$Type): $BlockContainerJS
 "getSlots"(): integer
 "getStackInSlot"(arg0: integer): $ItemStack
 "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
 "getSlots"(): integer
 "getStackInSlot"(i: integer): $ItemStack
 "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
 "isMutable"(): boolean
 "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
 "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
 "getSlotLimit"(i: integer): integer
 "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
 "setChanged"(): void
 "asContainer"(): $Container
 "countNonEmpty"(ingredient: $Ingredient$Type): integer
 "countNonEmpty"(): integer
 "getAllItems"(): $List<($ItemStack)>
 "getHeight"(): integer
 "find"(ingredient: $Ingredient$Type): integer
 "find"(): integer
 "getWidth"(): integer
 "clear"(): void
 "clear"(ingredient: $Ingredient$Type): void
 "count"(ingredient: $Ingredient$Type): integer
 "count"(): integer
 "isEmpty"(): boolean
}

export namespace $IItemHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemHandler$Type = ($IItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemHandler_ = $IItemHandler$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterEntitySpectatorShadersEvent" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterEntitySpectatorShadersEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($EntityType$Type<(any)>), ($ResourceLocation$Type)>)

public "register"(arg0: $EntityType$Type<(any)>, arg1: $ResourceLocation$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterEntitySpectatorShadersEvent$Type = ($RegisterEntitySpectatorShadersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterEntitySpectatorShadersEvent_ = $RegisterEntitySpectatorShadersEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiOverlayEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$NamedGuiOverlay, $NamedGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiOverlayEvent extends $Event {

constructor()

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getWindow"(): $Window
public "getGuiGraphics"(): $GuiGraphics
public "getOverlay"(): $NamedGuiOverlay
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): float
get "cancelable"(): boolean
get "window"(): $Window
get "guiGraphics"(): $GuiGraphics
get "overlay"(): $NamedGuiOverlay
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiOverlayEvent$Type = ($RenderGuiOverlayEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiOverlayEvent_ = $RenderGuiOverlayEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ForgeConfigSpec$Builder, $ForgeConfigSpec$Builder$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$Builder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ForgeConfigSpec$ConfigValue<T> implements $Supplier<(T)> {


public "get"(): T
public "next"(): $ForgeConfigSpec$Builder
public "getDefault"(): T
public "set"(arg0: T): void
public "save"(): void
public "getPath"(): $List<(string)>
public "clearCache"(): void
get "default"(): T
get "path"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$ConfigValue$Type<T> = ($ForgeConfigSpec$ConfigValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$ConfigValue_<T> = $ForgeConfigSpec$ConfigValue$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/model/pipeline/$VertexConsumerWrapper" {
import {$VertexFormatElement, $VertexFormatElement$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormatElement"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack$Pose, $PoseStack$Pose$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack$Pose"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $VertexConsumerWrapper implements $VertexConsumer {

constructor(arg0: $VertexConsumer$Type)

public "vertex"(arg0: double, arg1: double, arg2: double): $VertexConsumer
public "uv"(arg0: float, arg1: float): $VertexConsumer
public "color"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $VertexConsumer
public "normal"(arg0: float, arg1: float, arg2: float): $VertexConsumer
public "overlayCoords"(arg0: integer, arg1: integer): $VertexConsumer
public "uv2"(arg0: integer, arg1: integer): $VertexConsumer
public "defaultColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "unsetDefaultColor"(): void
public "misc"(arg0: $VertexFormatElement$Type, ...arg1: (integer)[]): $VertexConsumer
public "endVertex"(): void
public "overlayCoords"(arg0: integer): $VertexConsumer
public "uv2"(arg0: integer): $VertexConsumer
public "vertex"(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: integer, arg10: integer, arg11: float, arg12: float, arg13: float): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: integer): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: float, arg7: (integer)[], arg8: integer, arg9: boolean): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: (integer)[], arg7: integer, arg8: boolean): void
public "color"(arg0: integer): $VertexConsumer
public "normal"(arg0: $Matrix3f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "vertex"(arg0: $Matrix4f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "color"(arg0: float, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: integer, arg7: integer, arg8: boolean): void
public "applyBakedLighting"(arg0: integer, arg1: $ByteBuffer$Type): integer
public "applyBakedNormals"(arg0: $Vector3f$Type, arg1: $ByteBuffer$Type, arg2: $Matrix3f$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VertexConsumerWrapper$Type = ($VertexConsumerWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VertexConsumerWrapper_ = $VertexConsumerWrapper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent$AllowDespawn" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobSpawnEvent, $MobSpawnEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$ServerLevelAccessor, $ServerLevelAccessor$Type} from "packages/net/minecraft/world/level/$ServerLevelAccessor"

export class $MobSpawnEvent$AllowDespawn extends $MobSpawnEvent {

constructor()
constructor(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type)

public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnEvent$AllowDespawn$Type = ($MobSpawnEvent$AllowDespawn);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobSpawnEvent$AllowDespawn_ = $MobSpawnEvent$AllowDespawn$Type;
}}
declare module "packages/net/minecraftforge/eventbus/$EventBus" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IEventExceptionHandler, $IEventExceptionHandler$Type} from "packages/net/minecraftforge/eventbus/api/$IEventExceptionHandler"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$GenericEvent, $GenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$GenericEvent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IEventListener, $IEventListener$Type} from "packages/net/minecraftforge/eventbus/api/$IEventListener"
import {$IEventBusInvokeDispatcher, $IEventBusInvokeDispatcher$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBusInvokeDispatcher"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BusBuilderImpl, $BusBuilderImpl$Type} from "packages/net/minecraftforge/eventbus/$BusBuilderImpl"
import {$EventPriority, $EventPriority$Type} from "packages/net/minecraftforge/eventbus/api/$EventPriority"

export class $EventBus implements $IEventExceptionHandler, $IEventBus {

constructor(arg0: $BusBuilderImpl$Type)

public "shutdown"(): void
public "start"(): void
public "register"(arg0: any): void
public "unregister"(arg0: any): void
public "post"(arg0: $Event$Type): boolean
public "post"(arg0: $Event$Type, arg1: $IEventBusInvokeDispatcher$Type): boolean
public "handleException"(arg0: $IEventBus$Type, arg1: $Event$Type, arg2: ($IEventListener$Type)[], arg3: integer, arg4: $Throwable$Type): void
public "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $Consumer$Type<(T)>): void
public "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: boolean, arg3: $Consumer$Type<(T)>): void
public "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: $Consumer$Type<(T)>): void
public "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: boolean, arg3: $Class$Type<(T)>, arg4: $Consumer$Type<(T)>): void
public "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: boolean, arg2: $Class$Type<(T)>, arg3: $Consumer$Type<(T)>): void
public "addListener"<T extends $Event>(arg0: $Consumer$Type<(T)>): void
public "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: $Consumer$Type<(T)>): void
public "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: boolean, arg2: $Consumer$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventBus$Type = ($EventBus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventBus_ = $EventBus$Type;
}}
declare module "packages/net/minecraftforge/common/world/$NoneStructureModifier" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$ModifiableStructureInfo$StructureInfo$Builder, $ModifiableStructureInfo$StructureInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo$Builder"
import {$StructureModifier$Phase, $StructureModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$StructureModifier$Phase"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$StructureModifier, $StructureModifier$Type} from "packages/net/minecraftforge/common/world/$StructureModifier"

export class $NoneStructureModifier implements $StructureModifier {
static readonly "INSTANCE": $NoneStructureModifier

constructor()

public "modify"(arg0: $Holder$Type<($Structure$Type)>, arg1: $StructureModifier$Phase$Type, arg2: $ModifiableStructureInfo$StructureInfo$Builder$Type): void
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoneStructureModifier$Type = ($NoneStructureModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoneStructureModifier_ = $NoneStructureModifier$Type;
}}
declare module "packages/net/minecraftforge/gametest/$ForgeGameTestHooks" {
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $ForgeGameTestHooks {

constructor()

public static "prefixGameTestTemplate"(arg0: $Method$Type): boolean
public static "getTemplateNamespace"(arg0: $Method$Type): string
public static "registerGametests"(): void
public static "isGametestServer"(): boolean
public static "isGametestEnabled"(): boolean
get "gametestServer"(): boolean
get "gametestEnabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeGameTestHooks$Type = ($ForgeGameTestHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeGameTestHooks_ = $ForgeGameTestHooks$Type;
}}
declare module "packages/net/minecraftforge/client/event/$EntityRenderersEvent$RegisterLayerDefinitions" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityRenderersEvent, $EntityRenderersEvent$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"

export class $EntityRenderersEvent$RegisterLayerDefinitions extends $EntityRenderersEvent {

constructor()

public "registerLayerDefinition"(arg0: $ModelLayerLocation$Type, arg1: $Supplier$Type<($LayerDefinition$Type)>): void
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRenderersEvent$RegisterLayerDefinitions$Type = ($EntityRenderersEvent$RegisterLayerDefinitions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRenderersEvent$RegisterLayerDefinitions_ = $EntityRenderersEvent$RegisterLayerDefinitions$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$ModFileScanData$AnnotationData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ElementType, $ElementType$Type} from "packages/java/lang/annotation/$ElementType"
import {$Type, $Type$Type} from "packages/org/objectweb/asm/$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModFileScanData$AnnotationData extends $Record {

constructor(annotationType: $Type$Type, targetType: $ElementType$Type, clazz: $Type$Type, memberName: string, annotationData: $Map$Type<(string), (any)>)

public "clazz"(): $Type
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "annotationData"(): $Map<(string), (any)>
public "annotationType"(): $Type
public "targetType"(): $ElementType
public "memberName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFileScanData$AnnotationData$Type = ($ModFileScanData$AnnotationData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFileScanData$AnnotationData_ = $ModFileScanData$AnnotationData$Type;
}}
declare module "packages/net/minecraftforge/network/$ConnectionData$ModMismatchData" {
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ConnectionData, $ConnectionData$Type} from "packages/net/minecraftforge/network/$ConnectionData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConnectionData$ModMismatchData extends $Record {

constructor(mismatchedModData: $Map$Type<($ResourceLocation$Type), (string)>, presentModData: $Map$Type<($ResourceLocation$Type), ($Pair$Type<(string), (string)>)>, mismatchedDataFromServer: boolean)

public "presentModData"(): $Map<($ResourceLocation), ($Pair<(string), (string)>)>
public "mismatchedModData"(): $Map<($ResourceLocation), (string)>
public "containsMismatches"(): boolean
public "mismatchedDataFromServer"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "channel"(arg0: $Map$Type<($ResourceLocation$Type), (string)>, arg1: $ConnectionData$Type, arg2: boolean): $ConnectionData$ModMismatchData
public static "registry"(arg0: $Multimap$Type<($ResourceLocation$Type), ($ResourceLocation$Type)>, arg1: $ConnectionData$Type): $ConnectionData$ModMismatchData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionData$ModMismatchData$Type = ($ConnectionData$ModMismatchData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionData$ModMismatchData_ = $ConnectionData$ModMismatchData$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$TitleScreenModUpdateIndicator" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$Button, $Button$Type} from "packages/net/minecraft/client/gui/components/$Button"
import {$TitleScreen, $TitleScreen$Type} from "packages/net/minecraft/client/gui/screens/$TitleScreen"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TitleScreenModUpdateIndicator extends $Screen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $Button$Type)

public static "init"(arg0: $TitleScreen$Type, arg1: $Button$Type): $TitleScreenModUpdateIndicator
public "m_7856_"(): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TitleScreenModUpdateIndicator$Type = ($TitleScreenModUpdateIndicator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TitleScreenModUpdateIndicator_ = $TitleScreenModUpdateIndicator$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeDispensibleContainerItem" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IForgeDispensibleContainerItem {

 "emptyContents"(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockHitResult$Type, arg4: $ItemStack$Type): boolean
}

export namespace $IForgeDispensibleContainerItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeDispensibleContainerItem$Type = ($IForgeDispensibleContainerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeDispensibleContainerItem_ = $IForgeDispensibleContainerItem$Type;
}}
declare module "packages/net/minecraftforge/common/util/$TriPredicate" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $TriPredicate<T, U, V> {

 "test"(arg0: T, arg1: U, arg2: V): boolean
 "or"(arg0: $TriPredicate$Type<(any), (any), (any)>): $TriPredicate<(T), (U), (V)>
 "negate"(): $TriPredicate<(T), (U), (V)>
 "and"(arg0: $TriPredicate$Type<(any), (any), (any)>): $TriPredicate<(T), (U), (V)>

(arg0: T, arg1: U, arg2: V): boolean
}

export namespace $TriPredicate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TriPredicate$Type<T, U, V> = ($TriPredicate<(T), (U), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TriPredicate_<T, U, V> = $TriPredicate$Type<(T), (U), (V)>;
}}
declare module "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent$Clone" {
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ClientPlayerNetworkEvent, $ClientPlayerNetworkEvent$Type} from "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent"
import {$MultiPlayerGameMode, $MultiPlayerGameMode$Type} from "packages/net/minecraft/client/multiplayer/$MultiPlayerGameMode"

export class $ClientPlayerNetworkEvent$Clone extends $ClientPlayerNetworkEvent {

constructor()
constructor(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type, arg2: $LocalPlayer$Type, arg3: $Connection$Type)

public "getPlayer"(): $LocalPlayer
public "getOldPlayer"(): $LocalPlayer
public "getNewPlayer"(): $LocalPlayer
public "getListenerList"(): $ListenerList
get "player"(): $LocalPlayer
get "oldPlayer"(): $LocalPlayer
get "newPlayer"(): $LocalPlayer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerNetworkEvent$Clone$Type = ($ClientPlayerNetworkEvent$Clone);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerNetworkEvent$Clone_ = $ClientPlayerNetworkEvent$Clone$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkDataEvent$Save" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkDataEvent, $ChunkDataEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkDataEvent"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"

export class $ChunkDataEvent$Save extends $ChunkDataEvent {

constructor(arg0: $ChunkAccess$Type, arg1: $LevelAccessor$Type, arg2: $CompoundTag$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkDataEvent$Save$Type = ($ChunkDataEvent$Save);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkDataEvent$Save_ = $ChunkDataEvent$Save$Type;
}}
declare module "packages/net/minecraftforge/gametest/$GameTestMain" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GameTestMain {

constructor()

public static "main"(arg0: (string)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameTestMain$Type = ($GameTestMain);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameTestMain_ = $GameTestMain$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/$AccessTransformer" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$AccessTransformer$Modifier, $AccessTransformer$Modifier$Type} from "packages/net/minecraftforge/accesstransformer/$AccessTransformer$Modifier"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AccessTransformer$FinalState, $AccessTransformer$FinalState$Type} from "packages/net/minecraftforge/accesstransformer/$AccessTransformer$FinalState"
import {$Target, $Target$Type} from "packages/net/minecraftforge/accesstransformer/$Target"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $AccessTransformer {

constructor(arg0: $Target$Type<(any)>, arg1: $AccessTransformer$Modifier$Type, arg2: $AccessTransformer$FinalState$Type, arg3: string, arg4: integer)

public "toString"(): string
public "getTarget"<T>(): $Target<(T)>
public "isValid"(): boolean
public "applyModifier"<T>(arg0: T, arg1: $Class$Type<(T)>, arg2: $Set$Type<(string)>): void
public "getOrigins"(): $List<(string)>
public "mergeStates"(arg0: $AccessTransformer$Type, arg1: string): $AccessTransformer
get "target"(): $Target<(T)>
get "valid"(): boolean
get "origins"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccessTransformer$Type = ($AccessTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AccessTransformer_ = $AccessTransformer$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent extends $Event {
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor()
constructor(arg0: $TickEvent$Type$Type, arg1: $LogicalSide$Type, arg2: $TickEvent$Phase$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$Type = ($TickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent_ = $TickEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenshotEvent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$File, $File$Type} from "packages/java/io/$File"
import {$NativeImage, $NativeImage$Type} from "packages/com/mojang/blaze3d/platform/$NativeImage"

export class $ScreenshotEvent extends $Event {
static readonly "DEFAULT_CANCEL_REASON": $Component

constructor(arg0: $NativeImage$Type, arg1: $File$Type)
constructor()

public "getScreenshotFile"(): $File
public "getCancelMessage"(): $Component
public "setScreenshotFile"(arg0: $File$Type): void
public "setResultMessage"(arg0: $Component$Type): void
public "getResultMessage"(): $Component
public "isCancelable"(): boolean
public "getImage"(): $NativeImage
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "screenshotFile"(): $File
get "cancelMessage"(): $Component
set "screenshotFile"(value: $File$Type)
set "resultMessage"(value: $Component$Type)
get "resultMessage"(): $Component
get "cancelable"(): boolean
get "image"(): $NativeImage
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenshotEvent$Type = ($ScreenshotEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenshotEvent_ = $ScreenshotEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$IBindingsProvider" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$I18NParser, $I18NParser$Type} from "packages/net/minecraftforge/fml/$I18NParser"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IConfigEvent$ConfigConfig, $IConfigEvent$ConfigConfig$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent$ConfigConfig"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IBindingsProvider {

 "getMessageParser"(): $Supplier<($I18NParser)>
 "getForgeBusSupplier"(): $Supplier<($IEventBus)>
 "getConfigConfiguration"(): $Supplier<($IConfigEvent$ConfigConfig)>
}

export namespace $IBindingsProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBindingsProvider$Type = ($IBindingsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBindingsProvider_ = $IBindingsProvider$Type;
}}
declare module "packages/net/minecraftforge/common/world/$StructureSettingsBuilder" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$TerrainAdjustment, $TerrainAdjustment$Type} from "packages/net/minecraft/world/level/levelgen/structure/$TerrainAdjustment"
import {$StructureSettingsBuilder$StructureSpawnOverrideBuilder, $StructureSettingsBuilder$StructureSpawnOverrideBuilder$Type} from "packages/net/minecraftforge/common/world/$StructureSettingsBuilder$StructureSpawnOverrideBuilder"
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$Structure$StructureSettings, $Structure$StructureSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$StructureSettings"

export class $StructureSettingsBuilder {


public static "copyOf"(arg0: $Structure$StructureSettings$Type): $StructureSettingsBuilder
public "build"(): $Structure$StructureSettings
public "getBiomes"(): $HolderSet<($Biome)>
public "removeSpawnOverrides"(arg0: $MobCategory$Type): void
public "getTerrainAdaptation"(): $TerrainAdjustment
public "setTerrainAdaptation"(arg0: $TerrainAdjustment$Type): void
public "getOrAddSpawnOverrides"(arg0: $MobCategory$Type): $StructureSettingsBuilder$StructureSpawnOverrideBuilder
public "setDecorationStep"(arg0: $GenerationStep$Decoration$Type): void
public "getDecorationStep"(): $GenerationStep$Decoration
public "setBiomes"(arg0: $HolderSet$Type<($Biome$Type)>): void
public "getSpawnOverrides"(arg0: $MobCategory$Type): $StructureSettingsBuilder$StructureSpawnOverrideBuilder
get "biomes"(): $HolderSet<($Biome)>
get "terrainAdaptation"(): $TerrainAdjustment
set "terrainAdaptation"(value: $TerrainAdjustment$Type)
set "decorationStep"(value: $GenerationStep$Decoration$Type)
get "decorationStep"(): $GenerationStep$Decoration
set "biomes"(value: $HolderSet$Type<($Biome$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSettingsBuilder$Type = ($StructureSettingsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureSettingsBuilder_ = $StructureSettingsBuilder$Type;
}}
declare module "packages/net/minecraftforge/server/permission/exceptions/$UnregisteredPermissionException" {
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $UnregisteredPermissionException extends $RuntimeException {

constructor(arg0: $PermissionNode$Type<(any)>)

public "getNode"(): $PermissionNode<(any)>
get "node"(): $PermissionNode<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnregisteredPermissionException$Type = ($UnregisteredPermissionException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnregisteredPermissionException_ = $UnregisteredPermissionException$Type;
}}
declare module "packages/net/minecraftforge/event/level/$LevelEvent$Save" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"

export class $LevelEvent$Save extends $LevelEvent {

constructor(arg0: $LevelAccessor$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEvent$Save$Type = ($LevelEvent$Save);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEvent$Save_ = $LevelEvent$Save$Type;
}}
declare module "packages/net/minecraftforge/event/enchanting/$EnchantmentLevelSetEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EnchantmentLevelSetEvent extends $Event {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: integer, arg3: integer, arg4: $ItemStack$Type, arg5: integer)

public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "isCancelable"(): boolean
public "getEnchantLevel"(): integer
public "getEnchantRow"(): integer
public "setEnchantLevel"(arg0: integer): void
public "getOriginalLevel"(): integer
public "getPower"(): integer
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $Level
get "item"(): $ItemStack
get "cancelable"(): boolean
get "enchantLevel"(): integer
get "enchantRow"(): integer
set "enchantLevel"(value: integer)
get "originalLevel"(): integer
get "power"(): integer
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentLevelSetEvent$Type = ($EnchantmentLevelSetEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentLevelSetEvent_ = $EnchantmentLevelSetEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent$SpawnPlacementCheck" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$MobSpawnType, $MobSpawnType$Type} from "packages/net/minecraft/world/entity/$MobSpawnType"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevelAccessor, $ServerLevelAccessor$Type} from "packages/net/minecraft/world/level/$ServerLevelAccessor"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MobSpawnEvent$SpawnPlacementCheck extends $Event {

constructor()
constructor(arg0: $EntityType$Type<(any)>, arg1: $ServerLevelAccessor$Type, arg2: $MobSpawnType$Type, arg3: $BlockPos$Type, arg4: $RandomSource$Type, arg5: boolean)

public "getLevel"(): $ServerLevelAccessor
public "isCancelable"(): boolean
public "getDefaultResult"(): boolean
public "getEntityType"(): $EntityType<(any)>
public "getSpawnType"(): $MobSpawnType
public "getPos"(): $BlockPos
public "getRandom"(): $RandomSource
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $ServerLevelAccessor
get "cancelable"(): boolean
get "defaultResult"(): boolean
get "entityType"(): $EntityType<(any)>
get "spawnType"(): $MobSpawnType
get "pos"(): $BlockPos
get "random"(): $RandomSource
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnEvent$SpawnPlacementCheck$Type = ($MobSpawnEvent$SpawnPlacementCheck);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobSpawnEvent$SpawnPlacementCheck_ = $MobSpawnEvent$SpawnPlacementCheck$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/common/$IClientBlockExtensions" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ParticleEngine, $ParticleEngine$Type} from "packages/net/minecraft/client/particle/$ParticleEngine"
import {$Vector3d, $Vector3d$Type} from "packages/org/joml/$Vector3d"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IClientBlockExtensions {

 "areBreakingParticlesTinted"(arg0: $BlockState$Type, arg1: $ClientLevel$Type, arg2: $BlockPos$Type): boolean
 "addHitEffects"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $HitResult$Type, arg3: $ParticleEngine$Type): boolean
 "getFogColor"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $Entity$Type, arg4: $Vector3d$Type, arg5: float): $Vector3d
 "addDestroyEffects"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $ParticleEngine$Type): boolean
}

export namespace $IClientBlockExtensions {
const DEFAULT: $IClientBlockExtensions
function of(arg0: $BlockState$Type): $IClientBlockExtensions
function of(arg0: $Block$Type): $IClientBlockExtensions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IClientBlockExtensions$Type = ($IClientBlockExtensions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IClientBlockExtensions_ = $IClientBlockExtensions$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$OrHolderSet" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$CompositeHolderSet, $CompositeHolderSet$Type} from "packages/net/minecraftforge/registries/holdersets/$CompositeHolderSet"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $OrHolderSet<T> extends $CompositeHolderSet<(T)> {

constructor(arg0: $List$Type<($HolderSet$Type<(T)>)>)

public "type"(): $HolderSetType
public "toString"(): string
public static "codec"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>
public static "direct"<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
public static "direct"<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
/**
 * 
 * @deprecated
 */
public static "emptyNamed"<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrHolderSet$Type<T> = ($OrHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrHolderSet_<T> = $OrHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/data/$VanillaSoundDefinitionsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$SoundDefinitionsProvider, $SoundDefinitionsProvider$Type} from "packages/net/minecraftforge/common/data/$SoundDefinitionsProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"

export class $VanillaSoundDefinitionsProvider extends $SoundDefinitionsProvider {

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type)

public "registerSounds"(): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaSoundDefinitionsProvider$Type = ($VanillaSoundDefinitionsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaSoundDefinitionsProvider_ = $VanillaSoundDefinitionsProvider$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderTooltipEvent$Pre" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$RenderTooltipEvent, $RenderTooltipEvent$Type} from "packages/net/minecraftforge/client/event/$RenderTooltipEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"
import {$ClientTooltipPositioner, $ClientTooltipPositioner$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipPositioner"

export class $RenderTooltipEvent$Pre extends $RenderTooltipEvent {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: $Font$Type, arg7: $List$Type<($ClientTooltipComponent$Type)>, arg8: $ClientTooltipPositioner$Type)

public "isCancelable"(): boolean
public "setX"(arg0: integer): void
public "setY"(arg0: integer): void
public "getScreenWidth"(): integer
public "getScreenHeight"(): integer
public "getTooltipPositioner"(): $ClientTooltipPositioner
public "setFont"(arg0: $Font$Type): void
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
set "x"(value: integer)
set "y"(value: integer)
get "screenWidth"(): integer
get "screenHeight"(): integer
get "tooltipPositioner"(): $ClientTooltipPositioner
set "font"(value: $Font$Type)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTooltipEvent$Pre$Type = ($RenderTooltipEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTooltipEvent$Pre_ = $RenderTooltipEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeAdvancementBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export interface $IForgeAdvancementBuilder {

 "save"(arg0: $Consumer$Type<($Advancement$Type)>, arg1: $ResourceLocation$Type, arg2: $ExistingFileHelper$Type): $Advancement
}

export namespace $IForgeAdvancementBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeAdvancementBuilder$Type = ($IForgeAdvancementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeAdvancementBuilder_ = $IForgeAdvancementBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ClimateSettingsBuilder" {
import {$Biome$ClimateSettings, $Biome$ClimateSettings$Type} from "packages/net/minecraft/world/level/biome/$Biome$ClimateSettings"
import {$Biome$TemperatureModifier, $Biome$TemperatureModifier$Type} from "packages/net/minecraft/world/level/biome/$Biome$TemperatureModifier"

export class $ClimateSettingsBuilder {


public static "copyOf"(arg0: $Biome$ClimateSettings$Type): $ClimateSettingsBuilder
public static "create"(arg0: boolean, arg1: float, arg2: $Biome$TemperatureModifier$Type, arg3: float): $ClimateSettingsBuilder
public "build"(): $Biome$ClimateSettings
public "getDownfall"(): float
public "setHasPrecipitation"(arg0: boolean): void
public "getTemperatureModifier"(): $Biome$TemperatureModifier
public "setTemperatureModifier"(arg0: $Biome$TemperatureModifier$Type): void
public "getTemperature"(): float
public "setDownfall"(arg0: float): void
public "setTemperature"(arg0: float): void
public "hasPrecipitation"(): boolean
get "downfall"(): float
get "temperatureModifier"(): $Biome$TemperatureModifier
set "temperatureModifier"(value: $Biome$TemperatureModifier$Type)
get "temperature"(): float
set "downfall"(value: float)
set "temperature"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClimateSettingsBuilder$Type = ($ClimateSettingsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClimateSettingsBuilder_ = $ClimateSettingsBuilder$Type;
}}
declare module "packages/net/minecraftforge/network/$PacketDistributor$PacketTarget" {
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"

export class $PacketDistributor$PacketTarget {


public "send"(arg0: $Packet$Type<(any)>): void
public "getDirection"(): $NetworkDirection
get "direction"(): $NetworkDirection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketDistributor$PacketTarget$Type = ($PacketDistributor$PacketTarget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketDistributor$PacketTarget_ = $PacketDistributor$PacketTarget$Type;
}}
declare module "packages/net/minecraftforge/common/util/$JsonUtils" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"

export class $JsonUtils {

constructor()

public static "readNBT"(arg0: $JsonObject$Type, arg1: string): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$Type = ($JsonUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonUtils_ = $JsonUtils$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBlockState" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$SpawnPlacements$Type, $SpawnPlacements$Type$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$Type"
import {$SignalGetter, $SignalGetter$Type} from "packages/net/minecraft/world/level/$SignalGetter"
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IPlantable, $IPlantable$Type} from "packages/net/minecraftforge/common/$IPlantable"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $IForgeBlockState {

 "rotate"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $Rotation$Type): $BlockState
 "isSlimeBlock"(): boolean
 "addLandingEffects"(arg0: $ServerLevel$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $LivingEntity$Type, arg4: integer): boolean
 "isPortalFrame"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): boolean
 "getExpDrop"(arg0: $LevelReader$Type, arg1: $RandomSource$Type, arg2: $BlockPos$Type, arg3: integer, arg4: integer): integer
 "getBlockPathType"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Mob$Type): $BlockPathTypes
 "hidesNeighborFace"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Direction$Type): boolean
 "canSustainPlant"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $IPlantable$Type): boolean
 "isBurning"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): boolean
 "isLadder"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $LivingEntity$Type): boolean
 "canHarvestBlock"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Player$Type): boolean
 "isFertile"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): boolean
 "isConduitFrame"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): boolean
 "onTreeGrow"(arg0: $LevelReader$Type, arg1: $BiConsumer$Type<($BlockPos$Type), ($BlockState$Type)>, arg2: $RandomSource$Type, arg3: $BlockPos$Type, arg4: $TreeConfiguration$Type): boolean
 "isValidSpawn"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $SpawnPlacements$Type$Type, arg3: $EntityType$Type<(any)>): boolean
 "onNeighborChange"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): void
 "getWeakChanges"(arg0: $LevelReader$Type, arg1: $BlockPos$Type): boolean
 "getRespawnPosition"(arg0: $EntityType$Type<(any)>, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: float, arg4: $LivingEntity$Type): $Optional<($Vec3)>
 "getExplosionResistance"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Explosion$Type): float
 "getEnchantPowerBonus"(arg0: $LevelReader$Type, arg1: $BlockPos$Type): float
 "canDropFromExplosion"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Explosion$Type): boolean
 "shouldDisplayFluidOverlay"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidState$Type): boolean
 "getToolModifiedState"(arg0: $UseOnContext$Type, arg1: $ToolAction$Type, arg2: boolean): $BlockState
 "getBeaconColorMultiplier"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type): (float)[]
 "getAdjacentBlockPathType"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Mob$Type, arg3: $BlockPathTypes$Type): $BlockPathTypes
 "getStateAtViewpoint"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Vec3$Type): $BlockState
 "onDestroyedByPlayer"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Player$Type, arg3: boolean, arg4: $FluidState$Type): boolean
 "supportsExternalFaceHiding"(): boolean
 "canRedstoneConnectTo"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
 "getSoundType"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): $SoundType
 "getFriction"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): float
 "isScaffolding"(arg0: $LivingEntity$Type): boolean
 "isBed"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $LivingEntity$Type): boolean
 "setBedOccupied"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $LivingEntity$Type, arg3: boolean): void
 "getBedDirection"(arg0: $LevelReader$Type, arg1: $BlockPos$Type): $Direction
 "getCloneItemStack"(arg0: $HitResult$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Player$Type): $ItemStack
 "addRunningEffects"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): boolean
 "getLightEmission"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): integer
 "onBlockStateChange"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): void
 "shouldCheckWeakPower"(arg0: $SignalGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
 "isFlammable"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
 "isFireSource"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): boolean
 "canEntityDestroy"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): boolean
 "onBlockExploded"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Explosion$Type): void
 "canStickTo"(arg0: $BlockState$Type): boolean
 "getFireSpreadSpeed"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): integer
 "getFlammability"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): integer
 "onCaughtFire"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $LivingEntity$Type): void
 "isStickyBlock"(): boolean
 "canBeHydrated"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $FluidState$Type, arg3: $BlockPos$Type): boolean
 "getAppearance"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type): $BlockState
 "collisionExtendsVertically"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Entity$Type): boolean
}

export namespace $IForgeBlockState {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBlockState$Type = ($IForgeBlockState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBlockState_ = $IForgeBlockState$Type;
}}
declare module "packages/net/minecraftforge/event/$RegisterGameTestsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $RegisterGameTestsEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Set$Type<($Method$Type)>)

public "register"(arg0: $Method$Type): void
public "register"(arg0: $Class$Type<(any)>): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGameTestsEvent$Type = ($RegisterGameTestsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGameTestsEvent_ = $RegisterGameTestsEvent$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/templates/$FluidTank" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$IFluidTank, $IFluidTank$Type} from "packages/net/minecraftforge/fluids/$IFluidTank"

export class $FluidTank implements $IFluidHandler, $IFluidTank {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $Predicate$Type<($FluidStack$Type)>)

public "isEmpty"(): boolean
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "getSpace"(): integer
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "getCapacity"(): integer
public "setCapacity"(arg0: integer): $FluidTank
public "readFromNBT"(arg0: $CompoundTag$Type): $FluidTank
public "setFluid"(arg0: $FluidStack$Type): void
public "setValidator"(arg0: $Predicate$Type<($FluidStack$Type)>): $FluidTank
public "getFluidAmount"(): integer
public "writeToNBT"(arg0: $CompoundTag$Type): $CompoundTag
public "getTanks"(): integer
public "isFluidValid"(arg0: $FluidStack$Type): boolean
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
public "getFluid"(): $FluidStack
get "empty"(): boolean
get "space"(): integer
get "capacity"(): integer
set "capacity"(value: integer)
set "fluid"(value: $FluidStack$Type)
set "validator"(value: $Predicate$Type<($FluidStack$Type)>)
get "fluidAmount"(): integer
get "tanks"(): integer
get "fluid"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTank$Type = ($FluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTank_ = $FluidTank$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerNegotiationEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Future, $Future$Type} from "packages/java/util/concurrent/$Future"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $PlayerNegotiationEvent extends $Event {

constructor()
constructor(arg0: $Connection$Type, arg1: $GameProfile$Type, arg2: $List$Type<($Future$Type<(void)>)>)

public "getConnection"(): $Connection
public "isCancelable"(): boolean
public "enqueueWork"(arg0: $Runnable$Type): void
public "enqueueWork"(arg0: $Future$Type<(void)>): void
public "getProfile"(): $GameProfile
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "connection"(): $Connection
get "cancelable"(): boolean
get "profile"(): $GameProfile
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerNegotiationEvent$Type = ($PlayerNegotiationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerNegotiationEvent_ = $PlayerNegotiationEvent$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/$INameHandler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $INameHandler {

 "translateFieldName"(arg0: string): string
 "translateClassName"(arg0: string): string
 "translateMethodName"(arg0: string): string
}

export namespace $INameHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INameHandler$Type = ($INameHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INameHandler_ = $INameHandler$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerXpEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerXpEvent extends $PlayerEvent {

constructor(arg0: $Player$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerXpEvent$Type = ($PlayerXpEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerXpEvent_ = $PlayerXpEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$LevelEvent$Load" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"

export class $LevelEvent$Load extends $LevelEvent {

constructor(arg0: $LevelAccessor$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEvent$Load$Type = ($LevelEvent$Load);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEvent$Load_ = $LevelEvent$Load$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingDamageEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingDamageEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float)
constructor()

public "getSource"(): $DamageSource
public "isCancelable"(): boolean
public "setAmount"(arg0: float): void
public "getAmount"(): float
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "cancelable"(): boolean
set "amount"(value: float)
get "amount"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingDamageEvent$Type = ($LivingDamageEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingDamageEvent_ = $LivingDamageEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$LongValue" {
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfigSpec$LongValue extends $ForgeConfigSpec$ConfigValue<(long)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$LongValue$Type = ($ForgeConfigSpec$LongValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$LongValue_ = $ForgeConfigSpec$LongValue$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeMinecraft" {
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export interface $IForgeMinecraft {

 "getLocale"(): $Locale
 "pushGuiLayer"(arg0: $Screen$Type): void
 "popGuiLayer"(): void
}

export namespace $IForgeMinecraft {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeMinecraft$Type = ($IForgeMinecraft);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeMinecraft_ = $IForgeMinecraft$Type;
}}
declare module "packages/net/minecraftforge/common/brewing/$IBrewingRecipe" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IBrewingRecipe {

 "isIngredient"(arg0: $ItemStack$Type): boolean
 "isInput"(arg0: $ItemStack$Type): boolean
 "getOutput"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $ItemStack
}

export namespace $IBrewingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBrewingRecipe$Type = ($IBrewingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBrewingRecipe_ = $IBrewingRecipe$Type;
}}
declare module "packages/net/minecraftforge/common/world/$StructureModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$ModifiableStructureInfo$StructureInfo$Builder, $ModifiableStructureInfo$StructureInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo$Builder"
import {$StructureModifier$Phase, $StructureModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$StructureModifier$Phase"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $StructureModifier {

 "modify"(arg0: $Holder$Type<($Structure$Type)>, arg1: $StructureModifier$Phase$Type, arg2: $ModifiableStructureInfo$StructureInfo$Builder$Type): void
 "codec"(): $Codec<(any)>
}

export namespace $StructureModifier {
const DIRECT_CODEC: $Codec<($StructureModifier)>
const REFERENCE_CODEC: $Codec<($Holder<($StructureModifier)>)>
const LIST_CODEC: $Codec<($HolderSet<($StructureModifier)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureModifier$Type = ($StructureModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureModifier_ = $StructureModifier$Type;
}}
declare module "packages/net/minecraftforge/logging/$CrashReportExtender" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"
import {$File, $File$Type} from "packages/java/io/$File"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$SystemReport, $SystemReport$Type} from "packages/net/minecraft/$SystemReport"
import {$LoadingFailedException, $LoadingFailedException$Type} from "packages/net/minecraftforge/fml/$LoadingFailedException"
import {$CrashReport, $CrashReport$Type} from "packages/net/minecraft/$CrashReport"

export class $CrashReportExtender {

constructor()

public static "extendSystemReport"(arg0: $SystemReport$Type): void
public static "generateEnhancedStackTrace"(arg0: ($StackTraceElement$Type)[]): string
public static "generateEnhancedStackTrace"(arg0: $Throwable$Type, arg1: boolean): string
public static "generateEnhancedStackTrace"(arg0: $Throwable$Type): string
public static "addCrashReportHeader"(arg0: $StringBuilder$Type, arg1: $CrashReport$Type): void
public static "dumpModLoadingCrashReport"(arg0: $Logger$Type, arg1: $LoadingFailedException$Type, arg2: $File$Type): $File
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrashReportExtender$Type = ($CrashReportExtender);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrashReportExtender_ = $CrashReportExtender$Type;
}}
declare module "packages/net/minecraftforge/fml/event/$IModBusEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IModBusEvent {

}

export namespace $IModBusEvent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModBusEvent$Type = ($IModBusEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModBusEvent_ = $IModBusEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$PistonEvent$PistonMoveType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PistonEvent$PistonMoveType extends $Enum<($PistonEvent$PistonMoveType)> {
static readonly "EXTEND": $PistonEvent$PistonMoveType
static readonly "RETRACT": $PistonEvent$PistonMoveType
readonly "isExtend": boolean


public static "values"(): ($PistonEvent$PistonMoveType)[]
public static "valueOf"(arg0: string): $PistonEvent$PistonMoveType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonEvent$PistonMoveType$Type = (("extend") | ("retract")) | ($PistonEvent$PistonMoveType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PistonEvent$PistonMoveType_ = $PistonEvent$PistonMoveType$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterTextureAtlasSpriteLoadersEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ITextureAtlasSpriteLoader, $ITextureAtlasSpriteLoader$Type} from "packages/net/minecraftforge/client/textures/$ITextureAtlasSpriteLoader"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterTextureAtlasSpriteLoadersEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($ITextureAtlasSpriteLoader$Type)>)

public "register"(arg0: string, arg1: $ITextureAtlasSpriteLoader$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterTextureAtlasSpriteLoadersEvent$Type = ($RegisterTextureAtlasSpriteLoadersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterTextureAtlasSpriteLoadersEvent_ = $RegisterTextureAtlasSpriteLoadersEvent$Type;
}}
declare module "packages/net/minecraftforge/server/console/$ConsoleCommandCompleter" {
import {$DedicatedServer, $DedicatedServer$Type} from "packages/net/minecraft/server/dedicated/$DedicatedServer"
import {$Candidate, $Candidate$Type} from "packages/org/jline/reader/$Candidate"
import {$LineReader, $LineReader$Type} from "packages/org/jline/reader/$LineReader"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Completer, $Completer$Type} from "packages/org/jline/reader/$Completer"
import {$ParsedLine, $ParsedLine$Type} from "packages/org/jline/reader/$ParsedLine"

export class $ConsoleCommandCompleter implements $Completer {

constructor(arg0: $DedicatedServer$Type)

public "complete"(arg0: $LineReader$Type, arg1: $ParsedLine$Type, arg2: $List$Type<($Candidate$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleCommandCompleter$Type = ($ConsoleCommandCompleter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleCommandCompleter_ = $ConsoleCommandCompleter$Type;
}}
declare module "packages/net/minecraftforge/internal/$ForgeBindings" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IBindingsProvider, $IBindingsProvider$Type} from "packages/net/minecraftforge/fml/$IBindingsProvider"
import {$I18NParser, $I18NParser$Type} from "packages/net/minecraftforge/fml/$I18NParser"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IConfigEvent$ConfigConfig, $IConfigEvent$ConfigConfig$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent$ConfigConfig"

export class $ForgeBindings implements $IBindingsProvider {

constructor()

public "getMessageParser"(): $Supplier<($I18NParser)>
public "getForgeBusSupplier"(): $Supplier<($IEventBus)>
public "getConfigConfiguration"(): $Supplier<($IConfigEvent$ConfigConfig)>
get "messageParser"(): $Supplier<($I18NParser)>
get "forgeBusSupplier"(): $Supplier<($IEventBus)>
get "configConfiguration"(): $Supplier<($IConfigEvent$ConfigConfig)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBindings$Type = ($ForgeBindings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBindings_ = $ForgeBindings$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeFluidTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$FluidTagsProvider, $FluidTagsProvider$Type} from "packages/net/minecraft/data/tags/$FluidTagsProvider"

export class $ForgeFluidTagsProvider extends $FluidTagsProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "m_6577_"(arg0: $HolderLookup$Provider$Type): void
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFluidTagsProvider$Type = ($ForgeFluidTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFluidTagsProvider_ = $ForgeFluidTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/server/permission/events/$PermissionGatherEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $PermissionGatherEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionGatherEvent$Type = ($PermissionGatherEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionGatherEvent_ = $PermissionGatherEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyPressed$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$KeyPressed, $ScreenEvent$KeyPressed$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyPressed"

export class $ScreenEvent$KeyPressed$Pre extends $ScreenEvent$KeyPressed {

constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)
constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyPressed$Pre$Type = ($ScreenEvent$KeyPressed$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyPressed$Pre_ = $ScreenEvent$KeyPressed$Pre$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingGetProjectileEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingGetProjectileEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type)

public "getProjectileWeaponItemStack"(): $ItemStack
public "setProjectileItemStack"(arg0: $ItemStack$Type): void
public "getProjectileItemStack"(): $ItemStack
public "getListenerList"(): $ListenerList
get "projectileWeaponItemStack"(): $ItemStack
set "projectileItemStack"(value: $ItemStack$Type)
get "projectileItemStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingGetProjectileEvent$Type = ($LivingGetProjectileEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingGetProjectileEvent_ = $LivingGetProjectileEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeRegistryTagManager" {
import {$ITag, $ITag$Type} from "packages/net/minecraftforge/registries/tags/$ITag"
import {$IReverseTag, $IReverseTag$Type} from "packages/net/minecraftforge/registries/tags/$IReverseTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$ITagManager, $ITagManager$Type} from "packages/net/minecraftforge/registries/tags/$ITagManager"

export class $ForgeRegistryTagManager<V> implements $ITagManager<(V)> {


public "iterator"(): $Iterator<($ITag<(V)>)>
public "stream"(): $Stream<($ITag<(V)>)>
public "getTag"(arg0: $TagKey$Type<(V)>): $ITag<(V)>
public "addOptionalTagDefaults"(arg0: $TagKey$Type<(V)>, arg1: $Set$Type<(any)>): void
public "createOptionalTagKey"(arg0: $ResourceLocation$Type, arg1: $Set$Type<(any)>): $TagKey<(V)>
public "getReverseTag"(arg0: V): $Optional<($IReverseTag<(V)>)>
public "getTagNames"(): $Stream<($TagKey<(V)>)>
public "isKnownTagName"(arg0: $TagKey$Type<(V)>): boolean
public "createTagKey"(arg0: $ResourceLocation$Type): $TagKey<(V)>
public "spliterator"(): $Spliterator<($ITag<(V)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ITag<(V)>>;
get "tagNames"(): $Stream<($TagKey<(V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRegistryTagManager$Type<V> = ($ForgeRegistryTagManager<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRegistryTagManager_<V> = $ForgeRegistryTagManager$Type<(V)>;
}}
declare module "packages/net/minecraftforge/client/model/$ItemLayerModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $ItemLayerModel implements $IUnbakedGeometry<($ItemLayerModel)> {


public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemLayerModel$Type = ($ItemLayerModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemLayerModel_ = $ItemLayerModel$Type;
}}
declare module "packages/net/minecraftforge/registries/$RegistryBuilder" {
import {$IForgeRegistry$MissingFactory, $IForgeRegistry$MissingFactory$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$MissingFactory"
import {$IForgeRegistry$BakeCallback, $IForgeRegistry$BakeCallback$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$BakeCallback"
import {$IForgeRegistry$CreateCallback, $IForgeRegistry$CreateCallback$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$CreateCallback"
import {$IForgeRegistry$AddCallback, $IForgeRegistry$AddCallback$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$AddCallback"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IForgeRegistry$ClearCallback, $IForgeRegistry$ClearCallback$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$ClearCallback"
import {$IForgeRegistry$ValidateCallback, $IForgeRegistry$ValidateCallback$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry$ValidateCallback"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $RegistryBuilder<T> {

constructor()

public "add"(arg0: $IForgeRegistry$ValidateCallback$Type<(T)>): $RegistryBuilder<(T)>
public "add"(arg0: $IForgeRegistry$CreateCallback$Type<(T)>): $RegistryBuilder<(T)>
public "add"(arg0: $IForgeRegistry$ClearCallback$Type<(T)>): $RegistryBuilder<(T)>
public "add"(arg0: $IForgeRegistry$AddCallback$Type<(T)>): $RegistryBuilder<(T)>
public "add"(arg0: $IForgeRegistry$BakeCallback$Type<(T)>): $RegistryBuilder<(T)>
public "getDefault"(): $ResourceLocation
public static "of"<T>(): $RegistryBuilder<(T)>
public static "of"<T>(arg0: $ResourceLocation$Type): $RegistryBuilder<(T)>
public static "of"<T>(arg0: string): $RegistryBuilder<(T)>
public "set"(arg0: $IForgeRegistry$MissingFactory$Type<(T)>): $RegistryBuilder<(T)>
public "setName"(arg0: $ResourceLocation$Type): $RegistryBuilder<(T)>
public "missing"(arg0: $IForgeRegistry$MissingFactory$Type<(T)>): $RegistryBuilder<(T)>
public "getAllowModifications"(): boolean
public "legacyName"(arg0: $ResourceLocation$Type): $RegistryBuilder<(T)>
public "legacyName"(arg0: string): $RegistryBuilder<(T)>
public "addCallback"(arg0: any): $RegistryBuilder<(T)>
public "disableSync"(): $RegistryBuilder<(T)>
public "onValidate"(arg0: $IForgeRegistry$ValidateCallback$Type<(T)>): $RegistryBuilder<(T)>
public "disableSaving"(): $RegistryBuilder<(T)>
public "setMaxID"(arg0: integer): $RegistryBuilder<(T)>
public "disableOverrides"(): $RegistryBuilder<(T)>
public "setDefaultKey"(arg0: $ResourceLocation$Type): $RegistryBuilder<(T)>
public "onAdd"(arg0: $IForgeRegistry$AddCallback$Type<(T)>): $RegistryBuilder<(T)>
public "setIDRange"(arg0: integer, arg1: integer): $RegistryBuilder<(T)>
public "getAdd"(): $IForgeRegistry$AddCallback<(T)>
public "getCreate"(): $IForgeRegistry$CreateCallback<(T)>
public "getClear"(): $IForgeRegistry$ClearCallback<(T)>
public "getMaxId"(): integer
public "getValidate"(): $IForgeRegistry$ValidateCallback<(T)>
public "getBake"(): $IForgeRegistry$BakeCallback<(T)>
public "getMissingFactory"(): $IForgeRegistry$MissingFactory<(T)>
public "getAllowOverrides"(): boolean
public "getMinId"(): integer
public "onCreate"(arg0: $IForgeRegistry$CreateCallback$Type<(T)>): $RegistryBuilder<(T)>
public "onBake"(arg0: $IForgeRegistry$BakeCallback$Type<(T)>): $RegistryBuilder<(T)>
public "onClear"(arg0: $IForgeRegistry$ClearCallback$Type<(T)>): $RegistryBuilder<(T)>
public "getSync"(): boolean
public "getSaveToDisc"(): boolean
public "getLegacyNames"(): $Set<($ResourceLocation)>
public "hasTags"(): $RegistryBuilder<(T)>
public "allowModification"(): $RegistryBuilder<(T)>
get "default"(): $ResourceLocation
set "name"(value: $ResourceLocation$Type)
get "allowModifications"(): boolean
set "maxID"(value: integer)
set "defaultKey"(value: $ResourceLocation$Type)
get "create"(): $IForgeRegistry$CreateCallback<(T)>
get "clear"(): $IForgeRegistry$ClearCallback<(T)>
get "maxId"(): integer
get "validate"(): $IForgeRegistry$ValidateCallback<(T)>
get "bake"(): $IForgeRegistry$BakeCallback<(T)>
get "missingFactory"(): $IForgeRegistry$MissingFactory<(T)>
get "allowOverrides"(): boolean
get "minId"(): integer
get "sync"(): boolean
get "saveToDisc"(): boolean
get "legacyNames"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryBuilder$Type<T> = ($RegistryBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryBuilder_<T> = $RegistryBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/registries/$GameData" {
import {$Lifecycle, $Lifecycle$Type} from "packages/com/mojang/serialization/$Lifecycle"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$ForgeRegistry$Snapshot, $ForgeRegistry$Snapshot$Type} from "packages/net/minecraftforge/registries/$ForgeRegistry$Snapshot"
import {$PoiType, $PoiType$Type} from "packages/net/minecraft/world/entity/ai/village/poi/$PoiType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$MappedRegistry, $MappedRegistry$Type} from "packages/net/minecraft/core/$MappedRegistry"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GameData {

constructor()

public static "init"(): void
public static "checkPrefix"(arg0: string, arg1: boolean): $ResourceLocation
public static "getBlockStatePointOfInterestTypeMap"(): $Map<($BlockState), ($PoiType)>
public static "getWrapper"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Lifecycle$Type): $MappedRegistry<(T)>
public static "getWrapper"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Lifecycle$Type, arg2: string): $MappedRegistry<(T)>
public static "vanillaSnapshot"(): void
public static "freezeData"(): void
public static "getBlockStateIDMap"(): $IdMapper<($BlockState)>
public static "unfreezeData"(): void
public static "getBlockItemMap"(): $Map<($Block), ($Item)>
public static "postRegisterEvents"(): void
public static "revertToFrozen"(): void
public static "revertTo"(arg0: $RegistryManager$Type, arg1: boolean): void
public static "revert"(arg0: $RegistryManager$Type, arg1: $ResourceLocation$Type, arg2: boolean): void
public static "injectSnapshot"(arg0: $Map$Type<($ResourceLocation$Type), ($ForgeRegistry$Snapshot$Type)>, arg1: boolean, arg2: boolean): $Multimap<($ResourceLocation), ($ResourceLocation)>
get "blockStatePointOfInterestTypeMap"(): $Map<($BlockState), ($PoiType)>
get "blockStateIDMap"(): $IdMapper<($BlockState)>
get "blockItemMap"(): $Map<($Block), ($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameData$Type = ($GameData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameData_ = $GameData$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$CapabilityDispatcher" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CapabilityDispatcher implements $INBTSerializable<($CompoundTag)>, $ICapabilityProvider {

constructor(arg0: $Map$Type<($ResourceLocation$Type), ($ICapabilityProvider$Type)>, arg1: $List$Type<($Runnable$Type)>)
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($ICapabilityProvider$Type)>, arg1: $List$Type<($Runnable$Type)>, arg2: $ICapabilityProvider$Type)

public "invalidate"(): void
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "areCompatible"(arg0: $CapabilityDispatcher$Type): boolean
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityDispatcher$Type = ($CapabilityDispatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityDispatcher_ = $CapabilityDispatcher$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$AnimalTameEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Animal, $Animal$Type} from "packages/net/minecraft/world/entity/animal/$Animal"

export class $AnimalTameEvent extends $LivingEvent {

constructor()
constructor(arg0: $Animal$Type, arg1: $Player$Type)

public "isCancelable"(): boolean
public "getAnimal"(): $Animal
public "getTamer"(): $Player
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "animal"(): $Animal
get "tamer"(): $Player
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnimalTameEvent$Type = ($AnimalTameEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnimalTameEvent_ = $AnimalTameEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$Phase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TickEvent$Phase extends $Enum<($TickEvent$Phase)> {
static readonly "START": $TickEvent$Phase
static readonly "END": $TickEvent$Phase


public static "values"(): ($TickEvent$Phase)[]
public static "valueOf"(arg0: string): $TickEvent$Phase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$Phase$Type = (("start") | ("end")) | ($TickEvent$Phase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$Phase_ = $TickEvent$Phase$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeLevelChunk" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IForgeLevelChunk extends $ICapabilityProvider {

 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>

(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
}

export namespace $IForgeLevelChunk {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeLevelChunk$Type = ($IForgeLevelChunk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeLevelChunk_ = $IForgeLevelChunk$Type;
}}
declare module "packages/net/minecraftforge/common/util/$BrainBuilder" {
import {$Schedule, $Schedule$Type} from "packages/net/minecraft/world/entity/schedule/$Schedule"
import {$SensorType, $SensorType$Type} from "packages/net/minecraft/world/entity/ai/sensing/$SensorType"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Brain, $Brain$Type} from "packages/net/minecraft/world/entity/ai/$Brain"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Activity, $Activity$Type} from "packages/net/minecraft/world/entity/schedule/$Activity"
import {$BehaviorControl, $BehaviorControl$Type} from "packages/net/minecraft/world/entity/ai/behavior/$BehaviorControl"
import {$Brain$Provider, $Brain$Provider$Type} from "packages/net/minecraft/world/entity/ai/$Brain$Provider"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$MemoryModuleType, $MemoryModuleType$Type} from "packages/net/minecraft/world/entity/ai/memory/$MemoryModuleType"
import {$MemoryStatus, $MemoryStatus$Type} from "packages/net/minecraft/world/entity/ai/memory/$MemoryStatus"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BrainBuilder<E extends $LivingEntity> {

constructor(arg0: $Brain$Type<(E)>)

public "provider"(): $Brain$Provider<(E)>
public "setActiveActivites"(arg0: $Set$Type<($Activity$Type)>): void
public "getSensorTypes"(): $Collection<($SensorType<(any)>)>
public "getMemoryTypes"(): $Collection<($MemoryModuleType<(any)>)>
public "getDefaultActivity"(): $Activity
public "setDefaultActivity"(arg0: $Activity$Type): void
public "getCoreActivities"(): $Set<($Activity)>
public "getActiveActivites"(): $Set<($Activity)>
public "getActivityRequirements"(): $Map<($Activity), ($Set<($Pair<($MemoryModuleType<(any)>), ($MemoryStatus)>)>)>
public "addBehaviorToActivityByPriority"(arg0: integer, arg1: $Activity$Type, arg2: $BehaviorControl$Type<(any)>): void
public "addRequirementsToActivity"(arg0: $Activity$Type, arg1: $Collection$Type<($Pair$Type<($MemoryModuleType$Type<(any)>), ($MemoryStatus$Type)>)>): void
public "addActivityMemoriesToEraseWhenStoppedFrom"(arg0: $Map$Type<($Activity$Type), ($Set$Type<($MemoryModuleType$Type<(any)>)>)>): void
public "addAvailableBehaviorsByPriorityFrom"(arg0: $Map$Type<(integer), ($Map$Type<($Activity$Type), ($Set$Type<($BehaviorControl$Type<(any)>)>)>)>): void
public "addActivityMemoriesToEraseWhenStoppedTo"(arg0: $Map$Type<($Activity$Type), ($Set$Type<($MemoryModuleType$Type<(any)>)>)>): void
public "addAvailableBehaviorsByPriorityTo"(arg0: $Map$Type<(integer), ($Map$Type<($Activity$Type), ($Set$Type<($BehaviorControl$Type<(any)>)>)>)>): void
public "addActivityRequirementsFrom"(arg0: $Map$Type<($Activity$Type), ($Set$Type<($Pair$Type<($MemoryModuleType$Type<(any)>), ($MemoryStatus$Type)>)>)>): void
public "getAvailableBehaviorsByPriority"(): $Map<(integer), ($Map<($Activity), ($Set<($BehaviorControl<(any)>)>)>)>
public "addActivityRequirementsTo"(arg0: $Map$Type<($Activity$Type), ($Set$Type<($Pair$Type<($MemoryModuleType$Type<(any)>), ($MemoryStatus$Type)>)>)>): void
public "getSchedule"(): $Schedule
public "setSchedule"(arg0: $Schedule$Type): void
public "getActivityMemoriesToEraseWhenStopped"(): $Map<($Activity), ($Set<($MemoryModuleType<(any)>)>)>
public "addMemoriesToEraseWhenActivityStopped"(arg0: $Activity$Type, arg1: $Collection$Type<($MemoryModuleType$Type<(any)>)>): void
public "makeBrain"(arg0: $Dynamic$Type<(any)>): $Brain<(E)>
set "activeActivites"(value: $Set$Type<($Activity$Type)>)
get "sensorTypes"(): $Collection<($SensorType<(any)>)>
get "memoryTypes"(): $Collection<($MemoryModuleType<(any)>)>
get "defaultActivity"(): $Activity
set "defaultActivity"(value: $Activity$Type)
get "coreActivities"(): $Set<($Activity)>
get "activeActivites"(): $Set<($Activity)>
get "activityRequirements"(): $Map<($Activity), ($Set<($Pair<($MemoryModuleType<(any)>), ($MemoryStatus)>)>)>
get "availableBehaviorsByPriority"(): $Map<(integer), ($Map<($Activity), ($Set<($BehaviorControl<(any)>)>)>)>
get "schedule"(): $Schedule
set "schedule"(value: $Schedule$Type)
get "activityMemoriesToEraseWhenStopped"(): $Map<($Activity), ($Set<($MemoryModuleType<(any)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrainBuilder$Type<E> = ($BrainBuilder<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BrainBuilder_<E> = $BrainBuilder$Type<(E)>;
}}
declare module "packages/net/minecraftforge/fluids/$FluidUtil" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IFluidHandlerItem, $IFluidHandlerItem$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FluidActionResult, $FluidActionResult$Type} from "packages/net/minecraftforge/fluids/$FluidActionResult"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidUtil {


public static "tryEmptyContainerAndStow"(arg0: $ItemStack$Type, arg1: $IFluidHandler$Type, arg2: $IItemHandler$Type, arg3: integer, arg4: $Player$Type, arg5: boolean): $FluidActionResult
public static "destroyBlockOnFluidPlacement"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public static "tryFillContainerAndStow"(arg0: $ItemStack$Type, arg1: $IFluidHandler$Type, arg2: $IItemHandler$Type, arg3: integer, arg4: $Player$Type, arg5: boolean): $FluidActionResult
public static "tryPlaceFluid"(arg0: $Player$Type, arg1: $Level$Type, arg2: $InteractionHand$Type, arg3: $BlockPos$Type, arg4: $ItemStack$Type, arg5: $FluidStack$Type): $FluidActionResult
public static "tryPlaceFluid"(arg0: $Player$Type, arg1: $Level$Type, arg2: $InteractionHand$Type, arg3: $BlockPos$Type, arg4: $IFluidHandler$Type, arg5: $FluidStack$Type): boolean
public static "tryFillContainer"(arg0: $ItemStack$Type, arg1: $IFluidHandler$Type, arg2: integer, arg3: $Player$Type, arg4: boolean): $FluidActionResult
public static "tryFluidTransfer"(arg0: $IFluidHandler$Type, arg1: $IFluidHandler$Type, arg2: integer, arg3: boolean): $FluidStack
public static "tryFluidTransfer"(arg0: $IFluidHandler$Type, arg1: $IFluidHandler$Type, arg2: $FluidStack$Type, arg3: boolean): $FluidStack
public static "tryEmptyContainer"(arg0: $ItemStack$Type, arg1: $IFluidHandler$Type, arg2: integer, arg3: $Player$Type, arg4: boolean): $FluidActionResult
public static "getFluidHandler"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type): $LazyOptional<($IFluidHandler)>
public static "getFluidHandler"(arg0: $ItemStack$Type): $LazyOptional<($IFluidHandlerItem)>
public static "getFilledBucket"(arg0: $FluidStack$Type): $ItemStack
public static "getFluidContained"(arg0: $ItemStack$Type): $Optional<($FluidStack)>
public static "tryPickUpFluid"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $Level$Type, arg3: $BlockPos$Type, arg4: $Direction$Type): $FluidActionResult
public static "interactWithFluidHandler"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $Level$Type, arg3: $BlockPos$Type, arg4: $Direction$Type): boolean
public static "interactWithFluidHandler"(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $IFluidHandler$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidUtil$Type = ($FluidUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidUtil_ = $FluidUtil$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderTooltipEvent$GatherComponents" {
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $RenderTooltipEvent$GatherComponents extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: integer, arg2: integer, arg3: $List$Type<($Either$Type<($FormattedText$Type), ($TooltipComponent$Type)>)>, arg4: integer)

public "isCancelable"(): boolean
public "getTooltipElements"(): $List<($Either<($FormattedText), ($TooltipComponent)>)>
public "setMaxWidth"(arg0: integer): void
public "getScreenWidth"(): integer
public "getScreenHeight"(): integer
public "getMaxWidth"(): integer
public "getItemStack"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "tooltipElements"(): $List<($Either<($FormattedText), ($TooltipComponent)>)>
set "maxWidth"(value: integer)
get "screenWidth"(): integer
get "screenHeight"(): integer
get "maxWidth"(): integer
get "itemStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTooltipEvent$GatherComponents$Type = ($RenderTooltipEvent$GatherComponents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTooltipEvent$GatherComponents_ = $RenderTooltipEvent$GatherComponents$Type;
}}
declare module "packages/net/minecraftforge/client/$ExtendedServerListData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $ExtendedServerListData extends $Record {

constructor(arg0: string, arg1: boolean, arg2: integer, arg3: string)
constructor(type: string, isCompatible: boolean, numberOfMods: integer, extraReason: string, truncated: boolean)

public "type"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "numberOfMods"(): integer
public "extraReason"(): string
public "truncated"(): boolean
public "isCompatible"(): boolean
get "compatible"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtendedServerListData$Type = ($ExtendedServerListData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtendedServerListData_ = $ExtendedServerListData$Type;
}}
declare module "packages/net/minecraftforge/client/$ClientCommandSourceStack" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Suggestions, $Suggestions$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestions"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$SharedSuggestionProvider$TextCoordinates, $SharedSuggestionProvider$TextCoordinates$Type} from "packages/net/minecraft/commands/$SharedSuggestionProvider$TextCoordinates"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$Vec2, $Vec2$Type} from "packages/net/minecraft/world/phys/$Vec2"
import {$Scoreboard, $Scoreboard$Type} from "packages/net/minecraft/world/scores/$Scoreboard"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$SimpleCommandExceptionType, $SimpleCommandExceptionType$Type} from "packages/com/mojang/brigadier/exceptions/$SimpleCommandExceptionType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Message, $Message$Type} from "packages/com/mojang/brigadier/$Message"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $ClientCommandSourceStack extends $CommandSourceStack {
static readonly "ERROR_NOT_PLAYER": $SimpleCommandExceptionType
static readonly "ERROR_NOT_ENTITY": $SimpleCommandExceptionType
readonly "source": $CommandSource

constructor(arg0: $CommandSource$Type, arg1: $Vec3$Type, arg2: $Vec2$Type, arg3: integer, arg4: string, arg5: $Component$Type, arg6: $Entity$Type)

public "getScoreboard"(): $Scoreboard
public "getOnlinePlayerNames"(): $Collection<(string)>
public "getServer"(): $MinecraftServer
public "getLevel"(): $ServerLevel
public "getUnsidedLevel"(): $Level
public "getAllTeams"(): $Collection<(string)>
public "getRecipeManager"(): $RecipeManager
public "getAdvancement"(arg0: $ResourceLocation$Type): $Advancement
public "levels"(): $Set<($ResourceKey<($Level)>)>
public "registryAccess"(): $RegistryAccess
public "getRecipeNames"(): $Stream<($ResourceLocation)>
public static "suggestResource"(arg0: $Iterable$Type<($ResourceLocation$Type)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "suggestResource"(arg0: $Iterable$Type<($ResourceLocation$Type)>, arg1: $SuggestionsBuilder$Type, arg2: string): $CompletableFuture<($Suggestions)>
public static "suggestResource"(arg0: $Stream$Type<($ResourceLocation$Type)>, arg1: $SuggestionsBuilder$Type, arg2: string): $CompletableFuture<($Suggestions)>
public static "suggest"(arg0: $Iterable$Type<(string)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "suggestCoordinates"(arg0: string, arg1: $Collection$Type<($SharedSuggestionProvider$TextCoordinates$Type)>, arg2: $SuggestionsBuilder$Type, arg3: $Predicate$Type<(string)>): $CompletableFuture<($Suggestions)>
public static "suggest2DCoordinates"(arg0: string, arg1: $Collection$Type<($SharedSuggestionProvider$TextCoordinates$Type)>, arg2: $SuggestionsBuilder$Type, arg3: $Predicate$Type<(string)>): $CompletableFuture<($Suggestions)>
public static "suggestResource"<T>(arg0: $Stream$Type<(T)>, arg1: $SuggestionsBuilder$Type, arg2: $Function$Type<(T), ($ResourceLocation$Type)>, arg3: $Function$Type<(T), ($Message$Type)>): $CompletableFuture<($Suggestions)>
public static "filterResources"<T>(arg0: $Iterable$Type<(T)>, arg1: string, arg2: $Function$Type<(T), ($ResourceLocation$Type)>, arg3: $Consumer$Type<(T)>): void
public static "matchesSubStr"(arg0: string, arg1: string): boolean
public static "filterResources"<T>(arg0: $Iterable$Type<(T)>, arg1: string, arg2: string, arg3: $Function$Type<(T), ($ResourceLocation$Type)>, arg4: $Consumer$Type<(T)>): void
public static "suggestResource"<T>(arg0: $Iterable$Type<(T)>, arg1: $SuggestionsBuilder$Type, arg2: $Function$Type<(T), ($ResourceLocation$Type)>, arg3: $Function$Type<(T), ($Message$Type)>): $CompletableFuture<($Suggestions)>
public static "suggest"(arg0: (string)[], arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "suggestResource"(arg0: $Stream$Type<($ResourceLocation$Type)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "suggest"(arg0: $Stream$Type<(string)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "suggest"<T>(arg0: $Iterable$Type<(T)>, arg1: $SuggestionsBuilder$Type, arg2: $Function$Type<(T), (string)>, arg3: $Function$Type<(T), ($Message$Type)>): $CompletableFuture<($Suggestions)>
get "scoreboard"(): $Scoreboard
get "onlinePlayerNames"(): $Collection<(string)>
get "server"(): $MinecraftServer
get "level"(): $ServerLevel
get "unsidedLevel"(): $Level
get "allTeams"(): $Collection<(string)>
get "recipeManager"(): $RecipeManager
get "recipeNames"(): $Stream<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientCommandSourceStack$Type = ($ClientCommandSourceStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientCommandSourceStack_ = $ClientCommandSourceStack$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/templates/$EmptyFluidHandler" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"

export class $EmptyFluidHandler implements $IFluidHandler {
static readonly "INSTANCE": $EmptyFluidHandler


public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyFluidHandler$Type = ($EmptyFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyFluidHandler_ = $EmptyFluidHandler$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$BlockStateProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TrapDoorBlock, $TrapDoorBlock$Type} from "packages/net/minecraft/world/level/block/$TrapDoorBlock"
import {$PressurePlateBlock, $PressurePlateBlock$Type} from "packages/net/minecraft/world/level/block/$PressurePlateBlock"
import {$ItemModelProvider, $ItemModelProvider$Type} from "packages/net/minecraftforge/client/model/generators/$ItemModelProvider"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$WallSide, $WallSide$Type} from "packages/net/minecraft/world/level/block/state/properties/$WallSide"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$WallBlock, $WallBlock$Type} from "packages/net/minecraft/world/level/block/$WallBlock"
import {$CrossCollisionBlock, $CrossCollisionBlock$Type} from "packages/net/minecraft/world/level/block/$CrossCollisionBlock"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$SlabBlock, $SlabBlock$Type} from "packages/net/minecraft/world/level/block/$SlabBlock"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$VariantBlockStateBuilder, $VariantBlockStateBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$VariantBlockStateBuilder"
import {$FenceGateBlock, $FenceGateBlock$Type} from "packages/net/minecraft/world/level/block/$FenceGateBlock"
import {$IronBarsBlock, $IronBarsBlock$Type} from "packages/net/minecraft/world/level/block/$IronBarsBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"
import {$ConfiguredModel, $ConfiguredModel$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel"
import {$MultiPartBlockStateBuilder, $MultiPartBlockStateBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder"
import {$RotatedPillarBlock, $RotatedPillarBlock$Type} from "packages/net/minecraft/world/level/block/$RotatedPillarBlock"
import {$FenceBlock, $FenceBlock$Type} from "packages/net/minecraft/world/level/block/$FenceBlock"
import {$ButtonBlock, $ButtonBlock$Type} from "packages/net/minecraft/world/level/block/$ButtonBlock"
import {$StandingSignBlock, $StandingSignBlock$Type} from "packages/net/minecraft/world/level/block/$StandingSignBlock"
import {$DoorBlock, $DoorBlock$Type} from "packages/net/minecraft/world/level/block/$DoorBlock"
import {$StairBlock, $StairBlock$Type} from "packages/net/minecraft/world/level/block/$StairBlock"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$WallSignBlock, $WallSignBlock$Type} from "packages/net/minecraft/world/level/block/$WallSignBlock"
import {$BlockModelProvider, $BlockModelProvider$Type} from "packages/net/minecraftforge/client/model/generators/$BlockModelProvider"

export class $BlockStateProvider implements $DataProvider {
static readonly "WALL_PROPS": $ImmutableMap<($Direction), ($Property<($WallSide)>)>

constructor(arg0: $PackOutput$Type, arg1: string, arg2: $ExistingFileHelper$Type)

public "blockTexture"(arg0: $Block$Type): $ResourceLocation
public "cubeAll"(arg0: $Block$Type): $ModelFile
public "mcLoc"(arg0: string): $ResourceLocation
public "getVariantBuilder"(arg0: $Block$Type): $VariantBlockStateBuilder
public "axisBlock"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type): void
public "axisBlock"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "axisBlock"(arg0: $RotatedPillarBlock$Type): void
public "axisBlock"(arg0: $RotatedPillarBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "simpleBlockItem"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "directionalBlock"(arg0: $Block$Type, arg1: $ModelFile$Type, arg2: integer): void
public "directionalBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>): void
public "directionalBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>, arg2: integer): void
public "directionalBlock"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "stairsBlock"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type): void
public "stairsBlock"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type): void
public "stairsBlock"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): void
public "stairsBlock"(arg0: $StairBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type): void
public "stairsBlock"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "buttonBlock"(arg0: $ButtonBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "buttonBlock"(arg0: $ButtonBlock$Type, arg1: $ResourceLocation$Type): void
public "signBlock"(arg0: $StandingSignBlock$Type, arg1: $WallSignBlock$Type, arg2: $ModelFile$Type): void
public "signBlock"(arg0: $StandingSignBlock$Type, arg1: $WallSignBlock$Type, arg2: $ResourceLocation$Type): void
public "pressurePlateBlock"(arg0: $PressurePlateBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "pressurePlateBlock"(arg0: $PressurePlateBlock$Type, arg1: $ResourceLocation$Type): void
public "fourWayBlock"(arg0: $CrossCollisionBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type): void
public "fourWayMultipart"(arg0: $MultiPartBlockStateBuilder$Type, arg1: $ModelFile$Type): void
public "paneBlock"(arg0: $IronBarsBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type, arg4: $ModelFile$Type, arg5: $ModelFile$Type): void
public "paneBlock"(arg0: $IronBarsBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "paneBlock"(arg0: $IronBarsBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "doorBlock"(arg0: $DoorBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type, arg4: $ModelFile$Type, arg5: $ModelFile$Type, arg6: $ModelFile$Type, arg7: $ModelFile$Type, arg8: $ModelFile$Type): void
public "doorBlock"(arg0: $DoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "doorBlock"(arg0: $DoorBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "trapdoorBlock"(arg0: $TrapDoorBlock$Type, arg1: $ResourceLocation$Type, arg2: boolean): void
public "trapdoorBlock"(arg0: $TrapDoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: boolean): void
public "trapdoorBlock"(arg0: $TrapDoorBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type, arg4: boolean): void
public "simpleBlock"(arg0: $Block$Type, ...arg1: ($ConfiguredModel$Type)[]): void
public "simpleBlock"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "simpleBlock"(arg0: $Block$Type): void
public "simpleBlock"(arg0: $Block$Type, arg1: $Function$Type<($ModelFile$Type), (($ConfiguredModel$Type)[])>): void
public "models"(): $BlockModelProvider
public "itemModels"(): $ItemModelProvider
public "logBlock"(arg0: $RotatedPillarBlock$Type): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type, arg5: $ResourceLocation$Type): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: string): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: string): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type, arg5: string): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "stairsBlockWithRenderType"(arg0: $StairBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "wallBlockWithRenderType"(arg0: $WallBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "wallBlockWithRenderType"(arg0: $WallBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: string): void
public "wallBlockWithRenderType"(arg0: $WallBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "wallBlockWithRenderType"(arg0: $WallBlock$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "horizontalFaceBlock"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "horizontalFaceBlock"(arg0: $Block$Type, arg1: $ModelFile$Type, arg2: integer): void
public "horizontalFaceBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>, arg2: integer): void
public "horizontalFaceBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>): void
public "logBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type): void
public "logBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: string): void
public "trapdoorBlockWithRenderType"(arg0: $TrapDoorBlock$Type, arg1: $ResourceLocation$Type, arg2: boolean, arg3: string): void
public "trapdoorBlockWithRenderType"(arg0: $TrapDoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: boolean, arg4: $ResourceLocation$Type): void
public "trapdoorBlockWithRenderType"(arg0: $TrapDoorBlock$Type, arg1: $ResourceLocation$Type, arg2: boolean, arg3: $ResourceLocation$Type): void
public "trapdoorBlockWithRenderType"(arg0: $TrapDoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: boolean, arg4: string): void
public "getMultipartBuilder"(arg0: $Block$Type): $MultiPartBlockStateBuilder
public "paneBlockWithRenderType"(arg0: $IronBarsBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "paneBlockWithRenderType"(arg0: $IronBarsBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: string): void
public "paneBlockWithRenderType"(arg0: $IronBarsBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: string): void
public "paneBlockWithRenderType"(arg0: $IronBarsBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): void
public "fenceGateBlockWithRenderType"(arg0: $FenceGateBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "fenceGateBlockWithRenderType"(arg0: $FenceGateBlock$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "fenceGateBlockWithRenderType"(arg0: $FenceGateBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: string): void
public "fenceGateBlockWithRenderType"(arg0: $FenceGateBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "doorBlockWithRenderType"(arg0: $DoorBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: string): void
public "doorBlockWithRenderType"(arg0: $DoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): void
public "doorBlockWithRenderType"(arg0: $DoorBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "doorBlockWithRenderType"(arg0: $DoorBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: string): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: string): void
public "axisBlockWithRenderType"(arg0: $RotatedPillarBlock$Type, arg1: string): void
public "fenceBlockWithRenderType"(arg0: $FenceBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "fenceBlockWithRenderType"(arg0: $FenceBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "fenceBlockWithRenderType"(arg0: $FenceBlock$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "fenceBlockWithRenderType"(arg0: $FenceBlock$Type, arg1: string, arg2: $ResourceLocation$Type, arg3: string): void
public "simpleBlockWithItem"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "horizontalBlock"(arg0: $Block$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type): void
public "horizontalBlock"(arg0: $Block$Type, arg1: $ModelFile$Type, arg2: integer): void
public "horizontalBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>, arg2: integer): void
public "horizontalBlock"(arg0: $Block$Type, arg1: $ModelFile$Type): void
public "horizontalBlock"(arg0: $Block$Type, arg1: $Function$Type<($BlockState$Type), ($ModelFile$Type)>): void
public "modLoc"(arg0: string): $ResourceLocation
public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public "slabBlock"(arg0: $SlabBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type): void
public "slabBlock"(arg0: $SlabBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type): void
public "slabBlock"(arg0: $SlabBlock$Type, arg1: $ResourceLocation$Type, arg2: $ResourceLocation$Type, arg3: $ResourceLocation$Type, arg4: $ResourceLocation$Type): void
public "wallBlock"(arg0: $WallBlock$Type, arg1: $ResourceLocation$Type): void
public "wallBlock"(arg0: $WallBlock$Type, arg1: string, arg2: $ResourceLocation$Type): void
public "wallBlock"(arg0: $WallBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type): void
public "fenceBlock"(arg0: $FenceBlock$Type, arg1: $ResourceLocation$Type): void
public "fenceBlock"(arg0: $FenceBlock$Type, arg1: string, arg2: $ResourceLocation$Type): void
public "fenceGateBlock"(arg0: $FenceGateBlock$Type, arg1: $ModelFile$Type, arg2: $ModelFile$Type, arg3: $ModelFile$Type, arg4: $ModelFile$Type): void
public "fenceGateBlock"(arg0: $FenceGateBlock$Type, arg1: $ResourceLocation$Type): void
public "fenceGateBlock"(arg0: $FenceGateBlock$Type, arg1: string, arg2: $ResourceLocation$Type): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProvider$Type = ($BlockStateProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateProvider_ = $BlockStateProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$ChorusFruit" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $EntityTeleportEvent$ChorusFruit extends $EntityTeleportEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: double, arg2: double, arg3: double)

public "isCancelable"(): boolean
public "getEntityLiving"(): $LivingEntity
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "entityLiving"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$ChorusFruit$Type = ($EntityTeleportEvent$ChorusFruit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent$ChorusFruit_ = $EntityTeleportEvent$ChorusFruit$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ModelEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $ModelEvent extends $Event {


public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelEvent$Type = ($ModelEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelEvent_ = $ModelEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$PlayLevelSoundEvent" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"

export class $PlayLevelSoundEvent extends $Event {

constructor()
constructor(arg0: $Level$Type, arg1: $Holder$Type<($SoundEvent$Type)>, arg2: $SoundSource$Type, arg3: float, arg4: float)

public "getLevel"(): $Level
public "getSource"(): $SoundSource
public "isCancelable"(): boolean
public "setSource"(arg0: $SoundSource$Type): void
public "setSound"(arg0: $Holder$Type<($SoundEvent$Type)>): void
public "setNewPitch"(arg0: float): void
public "setNewVolume"(arg0: float): void
public "getOriginalPitch"(): float
public "getOriginalVolume"(): float
public "getNewPitch"(): float
public "getNewVolume"(): float
public "getSound"(): $Holder<($SoundEvent)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $Level
get "source"(): $SoundSource
get "cancelable"(): boolean
set "source"(value: $SoundSource$Type)
set "sound"(value: $Holder$Type<($SoundEvent$Type)>)
set "newPitch"(value: float)
set "newVolume"(value: float)
get "originalPitch"(): float
get "originalVolume"(): float
get "newPitch"(): float
get "newVolume"(): float
get "sound"(): $Holder<($SoundEvent)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayLevelSoundEvent$Type = ($PlayLevelSoundEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayLevelSoundEvent_ = $PlayLevelSoundEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$ServerLevelAccessor, $ServerLevelAccessor$Type} from "packages/net/minecraft/world/level/$ServerLevelAccessor"

export class $MobSpawnEvent extends $EntityEvent {

constructor()

public "getLevel"(): $ServerLevelAccessor
public "getY"(): double
public "getZ"(): double
public "getX"(): double
public "getEntity"(): $Mob
public "getListenerList"(): $ListenerList
get "level"(): $ServerLevelAccessor
get "y"(): double
get "z"(): double
get "x"(): double
get "entity"(): $Mob
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnEvent$Type = ($MobSpawnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobSpawnEvent_ = $MobSpawnEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$ITeleporter" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$PortalInfo, $PortalInfo$Type} from "packages/net/minecraft/world/level/portal/$PortalInfo"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $ITeleporter {

 "playTeleportSound"(arg0: $ServerPlayer$Type, arg1: $ServerLevel$Type, arg2: $ServerLevel$Type): boolean
 "placeEntity"(arg0: $Entity$Type, arg1: $ServerLevel$Type, arg2: $ServerLevel$Type, arg3: float, arg4: $Function$Type<(boolean), ($Entity$Type)>): $Entity
 "getPortalInfo"(arg0: $Entity$Type, arg1: $ServerLevel$Type, arg2: $Function$Type<($ServerLevel$Type), ($PortalInfo$Type)>): $PortalInfo
 "isVanilla"(): boolean
}

export namespace $ITeleporter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITeleporter$Type = ($ITeleporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITeleporter_ = $ITeleporter$Type;
}}
declare module "packages/net/minecraftforge/client/model/$ForgeFaceData" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ForgeFaceData extends $Record {
static readonly "DEFAULT": $ForgeFaceData
static readonly "COLOR": $Codec<(integer)>
static readonly "CODEC": $Codec<($ForgeFaceData)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: boolean)
constructor(color: integer, blockLight: integer, skyLight: integer, ambientOcclusion: boolean, calculateNormals: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "read"(arg0: $JsonElement$Type, arg1: $ForgeFaceData$Type): $ForgeFaceData
public "color"(): integer
public "calculateNormals"(): boolean
public "ambientOcclusion"(): boolean
public "skyLight"(): integer
public "blockLight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFaceData$Type = ($ForgeFaceData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFaceData_ = $ForgeFaceData$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkWatchEvent$Watch" {
import {$ChunkWatchEvent, $ChunkWatchEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkWatchEvent"
import {$LevelChunk, $LevelChunk$Type} from "packages/net/minecraft/world/level/chunk/$LevelChunk"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $ChunkWatchEvent$Watch extends $ChunkWatchEvent {

constructor()
constructor(arg0: $ServerPlayer$Type, arg1: $LevelChunk$Type, arg2: $ServerLevel$Type)

public "getChunk"(): $LevelChunk
public "getListenerList"(): $ListenerList
get "chunk"(): $LevelChunk
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkWatchEvent$Watch$Type = ($ChunkWatchEvent$Watch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkWatchEvent$Watch_ = $ChunkWatchEvent$Watch$Type;
}}
declare module "packages/net/minecraftforge/client/event/$EntityRenderersEvent$AddLayers" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$EntityRendererProvider$Context, $EntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider$Context"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityRenderersEvent, $EntityRenderersEvent$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LivingEntityRenderer, $LivingEntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$LivingEntityRenderer"
import {$EntityRenderer, $EntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRenderer"
import {$EntityModelSet, $EntityModelSet$Type} from "packages/net/minecraft/client/model/geom/$EntityModelSet"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EntityRenderersEvent$AddLayers extends $EntityRenderersEvent {

constructor(arg0: $Map$Type<($EntityType$Type<(any)>), ($EntityRenderer$Type<(any)>)>, arg1: $Map$Type<(string), ($EntityRenderer$Type<(any)>)>, arg2: $EntityRendererProvider$Context$Type)
constructor()

public "getContext"(): $EntityRendererProvider$Context
public "getSkins"(): $Set<(string)>
public "getEntityModels"(): $EntityModelSet
public "getSkin"<R extends $LivingEntityRenderer<(any), (any)>>(arg0: string): R
public "getRenderer"<T extends $LivingEntity, R extends $LivingEntityRenderer<(T), (any)>>(arg0: $EntityType$Type<(any)>): R
public "getListenerList"(): $ListenerList
get "context"(): $EntityRendererProvider$Context
get "skins"(): $Set<(string)>
get "entityModels"(): $EntityModelSet
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRenderersEvent$AddLayers$Type = ($EntityRenderersEvent$AddLayers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRenderersEvent$AddLayers_ = $EntityRenderersEvent$AddLayers$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$IEventBus" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$GenericEvent, $GenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$GenericEvent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IEventBusInvokeDispatcher, $IEventBusInvokeDispatcher$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBusInvokeDispatcher"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$EventPriority, $EventPriority$Type} from "packages/net/minecraftforge/eventbus/api/$EventPriority"

export interface $IEventBus {

 "shutdown"(): void
 "start"(): void
 "register"(arg0: any): void
 "unregister"(arg0: any): void
 "post"(arg0: $Event$Type, arg1: $IEventBusInvokeDispatcher$Type): boolean
 "post"(arg0: $Event$Type): boolean
 "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: boolean, arg3: $Consumer$Type<(T)>): void
 "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: boolean, arg3: $Class$Type<(T)>, arg4: $Consumer$Type<(T)>): void
 "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $EventPriority$Type, arg2: $Consumer$Type<(T)>): void
 "addGenericListener"<T extends $GenericEvent<(any)>, F>(arg0: $Class$Type<(F)>, arg1: $Consumer$Type<(T)>): void
 "addListener"<T extends $Event>(arg0: $Consumer$Type<(T)>): void
 "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: boolean, arg2: $Consumer$Type<(T)>): void
 "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: boolean, arg2: $Class$Type<(T)>, arg3: $Consumer$Type<(T)>): void
 "addListener"<T extends $Event>(arg0: $EventPriority$Type, arg1: $Consumer$Type<(T)>): void
}

export namespace $IEventBus {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventBus$Type = ($IEventBus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventBus_ = $IEventBus$Type;
}}
declare module "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent$DebugText" {
import {$CustomizeGuiOverlayEvent, $CustomizeGuiOverlayEvent$Type} from "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $CustomizeGuiOverlayEvent$DebugText extends $CustomizeGuiOverlayEvent {

constructor()
constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: $ArrayList$Type<(string)>, arg4: $ArrayList$Type<(string)>)

public "getRight"(): $ArrayList<(string)>
public "getLeft"(): $ArrayList<(string)>
public "getListenerList"(): $ListenerList
get "right"(): $ArrayList<(string)>
get "left"(): $ArrayList<(string)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomizeGuiOverlayEvent$DebugText$Type = ($CustomizeGuiOverlayEvent$DebugText);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomizeGuiOverlayEvent$DebugText_ = $CustomizeGuiOverlayEvent$DebugText$Type;
}}
declare module "packages/net/minecraftforge/common/data/$SpriteSourceProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$JsonCodecProvider, $JsonCodecProvider$Type} from "packages/net/minecraftforge/common/data/$JsonCodecProvider"
import {$SpriteSource, $SpriteSource$Type} from "packages/net/minecraft/client/renderer/texture/atlas/$SpriteSource"

export class $SpriteSourceProvider extends $JsonCodecProvider<($List<($SpriteSource)>)> {

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type, arg2: string)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpriteSourceProvider$Type = ($SpriteSourceProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpriteSourceProvider_ = $SpriteSourceProvider$Type;
}}
declare module "packages/net/minecraftforge/fluids/$IFluidTank" {
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"

export interface $IFluidTank {

 "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
 "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "getCapacity"(): integer
 "getFluidAmount"(): integer
 "isFluidValid"(arg0: $FluidStack$Type): boolean
 "getFluid"(): $FluidStack
}

export namespace $IFluidTank {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidTank$Type = ($IFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidTank_ = $IFluidTank$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderHighlightEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"

export class $RenderHighlightEvent extends $Event {

constructor()

public "getTarget"(): $HitResult
public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getCamera"(): $Camera
public "getLevelRenderer"(): $LevelRenderer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "target"(): $HitResult
get "partialTick"(): float
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "camera"(): $Camera
get "levelRenderer"(): $LevelRenderer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderHighlightEvent$Type = ($RenderHighlightEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderHighlightEvent_ = $RenderHighlightEvent$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$Event$Result" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Event$Result extends $Enum<($Event$Result)> {
static readonly "DENY": $Event$Result
static readonly "DEFAULT": $Event$Result
static readonly "ALLOW": $Event$Result


public static "values"(): ($Event$Result)[]
public static "valueOf"(arg0: string): $Event$Result
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Event$Result$Type = (("allow") | ("deny") | ("default")) | ($Event$Result);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Event$Result_ = $Event$Result$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PermissionsChangedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PermissionsChangedEvent extends $PlayerEvent {

constructor()
constructor(arg0: $ServerPlayer$Type, arg1: integer, arg2: integer)

public "isCancelable"(): boolean
public "getOldLevel"(): integer
public "getNewLevel"(): integer
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "oldLevel"(): integer
get "newLevel"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionsChangedEvent$Type = ($PermissionsChangedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionsChangedEvent_ = $PermissionsChangedEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$WorldWorkerManager" {
import {$WorldWorkerManager$IWorker, $WorldWorkerManager$IWorker$Type} from "packages/net/minecraftforge/common/$WorldWorkerManager$IWorker"

export class $WorldWorkerManager {

constructor()

public static "clear"(): void
public static "tick"(arg0: boolean): void
public static "addWorker"(arg0: $WorldWorkerManager$IWorker$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldWorkerManager$Type = ($WorldWorkerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldWorkerManager_ = $WorldWorkerManager$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$AttackEntityEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AttackEntityEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Entity$Type)

public "getTarget"(): $Entity
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "target"(): $Entity
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttackEntityEvent$Type = ($AttackEntityEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttackEntityEvent_ = $AttackEntityEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$DisplayWindow" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$ImmediateWindowProvider, $ImmediateWindowProvider$Type} from "packages/net/minecraftforge/fml/loading/$ImmediateWindowProvider"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RenderElement$DisplayContext, $RenderElement$DisplayContext$Type} from "packages/net/minecraftforge/fml/earlydisplay/$RenderElement$DisplayContext"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ModuleLayer, $ModuleLayer$Type} from "packages/java/lang/$ModuleLayer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DisplayWindow implements $ImmediateWindowProvider {

constructor()

public "name"(): string
public "context"(): $RenderElement$DisplayContext
public "start"(arg0: string, arg1: string): $Runnable
public "initialize"(arg0: (string)[]): $Runnable
public "close"(): void
public "updateModuleReads"(arg0: $ModuleLayer$Type): void
public "periodicTick"(): void
public "getGLVersion"(): string
public "loadingOverlay"<T>(arg0: $Supplier$Type<(any)>, arg1: $Supplier$Type<(any)>, arg2: $Consumer$Type<($Optional$Type<($Throwable$Type)>)>, arg3: boolean): $Supplier<(T)>
public "render"(arg0: integer): void
public "positionWindow"(arg0: $Optional$Type<(any)>, arg1: $IntConsumer$Type, arg2: $IntConsumer$Type, arg3: $IntConsumer$Type, arg4: $IntConsumer$Type): boolean
public "initWindow"(arg0: string): void
public "addMojangTexture"(arg0: integer): void
public "updateFramebufferSize"(arg0: $IntConsumer$Type, arg1: $IntConsumer$Type): void
public "setupMinecraftWindow"(arg0: $IntSupplier$Type, arg1: $IntSupplier$Type, arg2: $Supplier$Type<(string)>, arg3: $LongSupplier$Type): long
public "getFramebufferTextureId"(): integer
get "gLVersion"(): string
get "framebufferTextureId"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayWindow$Type = ($DisplayWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisplayWindow_ = $DisplayWindow$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$RootTransformsBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$TransformationHelper$TransformOrigin, $TransformationHelper$TransformOrigin$Type} from "packages/net/minecraftforge/common/util/$TransformationHelper$TransformOrigin"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $ModelBuilder$RootTransformsBuilder {


public "scale"(arg0: $Vector3f$Type): $ModelBuilder$RootTransformsBuilder<>
public "scale"(arg0: float): $ModelBuilder$RootTransformsBuilder<>
public "scale"(arg0: float, arg1: float, arg2: float): $ModelBuilder$RootTransformsBuilder<>
public "end"(): $ModelBuilder<(T)>
public "transform"(arg0: $Transformation$Type): $ModelBuilder$RootTransformsBuilder<>
public "origin"(arg0: $Vector3f$Type): $ModelBuilder$RootTransformsBuilder<>
public "origin"(arg0: $TransformationHelper$TransformOrigin$Type): $ModelBuilder$RootTransformsBuilder<>
public "toJson"(): $JsonObject
public "translation"(arg0: $Vector3f$Type): $ModelBuilder$RootTransformsBuilder<>
public "translation"(arg0: float, arg1: float, arg2: float): $ModelBuilder$RootTransformsBuilder<>
public "rotation"(arg0: float, arg1: float, arg2: float, arg3: boolean): $ModelBuilder$RootTransformsBuilder<>
public "rotation"(arg0: $Quaternionf$Type): $ModelBuilder$RootTransformsBuilder<>
public "leftRotation"(arg0: float, arg1: float, arg2: float, arg3: boolean): $ModelBuilder$RootTransformsBuilder<>
public "leftRotation"(arg0: $Quaternionf$Type): $ModelBuilder$RootTransformsBuilder<>
public "postRotation"(arg0: float, arg1: float, arg2: float, arg3: boolean): $ModelBuilder$RootTransformsBuilder<>
public "postRotation"(arg0: $Quaternionf$Type): $ModelBuilder$RootTransformsBuilder<>
public "rightRotation"(arg0: float, arg1: float, arg2: float, arg3: boolean): $ModelBuilder$RootTransformsBuilder<>
public "rightRotation"(arg0: $Quaternionf$Type): $ModelBuilder$RootTransformsBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$RootTransformsBuilder$Type = ($ModelBuilder$RootTransformsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$RootTransformsBuilder_ = $ModelBuilder$RootTransformsBuilder$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingJumpEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEvent$LivingJumpEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEvent$LivingJumpEvent$Type = ($LivingEvent$LivingJumpEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEvent$LivingJumpEvent_ = $LivingEvent$LivingJumpEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgePotion" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IForgePotion {

 "isFoil"(arg0: $ItemStack$Type): boolean
}

export namespace $IForgePotion {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgePotion$Type = ($IForgePotion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgePotion_ = $IForgePotion$Type;
}}
declare module "packages/net/minecraftforge/logging/$CrashReportAnalyser" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$StackTraceElement, $StackTraceElement$Type} from "packages/java/lang/$StackTraceElement"

export class $CrashReportAnalyser {


public static "appendSuspectedMods"(arg0: $Throwable$Type, arg1: ($StackTraceElement$Type)[]): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrashReportAnalyser$Type = ($CrashReportAnalyser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CrashReportAnalyser_ = $CrashReportAnalyser$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterDimensionSpecialEffectsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$DimensionSpecialEffects, $DimensionSpecialEffects$Type} from "packages/net/minecraft/client/renderer/$DimensionSpecialEffects"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterDimensionSpecialEffectsEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($DimensionSpecialEffects$Type)>)

public "register"(arg0: $ResourceLocation$Type, arg1: $DimensionSpecialEffects$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterDimensionSpecialEffectsEvent$Type = ($RegisterDimensionSpecialEffectsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterDimensionSpecialEffectsEvent_ = $RegisterDimensionSpecialEffectsEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent$FinalizeSpawn" {
import {$SpawnGroupData, $SpawnGroupData$Type} from "packages/net/minecraft/world/entity/$SpawnGroupData"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobSpawnEvent, $MobSpawnEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobSpawnEvent"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$MobSpawnType, $MobSpawnType$Type} from "packages/net/minecraft/world/entity/$MobSpawnType"
import {$BaseSpawner, $BaseSpawner$Type} from "packages/net/minecraft/world/level/$BaseSpawner"
import {$ServerLevelAccessor, $ServerLevelAccessor$Type} from "packages/net/minecraft/world/level/$ServerLevelAccessor"
import {$DifficultyInstance, $DifficultyInstance$Type} from "packages/net/minecraft/world/$DifficultyInstance"

export class $MobSpawnEvent$FinalizeSpawn extends $MobSpawnEvent {

constructor()
constructor(arg0: $Mob$Type, arg1: $ServerLevelAccessor$Type, arg2: double, arg3: double, arg4: double, arg5: $DifficultyInstance$Type, arg6: $MobSpawnType$Type, arg7: $SpawnGroupData$Type, arg8: $CompoundTag$Type, arg9: $BaseSpawner$Type)

public "isCancelable"(): boolean
public "getSpawnData"(): $SpawnGroupData
public "getDifficulty"(): $DifficultyInstance
public "getSpawnTag"(): $CompoundTag
public "setSpawnCancelled"(arg0: boolean): void
public "getSpawnType"(): $MobSpawnType
public "isSpawnCancelled"(): boolean
public "setDifficulty"(arg0: $DifficultyInstance$Type): void
public "setSpawnData"(arg0: $SpawnGroupData$Type): void
public "setSpawnTag"(arg0: $CompoundTag$Type): void
public "getSpawner"(): $BaseSpawner
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "spawnData"(): $SpawnGroupData
get "difficulty"(): $DifficultyInstance
get "spawnTag"(): $CompoundTag
set "spawnCancelled"(value: boolean)
get "spawnType"(): $MobSpawnType
get "spawnCancelled"(): boolean
set "difficulty"(value: $DifficultyInstance$Type)
set "spawnData"(value: $SpawnGroupData$Type)
set "spawnTag"(value: $CompoundTag$Type)
get "spawner"(): $BaseSpawner
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnEvent$FinalizeSpawn$Type = ($MobSpawnEvent$FinalizeSpawn);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobSpawnEvent$FinalizeSpawn_ = $MobSpawnEvent$FinalizeSpawn$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$CapabilityManager" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CapabilityToken, $CapabilityToken$Type} from "packages/net/minecraftforge/common/capabilities/$CapabilityToken"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ModFileScanData, $ModFileScanData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData"

export class $CapabilityManager extends $Enum<($CapabilityManager)> {
static readonly "INSTANCE": $CapabilityManager


public static "get"<T>(arg0: $CapabilityToken$Type<(T)>): $Capability<(T)>
public static "values"(): ($CapabilityManager)[]
public static "valueOf"(arg0: string): $CapabilityManager
public "injectCapabilities"(arg0: $List$Type<($ModFileScanData$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityManager$Type = (("instance")) | ($CapabilityManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityManager_ = $CapabilityManager$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$NetworkFilters" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"

export class $NetworkFilters {


public static "injectIfNecessary"(arg0: $Connection$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkFilters$Type = ($NetworkFilters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkFilters_ = $NetworkFilters$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent$Stop" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityUseItemEvent, $LivingEntityUseItemEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEntityUseItemEvent$Stop extends $LivingEntityUseItemEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityUseItemEvent$Stop$Type = ($LivingEntityUseItemEvent$Stop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityUseItemEvent$Stop_ = $LivingEntityUseItemEvent$Stop$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBlockEntity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$ICapabilitySerializable, $ICapabilitySerializable$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilitySerializable"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IForgeBlockEntity extends $ICapabilitySerializable<($CompoundTag)> {

 "getPersistentData"(): $CompoundTag
 "onLoad"(): void
 "hasCustomOutlineRendering"(arg0: $Player$Type): boolean
 "getRenderBoundingBox"(): $AABB
 "requestModelDataUpdate"(): void
 "deserializeNBT"(arg0: $CompoundTag$Type): void
 "serializeNBT"(): $CompoundTag
 "onChunkUnloaded"(): void
 "onDataPacket"(arg0: $Connection$Type, arg1: $ClientboundBlockEntityDataPacket$Type): void
 "handleUpdateTag"(arg0: $CompoundTag$Type): void
 "getModelData"(): $ModelData
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}

export namespace $IForgeBlockEntity {
const INFINITE_EXTENT_AABB: $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBlockEntity$Type = ($IForgeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBlockEntity_ = $IForgeBlockEntity$Type;
}}
declare module "packages/net/minecraftforge/forgespi/coremod/$ICoreModFile" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export interface $ICoreModFile {

 "getPath"(): $Path
 "readCoreMod"(): $Reader
 "getAdditionalFile"(arg0: string): $Reader
 "getOwnerId"(): string
}

export namespace $ICoreModFile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICoreModFile$Type = ($ICoreModFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICoreModFile_ = $ICoreModFile$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$InterModProcessEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $InterModProcessEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterModProcessEvent$Type = ($InterModProcessEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterModProcessEvent_ = $InterModProcessEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$TradeWithVillagerEvent" {
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractVillager, $AbstractVillager$Type} from "packages/net/minecraft/world/entity/npc/$AbstractVillager"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $TradeWithVillagerEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $MerchantOffer$Type, arg2: $AbstractVillager$Type)

public "getMerchantOffer"(): $MerchantOffer
public "getAbstractVillager"(): $AbstractVillager
public "getListenerList"(): $ListenerList
get "merchantOffer"(): $MerchantOffer
get "abstractVillager"(): $AbstractVillager
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TradeWithVillagerEvent$Type = ($TradeWithVillagerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TradeWithVillagerEvent_ = $TradeWithVillagerEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$Builder" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$ForgeConfigSpec$EnumValue, $ForgeConfigSpec$EnumValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$EnumValue"
import {$ForgeConfigSpec$IntValue, $ForgeConfigSpec$IntValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$IntValue"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$ForgeConfigSpec$ValueSpec, $ForgeConfigSpec$ValueSpec$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ValueSpec"
import {$ForgeConfigSpec$LongValue, $ForgeConfigSpec$LongValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$LongValue"
import {$ForgeConfigSpec$DoubleValue, $ForgeConfigSpec$DoubleValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$DoubleValue"
import {$ForgeConfigSpec$BooleanValue, $ForgeConfigSpec$BooleanValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ForgeConfigSpec, $ForgeConfigSpec$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EnumGetMethod, $EnumGetMethod$Type} from "packages/com/electronwill/nightconfig/core/$EnumGetMethod"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ForgeConfigSpec$Builder {

constructor()

public "comment"(...arg0: (string)[]): $ForgeConfigSpec$Builder
public "comment"(arg0: string): $ForgeConfigSpec$Builder
public "build"(): $ForgeConfigSpec
public "push"(arg0: $List$Type<(string)>): $ForgeConfigSpec$Builder
public "push"(arg0: string): $ForgeConfigSpec$Builder
public "pop"(): $ForgeConfigSpec$Builder
public "pop"(arg0: integer): $ForgeConfigSpec$Builder
public "configure"<T>(arg0: $Function$Type<($ForgeConfigSpec$Builder$Type), (T)>): $Pair<(T), ($ForgeConfigSpec)>
public "translation"(arg0: string): $ForgeConfigSpec$Builder
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $EnumGetMethod$Type, ...arg3: (V)[]): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $Collection$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $EnumGetMethod$Type, arg3: $Collection$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $Collection$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $EnumGetMethod$Type): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, ...arg2: (V)[]): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $EnumGetMethod$Type, ...arg3: (V)[]): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, ...arg2: (V)[]): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $EnumGetMethod$Type, arg3: $Predicate$Type<(any)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: $Supplier$Type<(V)>, arg2: $Predicate$Type<(any)>, arg3: $Class$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: $Supplier$Type<(V)>, arg2: $EnumGetMethod$Type, arg3: $Predicate$Type<(any)>, arg4: $Class$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(V)>, arg2: $Predicate$Type<(any)>, arg3: $Class$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $EnumGetMethod$Type, arg3: $Collection$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $EnumGetMethod$Type, arg3: $Predicate$Type<(any)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(V)>, arg2: $EnumGetMethod$Type, arg3: $Predicate$Type<(any)>, arg4: $Class$Type<(V)>): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: string, arg1: V, arg2: $EnumGetMethod$Type): $ForgeConfigSpec$EnumValue<(V)>
public "defineEnum"<V extends $Enum<(V)>>(arg0: $List$Type<(string)>, arg1: V): $ForgeConfigSpec$EnumValue<(V)>
public "defineList"<T>(arg0: string, arg1: $Supplier$Type<($List$Type<(any)>)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineList"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<($List$Type<(any)>)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineList"<T>(arg0: string, arg1: $List$Type<(any)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineList"<T>(arg0: $List$Type<(string)>, arg1: $List$Type<(any)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineInList"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(T)>, arg2: $Collection$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "defineInList"<T>(arg0: $List$Type<(string)>, arg1: T, arg2: $Collection$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "defineInList"<T>(arg0: string, arg1: $Supplier$Type<(T)>, arg2: $Collection$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "defineInList"<T>(arg0: string, arg1: T, arg2: $Collection$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "defineInRange"(arg0: string, arg1: long, arg2: long, arg3: long): $ForgeConfigSpec$LongValue
public "defineInRange"(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(integer)>, arg2: integer, arg3: integer): $ForgeConfigSpec$IntValue
public "defineInRange"(arg0: string, arg1: $Supplier$Type<(integer)>, arg2: integer, arg3: integer): $ForgeConfigSpec$IntValue
public "defineInRange"(arg0: $List$Type<(string)>, arg1: integer, arg2: integer, arg3: integer): $ForgeConfigSpec$IntValue
public "defineInRange"(arg0: string, arg1: integer, arg2: integer, arg3: integer): $ForgeConfigSpec$IntValue
public "defineInRange"(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(double)>, arg2: double, arg3: double): $ForgeConfigSpec$DoubleValue
public "defineInRange"<V extends $Comparable<(any)>>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(V)>, arg2: V, arg3: V, arg4: $Class$Type<(V)>): $ForgeConfigSpec$ConfigValue<(V)>
public "defineInRange"<V extends $Comparable<(any)>>(arg0: string, arg1: V, arg2: V, arg3: V, arg4: $Class$Type<(V)>): $ForgeConfigSpec$ConfigValue<(V)>
public "defineInRange"<V extends $Comparable<(any)>>(arg0: $List$Type<(string)>, arg1: V, arg2: V, arg3: V, arg4: $Class$Type<(V)>): $ForgeConfigSpec$ConfigValue<(V)>
public "defineInRange"(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(long)>, arg2: long, arg3: long): $ForgeConfigSpec$LongValue
public "defineInRange"(arg0: string, arg1: $Supplier$Type<(long)>, arg2: long, arg3: long): $ForgeConfigSpec$LongValue
public "defineInRange"(arg0: $List$Type<(string)>, arg1: long, arg2: long, arg3: long): $ForgeConfigSpec$LongValue
public "defineInRange"<V extends $Comparable<(any)>>(arg0: string, arg1: $Supplier$Type<(V)>, arg2: V, arg3: V, arg4: $Class$Type<(V)>): $ForgeConfigSpec$ConfigValue<(V)>
public "defineInRange"(arg0: string, arg1: double, arg2: double, arg3: double): $ForgeConfigSpec$DoubleValue
public "defineInRange"(arg0: string, arg1: $Supplier$Type<(double)>, arg2: double, arg3: double): $ForgeConfigSpec$DoubleValue
public "defineInRange"(arg0: $List$Type<(string)>, arg1: double, arg2: double, arg3: double): $ForgeConfigSpec$DoubleValue
public "define"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(T)>, arg2: $Predicate$Type<(any)>, arg3: $Class$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: string, arg1: $Supplier$Type<(T)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(T)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: $List$Type<(string)>, arg1: $ForgeConfigSpec$ValueSpec$Type, arg2: $Supplier$Type<(T)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: string, arg1: T): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: $List$Type<(string)>, arg1: T): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: string, arg1: T, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"<T>(arg0: $List$Type<(string)>, arg1: T, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<(T)>
public "define"(arg0: string, arg1: boolean): $ForgeConfigSpec$BooleanValue
public "define"(arg0: string, arg1: $Supplier$Type<(boolean)>): $ForgeConfigSpec$BooleanValue
public "define"(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(boolean)>): $ForgeConfigSpec$BooleanValue
public "define"(arg0: $List$Type<(string)>, arg1: boolean): $ForgeConfigSpec$BooleanValue
public "worldRestart"(): $ForgeConfigSpec$Builder
public "defineListAllowEmpty"<T>(arg0: string, arg1: $Supplier$Type<($List$Type<(any)>)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineListAllowEmpty"<T>(arg0: $List$Type<(string)>, arg1: $List$Type<(any)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineListAllowEmpty"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<($List$Type<(any)>)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
public "defineListAllowEmpty"<T>(arg0: string, arg1: $List$Type<(any)>, arg2: $Predicate$Type<(any)>): $ForgeConfigSpec$ConfigValue<($List<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$Builder$Type = ($ForgeConfigSpec$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$Builder_ = $ForgeConfigSpec$Builder$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseScrolled$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$MouseScrolled, $ScreenEvent$MouseScrolled$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseScrolled"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseScrolled$Post extends $ScreenEvent$MouseScrolled {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: double)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseScrolled$Post$Type = ($ScreenEvent$MouseScrolled$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseScrolled$Post_ = $ScreenEvent$MouseScrolled$Post$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterClientTooltipComponentFactoriesEvent" {
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterClientTooltipComponentFactoriesEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($Class$Type<(any)>), ($Function$Type<($TooltipComponent$Type), ($ClientTooltipComponent$Type)>)>)

public "register"<T extends $TooltipComponent>(arg0: $Class$Type<(T)>, arg1: $Function$Type<(any), (any)>): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterClientTooltipComponentFactoriesEvent$Type = ($RegisterClientTooltipComponentFactoriesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterClientTooltipComponentFactoriesEvent_ = $RegisterClientTooltipComponentFactoriesEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderHighlightEvent$Block" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"
import {$RenderHighlightEvent, $RenderHighlightEvent$Type} from "packages/net/minecraftforge/client/event/$RenderHighlightEvent"

export class $RenderHighlightEvent$Block extends $RenderHighlightEvent {

constructor()
constructor(arg0: $LevelRenderer$Type, arg1: $Camera$Type, arg2: $BlockHitResult$Type, arg3: float, arg4: $PoseStack$Type, arg5: $MultiBufferSource$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderHighlightEvent$Block$Type = ($RenderHighlightEvent$Block);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderHighlightEvent$Block_ = $RenderHighlightEvent$Block$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeHandler" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$HandshakeHandler$HandshakeConsumer, $HandshakeHandler$HandshakeConsumer$Type} from "packages/net/minecraftforge/network/$HandshakeHandler$HandshakeConsumer"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $HandshakeHandler {


public static "biConsumerFor"<MSG extends $IntSupplier>(arg0: $HandshakeHandler$HandshakeConsumer$Type<(MSG)>): $BiConsumer<(MSG), ($Supplier<($NetworkEvent$Context)>)>
public static "indexFirst"<MSG extends $IntSupplier>(arg0: $HandshakeHandler$HandshakeConsumer$Type<(MSG)>): $BiConsumer<(MSG), ($Supplier<($NetworkEvent$Context)>)>
public "tickServer"(): boolean
public static "packetNeedsResponse"(arg0: $Connection$Type, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeHandler$Type = ($HandshakeHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeHandler_ = $HandshakeHandler$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$ModLifecycleEvent" {
import {$InterModComms$IMCMessage, $InterModComms$IMCMessage$Type} from "packages/net/minecraftforge/fml/$InterModComms$IMCMessage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLifecycleEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $ModContainer$Type)

public "toString"(): string
public "description"(): string
public "isCancelable"(): boolean
public "getIMCStream"(arg0: $Predicate$Type<(string)>): $Stream<($InterModComms$IMCMessage)>
public "getIMCStream"(): $Stream<($InterModComms$IMCMessage)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "iMCStream"(): $Stream<($InterModComms$IMCMessage)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLifecycleEvent$Type = ($ModLifecycleEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLifecycleEvent_ = $ModLifecycleEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$EnderPearl" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$ThrownEnderpearl, $ThrownEnderpearl$Type} from "packages/net/minecraft/world/entity/projectile/$ThrownEnderpearl"

export class $EntityTeleportEvent$EnderPearl extends $EntityTeleportEvent {

constructor()
constructor(arg0: $ServerPlayer$Type, arg1: double, arg2: double, arg3: double, arg4: $ThrownEnderpearl$Type, arg5: float, arg6: $HitResult$Type)

public "isCancelable"(): boolean
public "getAttackDamage"(): float
public "getPlayer"(): $ServerPlayer
public "setAttackDamage"(arg0: float): void
public "getHitResult"(): $HitResult
public "getPearlEntity"(): $ThrownEnderpearl
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "attackDamage"(): float
get "player"(): $ServerPlayer
set "attackDamage"(value: float)
get "hitResult"(): $HitResult
get "pearlEntity"(): $ThrownEnderpearl
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$EnderPearl$Type = ($EntityTeleportEvent$EnderPearl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent$EnderPearl_ = $EntityTeleportEvent$EnderPearl$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$SimpleUnbakedGeometry" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $SimpleUnbakedGeometry<T extends $SimpleUnbakedGeometry<(T)>> implements $IUnbakedGeometry<(T)> {

constructor()

public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleUnbakedGeometry$Type<T> = ($SimpleUnbakedGeometry<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleUnbakedGeometry_<T> = $SimpleUnbakedGeometry$Type<(T)>;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionNode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$PermissionDynamicContextKey, $PermissionDynamicContextKey$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContextKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PermissionNode$PermissionResolver, $PermissionNode$PermissionResolver$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode$PermissionResolver"
import {$PermissionType, $PermissionType$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionType"

export class $PermissionNode<T> {

constructor(arg0: string, arg1: string, arg2: $PermissionType$Type<(T)>, arg3: $PermissionNode$PermissionResolver$Type<(T)>, ...arg4: ($PermissionDynamicContextKey$Type<(any)>)[])
constructor(arg0: $ResourceLocation$Type, arg1: $PermissionType$Type<(T)>, arg2: $PermissionNode$PermissionResolver$Type<(T)>, ...arg3: ($PermissionDynamicContextKey$Type<(any)>)[])

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getType"(): $PermissionType<(T)>
public "getDescription"(): $Component
public "getReadableName"(): $Component
public "getNodeName"(): string
public "setInformation"(arg0: $Component$Type, arg1: $Component$Type): $PermissionNode<(any)>
public "getDefaultResolver"(): $PermissionNode$PermissionResolver<(T)>
public "getDynamics"(): ($PermissionDynamicContextKey<(any)>)[]
get "type"(): $PermissionType<(T)>
get "description"(): $Component
get "readableName"(): $Component
get "nodeName"(): string
get "defaultResolver"(): $PermissionNode$PermissionResolver<(T)>
get "dynamics"(): ($PermissionDynamicContextKey<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionNode$Type<T> = ($PermissionNode<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionNode_<T> = $PermissionNode$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/ticket/$ChunkTicketManager" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ITicketGetter, $ITicketGetter$Type} from "packages/net/minecraftforge/common/ticket/$ITicketGetter"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$SimpleTicket, $SimpleTicket$Type} from "packages/net/minecraftforge/common/ticket/$SimpleTicket"

export class $ChunkTicketManager<T> implements $ITicketGetter<(T)> {
readonly "pos": $ChunkPos

constructor(arg0: $ChunkPos$Type)

public "add"(arg0: $SimpleTicket$Type<(T)>): void
public "remove"(arg0: $SimpleTicket$Type<(T)>): void
public "getTickets"(): $Collection<($SimpleTicket<(T)>)>
get "tickets"(): $Collection<($SimpleTicket<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkTicketManager$Type<T> = ($ChunkTicketManager<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkTicketManager_<T> = $ChunkTicketManager$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$ComputeFovModifierEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $ComputeFovModifierEvent extends $Event {

constructor()
constructor(arg0: $Player$Type, arg1: float)

public "getNewFovModifier"(): float
public "isCancelable"(): boolean
public "getPlayer"(): $Player
public "setNewFovModifier"(arg0: float): void
public "getFovModifier"(): float
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "newFovModifier"(): float
get "cancelable"(): boolean
get "player"(): $Player
set "newFovModifier"(value: float)
get "fovModifier"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComputeFovModifierEvent$Type = ($ComputeFovModifierEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComputeFovModifierEvent_ = $ComputeFovModifierEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$ConditionalRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ConditionalRecipe$Serializer<T extends $Recipe<(any)>> implements $RecipeSerializer<(T)> {

constructor()

public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): T
public "toNetwork"(arg0: $FriendlyByteBuf$Type, arg1: T): void
public "fromNetwork"(arg0: $ResourceLocation$Type, arg1: $FriendlyByteBuf$Type): T
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type): T
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalRecipe$Serializer$Type<T> = ($ConditionalRecipe$Serializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalRecipe$Serializer_<T> = $ConditionalRecipe$Serializer$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/$AddReloadListenerEvent" {
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$PreparableReloadListener, $PreparableReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"

export class $AddReloadListenerEvent extends $Event {

constructor()
constructor(arg0: $ReloadableServerResources$Type, arg1: $RegistryAccess$Type)

public "getConditionContext"(): $ICondition$IContext
public "isCancelable"(): boolean
public "getListeners"(): $List<($PreparableReloadListener)>
public "getRegistryAccess"(): $RegistryAccess
public "getServerResources"(): $ReloadableServerResources
public "addListener"(arg0: $PreparableReloadListener$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "conditionContext"(): $ICondition$IContext
get "cancelable"(): boolean
get "listeners"(): $List<($PreparableReloadListener)>
get "registryAccess"(): $RegistryAccess
get "serverResources"(): $ReloadableServerResources
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddReloadListenerEvent$Type = ($AddReloadListenerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddReloadListenerEvent_ = $AddReloadListenerEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$PartialNBTIngredient" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"

export class $PartialNBTIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public static "of"(arg0: $ItemLike$Type, arg1: $CompoundTag$Type): $PartialNBTIngredient
public static "of"(arg0: $CompoundTag$Type, ...arg1: ($ItemLike$Type)[]): $PartialNBTIngredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getSerializer"(): $IIngredientSerializer<(any)>
public "canBeUsedForMatching"(): boolean
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PartialNBTIngredient$Type = ($PartialNBTIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PartialNBTIngredient_ = $PartialNBTIngredient$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityStruckByLightningEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$LightningBolt, $LightningBolt$Type} from "packages/net/minecraft/world/entity/$LightningBolt"

export class $EntityStruckByLightningEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $LightningBolt$Type)

public "isCancelable"(): boolean
public "getLightning"(): $LightningBolt
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "lightning"(): $LightningBolt
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityStruckByLightningEvent$Type = ($EntityStruckByLightningEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityStruckByLightningEvent_ = $EntityStruckByLightningEvent$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions$FontContext" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IClientItemExtensions$FontContext extends $Enum<($IClientItemExtensions$FontContext)> {
static readonly "ITEM_COUNT": $IClientItemExtensions$FontContext
static readonly "TOOLTIP": $IClientItemExtensions$FontContext
static readonly "SELECTED_ITEM_NAME": $IClientItemExtensions$FontContext


public static "values"(): ($IClientItemExtensions$FontContext)[]
public static "valueOf"(arg0: string): $IClientItemExtensions$FontContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IClientItemExtensions$FontContext$Type = (("item_count") | ("selected_item_name") | ("tooltip")) | ($IClientItemExtensions$FontContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IClientItemExtensions$FontContext_ = $IClientItemExtensions$FontContext$Type;
}}
declare module "packages/net/minecraftforge/registries/$ObjectHolderRef" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ObjectHolderRef implements $Consumer<($Predicate<($ResourceLocation)>)> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "accept"(arg0: $Predicate$Type<($ResourceLocation$Type)>): void
public "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<($Predicate<($ResourceLocation)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectHolderRef$Type = ($ObjectHolderRef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectHolderRef_ = $ObjectHolderRef$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjModel" {
import {$ObjModel$ModelSettings, $ObjModel$ModelSettings$Type} from "packages/net/minecraftforge/client/model/obj/$ObjModel$ModelSettings"
import {$CompositeRenderable, $CompositeRenderable$Type} from "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$ObjTokenizer, $ObjTokenizer$Type} from "packages/net/minecraftforge/client/model/obj/$ObjTokenizer"
import {$SimpleUnbakedGeometry, $SimpleUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$SimpleUnbakedGeometry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ObjModel extends $SimpleUnbakedGeometry<($ObjModel)> {
readonly "automaticCulling": boolean
readonly "shadeQuads": boolean
readonly "flipV": boolean
readonly "emissiveAmbient": boolean
readonly "mtlOverride": string
readonly "modelLocation": $ResourceLocation


public static "parse"(arg0: $ObjTokenizer$Type, arg1: $ObjModel$ModelSettings$Type): $ObjModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "bakeRenderable"(arg0: $IGeometryBakingContext$Type): $CompositeRenderable
public "getRootComponentNames"(): $Set<(string)>
get "configurableComponentNames"(): $Set<(string)>
get "rootComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjModel$Type = ($ObjModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjModel_ = $ObjModel$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Structure$StructureSettings, $Structure$StructureSettings$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure$StructureSettings"

export class $ModifiableStructureInfo$StructureInfo extends $Record {

constructor(structureSettings: $Structure$StructureSettings$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "structureSettings"(): $Structure$StructureSettings
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableStructureInfo$StructureInfo$Type = ($ModifiableStructureInfo$StructureInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableStructureInfo$StructureInfo_ = $ModifiableStructureInfo$StructureInfo$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/moddiscovery/$CoreModFile" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"
import {$ICoreModFile, $ICoreModFile$Type} from "packages/net/minecraftforge/forgespi/coremod/$ICoreModFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $CoreModFile implements $ICoreModFile {


public "toString"(): string
public "getPath"(): $Path
public "readCoreMod"(): $Reader
public "getAdditionalFile"(arg0: string): $Reader
public "getOwnerId"(): string
get "path"(): $Path
get "ownerId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoreModFile$Type = ($CoreModFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoreModFile_ = $CoreModFile$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkTicketLevelUpdatedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ChunkHolder, $ChunkHolder$Type} from "packages/net/minecraft/server/level/$ChunkHolder"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $ChunkTicketLevelUpdatedEvent extends $Event {

constructor()
constructor(arg0: $ServerLevel$Type, arg1: long, arg2: integer, arg3: integer, arg4: $ChunkHolder$Type)

public "getLevel"(): $ServerLevel
public "isCancelable"(): boolean
public "getNewTicketLevel"(): integer
public "getOldTicketLevel"(): integer
public "getChunkHolder"(): $ChunkHolder
public "getChunkPos"(): long
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $ServerLevel
get "cancelable"(): boolean
get "newTicketLevel"(): integer
get "oldTicketLevel"(): integer
get "chunkHolder"(): $ChunkHolder
get "chunkPos"(): long
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkTicketLevelUpdatedEvent$Type = ($ChunkTicketLevelUpdatedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkTicketLevelUpdatedEvent_ = $ChunkTicketLevelUpdatedEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerFlyableFallEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerFlyableFallEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: float, arg2: float)

public "getMultiplier"(): float
public "setMultiplier"(arg0: float): void
public "getDistance"(): float
public "setDistance"(arg0: float): void
public "getListenerList"(): $ListenerList
get "multiplier"(): float
set "multiplier"(value: float)
get "distance"(): float
set "distance"(value: float)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerFlyableFallEvent$Type = ($PlayerFlyableFallEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerFlyableFallEvent_ = $PlayerFlyableFallEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$LeftClickEmpty" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"

export class $PlayerInteractEvent$LeftClickEmpty extends $PlayerInteractEvent {

constructor(arg0: $Player$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$LeftClickEmpty$Type = ($PlayerInteractEvent$LeftClickEmpty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$LeftClickEmpty_ = $PlayerInteractEvent$LeftClickEmpty$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobEffectEvent$Added" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$MobEffectEvent, $MobEffectEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobEffectEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $MobEffectEvent$Added extends $MobEffectEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $MobEffectInstance$Type, arg2: $MobEffectInstance$Type, arg3: $Entity$Type)

public "getEffectInstance"(): $MobEffectInstance
public "getEffectSource"(): $Entity
public "getListenerList"(): $ListenerList
public "getOldEffectInstance"(): $MobEffectInstance
get "effectInstance"(): $MobEffectInstance
get "effectSource"(): $Entity
get "listenerList"(): $ListenerList
get "oldEffectInstance"(): $MobEffectInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectEvent$Added$Type = ($MobEffectEvent$Added);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectEvent$Added_ = $MobEffectEvent$Added$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeFluid" {
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Boat, $Boat$Type} from "packages/net/minecraft/world/entity/vehicle/$Boat"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IForgeFluid {

 "move"(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
 "getBlockPathType"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type, arg4: boolean): $BlockPathTypes
 "getExplosionResistance"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Explosion$Type): float
 "getAdjacentBlockPathType"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type, arg4: $BlockPathTypes$Type): $BlockPathTypes
 "shouldUpdateWhileBoating"(arg0: $FluidState$Type, arg1: $Boat$Type, arg2: $Entity$Type): boolean
 "getFluidType"(): $FluidType
 "supportsBoating"(arg0: $FluidState$Type, arg1: $Boat$Type): boolean
 "canConvertToSource"(arg0: $FluidState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
 "canExtinguish"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "canHydrate"(arg0: $FluidState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type): boolean

(arg0: $FluidState$Type, arg1: $LivingEntity$Type, arg2: $Vec3$Type, arg3: double): boolean
}

export namespace $IForgeFluid {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeFluid$Type = ($IForgeFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeFluid_ = $IForgeFluid$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Opening" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$Opening extends $ScreenEvent {

constructor()
constructor(arg0: $Screen$Type, arg1: $Screen$Type)

public "isCancelable"(): boolean
public "getNewScreen"(): $Screen
public "setNewScreen"(arg0: $Screen$Type): void
public "getCurrentScreen"(): $Screen
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "newScreen"(): $Screen
set "newScreen"(value: $Screen$Type)
get "currentScreen"(): $Screen
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Opening$Type = ($ScreenEvent$Opening);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Opening_ = $ScreenEvent$Opening$Type;
}}
declare module "packages/net/minecraftforge/registries/$ILockableRegistry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ILockableRegistry {

 "lock"(): void

(): void
}

export namespace $ILockableRegistry {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILockableRegistry$Type = ($ILockableRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILockableRegistry_ = $ILockableRegistry$Type;
}}
declare module "packages/net/minecraftforge/network/$MCRegisterPacketHandler" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $MCRegisterPacketHandler {
static readonly "INSTANCE": $MCRegisterPacketHandler

constructor()

public "addChannels"(arg0: $Set$Type<($ResourceLocation$Type)>, arg1: $Connection$Type): void
public "sendRegistry"(arg0: $Connection$Type, arg1: $NetworkDirection$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MCRegisterPacketHandler$Type = ($MCRegisterPacketHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MCRegisterPacketHandler_ = $MCRegisterPacketHandler$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingAttackEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingAttackEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float)

public "getSource"(): $DamageSource
public "isCancelable"(): boolean
public "getAmount"(): float
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "cancelable"(): boolean
get "amount"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingAttackEvent$Type = ($LivingAttackEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingAttackEvent_ = $LivingAttackEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobEffectEvent$Applicable" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$MobEffectEvent, $MobEffectEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobEffectEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $MobEffectEvent$Applicable extends $MobEffectEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $MobEffectInstance$Type)

public "getEffectInstance"(): $MobEffectInstance
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "effectInstance"(): $MobEffectInstance
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectEvent$Applicable$Type = ($MobEffectEvent$Applicable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectEvent$Applicable_ = $MobEffectEvent$Applicable$Type;
}}
declare module "packages/net/minecraftforge/event/$LootTableLoadEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LootTable, $LootTable$Type} from "packages/net/minecraft/world/level/storage/loot/$LootTable"

export class $LootTableLoadEvent extends $Event {

constructor()
constructor(arg0: $ResourceLocation$Type, arg1: $LootTable$Type)

public "getName"(): $ResourceLocation
public "getTable"(): $LootTable
public "isCancelable"(): boolean
public "setTable"(arg0: $LootTable$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "name"(): $ResourceLocation
get "table"(): $LootTable
get "cancelable"(): boolean
set "table"(value: $LootTable$Type)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableLoadEvent$Type = ($LootTableLoadEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableLoadEvent_ = $LootTableLoadEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgePlayer" {
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IForgePlayer {

 "getBlockReach"(): double
 "canReach"(arg0: $BlockPos$Type, arg1: double): boolean
 "canReach"(arg0: $Entity$Type, arg1: double): boolean
 "canReach"(arg0: $Vec3$Type, arg1: double): boolean
 "isCloseEnough"(arg0: $Entity$Type, arg1: double): boolean
 "getEntityReach"(): double
}

export namespace $IForgePlayer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgePlayer$Type = ($IForgePlayer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgePlayer_ = $IForgePlayer$Type;
}}
declare module "packages/net/minecraftforge/common/util/$INBTSerializable" {
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"

export interface $INBTSerializable<T extends $Tag> {

 "deserializeNBT"(arg0: T): void
 "serializeNBT"(): T
}

export namespace $INBTSerializable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INBTSerializable$Type<T> = ($INBTSerializable<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INBTSerializable_<T> = $INBTSerializable$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEquipmentChangeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEquipmentChangeEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $EquipmentSlot$Type, arg2: $ItemStack$Type, arg3: $ItemStack$Type)

public "getSlot"(): $EquipmentSlot
public "getFrom"(): $ItemStack
public "getTo"(): $ItemStack
public "getListenerList"(): $ListenerList
get "slot"(): $EquipmentSlot
get "from"(): $ItemStack
get "to"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEquipmentChangeEvent$Type = ($LivingEquipmentChangeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEquipmentChangeEvent_ = $LivingEquipmentChangeEvent$Type;
}}
declare module "packages/net/minecraftforge/energy/$EmptyEnergyStorage" {
import {$IEnergyStorage, $IEnergyStorage$Type} from "packages/net/minecraftforge/energy/$IEnergyStorage"

export class $EmptyEnergyStorage implements $IEnergyStorage {
static readonly "INSTANCE": $EmptyEnergyStorage


public "getEnergyStored"(): integer
public "getMaxEnergyStored"(): integer
public "canExtract"(): boolean
public "receiveEnergy"(arg0: integer, arg1: boolean): integer
public "canReceive"(): boolean
public "extractEnergy"(arg0: integer, arg1: boolean): integer
get "energyStored"(): integer
get "maxEnergyStored"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyEnergyStorage$Type = ($EmptyEnergyStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyEnergyStorage_ = $EmptyEnergyStorage$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TickEvent$Type extends $Enum<($TickEvent$Type)> {
static readonly "LEVEL": $TickEvent$Type
static readonly "PLAYER": $TickEvent$Type
static readonly "CLIENT": $TickEvent$Type
static readonly "SERVER": $TickEvent$Type
static readonly "RENDER": $TickEvent$Type


public static "values"(): ($TickEvent$Type)[]
public static "valueOf"(arg0: string): $TickEvent$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$Type$Type = (("server") | ("level") | ("client") | ("render") | ("player")) | ($TickEvent$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$Type_ = $TickEvent$Type$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeSpawnEggItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$SpawnEggItem, $SpawnEggItem$Type} from "packages/net/minecraft/world/item/$SpawnEggItem"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeSpawnEggItem extends $SpawnEggItem {
static readonly "BY_ID": $Map<($EntityType<(any)>), ($SpawnEggItem)>
 "defaultType": $EntityType<(any)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Supplier$Type<(any)>, arg1: integer, arg2: integer, arg3: $Item$Properties$Type)

public "getType"(arg0: $CompoundTag$Type): $EntityType<(any)>
public static "fromEntityType"(arg0: $EntityType$Type<(any)>): $SpawnEggItem
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSpawnEggItem$Type = ($ForgeSpawnEggItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSpawnEggItem_ = $ForgeSpawnEggItem$Type;
}}
declare module "packages/net/minecraftforge/event/furnace/$FurnaceFuelBurnTimeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $FurnaceFuelBurnTimeEvent extends $Event {

constructor(arg0: $ItemStack$Type, arg1: integer, arg2: $RecipeType$Type<(any)>)
constructor()

public "getRecipeType"(): $RecipeType<(any)>
public "isCancelable"(): boolean
public "setBurnTime"(arg0: integer): void
public "getBurnTime"(): integer
public "getItemStack"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "recipeType"(): $RecipeType<(any)>
get "cancelable"(): boolean
set "burnTime"(value: integer)
get "burnTime"(): integer
get "itemStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FurnaceFuelBurnTimeEvent$Type = ($FurnaceFuelBurnTimeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FurnaceFuelBurnTimeEvent_ = $FurnaceFuelBurnTimeEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$ModMismatchEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$LevelStorageSource$LevelDirectory, $LevelStorageSource$LevelDirectory$Type} from "packages/net/minecraft/world/level/storage/$LevelStorageSource$LevelDirectory"
import {$ModMismatchEvent$MismatchResolutionResult, $ModMismatchEvent$MismatchResolutionResult$Type} from "packages/net/minecraftforge/event/$ModMismatchEvent$MismatchResolutionResult"
import {$ModMismatchEvent$MismatchedVersionInfo, $ModMismatchEvent$MismatchedVersionInfo$Type} from "packages/net/minecraftforge/event/$ModMismatchEvent$MismatchedVersionInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModMismatchEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $LevelStorageSource$LevelDirectory$Type, arg1: $Map$Type<(string), ($ArtifactVersion$Type)>, arg2: $Map$Type<(string), ($ArtifactVersion$Type)>)

public "getResolved"(): $Stream<($ModMismatchEvent$MismatchResolutionResult)>
public "isCancelable"(): boolean
public "getVersionDifference"(arg0: string): $Optional<($ModMismatchEvent$MismatchedVersionInfo)>
public "getUnresolved"(): $Stream<($ModMismatchEvent$MismatchResolutionResult)>
public "anyUnresolved"(): boolean
public "anyResolved"(): boolean
public "getResolver"(arg0: string): $Optional<($ModContainer)>
public "getPreviousVersion"(arg0: string): $ArtifactVersion
public "getLevelDirectory"(): $LevelStorageSource$LevelDirectory
public "markResolved"(arg0: string): void
public "getCurrentVersion"(arg0: string): $ArtifactVersion
public "wasResolved"(arg0: string): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "resolved"(): $Stream<($ModMismatchEvent$MismatchResolutionResult)>
get "cancelable"(): boolean
get "unresolved"(): $Stream<($ModMismatchEvent$MismatchResolutionResult)>
get "levelDirectory"(): $LevelStorageSource$LevelDirectory
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModMismatchEvent$Type = ($ModMismatchEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModMismatchEvent_ = $ModMismatchEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiEvent extends $Event {

constructor()

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getWindow"(): $Window
public "getGuiGraphics"(): $GuiGraphics
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): float
get "cancelable"(): boolean
get "window"(): $Window
get "guiGraphics"(): $GuiGraphics
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiEvent$Type = ($RenderGuiEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiEvent_ = $RenderGuiEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$IModStateTransition" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ProgressMeter, $ProgressMeter$Type} from "packages/net/minecraftforge/fml/loading/progress/$ProgressMeter"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ThreadSelector, $ThreadSelector$Type} from "packages/net/minecraftforge/fml/$ThreadSelector"
import {$IModStateTransition$EventGenerator, $IModStateTransition$EventGenerator$Type} from "packages/net/minecraftforge/fml/$IModStateTransition$EventGenerator"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IModStateTransition {

 "build"<T extends ($Event) & ($IModBusEvent)>(arg0: string, arg1: $Executor$Type, arg2: $Executor$Type, arg3: $ProgressMeter$Type, arg4: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>, arg5: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>): $CompletableFuture<(void)>
 "postDispatchHook"(): $BiFunction<($Executor), (any), ($CompletableFuture<(void)>)>
 "preDispatchHook"(): $BiFunction<($Executor), (any), ($CompletableFuture<(void)>)>
 "threadSelector"(): $ThreadSelector
 "eventFunctionStream"(): $Supplier<($Stream<($IModStateTransition$EventGenerator<(any)>)>)>
 "nextModLoadingStage"(): $BiFunction<($ModLoadingStage), ($Throwable), ($ModLoadingStage)>
 "finalActivityGenerator"(): $BiFunction<($Executor), ($CompletableFuture<(void)>), ($CompletableFuture<(void)>)>
}

export namespace $IModStateTransition {
function buildNoopTransition(): $IModStateTransition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModStateTransition$Type = ($IModStateTransition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModStateTransition_ = $IModStateTransition$Type;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext" {
import {$PermissionDynamicContextKey, $PermissionDynamicContextKey$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContextKey"

export class $PermissionDynamicContext<T> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getValue"(): T
public "getDynamic"(): $PermissionDynamicContextKey<(T)>
public "getSerializedValue"(): string
get "value"(): T
get "dynamic"(): $PermissionDynamicContextKey<(T)>
get "serializedValue"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionDynamicContext$Type<T> = ($PermissionDynamicContext<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionDynamicContext_<T> = $PermissionDynamicContext$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$FarmlandTrampleEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $BlockEvent$FarmlandTrampleEvent extends $BlockEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: float, arg4: $Entity$Type)

public "isCancelable"(): boolean
public "getEntity"(): $Entity
public "getFallDistance"(): float
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "entity"(): $Entity
get "fallDistance"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$FarmlandTrampleEvent$Type = ($BlockEvent$FarmlandTrampleEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$FarmlandTrampleEvent_ = $BlockEvent$FarmlandTrampleEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"

export class $ChunkEvent extends $LevelEvent {

constructor()
constructor(arg0: $ChunkAccess$Type, arg1: $LevelAccessor$Type)
constructor(arg0: $ChunkAccess$Type)

public "getChunk"(): $ChunkAccess
public "getListenerList"(): $ListenerList
get "chunk"(): $ChunkAccess
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkEvent$Type = ($ChunkEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkEvent_ = $ChunkEvent$Type;
}}
declare module "packages/net/minecraftforge/client/loading/$NoVizFallback" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Monitor, $Monitor$Type} from "packages/com/mojang/blaze3d/platform/$Monitor"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$ReloadInstance, $ReloadInstance$Type} from "packages/net/minecraft/server/packs/resources/$ReloadInstance"
import {$LoadingOverlay, $LoadingOverlay$Type} from "packages/net/minecraft/client/gui/screens/$LoadingOverlay"

export class $NoVizFallback {

constructor()

public static "loadingOverlay"(arg0: $Supplier$Type<($Minecraft$Type)>, arg1: $Supplier$Type<($ReloadInstance$Type)>, arg2: $Consumer$Type<($Optional$Type<($Throwable$Type)>)>, arg3: boolean): $Supplier<($LoadingOverlay)>
public static "glVersion"(): string
public static "windowPositioning"(arg0: $Optional$Type<($Monitor$Type)>, arg1: $IntConsumer$Type, arg2: $IntConsumer$Type, arg3: $IntConsumer$Type, arg4: $IntConsumer$Type): boolean
public static "windowHandoff"(arg0: $IntSupplier$Type, arg1: $IntSupplier$Type, arg2: $Supplier$Type<(string)>, arg3: $LongSupplier$Type): $LongSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoVizFallback$Type = ($NoVizFallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoVizFallback_ = $NoVizFallback$Type;
}}
declare module "packages/net/minecraftforge/client/model/data/$ModelDataManager" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ChunkEvent$Unload, $ChunkEvent$Unload$Type} from "packages/net/minecraftforge/event/level/$ChunkEvent$Unload"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModelDataManager {

constructor(arg0: $Level$Type)

public "getAt"(arg0: $ChunkPos$Type): $Map<($BlockPos), ($ModelData)>
public "getAt"(arg0: $BlockPos$Type): $ModelData
public static "onChunkUnload"(arg0: $ChunkEvent$Unload$Type): void
public "requestRefresh"(arg0: $BlockEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelDataManager$Type = ($ModelDataManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelDataManager_ = $ModelDataManager$Type;
}}
declare module "packages/net/minecraftforge/common/util/$NonNullLazy" {
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/net/minecraftforge/common/util/$NonNullSupplier"

export interface $NonNullLazy<T> extends $NonNullSupplier<(T)> {

 "get"(): T

(arg0: $NonNullSupplier$Type<(T)>): $NonNullLazy<(T)>
}

export namespace $NonNullLazy {
function of<T>(arg0: $NonNullSupplier$Type<(T)>): $NonNullLazy<(T)>
function concurrentOf<T>(arg0: $NonNullSupplier$Type<(T)>): $NonNullLazy<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonNullLazy$Type<T> = ($NonNullLazy<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonNullLazy_<T> = $NonNullLazy$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$CriticalHitEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $CriticalHitEvent extends $PlayerEvent {

constructor(arg0: $Player$Type, arg1: $Entity$Type, arg2: float, arg3: boolean)
constructor()

public "getTarget"(): $Entity
public "isVanillaCritical"(): boolean
public "setDamageModifier"(arg0: float): void
public "getOldDamageModifier"(): float
public "getDamageModifier"(): float
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "target"(): $Entity
get "vanillaCritical"(): boolean
set "damageModifier"(value: float)
get "oldDamageModifier"(): float
get "damageModifier"(): float
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CriticalHitEvent$Type = ($CriticalHitEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CriticalHitEvent_ = $CriticalHitEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkInitialization" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$EventNetworkChannel, $EventNetworkChannel$Type} from "packages/net/minecraftforge/network/event/$EventNetworkChannel"
import {$SimpleChannel, $SimpleChannel$Type} from "packages/net/minecraftforge/network/simple/$SimpleChannel"

export class $NetworkInitialization {


public static "getHandshakeChannel"(): $SimpleChannel
public static "buildMCRegistrationChannels"(): $List<($EventNetworkChannel)>
public static "getPlayChannel"(): $SimpleChannel
get "handshakeChannel"(): $SimpleChannel
get "playChannel"(): $SimpleChannel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkInitialization$Type = ($NetworkInitialization);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkInitialization_ = $NetworkInitialization$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder$PartBuilder" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$MultiPartBlockStateBuilder$PartBuilder$ConditionGroup, $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder$PartBuilder$ConditionGroup"
import {$MultiPartBlockStateBuilder, $MultiPartBlockStateBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$BlockStateProvider$ConfiguredModelList, $BlockStateProvider$ConfiguredModelList$Type} from "packages/net/minecraftforge/client/model/generators/$BlockStateProvider$ConfiguredModelList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MultiPartBlockStateBuilder$PartBuilder {
 "models": $BlockStateProvider$ConfiguredModelList
 "useOr": boolean
readonly "conditions": $Multimap<($Property<(any)>), ($Comparable<(any)>)>
readonly "nestedConditionGroups": $List<($MultiPartBlockStateBuilder$PartBuilder$ConditionGroup)>


public "end"(): $MultiPartBlockStateBuilder
public "condition"<T extends $Comparable<(T)>>(arg0: $Property$Type<(T)>, ...arg1: (T)[]): $MultiPartBlockStateBuilder$PartBuilder
public "canApplyTo"(arg0: $Block$Type): boolean
public "nestedGroup"(): $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup
public "useOr"(): $MultiPartBlockStateBuilder$PartBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiPartBlockStateBuilder$PartBuilder$Type = ($MultiPartBlockStateBuilder$PartBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiPartBlockStateBuilder$PartBuilder_ = $MultiPartBlockStateBuilder$PartBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/loot/$LootModifier" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootContext, $LootContext$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$ObjectArrayList, $ObjectArrayList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$IGlobalLootModifier, $IGlobalLootModifier$Type} from "packages/net/minecraftforge/common/loot/$IGlobalLootModifier"

export class $LootModifier implements $IGlobalLootModifier {


public "apply"(arg0: $ObjectArrayList$Type<($ItemStack$Type)>, arg1: $LootContext$Type): $ObjectArrayList<($ItemStack)>
public static "getJson"<U>(arg0: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootModifier$Type = ($LootModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootModifier_ = $LootModifier$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeIntrinsicHolderTagAppender" {
import {$IForgeTagAppender, $IForgeTagAppender$Type} from "packages/net/minecraftforge/common/extensions/$IForgeTagAppender"
import {$TagsProvider$TagAppender, $TagsProvider$TagAppender$Type} from "packages/net/minecraft/data/tags/$TagsProvider$TagAppender"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$IntrinsicHolderTagsProvider$IntrinsicTagAppender, $IntrinsicHolderTagsProvider$IntrinsicTagAppender$Type} from "packages/net/minecraft/data/tags/$IntrinsicHolderTagsProvider$IntrinsicTagAppender"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $IForgeIntrinsicHolderTagAppender<T> extends $IForgeTagAppender<(T)> {

 "remove"(arg0: $ResourceKey$Type<(T)>, ...arg1: ($ResourceKey$Type<(T)>)[]): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "remove"(arg0: $ResourceKey$Type<(T)>): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "remove"(arg0: T): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "remove"(arg0: T, ...arg1: (T)[]): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "replace"(arg0: boolean): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "getKey"(arg0: T): $ResourceKey<(T)>
 "addTags"(...arg0: ($TagKey$Type<(T)>)[]): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
 "addOptionalTags"(...arg0: ($TagKey$Type<(T)>)[]): $TagsProvider$TagAppender<(T)>
 "addOptionalTag"(arg0: $TagKey$Type<(T)>): $TagsProvider$TagAppender<(T)>

(arg0: $ResourceKey$Type<(T)>, ...arg1: ($ResourceKey$Type<(T)>)[]): $IntrinsicHolderTagsProvider$IntrinsicTagAppender<(T)>
}

export namespace $IForgeIntrinsicHolderTagAppender {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeIntrinsicHolderTagAppender$Type<T> = ($IForgeIntrinsicHolderTagAppender<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeIntrinsicHolderTagAppender_<T> = $IForgeIntrinsicHolderTagAppender$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickItem" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"

export class $PlayerInteractEvent$RightClickItem extends $PlayerInteractEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $InteractionHand$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$RightClickItem$Type = ($PlayerInteractEvent$RightClickItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$RightClickItem_ = $PlayerInteractEvent$RightClickItem$Type;
}}
declare module "packages/net/minecraftforge/event/level/$PistonEvent" {
import {$PistonStructureResolver, $PistonStructureResolver$Type} from "packages/net/minecraft/world/level/block/piston/$PistonStructureResolver"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PistonEvent$PistonMoveType, $PistonEvent$PistonMoveType$Type} from "packages/net/minecraftforge/event/level/$PistonEvent$PistonMoveType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PistonEvent extends $BlockEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $Direction$Type, arg3: $PistonEvent$PistonMoveType$Type)

public "getPistonMoveType"(): $PistonEvent$PistonMoveType
public "getStructureHelper"(): $PistonStructureResolver
public "getFaceOffsetPos"(): $BlockPos
public "getDirection"(): $Direction
public "getListenerList"(): $ListenerList
get "pistonMoveType"(): $PistonEvent$PistonMoveType
get "structureHelper"(): $PistonStructureResolver
get "faceOffsetPos"(): $BlockPos
get "direction"(): $Direction
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonEvent$Type = ($PistonEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PistonEvent_ = $PistonEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$ICustomHolderSet" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$IForgeHolderSet$SerializationType, $IForgeHolderSet$SerializationType$Type} from "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ICustomHolderSet<T> extends $HolderSet<(T)> {

 "type"(): $HolderSetType
 "serializationType"(): $IForgeHolderSet$SerializationType
 "contains"(arg0: $Holder$Type<(T)>): boolean
 "stream"(): $Stream<($Holder<(T)>)>
 "canSerializeIn"(arg0: $HolderOwner$Type<(T)>): boolean
 "size"(): integer
 "get"(arg0: integer): $Holder<(T)>
 "unwrapKey"(): $Optional<($TagKey<(T)>)>
 "getRandomElement"(arg0: $RandomSource$Type): $Optional<($Holder<(T)>)>
 "unwrap"(): $Either<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
 "iterator"(): $Iterator<($Holder<(T)>)>
 "spliterator"(): $Spliterator<($Holder<(T)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "addInvalidationListener"(arg0: $Runnable$Type): void
}

export namespace $ICustomHolderSet {
function direct<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
function direct<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
function emptyNamed<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
function direct<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
function direct<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICustomHolderSet$Type<T> = ($ICustomHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICustomHolderSet_<T> = $ICustomHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/network/$DualStackUtils" {
import {$SocketAddress, $SocketAddress$Type} from "packages/java/net/$SocketAddress"
import {$InetAddress, $InetAddress$Type} from "packages/java/net/$InetAddress"

export class $DualStackUtils {

constructor()

public static "checkIPv6"(arg0: string): boolean
public static "checkIPv6"(arg0: $InetAddress$Type): boolean
public static "getLocalAddress"(): $InetAddress
public static "getMulticastGroup"(): string
public static "logInitialPreferences"(): void
public static "getAddressString"(arg0: $SocketAddress$Type): string
public static "initialise"(): void
get "localAddress"(): $InetAddress
get "multicastGroup"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DualStackUtils$Type = ($DualStackUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DualStackUtils_ = $DualStackUtils$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$IModLanguageProvider" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ILifecycleEvent, $ILifecycleEvent$Type} from "packages/net/minecraftforge/forgespi/language/$ILifecycleEvent"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ModFileScanData, $ModFileScanData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData"

export interface $IModLanguageProvider {

 "name"(): string
 "getFileVisitor"(): $Consumer<($ModFileScanData)>
 "consumeLifecycleEvent"<R extends $ILifecycleEvent<(R)>>(arg0: $Supplier$Type<(R)>): void
}

export namespace $IModLanguageProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModLanguageProvider$Type = ($IModLanguageProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModLanguageProvider_ = $IModLanguageProvider$Type;
}}
declare module "packages/net/minecraftforge/client/event/$TextureStitchEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$TextureAtlas, $TextureAtlas$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlas"

export class $TextureStitchEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $TextureAtlas$Type)

public "isCancelable"(): boolean
public "getAtlas"(): $TextureAtlas
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "atlas"(): $TextureAtlas
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureStitchEvent$Type = ($TextureStitchEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureStitchEvent_ = $TextureStitchEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$RenderTypeHelper" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $RenderTypeHelper {


public static "getFallbackItemRenderType"(arg0: $ItemStack$Type, arg1: $BakedModel$Type, arg2: boolean): $RenderType
public static "getMovingBlockRenderType"(arg0: $RenderType$Type): $RenderType
public static "getEntityRenderType"(arg0: $RenderType$Type, arg1: boolean): $RenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTypeHelper$Type = ($RenderTypeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTypeHelper_ = $RenderTypeHelper$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseScrolled$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$MouseScrolled, $ScreenEvent$MouseScrolled$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseScrolled"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseScrolled$Pre extends $ScreenEvent$MouseScrolled {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: double)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseScrolled$Pre$Type = ($ScreenEvent$MouseScrolled$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseScrolled$Pre_ = $ScreenEvent$MouseScrolled$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/$ClientForgeMod" {
import {$RegisterNamedRenderTypesEvent, $RegisterNamedRenderTypesEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterNamedRenderTypesEvent"
import {$ModelEvent$RegisterGeometryLoaders, $ModelEvent$RegisterGeometryLoaders$Type} from "packages/net/minecraftforge/client/event/$ModelEvent$RegisterGeometryLoaders"
import {$RegisterClientReloadListenersEvent, $RegisterClientReloadListenersEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterClientReloadListenersEvent"

export class $ClientForgeMod {

constructor()

public static "onRegisterNamedRenderTypes"(arg0: $RegisterNamedRenderTypesEvent$Type): void
public static "onRegisterGeometryLoaders"(arg0: $ModelEvent$RegisterGeometryLoaders$Type): void
public static "onRegisterReloadListeners"(arg0: $RegisterClientReloadListenersEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientForgeMod$Type = ($ClientForgeMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientForgeMod_ = $ClientForgeMod$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityJoinLevelEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityJoinLevelEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Level$Type, arg2: boolean)
constructor(arg0: $Entity$Type, arg1: $Level$Type)

public "getLevel"(): $Level
public "isCancelable"(): boolean
public "loadedFromDisk"(): boolean
public "getListenerList"(): $ListenerList
get "level"(): $Level
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityJoinLevelEvent$Type = ($EntityJoinLevelEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityJoinLevelEvent_ = $EntityJoinLevelEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$RenderGuiEvent, $RenderGuiEvent$Type} from "packages/net/minecraftforge/client/event/$RenderGuiEvent"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiEvent$Post extends $RenderGuiEvent {

constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiEvent$Post$Type = ($RenderGuiEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiEvent$Post_ = $RenderGuiEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/fml/event/config/$ModConfigEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent, $IConfigEvent$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModConfigEvent extends $Event implements $IModBusEvent, $IConfigEvent {

constructor()

public "isCancelable"(): boolean
public "getConfig"(): $ModConfig
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "self"<T extends ($Event) & ($IConfigEvent)>(): T
public static "reloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "unloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "loading"(arg0: $ModConfig$Type): $IConfigEvent
get "cancelable"(): boolean
get "config"(): $ModConfig
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModConfigEvent$Type = ($ModConfigEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModConfigEvent_ = $ModConfigEvent$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$DoubleValue" {
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfigSpec$DoubleValue extends $ForgeConfigSpec$ConfigValue<(double)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$DoubleValue$Type = ($ForgeConfigSpec$DoubleValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$DoubleValue_ = $ForgeConfigSpec$DoubleValue$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent$LoggingIn" {
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ClientPlayerNetworkEvent, $ClientPlayerNetworkEvent$Type} from "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent"
import {$MultiPlayerGameMode, $MultiPlayerGameMode$Type} from "packages/net/minecraft/client/multiplayer/$MultiPlayerGameMode"

export class $ClientPlayerNetworkEvent$LoggingIn extends $ClientPlayerNetworkEvent {

constructor(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type, arg2: $Connection$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerNetworkEvent$LoggingIn$Type = ($ClientPlayerNetworkEvent$LoggingIn);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerNetworkEvent$LoggingIn_ = $ClientPlayerNetworkEvent$LoggingIn$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeMod" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ForgeBiomeModifiers$RemoveSpawnsBiomeModifier, $ForgeBiomeModifiers$RemoveSpawnsBiomeModifier$Type} from "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$RemoveSpawnsBiomeModifier"
import {$PermissionGatherEvent$Nodes, $PermissionGatherEvent$Nodes$Type} from "packages/net/minecraftforge/server/permission/events/$PermissionGatherEvent$Nodes"
import {$GatherDataEvent, $GatherDataEvent$Type} from "packages/net/minecraftforge/data/event/$GatherDataEvent"
import {$MissingMappingsEvent, $MissingMappingsEvent$Type} from "packages/net/minecraftforge/registries/$MissingMappingsEvent"
import {$ServerStoppingEvent, $ServerStoppingEvent$Type} from "packages/net/minecraftforge/event/server/$ServerStoppingEvent"
import {$RegisterEvent, $RegisterEvent$Type} from "packages/net/minecraftforge/registries/$RegisterEvent"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$NoneBiomeModifier, $NoneBiomeModifier$Type} from "packages/net/minecraftforge/common/world/$NoneBiomeModifier"
import {$ForgeBiomeModifiers$AddSpawnsBiomeModifier, $ForgeBiomeModifiers$AddSpawnsBiomeModifier$Type} from "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$AddSpawnsBiomeModifier"
import {$ForgeBiomeModifiers$RemoveFeaturesBiomeModifier, $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier$Type} from "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$RemoveFeaturesBiomeModifier"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ForgeBiomeModifiers$AddFeaturesBiomeModifier, $ForgeBiomeModifiers$AddFeaturesBiomeModifier$Type} from "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$AddFeaturesBiomeModifier"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$IdMappingEvent, $IdMappingEvent$Type} from "packages/net/minecraftforge/registries/$IdMappingEvent"
import {$NoneStructureModifier, $NoneStructureModifier$Type} from "packages/net/minecraftforge/common/world/$NoneStructureModifier"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"
import {$FMLLoadCompleteEvent, $FMLLoadCompleteEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLLoadCompleteEvent"

export class $ForgeMod {
static readonly "VERSION_CHECK_CAT": string
static readonly "SWIM_SPEED": $RegistryObject<($Attribute)>
static readonly "NAMETAG_DISTANCE": $RegistryObject<($Attribute)>
static readonly "ENTITY_GRAVITY": $RegistryObject<($Attribute)>
static readonly "BLOCK_REACH": $RegistryObject<($Attribute)>
static readonly "ENTITY_REACH": $RegistryObject<($Attribute)>
static readonly "STEP_HEIGHT_ADDITION": $RegistryObject<($Attribute)>
static readonly "NONE_BIOME_MODIFIER_TYPE": $RegistryObject<($Codec<($NoneBiomeModifier)>)>
static readonly "ADD_FEATURES_BIOME_MODIFIER_TYPE": $RegistryObject<($Codec<($ForgeBiomeModifiers$AddFeaturesBiomeModifier)>)>
static readonly "REMOVE_FEATURES_BIOME_MODIFIER_TYPE": $RegistryObject<($Codec<($ForgeBiomeModifiers$RemoveFeaturesBiomeModifier)>)>
static readonly "ADD_SPAWNS_BIOME_MODIFIER_TYPE": $RegistryObject<($Codec<($ForgeBiomeModifiers$AddSpawnsBiomeModifier)>)>
static readonly "REMOVE_SPAWNS_BIOME_MODIFIER_TYPE": $RegistryObject<($Codec<($ForgeBiomeModifiers$RemoveSpawnsBiomeModifier)>)>
static readonly "NONE_STRUCTURE_MODIFIER_TYPE": $RegistryObject<($Codec<($NoneStructureModifier)>)>
static readonly "ANY_HOLDER_SET": $RegistryObject<($HolderSetType)>
static readonly "AND_HOLDER_SET": $RegistryObject<($HolderSetType)>
static readonly "OR_HOLDER_SET": $RegistryObject<($HolderSetType)>
static readonly "NOT_HOLDER_SET": $RegistryObject<($HolderSetType)>
static readonly "EMPTY_TYPE": $RegistryObject<($FluidType)>
static readonly "WATER_TYPE": $RegistryObject<($FluidType)>
static readonly "LAVA_TYPE": $RegistryObject<($FluidType)>
static readonly "BUCKET_EMPTY_MILK": $RegistryObject<($SoundEvent)>
static readonly "BUCKET_FILL_MILK": $RegistryObject<($SoundEvent)>
static readonly "MILK_TYPE": $RegistryObject<($FluidType)>
static readonly "MILK": $RegistryObject<($Fluid)>
static readonly "FLOWING_MILK": $RegistryObject<($Fluid)>
static readonly "USE_SELECTORS_PERMISSION": $PermissionNode<(boolean)>

constructor()

public static "getInstance"(): $ForgeMod
public "loadComplete"(arg0: $FMLLoadCompleteEvent$Type): void
public "gatherData"(arg0: $GatherDataEvent$Type): void
public static "enableMilkFluid"(): void
public "registerFluids"(arg0: $RegisterEvent$Type): void
public "registerLootData"(arg0: $RegisterEvent$Type): void
public "serverStopping"(arg0: $ServerStoppingEvent$Type): void
public "mappingChanged"(arg0: $IdMappingEvent$Type): void
public "registerRecipeSerializers"(arg0: $RegisterEvent$Type): void
public "registerVanillaDisplayContexts"(arg0: $RegisterEvent$Type): void
public "missingSoundMapping"(arg0: $MissingMappingsEvent$Type): void
public "registerPermissionNodes"(arg0: $PermissionGatherEvent$Nodes$Type): void
public "preInit"(arg0: $FMLCommonSetupEvent$Type): void
get "instance"(): $ForgeMod
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeMod$Type = ($ForgeMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeMod_ = $ForgeMod$Type;
}}
declare module "packages/net/minecraftforge/common/capabilities/$ICapabilityProviderImpl" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CapabilityProvider, $CapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$CapabilityProvider"
import {$CapabilityDispatcher, $CapabilityDispatcher$Type} from "packages/net/minecraftforge/common/capabilities/$CapabilityDispatcher"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $ICapabilityProviderImpl<B extends $ICapabilityProviderImpl<(B)>> extends $ICapabilityProvider {

 "reviveCaps"(): void
 "invalidateCaps"(): void
 "areCapsCompatible"(arg0: $CapabilityDispatcher$Type): boolean
 "areCapsCompatible"(arg0: $CapabilityProvider$Type<(B)>): boolean
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}

export namespace $ICapabilityProviderImpl {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityProviderImpl$Type<B> = ($ICapabilityProviderImpl<(B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityProviderImpl_<B> = $ICapabilityProviderImpl$Type<(B)>;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder$RotationBuilder" {
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"
import {$ModelBuilder$ElementBuilder, $ModelBuilder$ElementBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder"

export class $ModelBuilder$ElementBuilder$RotationBuilder {

constructor(arg0: $ModelBuilder$ElementBuilder$Type)

public "end"(): $ModelBuilder$ElementBuilder<>
public "origin"(arg0: float, arg1: float, arg2: float): $ModelBuilder$ElementBuilder$RotationBuilder<>
public "rescale"(arg0: boolean): $ModelBuilder$ElementBuilder$RotationBuilder<>
public "axis"(arg0: $Direction$Axis$Type): $ModelBuilder$ElementBuilder$RotationBuilder<>
public "angle"(arg0: float): $ModelBuilder$ElementBuilder$RotationBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$ElementBuilder$RotationBuilder$Type = ($ModelBuilder$ElementBuilder$RotationBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$ElementBuilder$RotationBuilder_ = $ModelBuilder$ElementBuilder$RotationBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/loaders/$ObjModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $ObjModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $ObjModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "emissiveAmbient"(arg0: boolean): $ObjModelBuilder<(T)>
public "shadeQuads"(arg0: boolean): $ObjModelBuilder<(T)>
public "automaticCulling"(arg0: boolean): $ObjModelBuilder<(T)>
public "flipV"(arg0: boolean): $ObjModelBuilder<(T)>
public "modelLocation"(arg0: $ResourceLocation$Type): $ObjModelBuilder<(T)>
public "overrideMaterialLibrary"(arg0: $ResourceLocation$Type): $ObjModelBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjModelBuilder$Type<T> = ($ObjModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjModelBuilder_<T> = $ObjModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent" {
import {$SpawnPlacements$Type, $SpawnPlacements$Type$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$Type"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$SpawnPlacements$SpawnPredicate, $SpawnPlacements$SpawnPredicate$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$SpawnPredicate"
import {$Heightmap$Types, $Heightmap$Types$Type} from "packages/net/minecraft/world/level/levelgen/$Heightmap$Types"
import {$SpawnPlacementRegisterEvent$MergedSpawnPredicate, $SpawnPlacementRegisterEvent$MergedSpawnPredicate$Type} from "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent$MergedSpawnPredicate"
import {$SpawnPlacementRegisterEvent$Operation, $SpawnPlacementRegisterEvent$Operation$Type} from "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent$Operation"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SpawnPlacementRegisterEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($EntityType$Type<(any)>), ($SpawnPlacementRegisterEvent$MergedSpawnPredicate$Type<(any)>)>)

public "register"<T extends $Entity>(arg0: $EntityType$Type<(T)>, arg1: $SpawnPlacements$Type$Type, arg2: $Heightmap$Types$Type, arg3: $SpawnPlacements$SpawnPredicate$Type<(T)>, arg4: $SpawnPlacementRegisterEvent$Operation$Type): void
public "register"<T extends $Entity>(arg0: $EntityType$Type<(T)>, arg1: $SpawnPlacements$SpawnPredicate$Type<(T)>): void
public "register"<T extends $Entity>(arg0: $EntityType$Type<(T)>, arg1: $SpawnPlacements$SpawnPredicate$Type<(T)>, arg2: $SpawnPlacementRegisterEvent$Operation$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnPlacementRegisterEvent$Type = ($SpawnPlacementRegisterEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpawnPlacementRegisterEvent_ = $SpawnPlacementRegisterEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/$BakedModelWrapper" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ChunkRenderTypeSet, $ChunkRenderTypeSet$Type} from "packages/net/minecraftforge/client/$ChunkRenderTypeSet"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $BakedModelWrapper<T extends $BakedModel> implements $BakedModel {

constructor(arg0: T)

public "usesBlockLight"(): boolean
public "isGui3d"(): boolean
public "useAmbientOcclusion"(arg0: $BlockState$Type): boolean
public "useAmbientOcclusion"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
public "getParticleIcon"(): $TextureAtlasSprite
public "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type): $List<($BakedQuad)>
public "getRenderTypes"(arg0: $BlockState$Type, arg1: $RandomSource$Type, arg2: $ModelData$Type): $ChunkRenderTypeSet
public "getRenderTypes"(arg0: $ItemStack$Type, arg1: boolean): $List<($RenderType)>
public "getRenderPasses"(arg0: $ItemStack$Type, arg1: boolean): $List<($BakedModel)>
public "isCustomRenderer"(): boolean
public "getOverrides"(): $ItemOverrides
public "applyTransform"(arg0: $ItemDisplayContext$Type, arg1: $PoseStack$Type, arg2: boolean): $BakedModel
public "getTransforms"(): $ItemTransforms
public "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type, arg3: $ModelData$Type, arg4: $RenderType$Type): $List<($BakedQuad)>
public "useAmbientOcclusion"(): boolean
public "getParticleIcon"(arg0: $ModelData$Type): $TextureAtlasSprite
public "getModelData"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ModelData$Type): $ModelData
public "useAmbientOcclusionWithLightEmission"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
get "gui3d"(): boolean
get "particleIcon"(): $TextureAtlasSprite
get "customRenderer"(): boolean
get "overrides"(): $ItemOverrides
get "transforms"(): $ItemTransforms
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BakedModelWrapper$Type<T> = ($BakedModelWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BakedModelWrapper_<T> = $BakedModelWrapper$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent$Finish" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityUseItemEvent, $LivingEntityUseItemEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEntityUseItemEvent$Finish extends $LivingEntityUseItemEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer, arg3: $ItemStack$Type)

public "setResultStack"(arg0: $ItemStack$Type): void
public "getResultStack"(): $ItemStack
public "getListenerList"(): $ListenerList
set "resultStack"(value: $ItemStack$Type)
get "resultStack"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityUseItemEvent$Finish$Type = ($LivingEntityUseItemEvent$Finish);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityUseItemEvent$Finish_ = $LivingEntityUseItemEvent$Finish$Type;
}}
declare module "packages/net/minecraftforge/server/console/$TerminalHandler" {
import {$DedicatedServer, $DedicatedServer$Type} from "packages/net/minecraft/server/dedicated/$DedicatedServer"

export class $TerminalHandler {


public static "handleCommands"(arg0: $DedicatedServer$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerminalHandler$Type = ($TerminalHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TerminalHandler_ = $TerminalHandler$Type;
}}
declare module "packages/net/minecraftforge/common/util/$SortedProperties" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enumeration, $Enumeration$Type} from "packages/java/util/$Enumeration"
import {$Properties, $Properties$Type} from "packages/java/util/$Properties"
import {$Writer, $Writer$Type} from "packages/java/io/$Writer"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SortedProperties extends $Properties {

constructor()

public static "store"(arg0: $Properties$Type, arg1: $Writer$Type, arg2: string): void
public "entrySet"(): $Set<($Map$Entry<(any), (any)>)>
public "keys"(): $Enumeration<(any)>
public "keySet"(): $Set<(any)>
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SortedProperties$Type = ($SortedProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SortedProperties_ = $SortedProperties$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkInstance" {
import {$NetworkEvent, $NetworkEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NetworkEvent$GatherLoginPayloadsEvent, $NetworkEvent$GatherLoginPayloadsEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent$GatherLoginPayloadsEvent"

export class $NetworkInstance {


public "registerObject"(arg0: any): void
public "addGatherListener"(arg0: $Consumer$Type<($NetworkEvent$GatherLoginPayloadsEvent$Type)>): void
public "isRemotePresent"(arg0: $Connection$Type): boolean
public "getChannelName"(): $ResourceLocation
public "unregisterObject"(arg0: any): void
public "addListener"<T extends $NetworkEvent>(arg0: $Consumer$Type<(T)>): void
get "channelName"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkInstance$Type = ($NetworkInstance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkInstance_ = $NetworkInstance$Type;
}}
declare module "packages/net/minecraftforge/common/data/$BlockTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$IntrinsicHolderTagsProvider, $IntrinsicHolderTagsProvider$Type} from "packages/net/minecraft/data/tags/$IntrinsicHolderTagsProvider"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BlockTagsProvider extends $IntrinsicHolderTagsProvider<($Block)> {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: string, arg3: $ExistingFileHelper$Type)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTagsProvider$Type = ($BlockTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTagsProvider_ = $BlockTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/fluids/$FluidActionResult" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $FluidActionResult {
static readonly "FAILURE": $FluidActionResult
readonly "success": boolean
readonly "result": $ItemStack

constructor(arg0: $ItemStack$Type)

public "getResult"(): $ItemStack
public "isSuccess"(): boolean
get "result"(): $ItemStack
get "success"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidActionResult$Type = ($FluidActionResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidActionResult_ = $FluidActionResult$Type;
}}
declare module "packages/net/minecraftforge/client/loading/$ForgeLoadingOverlay" {
import {$DisplayWindow, $DisplayWindow$Type} from "packages/net/minecraftforge/fml/earlydisplay/$DisplayWindow"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ReloadInstance, $ReloadInstance$Type} from "packages/net/minecraft/server/packs/resources/$ReloadInstance"
import {$LoadingOverlay, $LoadingOverlay$Type} from "packages/net/minecraft/client/gui/screens/$LoadingOverlay"

export class $ForgeLoadingOverlay extends $LoadingOverlay {
static readonly "FADE_OUT_TIME": long
static readonly "FADE_IN_TIME": long

constructor(arg0: $Minecraft$Type, arg1: $ReloadInstance$Type, arg2: $Consumer$Type<($Optional$Type<($Throwable$Type)>)>, arg3: $DisplayWindow$Type)

public static "newInstance"(arg0: $Supplier$Type<($Minecraft$Type)>, arg1: $Supplier$Type<($ReloadInstance$Type)>, arg2: $Consumer$Type<($Optional$Type<($Throwable$Type)>)>, arg3: $DisplayWindow$Type): $Supplier<($LoadingOverlay)>
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeLoadingOverlay$Type = ($ForgeLoadingOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeLoadingOverlay_ = $ForgeLoadingOverlay$Type;
}}
declare module "packages/net/minecraftforge/common/$UsernameCache" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UsernameCache {


public static "getMap"(): $Map<($UUID), (string)>
public static "containsUUID"(arg0: $UUID$Type): boolean
public static "getLastKnownUsername"(arg0: $UUID$Type): string
get "map"(): $Map<($UUID), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UsernameCache$Type = ($UsernameCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UsernameCache_ = $UsernameCache$Type;
}}
declare module "packages/net/minecraftforge/event/$AttachCapabilitiesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$GenericEvent, $GenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$GenericEvent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AttachCapabilitiesEvent<T> extends $GenericEvent<(T)> {

constructor()
constructor(arg0: $Class$Type<(T)>, arg1: T)

public "getObject"(): T
public "getCapabilities"(): $Map<($ResourceLocation), ($ICapabilityProvider)>
public "getListeners"(): $List<($Runnable)>
public "addCapability"(arg0: $ResourceLocation$Type, arg1: $ICapabilityProvider$Type): void
public "addListener"(arg0: $Runnable$Type): void
public "getListenerList"(): $ListenerList
get "object"(): T
get "capabilities"(): $Map<($ResourceLocation), ($ICapabilityProvider)>
get "listeners"(): $List<($Runnable)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachCapabilitiesEvent$Type<T> = ($AttachCapabilitiesEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachCapabilitiesEvent_<T> = $AttachCapabilitiesEvent$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/$PresetEditorManager" {
import {$PresetEditor, $PresetEditor$Type} from "packages/net/minecraft/client/gui/screens/worldselection/$PresetEditor"
import {$WorldPreset, $WorldPreset$Type} from "packages/net/minecraft/world/level/levelgen/presets/$WorldPreset"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $PresetEditorManager {


public static "get"(arg0: $ResourceKey$Type<($WorldPreset$Type)>): $PresetEditor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PresetEditorManager$Type = ($PresetEditorManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PresetEditorManager_ = $PresetEditorManager$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterPresetEditorsEvent" {
import {$PresetEditor, $PresetEditor$Type} from "packages/net/minecraft/client/gui/screens/worldselection/$PresetEditor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$WorldPreset, $WorldPreset$Type} from "packages/net/minecraft/world/level/levelgen/presets/$WorldPreset"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterPresetEditorsEvent extends $Event implements $IModBusEvent {

constructor(arg0: $Map$Type<($ResourceKey$Type<($WorldPreset$Type)>), ($PresetEditor$Type)>)
constructor()

public "register"(arg0: $ResourceKey$Type<($WorldPreset$Type)>, arg1: $PresetEditor$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterPresetEditorsEvent$Type = ($RegisterPresetEditorsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterPresetEditorsEvent_ = $RegisterPresetEditorsEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$IShapedRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $IShapedRecipe<T extends $Container> extends $Recipe<(T)> {

 "getRecipeHeight"(): integer
 "getRecipeWidth"(): integer
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getRemainingItems"(arg0: T): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "getToastSymbol"(): $ItemStack
 "isIncomplete"(): boolean
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "assemble"(arg0: T, arg1: $RegistryAccess$Type): $ItemStack
 "getId"(): $ResourceLocation
 "matches"(arg0: T, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $IShapedRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IShapedRecipe$Type<T> = ($IShapedRecipe<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IShapedRecipe_<T> = $IShapedRecipe$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/data/$ExistingFileHelper$IResourceType" {
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"

export interface $ExistingFileHelper$IResourceType {

 "getSuffix"(): string
 "getPrefix"(): string
 "getPackType"(): $PackType
}

export namespace $ExistingFileHelper$IResourceType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExistingFileHelper$IResourceType$Type = ($ExistingFileHelper$IResourceType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExistingFileHelper$IResourceType_ = $ExistingFileHelper$IResourceType$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ItemModelProvider" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ItemModelBuilder, $ItemModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ItemModelBuilder"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ModelProvider, $ModelProvider$Type} from "packages/net/minecraftforge/client/model/generators/$ModelProvider"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemModelProvider extends $ModelProvider<($ItemModelBuilder)> {
static readonly "BLOCK_FOLDER": string
static readonly "ITEM_FOLDER": string
readonly "generatedModels": $Map<($ResourceLocation), (T)>
readonly "existingFileHelper": $ExistingFileHelper

constructor(arg0: $PackOutput$Type, arg1: string, arg2: $ExistingFileHelper$Type)

public "basicItem"(arg0: $ResourceLocation$Type): $ItemModelBuilder
public "basicItem"(arg0: $Item$Type): $ItemModelBuilder
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelProvider$Type = ($ItemModelProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModelProvider_ = $ItemModelProvider$Type;
}}
declare module "packages/net/minecraftforge/energy/$IEnergyStorage" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IEnergyStorage {

 "getEnergyStored"(): integer
 "getMaxEnergyStored"(): integer
 "canExtract"(): boolean
 "receiveEnergy"(arg0: integer, arg1: boolean): integer
 "canReceive"(): boolean
 "extractEnergy"(arg0: integer, arg1: boolean): integer
}

export namespace $IEnergyStorage {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEnergyStorage$Type = ($IEnergyStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEnergyStorage_ = $IEnergyStorage$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$IGenericEvent" {
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export interface $IGenericEvent<T> {

 "getGenericType"(): $Type

(): $Type
}

export namespace $IGenericEvent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGenericEvent$Type<T> = ($IGenericEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGenericEvent_<T> = $IGenericEvent$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterItemDecorationsEvent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IItemDecorator, $IItemDecorator$Type} from "packages/net/minecraftforge/client/$IItemDecorator"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterItemDecorationsEvent extends $Event implements $IModBusEvent {

constructor(arg0: $Map$Type<($Item$Type), ($List$Type<($IItemDecorator$Type)>)>)
constructor()

public "register"(arg0: $ItemLike$Type, arg1: $IItemDecorator$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterItemDecorationsEvent$Type = ($RegisterItemDecorationsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterItemDecorationsEvent_ = $RegisterItemDecorationsEvent$Type;
}}
declare module "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$HasFluidInteraction" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"

export interface $FluidInteractionRegistry$HasFluidInteraction {

 "test"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type): boolean

(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type): boolean
}

export namespace $FluidInteractionRegistry$HasFluidInteraction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInteractionRegistry$HasFluidInteraction$Type = ($FluidInteractionRegistry$HasFluidInteraction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInteractionRegistry$HasFluidInteraction_ = $FluidInteractionRegistry$HasFluidInteraction$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$ModConfig" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$IConfigSpec, $IConfigSpec$Type} from "packages/net/minecraftforge/fml/config/$IConfigSpec"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ConfigFileTypeHandler, $ConfigFileTypeHandler$Type} from "packages/net/minecraftforge/fml/config/$ConfigFileTypeHandler"
import {$ModConfig$Type, $ModConfig$Type$Type} from "packages/net/minecraftforge/fml/config/$ModConfig$Type"
import {$CommentedConfig, $CommentedConfig$Type} from "packages/com/electronwill/nightconfig/core/$CommentedConfig"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModConfig {

constructor(arg0: $ModConfig$Type$Type, arg1: $IConfigSpec$Type<(any)>, arg2: $ModContainer$Type, arg3: string)
constructor(arg0: $ModConfig$Type$Type, arg1: $IConfigSpec$Type<(any)>, arg2: $ModContainer$Type)

public "save"(): void
public "getType"(): $ModConfig$Type
public "getFileName"(): string
public "getHandler"(): $ConfigFileTypeHandler
public "getFullPath"(): $Path
public "getConfigData"(): $CommentedConfig
public "getSpec"<T extends $IConfigSpec<(T)>>(): $IConfigSpec<(T)>
public "acceptSyncedConfig"(arg0: (byte)[]): void
public "getModId"(): string
get "type"(): $ModConfig$Type
get "fileName"(): string
get "handler"(): $ConfigFileTypeHandler
get "fullPath"(): $Path
get "configData"(): $CommentedConfig
get "spec"(): $IConfigSpec<(T)>
get "modId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModConfig$Type = ($ModConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModConfig_ = $ModConfig$Type;
}}
declare module "packages/net/minecraftforge/client/$FireworkShapeFactoryRegistry" {
import {$FireworkRocketItem$Shape, $FireworkRocketItem$Shape$Type} from "packages/net/minecraft/world/item/$FireworkRocketItem$Shape"
import {$FireworkShapeFactoryRegistry$Factory, $FireworkShapeFactoryRegistry$Factory$Type} from "packages/net/minecraftforge/client/$FireworkShapeFactoryRegistry$Factory"

export class $FireworkShapeFactoryRegistry {

constructor()

public static "get"(arg0: $FireworkRocketItem$Shape$Type): $FireworkShapeFactoryRegistry$Factory
public static "register"(arg0: $FireworkRocketItem$Shape$Type, arg1: $FireworkShapeFactoryRegistry$Factory$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkShapeFactoryRegistry$Type = ($FireworkShapeFactoryRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworkShapeFactoryRegistry_ = $FireworkShapeFactoryRegistry$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkRegistry" {
import {$ServerStatusPing$ChannelData, $ServerStatusPing$ChannelData$Type} from "packages/net/minecraftforge/network/$ServerStatusPing$ChannelData"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EventNetworkChannel, $EventNetworkChannel$Type} from "packages/net/minecraftforge/network/event/$EventNetworkChannel"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$SimpleChannel, $SimpleChannel$Type} from "packages/net/minecraftforge/network/simple/$SimpleChannel"

export class $NetworkRegistry {
static "ABSENT": $ServerStatusPing$ChannelData
static "ACCEPTVANILLA": string

constructor()

public static "lock"(): void
public "isLocked"(): boolean
public static "checkListPingCompatibilityForClient"(arg0: $Map$Type<($ResourceLocation$Type), ($ServerStatusPing$ChannelData$Type)>): boolean
public static "acceptMissingOr"(arg0: $Predicate$Type<(string)>): $Predicate<(string)>
public static "acceptMissingOr"(arg0: string): $Predicate<(string)>
public static "newEventChannel"(arg0: $ResourceLocation$Type, arg1: $Supplier$Type<(string)>, arg2: $Predicate$Type<(string)>, arg3: $Predicate$Type<(string)>): $EventNetworkChannel
public static "newSimpleChannel"(arg0: $ResourceLocation$Type, arg1: $Supplier$Type<(string)>, arg2: $Predicate$Type<(string)>, arg3: $Predicate$Type<(string)>): $SimpleChannel
public static "canConnectToVanillaServer"(): boolean
public static "acceptsVanillaClientConnections"(): boolean
public static "getClientNonVanillaNetworkMods"(): $List<(string)>
public static "getServerNonVanillaNetworkMods"(): $List<(string)>
get "locked"(): boolean
get "clientNonVanillaNetworkMods"(): $List<(string)>
get "serverNonVanillaNetworkMods"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkRegistry$Type = ($NetworkRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkRegistry_ = $NetworkRegistry$Type;
}}
declare module "packages/net/minecraftforge/common/world/$StructureSettingsBuilder$StructureSpawnOverrideBuilder" {
import {$StructureSpawnOverride, $StructureSpawnOverride$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureSpawnOverride"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$StructureSpawnOverride$BoundingBoxType, $StructureSpawnOverride$BoundingBoxType$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureSpawnOverride$BoundingBoxType"

export class $StructureSettingsBuilder$StructureSpawnOverrideBuilder {


public static "copyOf"(arg0: $StructureSpawnOverride$Type): $StructureSettingsBuilder$StructureSpawnOverrideBuilder
public "build"(): $StructureSpawnOverride
public "addSpawn"(arg0: $MobSpawnSettings$SpawnerData$Type): void
public "getBoundingBox"(): $StructureSpawnOverride$BoundingBoxType
public "getSpawns"(): $List<($MobSpawnSettings$SpawnerData)>
public "removeSpawn"(arg0: $MobSpawnSettings$SpawnerData$Type): void
public "setBoundingBox"(arg0: $StructureSpawnOverride$BoundingBoxType$Type): void
get "boundingBox"(): $StructureSpawnOverride$BoundingBoxType
get "spawns"(): $List<($MobSpawnSettings$SpawnerData)>
set "boundingBox"(value: $StructureSpawnOverride$BoundingBoxType$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSettingsBuilder$StructureSpawnOverrideBuilder$Type = ($StructureSettingsBuilder$StructureSpawnOverrideBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureSettingsBuilder$StructureSpawnOverrideBuilder_ = $StructureSettingsBuilder$StructureSpawnOverrideBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$ValueSpec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ForgeConfigSpec$Range, $ForgeConfigSpec$Range$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$Range"

export class $ForgeConfigSpec$ValueSpec {


public "test"(arg0: any): boolean
public "getDefault"(): any
public "getComment"(): string
public "getClazz"(): $Class<(any)>
public "getRange"<V extends $Comparable<(any)>>(): $ForgeConfigSpec$Range<(V)>
public "correct"(arg0: any): any
public "getTranslationKey"(): string
public "needsWorldRestart"(): boolean
get "default"(): any
get "comment"(): string
get "clazz"(): $Class<(any)>
get "range"(): $ForgeConfigSpec$Range<(V)>
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$ValueSpec$Type = ($ForgeConfigSpec$ValueSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$ValueSpec_ = $ForgeConfigSpec$ValueSpec$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ContainerScreenEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"

export class $ContainerScreenEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "getContainerScreen"(): $AbstractContainerScreen<(any)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "containerScreen"(): $AbstractContainerScreen<(any)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerScreenEvent$Type = ($ContainerScreenEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerScreenEvent_ = $ContainerScreenEvent$Type;
}}
declare module "packages/net/minecraftforge/network/simple/$SimpleChannel" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$NetworkInstance, $NetworkInstance$Type} from "packages/net/minecraftforge/network/$NetworkInstance"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NetworkEvent$ChannelRegistrationChangeEvent, $NetworkEvent$ChannelRegistrationChangeEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent$ChannelRegistrationChangeEvent"
import {$PacketDistributor$PacketTarget, $PacketDistributor$PacketTarget$Type} from "packages/net/minecraftforge/network/$PacketDistributor$PacketTarget"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$SimpleChannel$MessageBuilder, $SimpleChannel$MessageBuilder$Type} from "packages/net/minecraftforge/network/simple/$SimpleChannel$MessageBuilder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IndexedMessageCodec$MessageHandler, $IndexedMessageCodec$MessageHandler$Type} from "packages/net/minecraftforge/network/simple/$IndexedMessageCodec$MessageHandler"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $SimpleChannel {

constructor(arg0: $NetworkInstance$Type, arg1: $Consumer$Type<($NetworkEvent$ChannelRegistrationChangeEvent$Type)>)
constructor(arg0: $NetworkInstance$Type)

public "send"<MSG>(arg0: $PacketDistributor$PacketTarget$Type, arg1: MSG): void
public "messageBuilder"<M>(arg0: $Class$Type<(M)>, arg1: integer): $SimpleChannel$MessageBuilder<(M)>
public "messageBuilder"<M>(arg0: $Class$Type<(M)>, arg1: integer, arg2: $NetworkDirection$Type): $SimpleChannel$MessageBuilder<(M)>
public "encodeMessage"<MSG>(arg0: MSG, arg1: $FriendlyByteBuf$Type): integer
public "registerMessage"<MSG>(arg0: integer, arg1: $Class$Type<(MSG)>, arg2: $BiConsumer$Type<(MSG), ($FriendlyByteBuf$Type)>, arg3: $Function$Type<($FriendlyByteBuf$Type), (MSG)>, arg4: $BiConsumer$Type<(MSG), ($Supplier$Type<($NetworkEvent$Context$Type)>)>, arg5: $Optional$Type<($NetworkDirection$Type)>): $IndexedMessageCodec$MessageHandler<(MSG)>
public "registerMessage"<MSG>(arg0: integer, arg1: $Class$Type<(MSG)>, arg2: $BiConsumer$Type<(MSG), ($FriendlyByteBuf$Type)>, arg3: $Function$Type<($FriendlyByteBuf$Type), (MSG)>, arg4: $BiConsumer$Type<(MSG), ($Supplier$Type<($NetworkEvent$Context$Type)>)>): $IndexedMessageCodec$MessageHandler<(MSG)>
public "isRemotePresent"(arg0: $Connection$Type): boolean
public "toVanillaPacket"<MSG>(arg0: MSG, arg1: $NetworkDirection$Type): $Packet<(any)>
public "sendTo"<MSG>(arg0: MSG, arg1: $Connection$Type, arg2: $NetworkDirection$Type): void
public "reply"<MSG>(arg0: MSG, arg1: $NetworkEvent$Context$Type): void
public "sendToServer"<MSG>(arg0: MSG): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleChannel$Type = ($SimpleChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleChannel_ = $SimpleChannel$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ContainerScreenEvent$Render$Background" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ContainerScreenEvent$Render, $ContainerScreenEvent$Render$Type} from "packages/net/minecraftforge/client/event/$ContainerScreenEvent$Render"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"

export class $ContainerScreenEvent$Render$Background extends $ContainerScreenEvent$Render {

constructor(arg0: $AbstractContainerScreen$Type<(any)>, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerScreenEvent$Render$Background$Type = ($ContainerScreenEvent$Render$Background);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerScreenEvent$Render$Background_ = $ContainerScreenEvent$Render$Background$Type;
}}
declare module "packages/net/minecraftforge/registries/$NamespacedWrapper" {
import {$Lifecycle, $Lifecycle$Type} from "packages/com/mojang/serialization/$Lifecycle"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$ILockableRegistry, $ILockableRegistry$Type} from "packages/net/minecraftforge/registries/$ILockableRegistry"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$MappedRegistry, $MappedRegistry$Type} from "packages/net/minecraft/core/$MappedRegistry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$HolderGetter, $HolderGetter$Type} from "packages/net/minecraft/core/$HolderGetter"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NamespacedWrapper<T> extends $MappedRegistry<(T)> implements $ILockableRegistry {


/**
 * 
 * @deprecated
 */
public "lock"(): void
public "iterator"(): $Iterator<(T)>
public "size"(): integer
public "unfreeze"(): void
public "getKey"(arg0: T): $ResourceLocation
public "wrapAsHolder"(arg0: T): $Holder<(T)>
public "byId"(arg0: integer): T
public "lifecycle"(arg0: T): $Lifecycle
public "getResourceKey"(arg0: T): $Optional<($ResourceKey<(T)>)>
public "getId"(arg0: T): integer
public "get"(arg0: $ResourceKey$Type<(T)>): T
public "registryKeySet"(): $Set<($ResourceKey<(T)>)>
public "entrySet"(): $Set<($Map$Entry<($ResourceKey<(T)>), (T)>)>
public "containsKey"(arg0: $ResourceKey$Type<(T)>): boolean
public "getRandom"(arg0: $RandomSource$Type): $Optional<($Holder$Reference<(T)>)>
public "containsKey"(arg0: $ResourceLocation$Type): boolean
public "register"(arg0: $ResourceKey$Type<(T)>, arg1: T, arg2: $Lifecycle$Type): $Holder$Reference<(T)>
public "get"(arg0: $ResourceLocation$Type): T
public "freeze"(): $Registry<(T)>
public "createRegistrationLookup"(): $HolderGetter<(T)>
public "registerMapping"(arg0: integer, arg1: $ResourceKey$Type<(T)>, arg2: T, arg3: $Lifecycle$Type): $Holder$Reference<(T)>
public "isEmpty"(): boolean
public "getOptional"(arg0: $ResourceLocation$Type): $Optional<(T)>
public "getTag"(arg0: $TagKey$Type<(T)>): $Optional<($HolderSet$Named<(T)>)>
public "createIntrusiveHolder"(arg0: T): $Holder$Reference<(T)>
public "getHolder"(arg0: integer): $Optional<($Holder$Reference<(T)>)>
public "getHolder"(arg0: $ResourceKey$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
public "holders"(): $Stream<($Holder$Reference<(T)>)>
public "bindTags"(arg0: $Map$Type<($TagKey$Type<(T)>), ($List$Type<($Holder$Type<(T)>)>)>): void
public "getOrCreateTag"(arg0: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public "resetTags"(): void
public "getTags"(): $Stream<($Pair<($TagKey<(T)>), ($HolderSet$Named<(T)>)>)>
public "getTagNames"(): $Stream<($TagKey<(T)>)>
public "keySet"(): $Set<($ResourceLocation)>
public "registryLifecycle"(): $Lifecycle
public static "register"<T>(arg0: $Registry$Type<(any)>, arg1: string, arg2: T): T
public static "register"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: $ResourceLocation$Type, arg2: T): T
public static "register"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: $ResourceKey$Type<(V)>, arg2: T): T
public static "registerMapping"<V, T extends V>(arg0: $Registry$Type<(V)>, arg1: integer, arg2: string, arg3: T): T
public static "registerForHolder"<T>(arg0: $Registry$Type<(T)>, arg1: $ResourceKey$Type<(T)>, arg2: T): $Holder$Reference<(T)>
public static "registerForHolder"<T>(arg0: $Registry$Type<(T)>, arg1: $ResourceLocation$Type, arg2: T): $Holder$Reference<(T)>
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
get "empty"(): boolean
get "tags"(): $Stream<($Pair<($TagKey<(T)>), ($HolderSet$Named<(T)>)>)>
get "tagNames"(): $Stream<($TagKey<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamespacedWrapper$Type<T> = ($NamespacedWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamespacedWrapper_<T> = $NamespacedWrapper$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$ItemCraftedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $PlayerEvent$ItemCraftedEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $Container$Type)

public "getCrafting"(): $ItemStack
public "getInventory"(): $Container
public "getListenerList"(): $ListenerList
get "crafting"(): $ItemStack
get "inventory"(): $Container
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$ItemCraftedEvent$Type = ($PlayerEvent$ItemCraftedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$ItemCraftedEvent_ = $PlayerEvent$ItemCraftedEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ModLifecycleEvent, $ModLifecycleEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ModLifecycleEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ParallelDispatchEvent extends $ModLifecycleEvent {

constructor()
constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)

public "enqueueWork"(arg0: $Runnable$Type): $CompletableFuture<(void)>
public "enqueueWork"<T>(arg0: $Supplier$Type<(T)>): $CompletableFuture<(T)>
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParallelDispatchEvent$Type = ($ParallelDispatchEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParallelDispatchEvent_ = $ParallelDispatchEvent$Type;
}}
declare module "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Properties" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ForgeFlowingFluid$Properties {

constructor(arg0: $Supplier$Type<(any)>, arg1: $Supplier$Type<(any)>, arg2: $Supplier$Type<(any)>)

public "block"(arg0: $Supplier$Type<(any)>): $ForgeFlowingFluid$Properties
public "explosionResistance"(arg0: float): $ForgeFlowingFluid$Properties
public "bucket"(arg0: $Supplier$Type<(any)>): $ForgeFlowingFluid$Properties
public "tickRate"(arg0: integer): $ForgeFlowingFluid$Properties
public "slopeFindDistance"(arg0: integer): $ForgeFlowingFluid$Properties
public "levelDecreasePerBlock"(arg0: integer): $ForgeFlowingFluid$Properties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFlowingFluid$Properties$Type = ($ForgeFlowingFluid$Properties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFlowingFluid$Properties_ = $ForgeFlowingFluid$Properties$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$CharacterTyped" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$CharacterTyped extends $ScreenEvent {

constructor()
constructor(arg0: $Screen$Type, arg1: character, arg2: integer)

public "getModifiers"(): integer
public "getCodePoint"(): character
public "getListenerList"(): $ListenerList
get "modifiers"(): integer
get "codePoint"(): character
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$CharacterTyped$Type = ($ScreenEvent$CharacterTyped);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$CharacterTyped_ = $ScreenEvent$CharacterTyped$Type;
}}
declare module "packages/net/minecraftforge/common/util/$NonNullConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $NonNullConsumer<T> {

 "accept"(arg0: T): void

(arg0: T): void
}

export namespace $NonNullConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonNullConsumer$Type<T> = ($NonNullConsumer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonNullConsumer_<T> = $NonNullConsumer$Type<(T)>;
}}
declare module "packages/net/minecraftforge/forgespi/language/$ILifecycleEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ILifecycleEvent<R extends $ILifecycleEvent<(any)>> {

 "concrete"(): R
}

export namespace $ILifecycleEvent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILifecycleEvent$Type<R> = ($ILifecycleEvent<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILifecycleEvent_<R> = $ILifecycleEvent$Type<(R)>;
}}
declare module "packages/net/minecraftforge/common/$FarmlandWaterManager" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$AABBTicket, $AABBTicket$Type} from "packages/net/minecraftforge/common/ticket/$AABBTicket"
import {$SimpleTicket, $SimpleTicket$Type} from "packages/net/minecraftforge/common/ticket/$SimpleTicket"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $FarmlandWaterManager {

constructor()

public static "hasBlockWaterTicket"(arg0: $LevelReader$Type, arg1: $BlockPos$Type): boolean
public static "addAABBTicket"(arg0: $Level$Type, arg1: $AABB$Type): $AABBTicket
public static "addCustomTicket"<T extends $SimpleTicket<($Vec3)>>(arg0: $Level$Type, arg1: T, arg2: $ChunkPos$Type, ...arg3: ($ChunkPos$Type)[]): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandWaterManager$Type = ($FarmlandWaterManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FarmlandWaterManager_ = $FarmlandWaterManager$Type;
}}
declare module "packages/net/minecraftforge/fml/$InterModComms$IMCMessage" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $InterModComms$IMCMessage extends $Record {

constructor(senderModId: string, modId: string, method: string, messageSupplier: $Supplier$Type<(any)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "method"(): string
public "hashCode"(): integer
/**
 * 
 * @deprecated
 */
public "getMethod"(): string
public "messageSupplier"(): $Supplier<(any)>
/**
 * 
 * @deprecated
 */
public "getMessageSupplier"<T>(): $Supplier<(T)>
/**
 * 
 * @deprecated
 */
public "getSenderModId"(): string
public "senderModId"(): string
public "modId"(): string
/**
 * 
 * @deprecated
 */
public "getModId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterModComms$IMCMessage$Type = ($InterModComms$IMCMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterModComms$IMCMessage_ = $InterModComms$IMCMessage$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityLeaveLevelEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityLeaveLevelEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Level$Type)

public "getLevel"(): $Level
public "getListenerList"(): $ListenerList
get "level"(): $Level
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityLeaveLevelEvent$Type = ($EntityLeaveLevelEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityLeaveLevelEvent_ = $EntityLeaveLevelEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$ShieldBlockEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ShieldBlockEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: float)

public "isCancelable"(): boolean
public "getDamageSource"(): $DamageSource
public "getBlockedDamage"(): float
public "shieldTakesDamage"(): boolean
public "getOriginalBlockedDamage"(): float
public "setShieldTakesDamage"(arg0: boolean): void
public "setBlockedDamage"(arg0: float): void
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "damageSource"(): $DamageSource
get "blockedDamage"(): float
get "originalBlockedDamage"(): float
set "blockedDamage"(value: float)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShieldBlockEvent$Type = ($ShieldBlockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShieldBlockEvent_ = $ShieldBlockEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeMessages$LoginIndexedMessage" {
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"

export class $HandshakeMessages$LoginIndexedMessage implements $IntSupplier {


public "getAsInt"(): integer
get "asInt"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeMessages$LoginIndexedMessage$Type = ($HandshakeMessages$LoginIndexedMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeMessages$LoginIndexedMessage_ = $HandshakeMessages$LoginIndexedMessage$Type;
}}
declare module "packages/net/minecraftforge/client/$RecipeBookManager" {
import {$RecipeBookType, $RecipeBookType$Type} from "packages/net/minecraft/world/inventory/$RecipeBookType"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeBookCategories, $RecipeBookCategories$Type} from "packages/net/minecraft/client/$RecipeBookCategories"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeBookManager {

constructor()

public static "init"(): void
public static "getAggregateCategories"(): $Map<($RecipeBookCategories), ($List<($RecipeBookCategories)>)>
public static "getCustomCategoriesOrEmpty"(arg0: $RecipeBookType$Type): $List<($RecipeBookCategories)>
public static "findCategories"<T extends $Recipe<(any)>>(arg0: $RecipeType$Type<(T)>, arg1: T): $RecipeBookCategories
get "aggregateCategories"(): $Map<($RecipeBookCategories), ($List<($RecipeBookCategories)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeBookManager$Type = ($RecipeBookManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeBookManager_ = $RecipeBookManager$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingDestroyBlockEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingDestroyBlockEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "getState"(): $BlockState
public "isCancelable"(): boolean
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
get "state"(): $BlockState
get "cancelable"(): boolean
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingDestroyBlockEvent$Type = ($LivingDestroyBlockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingDestroyBlockEvent_ = $LivingDestroyBlockEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder$PartBuilder$ConditionGroup" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$MultiPartBlockStateBuilder$PartBuilder, $MultiPartBlockStateBuilder$PartBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$MultiPartBlockStateBuilder$PartBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"

export class $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup {
readonly "conditions": $Multimap<($Property<(any)>), ($Comparable<(any)>)>
readonly "nestedConditionGroups": $List<($MultiPartBlockStateBuilder$PartBuilder$ConditionGroup)>
 "useOr": boolean

constructor(arg0: $MultiPartBlockStateBuilder$PartBuilder$Type)

public "end"(): $MultiPartBlockStateBuilder$PartBuilder
public "condition"<T extends $Comparable<(T)>>(arg0: $Property$Type<(T)>, ...arg1: (T)[]): $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup
public "nestedGroup"(): $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup
public "useOr"(): $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup
public "endNestedGroup"(): $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup$Type = ($MultiPartBlockStateBuilder$PartBuilder$ConditionGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup_ = $MultiPartBlockStateBuilder$PartBuilder$ConditionGroup$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEvent extends $EntityEvent {

constructor()
constructor(arg0: $LivingEntity$Type)

public "getEntity"(): $LivingEntity
public "getListenerList"(): $ListenerList
get "entity"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEvent$Type = ($LivingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEvent_ = $LivingEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeRegistries" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Schedule, $Schedule$Type} from "packages/net/minecraft/world/entity/schedule/$Schedule"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ChunkStatus, $ChunkStatus$Type} from "packages/net/minecraft/world/level/chunk/$ChunkStatus"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$EntityDataSerializer, $EntityDataSerializer$Type} from "packages/net/minecraft/network/syncher/$EntityDataSerializer"
import {$PaintingVariant, $PaintingVariant$Type} from "packages/net/minecraft/world/entity/decoration/$PaintingVariant"
import {$PoiType, $PoiType$Type} from "packages/net/minecraft/world/entity/ai/village/poi/$PoiType"
import {$FoliagePlacerType, $FoliagePlacerType$Type} from "packages/net/minecraft/world/level/levelgen/feature/foliageplacers/$FoliagePlacerType"
import {$BlockStateProviderType, $BlockStateProviderType$Type} from "packages/net/minecraft/world/level/levelgen/feature/stateproviders/$BlockStateProviderType"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$StatType, $StatType$Type} from "packages/net/minecraft/stats/$StatType"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$VillagerProfession, $VillagerProfession$Type} from "packages/net/minecraft/world/entity/npc/$VillagerProfession"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Potion, $Potion$Type} from "packages/net/minecraft/world/item/alchemy/$Potion"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Activity, $Activity$Type} from "packages/net/minecraft/world/entity/schedule/$Activity"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MemoryModuleType, $MemoryModuleType$Type} from "packages/net/minecraft/world/entity/ai/memory/$MemoryModuleType"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$SensorType, $SensorType$Type} from "packages/net/minecraft/world/entity/ai/sensing/$SensorType"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ArgumentTypeInfo, $ArgumentTypeInfo$Type} from "packages/net/minecraft/commands/synchronization/$ArgumentTypeInfo"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$WorldCarver, $WorldCarver$Type} from "packages/net/minecraft/world/level/levelgen/carver/$WorldCarver"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$TreeDecoratorType, $TreeDecoratorType$Type} from "packages/net/minecraft/world/level/levelgen/feature/treedecorators/$TreeDecoratorType"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"

export class $ForgeRegistries {
static readonly "BLOCKS": $IForgeRegistry<($Block)>
static readonly "FLUIDS": $IForgeRegistry<($Fluid)>
static readonly "ITEMS": $IForgeRegistry<($Item)>
static readonly "MOB_EFFECTS": $IForgeRegistry<($MobEffect)>
static readonly "SOUND_EVENTS": $IForgeRegistry<($SoundEvent)>
static readonly "POTIONS": $IForgeRegistry<($Potion)>
static readonly "ENCHANTMENTS": $IForgeRegistry<($Enchantment)>
static readonly "ENTITY_TYPES": $IForgeRegistry<($EntityType<(any)>)>
static readonly "BLOCK_ENTITY_TYPES": $IForgeRegistry<($BlockEntityType<(any)>)>
static readonly "PARTICLE_TYPES": $IForgeRegistry<($ParticleType<(any)>)>
static readonly "MENU_TYPES": $IForgeRegistry<($MenuType<(any)>)>
static readonly "PAINTING_VARIANTS": $IForgeRegistry<($PaintingVariant)>
static readonly "RECIPE_TYPES": $IForgeRegistry<($RecipeType<(any)>)>
static readonly "RECIPE_SERIALIZERS": $IForgeRegistry<($RecipeSerializer<(any)>)>
static readonly "ATTRIBUTES": $IForgeRegistry<($Attribute)>
static readonly "STAT_TYPES": $IForgeRegistry<($StatType<(any)>)>
static readonly "COMMAND_ARGUMENT_TYPES": $IForgeRegistry<($ArgumentTypeInfo<(any), (any)>)>
static readonly "VILLAGER_PROFESSIONS": $IForgeRegistry<($VillagerProfession)>
static readonly "POI_TYPES": $IForgeRegistry<($PoiType)>
static readonly "MEMORY_MODULE_TYPES": $IForgeRegistry<($MemoryModuleType<(any)>)>
static readonly "SENSOR_TYPES": $IForgeRegistry<($SensorType<(any)>)>
static readonly "SCHEDULES": $IForgeRegistry<($Schedule)>
static readonly "ACTIVITIES": $IForgeRegistry<($Activity)>
static readonly "WORLD_CARVERS": $IForgeRegistry<($WorldCarver<(any)>)>
static readonly "FEATURES": $IForgeRegistry<($Feature<(any)>)>
static readonly "CHUNK_STATUS": $IForgeRegistry<($ChunkStatus)>
static readonly "BLOCK_STATE_PROVIDER_TYPES": $IForgeRegistry<($BlockStateProviderType<(any)>)>
static readonly "FOLIAGE_PLACER_TYPES": $IForgeRegistry<($FoliagePlacerType<(any)>)>
static readonly "TREE_DECORATOR_TYPES": $IForgeRegistry<($TreeDecoratorType<(any)>)>
static readonly "BIOMES": $IForgeRegistry<($Biome)>
static readonly "ENTITY_DATA_SERIALIZERS": $Supplier<($IForgeRegistry<($EntityDataSerializer<(any)>)>)>
static readonly "GLOBAL_LOOT_MODIFIER_SERIALIZERS": $Supplier<($IForgeRegistry<($Codec<(any)>)>)>
static readonly "BIOME_MODIFIER_SERIALIZERS": $Supplier<($IForgeRegistry<($Codec<(any)>)>)>
static readonly "STRUCTURE_MODIFIER_SERIALIZERS": $Supplier<($IForgeRegistry<($Codec<(any)>)>)>
static readonly "FLUID_TYPES": $Supplier<($IForgeRegistry<($FluidType)>)>
static readonly "HOLDER_SET_TYPES": $Supplier<($IForgeRegistry<($HolderSetType)>)>
static readonly "DISPLAY_CONTEXTS": $Supplier<($IForgeRegistry<($ItemDisplayContext)>)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRegistries$Type = ($ForgeRegistries);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRegistries_ = $ForgeRegistries$Type;
}}
declare module "packages/net/minecraftforge/common/world/$BiomeModifier$Phase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BiomeModifier$Phase extends $Enum<($BiomeModifier$Phase)> {
static readonly "BEFORE_EVERYTHING": $BiomeModifier$Phase
static readonly "ADD": $BiomeModifier$Phase
static readonly "REMOVE": $BiomeModifier$Phase
static readonly "MODIFY": $BiomeModifier$Phase
static readonly "AFTER_EVERYTHING": $BiomeModifier$Phase


public static "values"(): ($BiomeModifier$Phase)[]
public static "valueOf"(arg0: string): $BiomeModifier$Phase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeModifier$Phase$Type = (("add") | ("modify") | ("before_everything") | ("after_everything") | ("remove")) | ($BiomeModifier$Phase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeModifier$Phase_ = $BiomeModifier$Phase$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterRecipeBookCategoriesEvent" {
import {$RecipeBookType, $RecipeBookType$Type} from "packages/net/minecraft/world/inventory/$RecipeBookType"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeBookCategories, $RecipeBookCategories$Type} from "packages/net/minecraft/client/$RecipeBookCategories"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterRecipeBookCategoriesEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($RecipeBookCategories$Type), ($ImmutableList$Type<($RecipeBookCategories$Type)>)>, arg1: $Map$Type<($RecipeBookType$Type), ($ImmutableList$Type<($RecipeBookCategories$Type)>)>, arg2: $Map$Type<($RecipeType$Type<(any)>), ($Function$Type<($Recipe$Type<(any)>), ($RecipeBookCategories$Type)>)>)

public "isCancelable"(): boolean
public "registerAggregateCategory"(arg0: $RecipeBookCategories$Type, arg1: $List$Type<($RecipeBookCategories$Type)>): void
public "registerBookCategories"(arg0: $RecipeBookType$Type, arg1: $List$Type<($RecipeBookCategories$Type)>): void
public "registerRecipeCategoryFinder"(arg0: $RecipeType$Type<(any)>, arg1: $Function$Type<($Recipe$Type<(any)>), ($RecipeBookCategories$Type)>): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterRecipeBookCategoriesEvent$Type = ($RegisterRecipeBookCategoriesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterRecipeBookCategoriesEvent_ = $RegisterRecipeBookCategoriesEvent$Type;
}}
declare module "packages/net/minecraftforge/eventbus/$ListenerList" {
import {$IEventListener, $IEventListener$Type} from "packages/net/minecraftforge/eventbus/api/$IEventListener"
import {$EventPriority, $EventPriority$Type} from "packages/net/minecraftforge/eventbus/api/$EventPriority"

export class $ListenerList {

constructor()
constructor(arg0: $ListenerList$Type)

public "register"(arg0: integer, arg1: $EventPriority$Type, arg2: $IEventListener$Type): void
public "unregister"(arg0: integer, arg1: $IEventListener$Type): void
public "getListeners"(arg0: integer): ($IEventListener)[]
public static "unregisterAll"(arg0: integer, arg1: $IEventListener$Type): void
public static "clearBusID"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListenerList$Type = ($ListenerList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListenerList_ = $ListenerList$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IFluidHandler$FluidAction extends $Enum<($IFluidHandler$FluidAction)> {
static readonly "EXECUTE": $IFluidHandler$FluidAction
static readonly "SIMULATE": $IFluidHandler$FluidAction


public static "values"(): ($IFluidHandler$FluidAction)[]
public static "valueOf"(arg0: string): $IFluidHandler$FluidAction
public "execute"(): boolean
public "simulate"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidHandler$FluidAction$Type = (("execute") | ("simulate")) | ($IFluidHandler$FluidAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidHandler$FluidAction_ = $IFluidHandler$FluidAction$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$ExtendedButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Button, $Button$Type} from "packages/net/minecraft/client/gui/components/$Button"
import {$Button$Builder, $Button$Builder$Type} from "packages/net/minecraft/client/gui/components/$Button$Builder"
import {$Button$CreateNarration, $Button$CreateNarration$Type} from "packages/net/minecraft/client/gui/components/$Button$CreateNarration"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $ExtendedButton extends $Button {
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(arg0: $Button$Builder$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Component$Type, arg5: $Button$OnPress$Type, arg6: $Button$CreateNarration$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Component$Type, arg5: $Button$OnPress$Type)

public "m_87963_"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtendedButton$Type = ($ExtendedButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtendedButton_ = $ExtendedButton$Type;
}}
declare module "packages/net/minecraftforge/registries/tags/$ITagManager" {
import {$ITag, $ITag$Type} from "packages/net/minecraftforge/registries/tags/$ITag"
import {$IReverseTag, $IReverseTag$Type} from "packages/net/minecraftforge/registries/tags/$IReverseTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $ITagManager<V> extends $Iterable<($ITag<(V)>)> {

 "stream"(): $Stream<($ITag<(V)>)>
 "getTag"(arg0: $TagKey$Type<(V)>): $ITag<(V)>
 "addOptionalTagDefaults"(arg0: $TagKey$Type<(V)>, arg1: $Set$Type<(any)>): void
 "createOptionalTagKey"(arg0: $ResourceLocation$Type, arg1: $Set$Type<(any)>): $TagKey<(V)>
 "getReverseTag"(arg0: V): $Optional<($IReverseTag<(V)>)>
 "getTagNames"(): $Stream<($TagKey<(V)>)>
 "isKnownTagName"(arg0: $TagKey$Type<(V)>): boolean
 "createTagKey"(arg0: $ResourceLocation$Type): $TagKey<(V)>
 "iterator"(): $Iterator<($ITag<(V)>)>
 "spliterator"(): $Spliterator<($ITag<(V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ITagManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITagManager$Type<V> = ($ITagManager<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITagManager_<V> = $ITagManager$Type<(V)>;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobEffectEvent$Expired" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$MobEffectEvent, $MobEffectEvent$Type} from "packages/net/minecraftforge/event/entity/living/$MobEffectEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $MobEffectEvent$Expired extends $MobEffectEvent {

constructor(arg0: $LivingEntity$Type, arg1: $MobEffectInstance$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectEvent$Expired$Type = ($MobEffectEvent$Expired);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectEvent$Expired_ = $MobEffectEvent$Expired$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$ForgeConnectionNetworkFilter" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$VanillaPacketFilter, $VanillaPacketFilter$Type} from "packages/net/minecraftforge/network/filters/$VanillaPacketFilter"

export class $ForgeConnectionNetworkFilter extends $VanillaPacketFilter {

constructor(arg0: $Connection$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConnectionNetworkFilter$Type = ($ForgeConnectionNetworkFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConnectionNetworkFilter_ = $ForgeConnectionNetworkFilter$Type;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionType" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $PermissionType<T> {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "typeName"(): string
public "typeToken"(): $Class<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionType$Type<T> = ($PermissionType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionType_<T> = $PermissionType$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$MouseButton$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InputEvent$MouseButton, $InputEvent$MouseButton$Type} from "packages/net/minecraftforge/client/event/$InputEvent$MouseButton"

export class $InputEvent$MouseButton$Pre extends $InputEvent$MouseButton {

constructor()
constructor(arg0: integer, arg1: integer, arg2: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$MouseButton$Pre$Type = ($InputEvent$MouseButton$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$MouseButton$Pre_ = $InputEvent$MouseButton$Pre$Type;
}}
declare module "packages/net/minecraftforge/registries/$MissingMappingsEvent$Mapping" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $MissingMappingsEvent$Mapping<T> implements $Comparable<($MissingMappingsEvent$Mapping<(T)>)> {

constructor(arg0: $IForgeRegistry$Type<(T)>, arg1: $IForgeRegistry$Type<(T)>, arg2: $ResourceLocation$Type, arg3: integer)

public "compareTo"(arg0: $MissingMappingsEvent$Mapping$Type<(T)>): integer
public "getKey"(): $ResourceLocation
public "getId"(): integer
public "fail"(): void
public "ignore"(): void
public "warn"(): void
public "remap"(arg0: T): void
public "getRegistry"(): $IForgeRegistry<(T)>
get "key"(): $ResourceLocation
get "id"(): integer
get "registry"(): $IForgeRegistry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MissingMappingsEvent$Mapping$Type<T> = ($MissingMappingsEvent$Mapping<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MissingMappingsEvent$Mapping_<T> = $MissingMappingsEvent$Mapping$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Init" {
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScreenEvent, $ScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent"

export class $ScreenEvent$Init extends $ScreenEvent {

constructor()

public "getListenersList"(): $List<($GuiEventListener)>
public "removeListener"(arg0: $GuiEventListener$Type): void
public "addListener"(arg0: $GuiEventListener$Type): void
public "getListenerList"(): $ListenerList
get "listenersList"(): $List<($GuiEventListener)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Init$Type = ($ScreenEvent$Init);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Init_ = $ScreenEvent$Init$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerContainerEvent$Open" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$PlayerContainerEvent, $PlayerContainerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerContainerEvent"

export class $PlayerContainerEvent$Open extends $PlayerContainerEvent {

constructor(arg0: $Player$Type, arg1: $AbstractContainerMenu$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerContainerEvent$Open$Type = ($PlayerContainerEvent$Open);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerContainerEvent$Open_ = $PlayerContainerEvent$Open$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseDragged$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$MouseDragged, $ScreenEvent$MouseDragged$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseDragged"

export class $ScreenEvent$MouseDragged$Post extends $ScreenEvent$MouseDragged {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: double, arg5: double)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseDragged$Post$Type = ($ScreenEvent$MouseDragged$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseDragged$Post_ = $ScreenEvent$MouseDragged$Post$Type;
}}
declare module "packages/net/minecraftforge/common/util/$LevelCapabilityData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SavedData, $SavedData$Type} from "packages/net/minecraft/world/level/saveddata/$SavedData"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"

export class $LevelCapabilityData extends $SavedData {
static readonly "ID": string

constructor(arg0: $INBTSerializable$Type<($CompoundTag$Type)>)

public static "load"(arg0: $CompoundTag$Type, arg1: $INBTSerializable$Type<($CompoundTag$Type)>): $LevelCapabilityData
public "read"(arg0: $CompoundTag$Type): void
public "setCapabilities"(arg0: $INBTSerializable$Type<($CompoundTag$Type)>): void
public "save"(arg0: $CompoundTag$Type): $CompoundTag
public "isDirty"(): boolean
set "capabilities"(value: $INBTSerializable$Type<($CompoundTag$Type)>)
get "dirty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelCapabilityData$Type = ($LevelCapabilityData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelCapabilityData_ = $LevelCapabilityData$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$NeighborNotifyEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EnumSet, $EnumSet$Type} from "packages/java/util/$EnumSet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent$NeighborNotifyEvent extends $BlockEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $EnumSet$Type<($Direction$Type)>, arg4: boolean)

public "isCancelable"(): boolean
public "getNotifiedSides"(): $EnumSet<($Direction)>
public "getListenerList"(): $ListenerList
public "getForceRedstoneUpdate"(): boolean
get "cancelable"(): boolean
get "notifiedSides"(): $EnumSet<($Direction)>
get "listenerList"(): $ListenerList
get "forceRedstoneUpdate"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$NeighborNotifyEvent$Type = ($BlockEvent$NeighborNotifyEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$NeighborNotifyEvent_ = $BlockEvent$NeighborNotifyEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$InputEvent$MouseButton$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InputEvent$MouseButton, $InputEvent$MouseButton$Type} from "packages/net/minecraftforge/client/event/$InputEvent$MouseButton"

export class $InputEvent$MouseButton$Post extends $InputEvent$MouseButton {

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputEvent$MouseButton$Post$Type = ($InputEvent$MouseButton$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputEvent$MouseButton$Post_ = $InputEvent$MouseButton$Post$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$IEventListener" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export interface $IEventListener {

 "invoke"(arg0: $Event$Type): void
 "listenerName"(): string

(arg0: $Event$Type): void
}

export namespace $IEventListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventListener$Type = ($IEventListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventListener_ = $IEventListener$Type;
}}
declare module "packages/net/minecraftforge/client/model/data/$ModelData$Builder" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $ModelData$Builder {


public "build"(): $ModelData
public "with"<T>(arg0: $ModelProperty$Type<(T)>, arg1: T): $ModelData$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelData$Builder$Type = ($ModelData$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelData$Builder_ = $ModelData$Builder$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ConfiguredModel$Builder" {
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"
import {$ConfiguredModel, $ConfiguredModel$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel"

export class $ConfiguredModel$Builder<T> {


public "build"(): ($ConfiguredModel)[]
public "modelFile"(arg0: $ModelFile$Type): $ConfiguredModel$Builder<(T)>
public "addModel"(): T
public "uvLock"(arg0: boolean): $ConfiguredModel$Builder<(T)>
public "rotationY"(arg0: integer): $ConfiguredModel$Builder<(T)>
public "rotationX"(arg0: integer): $ConfiguredModel$Builder<(T)>
public "buildLast"(): $ConfiguredModel
public "weight"(arg0: integer): $ConfiguredModel$Builder<(T)>
public "nextModel"(): $ConfiguredModel$Builder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredModel$Builder$Type<T> = ($ConfiguredModel$Builder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfiguredModel$Builder_<T> = $ConfiguredModel$Builder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fluids/capability/wrappers/$FluidBlockWrapper" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IFluidBlock, $IFluidBlock$Type} from "packages/net/minecraftforge/fluids/$IFluidBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FluidBlockWrapper implements $IFluidHandler {

constructor(arg0: $IFluidBlock$Type, arg1: $Level$Type, arg2: $BlockPos$Type)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockWrapper$Type = ($FluidBlockWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBlockWrapper_ = $FluidBlockWrapper$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/templates/$FluidHandlerItemStack" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IFluidHandlerItem, $IFluidHandlerItem$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $FluidHandlerItemStack implements $IFluidHandlerItem, $ICapabilityProvider {
static readonly "FLUID_NBT_KEY": string

constructor(arg0: $ItemStack$Type, arg1: integer)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "canFillFluidType"(arg0: $FluidStack$Type): boolean
public "getContainer"(): $ItemStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "canDrainFluidType"(arg0: $FluidStack$Type): boolean
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
public "getFluid"(): $FluidStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
get "container"(): $ItemStack
get "tanks"(): integer
get "fluid"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidHandlerItemStack$Type = ($FluidHandlerItemStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidHandlerItemStack_ = $FluidHandlerItemStack$Type;
}}
declare module "packages/net/minecraftforge/client/model/$ElementsModel" {
import {$BlockElement, $BlockElement$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockElement"
import {$SimpleUnbakedGeometry, $SimpleUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$SimpleUnbakedGeometry"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ElementsModel extends $SimpleUnbakedGeometry<($ElementsModel)> {

constructor(arg0: $List$Type<($BlockElement$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElementsModel$Type = ($ElementsModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElementsModel_ = $ElementsModel$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"

export interface $IGeometryLoader<T extends $IUnbakedGeometry<(T)>> {

 "read"(arg0: $JsonObject$Type, arg1: $JsonDeserializationContext$Type): T

(arg0: $JsonObject$Type, arg1: $JsonDeserializationContext$Type): T
}

export namespace $IGeometryLoader {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGeometryLoader$Type<T> = ($IGeometryLoader<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGeometryLoader_<T> = $IGeometryLoader$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$FillBucketEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $FillBucketEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $Level$Type, arg3: $HitResult$Type)

public "getTarget"(): $HitResult
public "getLevel"(): $Level
public "isCancelable"(): boolean
public "setFilledBucket"(arg0: $ItemStack$Type): void
public "getEmptyBucket"(): $ItemStack
public "getFilledBucket"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "target"(): $HitResult
get "level"(): $Level
get "cancelable"(): boolean
set "filledBucket"(value: $ItemStack$Type)
get "emptyBucket"(): $ItemStack
get "filledBucket"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FillBucketEvent$Type = ($FillBucketEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FillBucketEvent_ = $FillBucketEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$DeferredRegister" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$RegistryBuilder, $RegistryBuilder$Type} from "packages/net/minecraftforge/registries/$RegistryBuilder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $DeferredRegister<T> {


public "register"<I extends T>(arg0: string, arg1: $Supplier$Type<(any)>): $RegistryObject<(I)>
public "register"(arg0: $IEventBus$Type): void
public static "create"<B>(arg0: $IForgeRegistry$Type<(B)>, arg1: string): $DeferredRegister<(B)>
public static "create"<B>(arg0: $ResourceKey$Type<(any)>, arg1: string): $DeferredRegister<(B)>
public static "create"<B>(arg0: $ResourceLocation$Type, arg1: string): $DeferredRegister<(B)>
public "getEntries"(): $Collection<($RegistryObject<(T)>)>
public static "createOptional"<B>(arg0: $ResourceLocation$Type, arg1: string): $DeferredRegister<(B)>
public static "createOptional"<B>(arg0: $ResourceKey$Type<(any)>, arg1: string): $DeferredRegister<(B)>
public "addOptionalTagDefaults"(arg0: $TagKey$Type<(T)>, arg1: $Set$Type<(any)>): void
public "createOptionalTagKey"(arg0: $ResourceLocation$Type, arg1: $Set$Type<(any)>): $TagKey<(T)>
public "createOptionalTagKey"(arg0: string, arg1: $Set$Type<(any)>): $TagKey<(T)>
public "makeRegistry"(arg0: $Supplier$Type<($RegistryBuilder$Type<(T)>)>): $Supplier<($IForgeRegistry<(T)>)>
public "getRegistryKey"(): $ResourceKey<(any)>
public "getRegistryName"(): $ResourceLocation
public "createTagKey"(arg0: string): $TagKey<(T)>
public "createTagKey"(arg0: $ResourceLocation$Type): $TagKey<(T)>
get "entries"(): $Collection<($RegistryObject<(T)>)>
get "registryKey"(): $ResourceKey<(any)>
get "registryName"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeferredRegister$Type<T> = ($DeferredRegister<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeferredRegister_<T> = $DeferredRegister$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$BreakEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent$BreakEvent extends $BlockEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Player$Type)

public "isCancelable"(): boolean
public "getExpToDrop"(): integer
public "setExpToDrop"(arg0: integer): void
public "getPlayer"(): $Player
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "expToDrop"(): integer
set "expToDrop"(value: integer)
get "player"(): $Player
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$BreakEvent$Type = ($BlockEvent$BreakEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$BreakEvent_ = $BlockEvent$BreakEvent$Type;
}}
declare module "packages/net/minecraftforge/items/$SlotItemHandler" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $SlotItemHandler extends $Slot {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(arg0: $IItemHandler$Type, arg1: integer, arg2: integer, arg3: integer)

public "initialize"(arg0: $ItemStack$Type): void
public "remove"(arg0: integer): $ItemStack
public "getItemHandler"(): $IItemHandler
public "getItem"(): $ItemStack
public "getMaxStackSize"(arg0: $ItemStack$Type): integer
public "mayPlace"(arg0: $ItemStack$Type): boolean
public "mayPickup"(arg0: $Player$Type): boolean
public "onQuickCraft"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): void
public "set"(arg0: $ItemStack$Type): void
public "getMaxStackSize"(): integer
get "itemHandler"(): $IItemHandler
get "item"(): $ItemStack
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotItemHandler$Type = ($SlotItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotItemHandler_ = $SlotItemHandler$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent$ClientTickEvent extends $TickEvent {
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor(arg0: $TickEvent$Phase$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$ClientTickEvent$Type = ($TickEvent$ClientTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$ClientTickEvent_ = $TickEvent$ClientTickEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$ConfigFileTypeHandler" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CommentedFileConfig, $CommentedFileConfig$Type} from "packages/com/electronwill/nightconfig/core/file/$CommentedFileConfig"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConfigFileTypeHandler {

constructor()

public "reader"(arg0: $Path$Type): $Function<($ModConfig), ($CommentedFileConfig)>
public "unload"(arg0: $Path$Type, arg1: $ModConfig$Type): void
public static "backUpConfig"(arg0: $CommentedFileConfig$Type): void
public static "backUpConfig"(arg0: $CommentedFileConfig$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigFileTypeHandler$Type = ($ConfigFileTypeHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigFileTypeHandler_ = $ConfigFileTypeHandler$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ToastAddEvent" {
import {$Toast, $Toast$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $ToastAddEvent extends $Event {

constructor()
constructor(arg0: $Toast$Type)

public "isCancelable"(): boolean
public "getToast"(): $Toast
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "toast"(): $Toast
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToastAddEvent$Type = ($ToastAddEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToastAddEvent_ = $ToastAddEvent$Type;
}}
declare module "packages/net/minecraftforge/common/brewing/$VanillaBrewingRecipe" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IBrewingRecipe, $IBrewingRecipe$Type} from "packages/net/minecraftforge/common/brewing/$IBrewingRecipe"

export class $VanillaBrewingRecipe implements $IBrewingRecipe {

constructor()

public "isIngredient"(arg0: $ItemStack$Type): boolean
public "isInput"(arg0: $ItemStack$Type): boolean
public "getOutput"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaBrewingRecipe$Type = ($VanillaBrewingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaBrewingRecipe_ = $VanillaBrewingRecipe$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Render$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$Render, $ScreenEvent$Render$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$Render"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ScreenEvent$Render$Pre extends $ScreenEvent$Render {

constructor()
constructor(arg0: $Screen$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: float)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Render$Pre$Type = ($ScreenEvent$Render$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Render$Pre_ = $ScreenEvent$Render$Pre$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeMessages$S2CConfigData" {
import {$HandshakeMessages$LoginIndexedMessage, $HandshakeMessages$LoginIndexedMessage$Type} from "packages/net/minecraftforge/network/$HandshakeMessages$LoginIndexedMessage"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export class $HandshakeMessages$S2CConfigData extends $HandshakeMessages$LoginIndexedMessage {

constructor(arg0: string, arg1: (byte)[])

public static "decode"(arg0: $FriendlyByteBuf$Type): $HandshakeMessages$S2CConfigData
public "getBytes"(): (byte)[]
public "getFileName"(): string
get "bytes"(): (byte)[]
get "fileName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeMessages$S2CConfigData$Type = ($HandshakeMessages$S2CConfigData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeMessages$S2CConfigData_ = $HandshakeMessages$S2CConfigData$Type;
}}
declare module "packages/net/minecraftforge/common/$BiomeManager$BiomeType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BiomeManager$BiomeType extends $Enum<($BiomeManager$BiomeType)> {
static readonly "DESERT": $BiomeManager$BiomeType
static readonly "DESERT_LEGACY": $BiomeManager$BiomeType
static readonly "WARM": $BiomeManager$BiomeType
static readonly "COOL": $BiomeManager$BiomeType
static readonly "ICY": $BiomeManager$BiomeType


public static "values"(): ($BiomeManager$BiomeType)[]
public static "valueOf"(arg0: string): $BiomeManager$BiomeType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$BiomeType$Type = (("warm") | ("desert_legacy") | ("cool") | ("desert") | ("icy")) | ($BiomeManager$BiomeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeManager$BiomeType_ = $BiomeManager$BiomeType$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/loaders/$ItemLayerModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"
import {$CustomLoaderBuilder, $CustomLoaderBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$CustomLoaderBuilder"

export class $ItemLayerModelBuilder<T extends $ModelBuilder<(T)>> extends $CustomLoaderBuilder<(T)> {


public static "begin"<T extends $ModelBuilder<(T)>>(arg0: T, arg1: $ExistingFileHelper$Type): $ItemLayerModelBuilder<(T)>
public "color"(arg0: integer, ...arg1: (integer)[]): $ItemLayerModelBuilder<(T)>
public "toJson"(arg0: $JsonObject$Type): $JsonObject
public "renderType"(arg0: $ResourceLocation$Type, ...arg1: (integer)[]): $ItemLayerModelBuilder<(T)>
public "renderType"(arg0: string, ...arg1: (integer)[]): $ItemLayerModelBuilder<(T)>
public "emissive"(arg0: integer, arg1: integer, ...arg2: (integer)[]): $ItemLayerModelBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemLayerModelBuilder$Type<T> = ($ItemLayerModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemLayerModelBuilder_<T> = $ItemLayerModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$BakedModelRenderable$Context" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Vector4f, $Vector4f$Type} from "packages/org/joml/$Vector4f"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export class $BakedModelRenderable$Context extends $Record {

constructor(arg0: $ModelData$Type)
constructor(state: $BlockState$Type, faces: ($Direction$Type)[], randomSource: $RandomSource$Type, seed: long, data: $ModelData$Type, tint: $Vector4f$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "data"(): $ModelData
public "state"(): $BlockState
public "seed"(): long
public "tint"(): $Vector4f
public "randomSource"(): $RandomSource
public "faces"(): ($Direction)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BakedModelRenderable$Context$Type = ($BakedModelRenderable$Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BakedModelRenderable$Context_ = $BakedModelRenderable$Context$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeInternalHandler" {
import {$LevelEvent$Unload, $LevelEvent$Unload$Type} from "packages/net/minecraftforge/event/level/$LevelEvent$Unload"
import {$ChunkEvent$Unload, $ChunkEvent$Unload$Type} from "packages/net/minecraftforge/event/level/$ChunkEvent$Unload"
import {$RegisterCommandsEvent, $RegisterCommandsEvent$Type} from "packages/net/minecraftforge/event/$RegisterCommandsEvent"
import {$TickEvent$ServerTickEvent, $TickEvent$ServerTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent"
import {$PlayerEvent$PlayerLoggedInEvent, $PlayerEvent$PlayerLoggedInEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerLoggedInEvent"
import {$EntityJoinLevelEvent, $EntityJoinLevelEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityJoinLevelEvent"
import {$TagsUpdatedEvent, $TagsUpdatedEvent$Type} from "packages/net/minecraftforge/event/$TagsUpdatedEvent"
import {$AddReloadListenerEvent, $AddReloadListenerEvent$Type} from "packages/net/minecraftforge/event/$AddReloadListenerEvent"
import {$ForgeInternalHandlerAccessor, $ForgeInternalHandlerAccessor$Type} from "packages/dev/xkmc/l2hostility/mixin/$ForgeInternalHandlerAccessor"
import {$TickEvent$ClientTickEvent, $TickEvent$ClientTickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent$ClientTickEvent"

export class $ForgeInternalHandler implements $ForgeInternalHandlerAccessor {

constructor()

public "onEntityJoinWorld"(arg0: $EntityJoinLevelEvent$Type): void
public "tagsUpdated"(arg0: $TagsUpdatedEvent$Type): void
public "onCommandsRegister"(arg0: $RegisterCommandsEvent$Type): void
public "onServerTick"(arg0: $TickEvent$ServerTickEvent$Type): void
public "onDimensionUnload"(arg0: $LevelEvent$Unload$Type): void
public "onResourceReload"(arg0: $AddReloadListenerEvent$Type): void
public "checkSettings"(arg0: $TickEvent$ClientTickEvent$Type): void
public "playerLogin"(arg0: $PlayerEvent$PlayerLoggedInEvent$Type): void
public "onChunkUnload"(arg0: $ChunkEvent$Unload$Type): void
public "resourceReloadListeners"(arg0: $AddReloadListenerEvent$Type): void
public "builtinMobSpawnBlocker"(arg0: $EntityJoinLevelEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeInternalHandler$Type = ($ForgeInternalHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeInternalHandler_ = $ForgeInternalHandler$Type;
}}
declare module "packages/net/minecraftforge/server/command/$TextComponentHelper" {
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $TextComponentHelper {


public static "createComponentTranslation"(arg0: $CommandSource$Type, arg1: string, ...arg2: (any)[]): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponentHelper$Type = ($TextComponentHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponentHelper_ = $TextComponentHelper$Type;
}}
declare module "packages/net/minecraftforge/server/command/$GenerateCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GenerateCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerateCommand$Type = ($GenerateCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenerateCommand_ = $GenerateCommand$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$MobEffectEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $MobEffectEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $MobEffectInstance$Type)

public "getEffectInstance"(): $MobEffectInstance
public "getListenerList"(): $ListenerList
get "effectInstance"(): $MobEffectInstance
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectEvent$Type = ($MobEffectEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectEvent_ = $MobEffectEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$ZombieEvent$SummonAidEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Zombie, $Zombie$Type} from "packages/net/minecraft/world/entity/monster/$Zombie"
import {$ZombieEvent, $ZombieEvent$Type} from "packages/net/minecraftforge/event/entity/living/$ZombieEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ZombieEvent$SummonAidEvent extends $ZombieEvent {

constructor(arg0: $Zombie$Type, arg1: $Level$Type, arg2: integer, arg3: integer, arg4: integer, arg5: $LivingEntity$Type, arg6: double)
constructor()

public "getLevel"(): $Level
public "getY"(): integer
public "getCustomSummonedAid"(): $Zombie
public "getAttacker"(): $LivingEntity
public "getZ"(): integer
public "getX"(): integer
public "getSummonChance"(): double
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "setCustomSummonedAid"(arg0: $Zombie$Type): void
get "level"(): $Level
get "y"(): integer
get "customSummonedAid"(): $Zombie
get "attacker"(): $LivingEntity
get "z"(): integer
get "x"(): integer
get "summonChance"(): double
get "listenerList"(): $ListenerList
set "customSummonedAid"(value: $Zombie$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ZombieEvent$SummonAidEvent$Type = ($ZombieEvent$SummonAidEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ZombieEvent$SummonAidEvent_ = $ZombieEvent$SummonAidEvent$Type;
}}
declare module "packages/net/minecraftforge/forge/snapshots/$ForgeSnapshotsModClient" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$TitleScreen, $TitleScreen$Type} from "packages/net/minecraft/client/gui/screens/$TitleScreen"
import {$VersionChecker$Status, $VersionChecker$Status$Type} from "packages/net/minecraftforge/fml/$VersionChecker$Status"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ForgeSnapshotsModClient {

constructor()

public static "renderMainMenuWarning"(arg0: $VersionChecker$Status$Type, arg1: $TitleScreen$Type, arg2: $GuiGraphics$Type, arg3: $Font$Type, arg4: integer, arg5: integer, arg6: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSnapshotsModClient$Type = ($ForgeSnapshotsModClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSnapshotsModClient_ = $ForgeSnapshotsModClient$Type;
}}
declare module "packages/net/minecraftforge/api/distmarker/$Dist" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Dist extends $Enum<($Dist)> {
static readonly "CLIENT": $Dist
static readonly "DEDICATED_SERVER": $Dist


public static "values"(): ($Dist)[]
public static "valueOf"(arg0: string): $Dist
public "isClient"(): boolean
public "isDedicatedServer"(): boolean
get "client"(): boolean
get "dedicatedServer"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Dist$Type = (("dedicated_server") | ("client")) | ($Dist);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Dist_ = $Dist$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$GenericEvent" {
import {$IGenericEvent, $IGenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$IGenericEvent"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $GenericEvent<T> extends $Event implements $IGenericEvent<(T)> {

constructor()

public "getGenericType"(): $Type
get "genericType"(): $Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericEvent$Type<T> = ($GenericEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericEvent_<T> = $GenericEvent$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fluids/capability/$IFluidHandler" {
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"

export interface $IFluidHandler {

 "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
 "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "getTanks"(): integer
 "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
 "getFluidInTank"(arg0: integer): $FluidStack
 "getTankCapacity"(arg0: integer): integer
}

export namespace $IFluidHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidHandler$Type = ($IFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidHandler_ = $IFluidHandler$Type;
}}
declare module "packages/net/minecraftforge/items/wrapper/$CombinedInvWrapper" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $CombinedInvWrapper implements $IItemHandlerModifiable {

constructor(...arg0: ($IItemHandlerModifiable$Type)[])

public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombinedInvWrapper$Type = ($CombinedInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombinedInvWrapper_ = $CombinedInvWrapper$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/$TargetType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $TargetType extends $Enum<($TargetType)> {
static readonly "FIELD": $TargetType
static readonly "METHOD": $TargetType
static readonly "CLASS": $TargetType


public static "values"(): ($TargetType)[]
public static "valueOf"(arg0: string): $TargetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetType$Type = (("field") | ("method") | ("class")) | ($TargetType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TargetType_ = $TargetType$Type;
}}
declare module "packages/net/minecraftforge/server/command/$EnumArgument" {
import {$Suggestions, $Suggestions$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestions"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$ArgumentType, $ArgumentType$Type} from "packages/com/mojang/brigadier/arguments/$ArgumentType"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"

export class $EnumArgument<T extends $Enum<(T)>> implements $ArgumentType<(T)> {


public "getExamples"(): $Collection<(string)>
public "listSuggestions"<S>(arg0: $CommandContext$Type<(S)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public static "enumArgument"<R extends $Enum<(R)>>(arg0: $Class$Type<(R)>): $EnumArgument<(R)>
get "examples"(): $Collection<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumArgument$Type<T> = ($EnumArgument<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumArgument_<T> = $EnumArgument$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/$TagsUpdatedEvent$UpdateCause" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TagsUpdatedEvent$UpdateCause extends $Enum<($TagsUpdatedEvent$UpdateCause)> {
static readonly "SERVER_DATA_LOAD": $TagsUpdatedEvent$UpdateCause
static readonly "CLIENT_PACKET_RECEIVED": $TagsUpdatedEvent$UpdateCause


public static "values"(): ($TagsUpdatedEvent$UpdateCause)[]
public static "valueOf"(arg0: string): $TagsUpdatedEvent$UpdateCause
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagsUpdatedEvent$UpdateCause$Type = (("client_packet_received") | ("server_data_load")) | ($TagsUpdatedEvent$UpdateCause);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagsUpdatedEvent$UpdateCause_ = $TagsUpdatedEvent$UpdateCause$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/moddiscovery/$ModInfo" {
import {$ModFileInfo, $ModFileInfo$Type} from "packages/net/minecraftforge/fml/loading/moddiscovery/$ModFileInfo"
import {$IConfigurable, $IConfigurable$Type} from "packages/net/minecraftforge/forgespi/language/$IConfigurable"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$URL, $URL$Type} from "packages/java/net/$URL"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModInfo implements $IModInfo, $IConfigurable {

constructor(arg0: $ModFileInfo$Type, arg1: $IConfigurable$Type)

public "getDisplayName"(): string
public "getVersion"(): $ArtifactVersion
public "getDescription"(): string
public "getConfig"(): $IConfigurable
public "getNamespace"(): string
public "getConfigElement"<T>(...arg0: (string)[]): $Optional<(T)>
public "getConfigList"(...arg0: (string)[]): $List<(any)>
public "getModId"(): string
public "getForgeFeatures"(): $List<(any)>
public "getUpdateURL"(): $Optional<($URL)>
public "getDependencies"(): $List<(any)>
public "getOwningFile"(): $ModFileInfo
public "getModProperties"(): $Map<(string), (any)>
public "getLogoBlur"(): boolean
public "getLogoFile"(): $Optional<(string)>
public "getModURL"(): $Optional<($URL)>
get "displayName"(): string
get "version"(): $ArtifactVersion
get "description"(): string
get "config"(): $IConfigurable
get "namespace"(): string
get "modId"(): string
get "forgeFeatures"(): $List<(any)>
get "updateURL"(): $Optional<($URL)>
get "dependencies"(): $List<(any)>
get "owningFile"(): $ModFileInfo
get "modProperties"(): $Map<(string), (any)>
get "logoBlur"(): boolean
get "logoFile"(): $Optional<(string)>
get "modURL"(): $Optional<($URL)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModInfo$Type = ($ModInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModInfo_ = $ModInfo$Type;
}}
declare module "packages/net/minecraftforge/client/$ForgeHooksClient" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerData, $ServerData$Type} from "packages/net/minecraft/client/multiplayer/$ServerData"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$AbstractClientPlayer, $AbstractClientPlayer$Type} from "packages/net/minecraft/client/player/$AbstractClientPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab$ItemDisplayParameters, $CreativeModeTab$ItemDisplayParameters$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$ItemDisplayParameters"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$SpriteContents, $SpriteContents$Type} from "packages/net/minecraft/client/renderer/texture/$SpriteContents"
import {$FogType, $FogType$Type} from "packages/net/minecraft/world/level/material/$FogType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$FogRenderer$FogMode, $FogRenderer$FogMode$Type} from "packages/net/minecraft/client/renderer/$FogRenderer$FogMode"
import {$PlayerInfo, $PlayerInfo$Type} from "packages/net/minecraft/client/multiplayer/$PlayerInfo"
import {$FogShape, $FogShape$Type} from "packages/com/mojang/blaze3d/shaders/$FogShape"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$JoinMultiplayerScreen, $JoinMultiplayerScreen$Type} from "packages/net/minecraft/client/gui/screens/multiplayer/$JoinMultiplayerScreen"
import {$CreativeModeTab$DisplayItemsGenerator, $CreativeModeTab$DisplayItemsGenerator$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$DisplayItemsGenerator"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Frustum, $Frustum$Type} from "packages/net/minecraft/client/renderer/culling/$Frustum"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$Resource, $Resource$Type} from "packages/net/minecraft/server/packs/resources/$Resource"
import {$ModelBakery, $ModelBakery$Type} from "packages/net/minecraft/client/resources/model/$ModelBakery"
import {$Toast, $Toast$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast"
import {$HumanoidModel, $HumanoidModel$Type} from "packages/net/minecraft/client/model/$HumanoidModel"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/net/minecraft/network/chat/$ChatType$Bound"
import {$ReloadableResourceManager, $ReloadableResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ReloadableResourceManager"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"
import {$ModelManager, $ModelManager$Type} from "packages/net/minecraft/client/resources/model/$ModelManager"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$InputEvent$InteractionKeyMappingTriggered, $InputEvent$InteractionKeyMappingTriggered$Type} from "packages/net/minecraftforge/client/event/$InputEvent$InteractionKeyMappingTriggered"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$ScreenEvent$RenderInventoryMobEffects, $ScreenEvent$RenderInventoryMobEffects$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$RenderInventoryMobEffects"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$NativeImage, $NativeImage$Type} from "packages/com/mojang/blaze3d/platform/$NativeImage"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"
import {$Input, $Input$Type} from "packages/net/minecraft/client/player/$Input"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RenderTooltipEvent$Color, $RenderTooltipEvent$Color$Type} from "packages/net/minecraftforge/client/event/$RenderTooltipEvent$Color"
import {$ServerStatus, $ServerStatus$Type} from "packages/net/minecraft/network/protocol/status/$ServerStatus"
import {$FrameSize, $FrameSize$Type} from "packages/net/minecraft/client/resources/metadata/animation/$FrameSize"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$ScreenshotEvent, $ScreenshotEvent$Type} from "packages/net/minecraftforge/client/event/$ScreenshotEvent"
import {$HumanoidArm, $HumanoidArm$Type} from "packages/net/minecraft/world/entity/$HumanoidArm"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$TextureAtlas, $TextureAtlas$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlas"
import {$GameRenderer, $GameRenderer$Type} from "packages/net/minecraft/client/renderer/$GameRenderer"
import {$RenderTooltipEvent$Pre, $RenderTooltipEvent$Pre$Type} from "packages/net/minecraftforge/client/event/$RenderTooltipEvent$Pre"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemColors, $ItemColors$Type} from "packages/net/minecraft/client/color/item/$ItemColors"
import {$ParticleRenderType, $ParticleRenderType$Type} from "packages/net/minecraft/client/particle/$ParticleRenderType"
import {$Options, $Options$Type} from "packages/net/minecraft/client/$Options"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$RenderBlockScreenEffectEvent$OverlayType, $RenderBlockScreenEffectEvent$OverlayType$Type} from "packages/net/minecraftforge/client/event/$RenderBlockScreenEffectEvent$OverlayType"
import {$CustomizeGuiOverlayEvent$BossEventProgress, $CustomizeGuiOverlayEvent$BossEventProgress$Type} from "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent$BossEventProgress"
import {$MouseHandler, $MouseHandler$Type} from "packages/net/minecraft/client/$MouseHandler"
import {$MultiPlayerGameMode, $MultiPlayerGameMode$Type} from "packages/net/minecraft/client/multiplayer/$MultiPlayerGameMode"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$ImmutableMap$Builder, $ImmutableMap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMap$Builder"
import {$RenderLevelStageEvent$Stage, $RenderLevelStageEvent$Stage$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent$Stage"
import {$BlockRenderDispatcher, $BlockRenderDispatcher$Type} from "packages/net/minecraft/client/renderer/block/$BlockRenderDispatcher"
import {$AnimationMetadataSection, $AnimationMetadataSection$Type} from "packages/net/minecraft/client/resources/metadata/animation/$AnimationMetadataSection"
import {$ViewportEvent$ComputeCameraAngles, $ViewportEvent$ComputeCameraAngles$Type} from "packages/net/minecraftforge/client/event/$ViewportEvent$ComputeCameraAngles"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$LerpingBossEvent, $LerpingBossEvent$Type} from "packages/net/minecraft/client/gui/components/$LerpingBossEvent"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ClientTooltipPositioner, $ClientTooltipPositioner$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipPositioner"
import {$File, $File$Type} from "packages/java/io/$File"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameType, $GameType$Type} from "packages/net/minecraft/world/level/$GameType"
import {$LayerDefinition, $LayerDefinition$Type} from "packages/net/minecraft/client/model/geom/builders/$LayerDefinition"
import {$LevelRenderer, $LevelRenderer$Type} from "packages/net/minecraft/client/renderer/$LevelRenderer"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$TitleScreen, $TitleScreen$Type} from "packages/net/minecraft/client/gui/screens/$TitleScreen"
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$PlayerChatMessage, $PlayerChatMessage$Type} from "packages/net/minecraft/network/chat/$PlayerChatMessage"
import {$ModelLayerLocation, $ModelLayerLocation$Type} from "packages/net/minecraft/client/model/geom/$ModelLayerLocation"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Model, $Model$Type} from "packages/net/minecraft/client/model/$Model"
import {$ParticleEngine, $ParticleEngine$Type} from "packages/net/minecraft/client/particle/$ParticleEngine"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeHooksClient {
static "forgeStatusLine": string

constructor()

public static "fixDomain"(arg0: string, arg1: string): string
public static "getFluidSprites"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $FluidState$Type): ($TextureAtlasSprite)[]
public static "onFogRender"(arg0: $FogRenderer$FogMode$Type, arg1: $FogType$Type, arg2: $Camera$Type, arg3: float, arg4: float, arg5: float, arg6: float, arg7: $FogShape$Type): void
public static "onScreenshot"(arg0: $NativeImage$Type, arg1: $File$Type): $ScreenshotEvent
public static "fillNormal"(arg0: (integer)[], arg1: $Direction$Type, arg2: boolean): void
public static "fillNormal"(arg0: (integer)[], arg1: $Direction$Type): void
public static "loadSpriteContents"(arg0: $ResourceLocation$Type, arg1: $Resource$Type, arg2: $FrameSize$Type, arg3: $NativeImage$Type, arg4: $AnimationMetadataSection$Type): $SpriteContents
public static "onClientPlayerChat"(arg0: $ChatType$Bound$Type, arg1: $Component$Type, arg2: $PlayerChatMessage$Type, arg3: $UUID$Type): $Component
public static "onClientSystemChat"(arg0: $Component$Type, arg1: boolean): $Component
public static "drawForgePingInfo"(arg0: $JoinMultiplayerScreen$Type, arg1: $ServerData$Type, arg2: $GuiGraphics$Type, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): void
public static "firePlayerLogin"(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type, arg2: $Connection$Type): void
public static "firePlayerRespawn"(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type, arg2: $LocalPlayer$Type, arg3: $Connection$Type): void
public static "getTooltipFont"(arg0: $ItemStack$Type, arg1: $Font$Type): $Font
public static "renderBlockOverlay"(arg0: $Player$Type, arg1: $PoseStack$Type, arg2: $RenderBlockScreenEffectEvent$OverlayType$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type): boolean
public static "renderWaterOverlay"(arg0: $Player$Type, arg1: $PoseStack$Type): boolean
public static "getNearestStable"(arg0: float, arg1: float, arg2: float): $Direction
public static "renderFireOverlay"(arg0: $Player$Type, arg1: $PoseStack$Type): boolean
public static "onRenderTooltipPre"(arg0: $ItemStack$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: $List$Type<($ClientTooltipComponent$Type)>, arg7: $Font$Type, arg8: $ClientTooltipPositioner$Type): $RenderTooltipEvent$Pre
public static "dispatchRenderStage"(arg0: $RenderLevelStageEvent$Stage$Type, arg1: $LevelRenderer$Type, arg2: $PoseStack$Type, arg3: $Matrix4f$Type, arg4: integer, arg5: $Camera$Type, arg6: $Frustum$Type): void
public static "dispatchRenderStage"(arg0: $RenderType$Type, arg1: $LevelRenderer$Type, arg2: $PoseStack$Type, arg3: $Matrix4f$Type, arg4: integer, arg5: $Camera$Type, arg6: $Frustum$Type): void
public static "onTextureStitchedPost"(arg0: $TextureAtlas$Type): void
public static "handleCameraTransforms"(arg0: $PoseStack$Type, arg1: $BakedModel$Type, arg2: $ItemDisplayContext$Type, arg3: boolean): $BakedModel
public static "clearGuiLayers"(arg0: $Minecraft$Type): void
public static "onModelBake"(arg0: $ModelManager$Type, arg1: $Map$Type<($ResourceLocation$Type), ($BakedModel$Type)>, arg2: $ModelBakery$Type): void
public static "onItemColorsInit"(arg0: $ItemColors$Type, arg1: $BlockColors$Type): void
public static "onDrawHighlight"(arg0: $LevelRenderer$Type, arg1: $Camera$Type, arg2: $HitResult$Type, arg3: float, arg4: $PoseStack$Type, arg5: $MultiBufferSource$Type): boolean
public static "onRegisterParticleProviders"(arg0: $ParticleEngine$Type): void
public static "handleClientLevelClosing"(arg0: $ClientLevel$Type): void
public static "isNameplateInRenderDistance"(arg0: $Entity$Type, arg1: double): boolean
public static "isBlockInSolidLayer"(arg0: $BlockState$Type): boolean
public static "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer): boolean
public static "getArmorModel"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: $EquipmentSlot$Type, arg3: $HumanoidModel$Type<(any)>): $Model
public static "resizeGuiLayers"(arg0: $Minecraft$Type, arg1: integer, arg2: integer): void
public static "onClickInput"(arg0: integer, arg1: $KeyMapping$Type, arg2: $InteractionHand$Type): $InputEvent$InteractionKeyMappingTriggered
public static "firePlayerLogout"(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type): void
public static "getMaxMipmapLevel"(arg0: integer, arg1: integer): integer
public static "calculateFaceWithoutAO"(arg0: $BlockAndTintGetter$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $BakedQuad$Type, arg4: boolean, arg5: (float)[], arg6: (integer)[]): boolean
public static "onCustomizeBossEventProgress"(arg0: $GuiGraphics$Type, arg1: $Window$Type, arg2: $LerpingBossEvent$Type, arg3: integer, arg4: integer, arg5: integer): $CustomizeGuiOverlayEvent$BossEventProgress
public static "onClientChangeGameType"(arg0: $PlayerInfo$Type, arg1: $GameType$Type, arg2: $GameType$Type): void
public static "renderPistonMovedBlocks"(arg0: $BlockPos$Type, arg1: $BlockState$Type, arg2: $PoseStack$Type, arg3: $MultiBufferSource$Type, arg4: $Level$Type, arg5: boolean, arg6: integer, arg7: $BlockRenderDispatcher$Type): void
public static "renderSpecificFirstPersonHand"(arg0: $InteractionHand$Type, arg1: $PoseStack$Type, arg2: $MultiBufferSource$Type, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float, arg8: $ItemStack$Type): boolean
public static "onModifyBakingResult"(arg0: $Map$Type<($ResourceLocation$Type), ($BakedModel$Type)>, arg1: $ModelBakery$Type): void
public static "onClientSendMessage"(arg0: string): string
public static "getEntityRenderType"(arg0: $RenderType$Type, arg1: boolean): $RenderType
public static "processForgeListPingData"(arg0: $ServerStatus$Type, arg1: $ServerData$Type): void
public static "loadTextureAtlasSprite"(arg0: $ResourceLocation$Type, arg1: $SpriteContents$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $TextureAtlasSprite
public static "loadLayerDefinitions"(arg0: $ImmutableMap$Builder$Type<($ModelLayerLocation$Type), ($LayerDefinition$Type)>): void
public static "createWorldConfirmationScreen"(arg0: $Runnable$Type): void
public static "getShaderImportLocation"(arg0: string, arg1: boolean, arg2: string): $ResourceLocation
public static "getArmorTexture"(arg0: $Entity$Type, arg1: $ItemStack$Type, arg2: string, arg3: $EquipmentSlot$Type, arg4: string): string
public static "renderMainMenu"(arg0: $TitleScreen$Type, arg1: $GuiGraphics$Type, arg2: $Font$Type, arg3: integer, arg4: integer, arg5: integer): void
public static "onBlockColorsInit"(arg0: $BlockColors$Type): void
public static "loadEntityShader"(arg0: $Entity$Type, arg1: $GameRenderer$Type): void
public static "getFieldOfView"(arg0: $GameRenderer$Type, arg1: $Camera$Type, arg2: double, arg3: double, arg4: boolean): double
public static "getGuiFarPlane"(): float
public static "onCameraSetup"(arg0: $GameRenderer$Type, arg1: $Camera$Type, arg2: float): $ViewportEvent$ComputeCameraAngles
public static "drawScreen"(arg0: $Screen$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: float): void
public static "onToastAdd"(arg0: $Toast$Type): boolean
public static "getFieldOfViewModifier"(arg0: $Player$Type, arg1: float): float
public static "onScreenMouseScrollPost"(arg0: $MouseHandler$Type, arg1: $Screen$Type, arg2: double): void
public static "onScreenMouseReleasedPre"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer): boolean
public static "onScreenMouseDragPost"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: double, arg5: double): void
public static "onScreenMouseClickedPost"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: boolean): boolean
public static "onScreenMouseScrollPre"(arg0: $MouseHandler$Type, arg1: $Screen$Type, arg2: double): boolean
public static "onScreenMouseDragPre"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: double, arg5: double): boolean
public static "onScreenMouseClickedPre"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer): boolean
public static "onScreenMouseReleasedPost"(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: boolean): boolean
public static "onScreenKeyReleasedPost"(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer): boolean
public static "onScreenCharTypedPost"(arg0: $Screen$Type, arg1: character, arg2: integer): void
public static "onScreenKeyPressedPre"(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer): boolean
public static "onScreenKeyPressedPost"(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer): boolean
public static "onScreenCharTypedPre"(arg0: $Screen$Type, arg1: character, arg2: integer): boolean
public static "onScreenKeyReleasedPre"(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
public static "onCreativeModeTabBuildContents"(arg0: $CreativeModeTab$Type, arg1: $ResourceKey$Type<($CreativeModeTab$Type)>, arg2: $CreativeModeTab$DisplayItemsGenerator$Type, arg3: $CreativeModeTab$ItemDisplayParameters$Type, arg4: $CreativeModeTab$Output$Type): void
public static "gatherTooltipComponents"(arg0: $ItemStack$Type, arg1: $List$Type<(any)>, arg2: integer, arg3: integer, arg4: integer, arg5: $Font$Type): $List<($ClientTooltipComponent)>
public static "gatherTooltipComponents"(arg0: $ItemStack$Type, arg1: $List$Type<(any)>, arg2: $Optional$Type<($TooltipComponent$Type)>, arg3: integer, arg4: integer, arg5: integer, arg6: $Font$Type): $List<($ClientTooltipComponent)>
public static "onRenderTooltipColor"(arg0: $ItemStack$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: $Font$Type, arg5: $List$Type<($ClientTooltipComponent$Type)>): $RenderTooltipEvent$Color
public static "onKeyInput"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public static "makeParticleRenderTypeComparator"(arg0: $List$Type<($ParticleRenderType$Type)>): $Comparator<($ParticleRenderType)>
public static "getBlockMaterial"(arg0: $ResourceLocation$Type): $Material
public static "playSound"(arg0: $SoundEngine$Type, arg1: $SoundInstance$Type): $SoundInstance
public static "shouldRenderEffect"(arg0: $MobEffectInstance$Type): boolean
public static "onScreenPotionSize"(arg0: $Screen$Type, arg1: integer, arg2: boolean, arg3: integer): $ScreenEvent$RenderInventoryMobEffects
public static "getFogColor"(arg0: $Camera$Type, arg1: float, arg2: $ClientLevel$Type, arg3: integer, arg4: float, arg5: float, arg6: float, arg7: float): $Vector3f
public static "onClientChat"(arg0: $ChatType$Bound$Type, arg1: $Component$Type, arg2: $UUID$Type): $Component
public static "onRecipesUpdated"(arg0: $RecipeManager$Type): void
public static "renderSpecificFirstPersonArm"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: integer, arg3: $AbstractClientPlayer$Type, arg4: $HumanoidArm$Type): boolean
public static "registerLayerDefinition"(arg0: $ModelLayerLocation$Type, arg1: $Supplier$Type<($LayerDefinition$Type)>): void
public static "onMovementInputUpdate"(arg0: $Player$Type, arg1: $Input$Type): void
public static "onMouseButtonPre"(arg0: integer, arg1: integer, arg2: integer): boolean
public static "onMouseScroll"(arg0: $MouseHandler$Type, arg1: double): boolean
public static "onMouseButtonPost"(arg0: integer, arg1: integer, arg2: integer): void
public static "onRegisterKeyMappings"(arg0: $Options$Type): void
public static "pushGuiLayer"(arg0: $Minecraft$Type, arg1: $Screen$Type): void
public static "popGuiLayer"(arg0: $Minecraft$Type): void
public static "initClientHooks"(arg0: $Minecraft$Type, arg1: $ReloadableResourceManager$Type): void
public static "onRegisterAdditionalModels"(arg0: $Set$Type<($ResourceLocation$Type)>): void
public static "copyModelProperties"<T extends $LivingEntity>(arg0: $HumanoidModel$Type<(T)>, arg1: $HumanoidModel$Type<(any)>): void
get "guiFarPlane"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeHooksClient$Type = ($ForgeHooksClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeHooksClient_ = $ForgeHooksClient$Type;
}}
declare module "packages/net/minecraftforge/event/level/$NoteBlockEvent$Note" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $NoteBlockEvent$Note extends $Enum<($NoteBlockEvent$Note)> {
static readonly "F_SHARP": $NoteBlockEvent$Note
static readonly "G": $NoteBlockEvent$Note
static readonly "G_SHARP": $NoteBlockEvent$Note
static readonly "A": $NoteBlockEvent$Note
static readonly "A_SHARP": $NoteBlockEvent$Note
static readonly "B": $NoteBlockEvent$Note
static readonly "C": $NoteBlockEvent$Note
static readonly "C_SHARP": $NoteBlockEvent$Note
static readonly "D": $NoteBlockEvent$Note
static readonly "D_SHARP": $NoteBlockEvent$Note
static readonly "E": $NoteBlockEvent$Note
static readonly "F": $NoteBlockEvent$Note


public static "values"(): ($NoteBlockEvent$Note)[]
public static "valueOf"(arg0: string): $NoteBlockEvent$Note
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockEvent$Note$Type = (("g_sharp") | ("a") | ("a_sharp") | ("b") | ("c") | ("c_sharp") | ("d") | ("e") | ("f") | ("g") | ("f_sharp") | ("d_sharp")) | ($NoteBlockEvent$Note);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoteBlockEvent$Note_ = $NoteBlockEvent$Note$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent$RegistrationChangeType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $NetworkEvent$RegistrationChangeType extends $Enum<($NetworkEvent$RegistrationChangeType)> {
static readonly "REGISTER": $NetworkEvent$RegistrationChangeType
static readonly "UNREGISTER": $NetworkEvent$RegistrationChangeType


public static "values"(): ($NetworkEvent$RegistrationChangeType)[]
public static "valueOf"(arg0: string): $NetworkEvent$RegistrationChangeType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$RegistrationChangeType$Type = (("unregister") | ("register")) | ($NetworkEvent$RegistrationChangeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent$RegistrationChangeType_ = $NetworkEvent$RegistrationChangeType$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeLootTableProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LootTableProvider$SubProviderEntry, $LootTableProvider$SubProviderEntry$Type} from "packages/net/minecraft/data/loot/$LootTableProvider$SubProviderEntry"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$LootTableProvider, $LootTableProvider$Type} from "packages/net/minecraft/data/loot/$LootTableProvider"

export class $ForgeLootTableProvider extends $LootTableProvider {

constructor(arg0: $PackOutput$Type)

public "getTables"(): $List<($LootTableProvider$SubProviderEntry)>
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "tables"(): $List<($LootTableProvider$SubProviderEntry)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeLootTableProvider$Type = ($ForgeLootTableProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeLootTableProvider_ = $ForgeLootTableProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$SleepingLocationCheckEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $SleepingLocationCheckEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $BlockPos$Type)

public "getSleepingLocation"(): $BlockPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "sleepingLocation"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SleepingLocationCheckEvent$Type = ($SleepingLocationCheckEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SleepingLocationCheckEvent_ = $SleepingLocationCheckEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$ClientCommandHandler" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$ClientCommandSourceStack, $ClientCommandSourceStack$Type} from "packages/net/minecraftforge/client/$ClientCommandSourceStack"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"
import {$SharedSuggestionProvider, $SharedSuggestionProvider$Type} from "packages/net/minecraft/commands/$SharedSuggestionProvider"

export class $ClientCommandHandler {

constructor()

public static "init"(): void
public static "getSource"(): $ClientCommandSourceStack
public static "getDispatcher"(): $CommandDispatcher<($CommandSourceStack)>
public static "mergeServerCommands"(arg0: $CommandDispatcher$Type<($SharedSuggestionProvider$Type)>, arg1: $CommandBuildContext$Type): $CommandDispatcher<($SharedSuggestionProvider)>
public static "runCommand"(arg0: string): boolean
get "source"(): $ClientCommandSourceStack
get "dispatcher"(): $CommandDispatcher<($CommandSourceStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientCommandHandler$Type = ($ClientCommandHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientCommandHandler_ = $ClientCommandHandler$Type;
}}
declare module "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay" {
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ForgeGui, $ForgeGui$Type} from "packages/net/minecraftforge/client/gui/overlay/$ForgeGui"

export interface $IGuiOverlay {

 "render"(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void

(arg0: $ForgeGui$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: integer, arg4: integer): void
}

export namespace $IGuiOverlay {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiOverlay$Type = ($IGuiOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiOverlay_ = $IGuiOverlay$Type;
}}
declare module "packages/net/minecraftforge/client/model/data/$ModelData" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"
import {$ModelData$Builder, $ModelData$Builder$Type} from "packages/net/minecraftforge/client/model/data/$ModelData$Builder"

export class $ModelData {
static readonly "EMPTY": $ModelData


public "get"<T>(arg0: $ModelProperty$Type<(T)>): T
public static "builder"(): $ModelData$Builder
public "getProperties"(): $Set<(any)>
public "has"(arg0: $ModelProperty$Type<(any)>): boolean
public "derive"(): $ModelData$Builder
get "properties"(): $Set<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelData$Type = ($ModelData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelData_ = $ModelData$Type;
}}
declare module "packages/net/minecraftforge/accesstransformer/parser/$AccessTransformerList" {
import {$INameHandler, $INameHandler$Type} from "packages/net/minecraftforge/accesstransformer/$INameHandler"
import {$AccessTransformer, $AccessTransformer$Type} from "packages/net/minecraftforge/accesstransformer/$AccessTransformer"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$TargetType, $TargetType$Type} from "packages/net/minecraftforge/accesstransformer/$TargetType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Type, $Type$Type} from "packages/org/objectweb/asm/$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $AccessTransformerList {

constructor()

public "loadFromPath"(arg0: $Path$Type, arg1: string): void
public "loadFromResource"(arg0: string): void
public "setNameHandler"(arg0: $INameHandler$Type): void
public "getTransformersForTarget"(arg0: $Type$Type): $Map<($TargetType), ($Map<(string), ($AccessTransformer)>)>
public "getAccessTransformers"(): $Map<(string), ($List<($AccessTransformer)>)>
public "containsClassTarget"(arg0: $Type$Type): boolean
set "nameHandler"(value: $INameHandler$Type)
get "accessTransformers"(): $Map<(string), ($List<($AccessTransformer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccessTransformerList$Type = ($AccessTransformerList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AccessTransformerList_ = $AccessTransformerList$Type;
}}
declare module "packages/net/minecraftforge/client/model/pipeline/$TransformingVertexPipeline" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$VertexConsumerWrapper, $VertexConsumerWrapper$Type} from "packages/net/minecraftforge/client/model/pipeline/$VertexConsumerWrapper"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"

export class $TransformingVertexPipeline extends $VertexConsumerWrapper {

constructor(arg0: $VertexConsumer$Type, arg1: $Transformation$Type)

public "vertex"(arg0: double, arg1: double, arg2: double): $VertexConsumer
public "normal"(arg0: float, arg1: float, arg2: float): $VertexConsumer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransformingVertexPipeline$Type = ($TransformingVertexPipeline);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransformingVertexPipeline_ = $TransformingVertexPipeline$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModContainer" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ProgressMeter, $ProgressMeter$Type} from "packages/net/minecraftforge/fml/loading/progress/$ProgressMeter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$IExtensionPoint, $IExtensionPoint$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent, $IConfigEvent$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IExtensionPoint$DisplayTest, $IExtensionPoint$DisplayTest$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint$DisplayTest"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IModStateTransition$EventGenerator, $IModStateTransition$EventGenerator$Type} from "packages/net/minecraftforge/fml/$IModStateTransition$EventGenerator"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModContainer {

constructor(arg0: $IModInfo$Type)

public "matches"(arg0: any): boolean
public "addConfig"(arg0: $ModConfig$Type): void
public static "buildTransitionHandler"<T extends ($Event) & ($IModBusEvent)>(arg0: $ModContainer$Type, arg1: $IModStateTransition$EventGenerator$Type<(T)>, arg2: $ProgressMeter$Type, arg3: $BiFunction$Type<($ModLoadingStage$Type), ($Throwable$Type), ($ModLoadingStage$Type)>, arg4: $Executor$Type): $CompletableFuture<(void)>
public "getCurrentState"(): $ModLoadingStage
public "getNamespace"(): string
public "getModInfo"(): $IModInfo
public "registerExtensionPoint"<T extends ($Record) & ($IExtensionPoint<(T)>)>(arg0: $Class$Type<(any)>, arg1: $Supplier$Type<(T)>): void
public "getMod"(): any
public "getCustomExtension"<T extends $Record>(arg0: $Class$Type<(any)>): $Optional<(T)>
public "registerDisplayTest"(arg0: $Supplier$Type<($IExtensionPoint$DisplayTest$Type)>): void
public "registerDisplayTest"(arg0: string, arg1: $BiPredicate$Type<(string), (boolean)>): void
public "registerDisplayTest"(arg0: $Supplier$Type<(string)>, arg1: $BiPredicate$Type<(string), (boolean)>): void
public "registerDisplayTest"(arg0: $IExtensionPoint$DisplayTest$Type): void
public "dispatchConfigEvent"(arg0: $IConfigEvent$Type): void
public "getModId"(): string
get "currentState"(): $ModLoadingStage
get "namespace"(): string
get "modInfo"(): $IModInfo
get "mod"(): any
get "modId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModContainer$Type = ($ModContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModContainer_ = $ModContainer$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$StrictNBTIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $StrictNBTIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public static "of"(arg0: $ItemStack$Type): $StrictNBTIngredient
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getSerializer"(): $IIngredientSerializer<(any)>
public "canBeUsedForMatching"(): boolean
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrictNBTIngredient$Type = ($StrictNBTIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StrictNBTIngredient_ = $StrictNBTIngredient$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeChunkManager$TicketHelper" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeChunkManager$TicketHelper {


public "getEntityTickets"(): $Map<($UUID), ($Pair<($LongSet), ($LongSet)>)>
public "removeAllTickets"(arg0: $BlockPos$Type): void
public "removeAllTickets"(arg0: $UUID$Type): void
public "removeTicket"(arg0: $BlockPos$Type, arg1: long, arg2: boolean): void
public "removeTicket"(arg0: $UUID$Type, arg1: long, arg2: boolean): void
public "getBlockTickets"(): $Map<($BlockPos), ($Pair<($LongSet), ($LongSet)>)>
get "entityTickets"(): $Map<($UUID), ($Pair<($LongSet), ($LongSet)>)>
get "blockTickets"(): $Map<($BlockPos), ($Pair<($LongSet), ($LongSet)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeChunkManager$TicketHelper$Type = ($ForgeChunkManager$TicketHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeChunkManager$TicketHelper_ = $ForgeChunkManager$TicketHelper$Type;
}}
declare module "packages/net/minecraftforge/server/command/$TPSCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TPSCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TPSCommand$Type = ($TPSCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TPSCommand_ = $TPSCommand$Type;
}}
declare module "packages/net/minecraftforge/common/util/$MutableHashedLinkedMap" {
import {$MutableHashedLinkedMap$MergeFunction, $MutableHashedLinkedMap$MergeFunction$Type} from "packages/net/minecraftforge/common/util/$MutableHashedLinkedMap$MergeFunction"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Hash$Strategy, $Hash$Strategy$Type} from "packages/it/unimi/dsi/fastutil/$Hash$Strategy"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MutableHashedLinkedMap<K, V> implements $Iterable<($Map$Entry<(K), (V)>)> {
static readonly "BASIC": $Hash$Strategy<(any)>
static readonly "IDENTITY": $Hash$Strategy<(any)>

constructor(arg0: $Hash$Strategy$Type<(any)>, arg1: $MutableHashedLinkedMap$MergeFunction$Type<(K), (V)>)
constructor(arg0: $Hash$Strategy$Type<(any)>)
constructor()

public "remove"(arg0: K): V
public "get"(arg0: K): V
public "put"(arg0: K, arg1: V): V
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($Map$Entry<(K), (V)>)>
public "contains"(arg0: K): boolean
public "putBefore"(arg0: K, arg1: K, arg2: V): V
public "putAfter"(arg0: K, arg1: K, arg2: V): V
public "putFirst"(arg0: K, arg1: V): V
public "spliterator"(): $Spliterator<($Map$Entry<(K), (V)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Map$Entry<(K), (V)>>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableHashedLinkedMap$Type<K, V> = ($MutableHashedLinkedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableHashedLinkedMap_<K, V> = $MutableHashedLinkedMap$Type<(K), (V)>;
}}
declare module "packages/net/minecraftforge/event/$PlayLevelSoundEvent$AtPosition" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$PlayLevelSoundEvent, $PlayLevelSoundEvent$Type} from "packages/net/minecraftforge/event/$PlayLevelSoundEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"

export class $PlayLevelSoundEvent$AtPosition extends $PlayLevelSoundEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $Vec3$Type, arg2: $Holder$Type<($SoundEvent$Type)>, arg3: $SoundSource$Type, arg4: float, arg5: float)

public "getPosition"(): $Vec3
public "getListenerList"(): $ListenerList
get "position"(): $Vec3
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayLevelSoundEvent$AtPosition$Type = ($PlayLevelSoundEvent$AtPosition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayLevelSoundEvent$AtPosition_ = $PlayLevelSoundEvent$AtPosition$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$SoundEngineLoadEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraftforge/client/event/sound/$SoundEvent"

export class $SoundEngineLoadEvent extends $SoundEvent implements $IModBusEvent {

constructor(arg0: $SoundEngine$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEngineLoadEvent$Type = ($SoundEngineLoadEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEngineLoadEvent_ = $SoundEngineLoadEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiEvent$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$RenderGuiEvent, $RenderGuiEvent$Type} from "packages/net/minecraftforge/client/event/$RenderGuiEvent"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiEvent$Pre extends $RenderGuiEvent {

constructor()
constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiEvent$Pre$Type = ($RenderGuiEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiEvent$Pre_ = $RenderGuiEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo$Builder" {
import {$ModifiableStructureInfo$StructureInfo, $ModifiableStructureInfo$StructureInfo$Type} from "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo"
import {$StructureSettingsBuilder, $StructureSettingsBuilder$Type} from "packages/net/minecraftforge/common/world/$StructureSettingsBuilder"

export class $ModifiableStructureInfo$StructureInfo$Builder {


public static "copyOf"(arg0: $ModifiableStructureInfo$StructureInfo$Type): $ModifiableStructureInfo$StructureInfo$Builder
public "build"(): $ModifiableStructureInfo$StructureInfo
public "getStructureSettings"(): $StructureSettingsBuilder
get "structureSettings"(): $StructureSettingsBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableStructureInfo$StructureInfo$Builder$Type = ($ModifiableStructureInfo$StructureInfo$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableStructureInfo$StructureInfo$Builder_ = $ModifiableStructureInfo$StructureInfo$Builder$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$AdvancementEvent$AdvancementEarnEvent" {
import {$AdvancementEvent, $AdvancementEvent$Type} from "packages/net/minecraftforge/event/entity/player/$AdvancementEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export class $AdvancementEvent$AdvancementEarnEvent extends $AdvancementEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Advancement$Type)

public "getAdvancement"(): $Advancement
public "getListenerList"(): $ListenerList
get "advancement"(): $Advancement
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementEvent$AdvancementEarnEvent$Type = ($AdvancementEvent$AdvancementEarnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdvancementEvent$AdvancementEarnEvent_ = $AdvancementEvent$AdvancementEarnEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$LoadingFailedException" {
import {$ModLoadingException, $ModLoadingException$Type} from "packages/net/minecraftforge/fml/$ModLoadingException"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $LoadingFailedException extends $RuntimeException {

constructor(arg0: $List$Type<($ModLoadingException$Type)>)

public "getMessage"(): string
public "getErrors"(): $List<($ModLoadingException)>
get "message"(): string
get "errors"(): $List<($ModLoadingException)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadingFailedException$Type = ($LoadingFailedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoadingFailedException_ = $LoadingFailedException$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ExplosionEvent$Detonate" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ExplosionEvent, $ExplosionEvent$Type} from "packages/net/minecraftforge/event/level/$ExplosionEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ExplosionEvent$Detonate extends $ExplosionEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $Explosion$Type, arg2: $List$Type<($Entity$Type)>)

public "getAffectedBlocks"(): $List<($BlockPos)>
public "getAffectedEntities"(): $List<($Entity)>
public "getListenerList"(): $ListenerList
get "affectedBlocks"(): $List<($BlockPos)>
get "affectedEntities"(): $List<($Entity)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEvent$Detonate$Type = ($ExplosionEvent$Detonate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEvent$Detonate_ = $ExplosionEvent$Detonate$Type;
}}
declare module "packages/net/minecraftforge/event/entity/item/$ItemTossEvent" {
import {$ItemEvent, $ItemEvent$Type} from "packages/net/minecraftforge/event/entity/item/$ItemEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $ItemTossEvent extends $ItemEvent {

constructor()
constructor(arg0: $ItemEntity$Type, arg1: $Player$Type)

public "isCancelable"(): boolean
public "getPlayer"(): $Player
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "player"(): $Player
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTossEvent$Type = ($ItemTossEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTossEvent_ = $ItemTossEvent$Type;
}}
declare module "packages/net/minecraftforge/common/data/$LanguageProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $LanguageProvider implements $DataProvider {

constructor(arg0: $PackOutput$Type, arg1: string, arg2: string)

public "add"(arg0: $ItemStack$Type, arg1: string): void
public "add"(arg0: string, arg1: string): void
public "add"(arg0: $Item$Type, arg1: string): void
public "add"(arg0: $Enchantment$Type, arg1: string): void
public "add"(arg0: $MobEffect$Type, arg1: string): void
public "add"(arg0: $EntityType$Type<(any)>, arg1: string): void
public "add"(arg0: $Block$Type, arg1: string): void
public "addItem"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "addItemStack"(arg0: $Supplier$Type<($ItemStack$Type)>, arg1: string): void
public "addEnchantment"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "addEntityType"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "addEffect"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "addBlock"(arg0: $Supplier$Type<(any)>, arg1: string): void
public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LanguageProvider$Type = ($LanguageProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LanguageProvider_ = $LanguageProvider$Type;
}}
declare module "packages/net/minecraftforge/forgespi/language/$ModFileScanData$ClassData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Type, $Type$Type} from "packages/org/objectweb/asm/$Type"

export class $ModFileScanData$ClassData extends $Record {

constructor(clazz: $Type$Type, parent: $Type$Type, interfaces: $Set$Type<($Type$Type)>)

public "clazz"(): $Type
public "parent"(): $Type
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "interfaces"(): $Set<($Type)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFileScanData$ClassData$Type = ($ModFileScanData$ClassData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFileScanData$ClassData_ = $ModFileScanData$ClassData$Type;
}}
declare module "packages/net/minecraftforge/server/permission/nodes/$PermissionNode$PermissionResolver" {
import {$PermissionDynamicContext, $PermissionDynamicContext$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"

export interface $PermissionNode$PermissionResolver<T> {

 "resolve"(arg0: $ServerPlayer$Type, arg1: $UUID$Type, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T

(arg0: $ServerPlayer$Type, arg1: $UUID$Type, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
}

export namespace $PermissionNode$PermissionResolver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionNode$PermissionResolver$Type<T> = ($PermissionNode$PermissionResolver<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionNode$PermissionResolver_<T> = $PermissionNode$PermissionResolver$Type<(T)>;
}}
declare module "packages/net/minecraftforge/versions/mcp/$MCPVersion" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MCPVersion {

constructor()

public static "getMCVersion"(): string
public static "getMCPVersion"(): string
public static "getMCPandMCVersion"(): string
get "mCVersion"(): string
get "mCPVersion"(): string
get "mCPandMCVersion"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MCPVersion$Type = ($MCPVersion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MCPVersion_ = $MCPVersion$Type;
}}
declare module "packages/net/minecraftforge/event/$GrindstoneEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GrindstoneEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "setXp"(arg0: integer): void
public "getTopItem"(): $ItemStack
public "getBottomItem"(): $ItemStack
public "getXp"(): integer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
set "xp"(value: integer)
get "topItem"(): $ItemStack
get "bottomItem"(): $ItemStack
get "xp"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrindstoneEvent$Type = ($GrindstoneEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GrindstoneEvent_ = $GrindstoneEvent$Type;
}}
declare module "packages/net/minecraftforge/event/server/$ServerLifecycleEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"

export class $ServerLifecycleEvent extends $Event {

constructor()
constructor(arg0: $MinecraftServer$Type)

public "isCancelable"(): boolean
public "getServer"(): $MinecraftServer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "server"(): $MinecraftServer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLifecycleEvent$Type = ($ServerLifecycleEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerLifecycleEvent_ = $ServerLifecycleEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$ConfigScreenHandler" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $ConfigScreenHandler {

constructor()

public static "getScreenFactoryFor"(arg0: $IModInfo$Type): $Optional<($BiFunction<($Minecraft), ($Screen), ($Screen)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigScreenHandler$Type = ($ConfigScreenHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigScreenHandler_ = $ConfigScreenHandler$Type;
}}
declare module "packages/net/minecraftforge/common/$PlantType" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PlantType {
static readonly "PLAINS": $PlantType
static readonly "DESERT": $PlantType
static readonly "BEACH": $PlantType
static readonly "CAVE": $PlantType
static readonly "WATER": $PlantType
static readonly "NETHER": $PlantType
static readonly "CROP": $PlantType


public "getName"(): string
public static "get"(arg0: string): $PlantType
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlantType$Type = ($PlantType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlantType_ = $PlantType$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$BlockGeometryBakingContext" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$BlockGeometryBakingContext$VisibilityData, $BlockGeometryBakingContext$VisibilityData$Type} from "packages/net/minecraftforge/client/model/geometry/$BlockGeometryBakingContext$VisibilityData"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $BlockGeometryBakingContext implements $IGeometryBakingContext {
readonly "owner": $BlockModel
readonly "visibilityData": $BlockGeometryBakingContext$VisibilityData

constructor(arg0: $BlockModel$Type)

public "copyFrom"(arg0: $BlockGeometryBakingContext$Type): void
public "getTransforms"(): $ItemTransforms
public "useAmbientOcclusion"(): boolean
public "isGui3d"(): boolean
public "getCustomGeometry"(): $IUnbakedGeometry<(any)>
public "useBlockLight"(): boolean
public "getMaterial"(arg0: string): $Material
public "hasCustomGeometry"(): boolean
public "setCustomGeometry"(arg0: $IUnbakedGeometry$Type<(any)>): void
public "setRootTransform"(arg0: $Transformation$Type): void
public "setRenderTypeHint"(arg0: $ResourceLocation$Type): void
public "setGui3d"(arg0: boolean): void
public "getRootTransform"(): $Transformation
public "getModelName"(): string
public "hasMaterial"(arg0: string): boolean
public "getRenderTypeHint"(): $ResourceLocation
public "isComponentVisible"(arg0: string, arg1: boolean): boolean
public "bake"(arg0: $ModelBaker$Type, arg1: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg2: $ModelState$Type, arg3: $ItemOverrides$Type, arg4: $ResourceLocation$Type): $BakedModel
public "getRenderType"(arg0: $ResourceLocation$Type): $RenderTypeGroup
get "transforms"(): $ItemTransforms
get "gui3d"(): boolean
get "customGeometry"(): $IUnbakedGeometry<(any)>
set "customGeometry"(value: $IUnbakedGeometry$Type<(any)>)
set "rootTransform"(value: $Transformation$Type)
set "renderTypeHint"(value: $ResourceLocation$Type)
set "gui3d"(value: boolean)
get "rootTransform"(): $Transformation
get "modelName"(): string
get "renderTypeHint"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockGeometryBakingContext$Type = ($BlockGeometryBakingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockGeometryBakingContext_ = $BlockGeometryBakingContext$Type;
}}
declare module "packages/net/minecraftforge/client/$NamedRenderTypeManager" {
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $NamedRenderTypeManager {


public static "get"(arg0: $ResourceLocation$Type): $RenderTypeGroup
public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedRenderTypeManager$Type = ($NamedRenderTypeManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedRenderTypeManager_ = $NamedRenderTypeManager$Type;
}}
declare module "packages/net/minecraftforge/resource/$PathPackResources" {
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$Type} from "packages/net/minecraft/server/packs/$PackResources$ResourceOutput"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$AbstractPackResources, $AbstractPackResources$Type} from "packages/net/minecraft/server/packs/$AbstractPackResources"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ICachingResourcePack, $ICachingResourcePack$Type} from "packages/org/embeddedt/modernfix/resources/$ICachingResourcePack"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $PathPackResources extends $AbstractPackResources implements $ICachingResourcePack {

constructor(arg0: string, arg1: boolean, arg2: $Path$Type)

public "toString"(): string
public "close"(): void
public "getSource"(): $Path
public "getResource"(arg0: $PackType$Type, arg1: $ResourceLocation$Type): $IoSupplier<($InputStream)>
public "invalidateCache"(): void
public "listResources"(arg0: $PackType$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$Type): void
public "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
public "getNamespaces"(arg0: $PackType$Type): $Set<(string)>
get "source"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathPackResources$Type = ($PathPackResources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathPackResources_ = $PathPackResources$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseButtonPressed" {
import {$ScreenEvent$MouseInput, $ScreenEvent$MouseInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$MouseButtonPressed extends $ScreenEvent$MouseInput {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer)

public "getButton"(): integer
public "getListenerList"(): $ListenerList
get "button"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseButtonPressed$Type = ($ScreenEvent$MouseButtonPressed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseButtonPressed_ = $ScreenEvent$MouseButtonPressed$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingDeathEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingDeathEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type)

public "getSource"(): $DamageSource
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingDeathEvent$Type = ($LivingDeathEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingDeathEvent_ = $LivingDeathEvent$Type;
}}
declare module "packages/net/minecraftforge/server/permission/handler/$IPermissionHandler" {
import {$PermissionDynamicContext, $PermissionDynamicContext$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionDynamicContext"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$PermissionNode, $PermissionNode$Type} from "packages/net/minecraftforge/server/permission/nodes/$PermissionNode"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IPermissionHandler {

 "getPermission"<T>(arg0: $ServerPlayer$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
 "getIdentifier"(): $ResourceLocation
 "getOfflinePermission"<T>(arg0: $UUID$Type, arg1: $PermissionNode$Type<(T)>, ...arg2: ($PermissionDynamicContext$Type<(any)>)[]): T
 "getRegisteredNodes"(): $Set<($PermissionNode<(any)>)>
}

export namespace $IPermissionHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPermissionHandler$Type = ($IPermissionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPermissionHandler_ = $IPermissionHandler$Type;
}}
declare module "packages/net/minecraftforge/common/util/$FakePlayerFactory" {
import {$FakePlayer, $FakePlayer$Type} from "packages/net/minecraftforge/common/util/$FakePlayer"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"

export class $FakePlayerFactory {

constructor()

public static "get"(arg0: $ServerLevel$Type, arg1: $GameProfile$Type): $FakePlayer
public static "getMinecraft"(arg0: $ServerLevel$Type): $FakePlayer
public static "unloadLevel"(arg0: $ServerLevel$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FakePlayerFactory$Type = ($FakePlayerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FakePlayerFactory_ = $FakePlayerFactory$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingFallEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingFallEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: float, arg2: float)

public "getDistance"(): float
public "setDistance"(arg0: float): void
public "isCancelable"(): boolean
public "getDamageMultiplier"(): float
public "setDamageMultiplier"(arg0: float): void
public "getListenerList"(): $ListenerList
get "distance"(): float
set "distance"(value: float)
get "cancelable"(): boolean
get "damageMultiplier"(): float
set "damageMultiplier"(value: float)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingFallEvent$Type = ($LivingFallEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingFallEvent_ = $LivingFallEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$PlayMessages$SpawnEntity" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayMessages$SpawnEntity {


public static "decode"(arg0: $FriendlyByteBuf$Type): $PlayMessages$SpawnEntity
public static "encode"(arg0: $PlayMessages$SpawnEntity$Type, arg1: $FriendlyByteBuf$Type): void
public static "handle"(arg0: $PlayMessages$SpawnEntity$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
public "getPosY"(): double
public "getPosX"(): double
public "getEntity"(): $Entity
public "getPitch"(): byte
public "getYaw"(): byte
public "getPosZ"(): double
public "getEntityId"(): integer
public "getVelX"(): integer
public "getVelZ"(): integer
public "getVelY"(): integer
public "getAdditionalData"(): $FriendlyByteBuf
public "getHeadYaw"(): byte
public "getTypeId"(): integer
public "getUuid"(): $UUID
get "posY"(): double
get "posX"(): double
get "entity"(): $Entity
get "pitch"(): byte
get "yaw"(): byte
get "posZ"(): double
get "entityId"(): integer
get "velX"(): integer
get "velZ"(): integer
get "velY"(): integer
get "additionalData"(): $FriendlyByteBuf
get "headYaw"(): byte
get "typeId"(): integer
get "uuid"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayMessages$SpawnEntity$Type = ($PlayMessages$SpawnEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayMessages$SpawnEntity_ = $PlayMessages$SpawnEntity$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IFluidHandlerItem extends $IFluidHandler {

 "getContainer"(): $ItemStack
 "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
 "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
 "getTanks"(): integer
 "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
 "getFluidInTank"(arg0: integer): $FluidStack
 "getTankCapacity"(arg0: integer): integer
}

export namespace $IFluidHandlerItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidHandlerItem$Type = ($IFluidHandlerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidHandlerItem_ = $IFluidHandlerItem$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$ArrowNockEvent" {
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ArrowNockEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $InteractionHand$Type, arg3: $Level$Type, arg4: boolean)

public "getLevel"(): $Level
public "setAction"(arg0: $InteractionResultHolder$Type<($ItemStack$Type)>): void
public "hasAmmo"(): boolean
public "getHand"(): $InteractionHand
public "getAction"(): $InteractionResultHolder<($ItemStack)>
public "getBow"(): $ItemStack
public "getListenerList"(): $ListenerList
get "level"(): $Level
set "action"(value: $InteractionResultHolder$Type<($ItemStack$Type)>)
get "hand"(): $InteractionHand
get "action"(): $InteractionResultHolder<($ItemStack)>
get "bow"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrowNockEvent$Type = ($ArrowNockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrowNockEvent_ = $ArrowNockEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$MultiItemValue" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $MultiItemValue implements $Ingredient$Value {

constructor(arg0: $Collection$Type<($ItemStack$Type)>)

public "serialize"(): $JsonObject
public "getItems"(): $Collection<($ItemStack)>
get "items"(): $Collection<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiItemValue$Type = ($MultiItemValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiItemValue_ = $MultiItemValue$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$ColourScheme" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ColourScheme$Colour, $ColourScheme$Colour$Type} from "packages/net/minecraftforge/fml/earlydisplay/$ColourScheme$Colour"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ColourScheme extends $Enum<($ColourScheme)> {
static readonly "RED": $ColourScheme
static readonly "BLACK": $ColourScheme


public static "values"(): ($ColourScheme)[]
public static "valueOf"(arg0: string): $ColourScheme
public "background"(): $ColourScheme$Colour
public "foreground"(): $ColourScheme$Colour
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColourScheme$Type = (("red") | ("black")) | ($ColourScheme);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColourScheme_ = $ColourScheme$Type;
}}
declare module "packages/net/minecraftforge/forgespi/locating/$ModFileFactory$ModFileInfoParser" {
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"

export interface $ModFileFactory$ModFileInfoParser {

 "build"(arg0: $IModFile$Type): $IModFileInfo

(arg0: $IModFile$Type): $IModFileInfo
}

export namespace $ModFileFactory$ModFileInfoParser {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFileFactory$ModFileInfoParser$Type = ($ModFileFactory$ModFileInfoParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFileFactory$ModFileInfoParser_ = $ModFileFactory$ModFileInfoParser$Type;
}}
declare module "packages/net/minecraftforge/client/$IArmPoseTransformer" {
import {$HumanoidArm, $HumanoidArm$Type} from "packages/net/minecraft/world/entity/$HumanoidArm"
import {$HumanoidModel, $HumanoidModel$Type} from "packages/net/minecraft/client/model/$HumanoidModel"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $IArmPoseTransformer {

 "applyTransform"(arg0: $HumanoidModel$Type<(any)>, arg1: $LivingEntity$Type, arg2: $HumanoidArm$Type): void

(arg0: $HumanoidModel$Type<(any)>, arg1: $LivingEntity$Type, arg2: $HumanoidArm$Type): void
}

export namespace $IArmPoseTransformer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IArmPoseTransformer$Type = ($IArmPoseTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IArmPoseTransformer_ = $IArmPoseTransformer$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkEvent$Unload" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$ChunkEvent, $ChunkEvent$Type} from "packages/net/minecraftforge/event/level/$ChunkEvent"

export class $ChunkEvent$Unload extends $ChunkEvent {

constructor(arg0: $ChunkAccess$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkEvent$Unload$Type = ($ChunkEvent$Unload);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkEvent$Unload_ = $ChunkEvent$Unload$Type;
}}
declare module "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Flowing" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$ForgeFlowingFluid$Properties, $ForgeFlowingFluid$Properties$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Properties"
import {$ForgeFlowingFluid, $ForgeFlowingFluid$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"

export class $ForgeFlowingFluid$Flowing extends $ForgeFlowingFluid {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>

constructor(arg0: $ForgeFlowingFluid$Properties$Type)

public "getAmount"(arg0: $FluidState$Type): integer
public "isSource"(arg0: $FluidState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFlowingFluid$Flowing$Type = ($ForgeFlowingFluid$Flowing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFlowingFluid$Flowing_ = $ForgeFlowingFluid$Flowing$Type;
}}
declare module "packages/net/minecraftforge/resource/$ResourcePackLoader" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$PackRepository, $PackRepository$Type} from "packages/net/minecraft/server/packs/repository/$PackRepository"
import {$PathPackResources, $PathPackResources$Type} from "packages/net/minecraftforge/resource/$PathPackResources"
import {$Pack, $Pack$Type} from "packages/net/minecraft/server/packs/repository/$Pack"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $ResourcePackLoader {

constructor()

public static "getPackFor"(arg0: string): $Optional<($PathPackResources)>
public static "createPackForMod"(arg0: $IModFileInfo$Type): $PathPackResources
public static "loadResourcePacks"(arg0: $PackRepository$Type, arg1: $Function$Type<($Map$Type<($IModFile$Type), (any)>), (any)>): void
/**
 * 
 * @deprecated
 */
public static "loadResourcePacks"(arg0: $PackRepository$Type, arg1: $BiFunction$Type<($Map$Type<($IModFile$Type), (any)>), ($BiConsumer$Type<(any), ($Pack$Type)>), (any)>): void
public static "getPackNames"(): $List<(string)>
public static "getSorter"<V>(): $Comparator<($Map$Entry<(string), (V)>)>
get "packNames"(): $List<(string)>
get "sorter"(): $Comparator<($Map$Entry<(string), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResourcePackLoader$Type = ($ResourcePackLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResourcePackLoader_ = $ResourcePackLoader$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$Clone" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerEvent$Clone extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Player$Type, arg2: boolean)

public "getOriginal"(): $Player
public "isWasDeath"(): boolean
public "getListenerList"(): $ListenerList
get "original"(): $Player
get "wasDeath"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$Clone$Type = ($PlayerEvent$Clone);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$Clone_ = $PlayerEvent$Clone$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeAdvancementProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$ForgeAdvancementProvider$AdvancementGenerator, $ForgeAdvancementProvider$AdvancementGenerator$Type} from "packages/net/minecraftforge/common/data/$ForgeAdvancementProvider$AdvancementGenerator"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$AdvancementProvider, $AdvancementProvider$Type} from "packages/net/minecraft/data/advancements/$AdvancementProvider"

export class $ForgeAdvancementProvider extends $AdvancementProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type, arg3: $List$Type<($ForgeAdvancementProvider$AdvancementGenerator$Type)>)

public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeAdvancementProvider$Type = ($ForgeAdvancementProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeAdvancementProvider_ = $ForgeAdvancementProvider$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $NetworkEvent extends $Event {

constructor()
constructor(arg0: $Supplier$Type<($NetworkEvent$Context$Type)>)

public "getPayload"(): $FriendlyByteBuf
public "getSource"(): $Supplier<($NetworkEvent$Context)>
public "isCancelable"(): boolean
public "getLoginIndex"(): integer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "payload"(): $FriendlyByteBuf
get "source"(): $Supplier<($NetworkEvent$Context)>
get "cancelable"(): boolean
get "loginIndex"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$Type = ($NetworkEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent_ = $NetworkEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$IConfigEvent" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent$ConfigConfig, $IConfigEvent$ConfigConfig$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent$ConfigConfig"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IConfigEvent {

 "self"<T extends ($Event) & ($IConfigEvent)>(): T
 "getConfig"(): $ModConfig

(): T
}

export namespace $IConfigEvent {
const CONFIGCONFIG: $IConfigEvent$ConfigConfig
function reloading(arg0: $ModConfig$Type): $IConfigEvent
function unloading(arg0: $ModConfig$Type): $IConfigEvent
function loading(arg0: $ModConfig$Type): $IConfigEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConfigEvent$Type = ($IConfigEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConfigEvent_ = $IConfigEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Init$Pre" {
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$Init, $ScreenEvent$Init$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$Init"

export class $ScreenEvent$Init$Pre extends $ScreenEvent$Init {

constructor()
constructor(arg0: $Screen$Type, arg1: $List$Type<($GuiEventListener$Type)>, arg2: $Consumer$Type<($GuiEventListener$Type)>, arg3: $Consumer$Type<($GuiEventListener$Type)>)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Init$Pre$Type = ($ScreenEvent$Init$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Init$Pre_ = $ScreenEvent$Init$Pre$Type;
}}
declare module "packages/net/minecraftforge/fluids/$DispenseFluidContainer" {
import {$BlockSource, $BlockSource$Type} from "packages/net/minecraft/core/$BlockSource"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$DefaultDispenseItemBehavior, $DefaultDispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DefaultDispenseItemBehavior"

export class $DispenseFluidContainer extends $DefaultDispenseItemBehavior {


public static "getInstance"(): $DispenseFluidContainer
public "m_7498_"(arg0: $BlockSource$Type, arg1: $ItemStack$Type): $ItemStack
public static "bootStrap"(): void
public static "setEntityPokingOutOfBlock"(arg0: $BlockSource$Type, arg1: $Entity$Type, arg2: $Direction$Type): void
get "instance"(): $DispenseFluidContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenseFluidContainer$Type = ($DispenseFluidContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DispenseFluidContainer_ = $DispenseFluidContainer$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IGeometryBakingContext {

 "getTransforms"(): $ItemTransforms
 "useAmbientOcclusion"(): boolean
 "getRenderType"(arg0: $ResourceLocation$Type): $RenderTypeGroup
 "isGui3d"(): boolean
 "useBlockLight"(): boolean
 "getMaterial"(arg0: string): $Material
 "getRootTransform"(): $Transformation
 "getModelName"(): string
 "hasMaterial"(arg0: string): boolean
 "getRenderTypeHint"(): $ResourceLocation
 "isComponentVisible"(arg0: string, arg1: boolean): boolean
}

export namespace $IGeometryBakingContext {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGeometryBakingContext$Type = ($IGeometryBakingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGeometryBakingContext_ = $IGeometryBakingContext$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeRegistry" {
import {$ForgeRegistryForgeAccessor, $ForgeRegistryForgeAccessor$Type} from "packages/fuzs/puzzleslib/mixin/accessor/$ForgeRegistryForgeAccessor"
import {$MissingMappingsEvent, $MissingMappingsEvent$Type} from "packages/net/minecraftforge/registries/$MissingMappingsEvent"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$IdMappingEvent$IdRemapping, $IdMappingEvent$IdRemapping$Type} from "packages/net/minecraftforge/registries/$IdMappingEvent$IdRemapping"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Marker, $Marker$Type} from "packages/org/apache/logging/log4j/$Marker"
import {$IForgeRegistryModifiable, $IForgeRegistryModifiable$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryModifiable"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"
import {$ForgeRegistry$Snapshot, $ForgeRegistry$Snapshot$Type} from "packages/net/minecraftforge/registries/$ForgeRegistry$Snapshot"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ITagManager, $ITagManager$Type} from "packages/net/minecraftforge/registries/tags/$ITagManager"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeRegistry<V> implements $IForgeRegistryInternal<(V)>, $IForgeRegistryModifiable<(V)>, $ForgeRegistryForgeAccessor<(any)> {
static readonly "REGISTRIES": $Marker


public "remove"(arg0: $ResourceLocation$Type): V
public "clear"(): void
public "getValue"(arg0: $ResourceLocation$Type): V
public "getValue"(arg0: integer): V
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(V)>
public "getKey"(arg0: V): $ResourceLocation
public "getKey"(arg0: integer): $ResourceKey<(V)>
public "register"(arg0: integer, arg1: $ResourceLocation$Type, arg2: V): void
public "register"(arg0: string, arg1: V): void
public "register"(arg0: $ResourceLocation$Type, arg1: V): void
public "containsKey"(arg0: $ResourceLocation$Type): boolean
public "containsValue"(arg0: V): boolean
public "getEntries"(): $Set<($Map$Entry<($ResourceKey<(V)>), (V)>)>
public "freeze"(): void
public "isLocked"(): boolean
public "getID"(arg0: $ResourceLocation$Type): integer
public "getID"(arg0: V): integer
public "getKeys"(): $Set<($ResourceLocation)>
public "tags"(): $ITagManager<(V)>
public "addAlias"(arg0: $ResourceLocation$Type, arg1: $ResourceLocation$Type): void
public "getDelegate"(arg0: $ResourceLocation$Type): $Optional<($Holder$Reference<(V)>)>
public "getDelegate"(arg0: V): $Optional<($Holder$Reference<(V)>)>
public "getDelegate"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder$Reference<(V)>)>
public "getRaw"(arg0: $ResourceLocation$Type): V
public "unfreeze"(): void
public "getResourceKey"(arg0: V): $Optional<($ResourceKey<(V)>)>
public "getCodec"(): $Codec<(V)>
public "getSlaveMap"<T>(arg0: $ResourceLocation$Type, arg1: $Class$Type<(T)>): T
public "bake"(): void
public "loadIds"(arg0: $Object2IntMap$Type<($ResourceLocation$Type)>, arg1: $Map$Type<($ResourceLocation$Type), (string)>, arg2: $Object2IntMap$Type<($ResourceLocation$Type)>, arg3: $Map$Type<($ResourceLocation$Type), ($IdMappingEvent$IdRemapping$Type)>, arg4: $ForgeRegistry$Type<(V)>, arg5: $ResourceLocation$Type): void
public "getRegistryKey"(): $ResourceKey<($Registry<(V)>)>
public "getMissingEvent"(arg0: $ResourceLocation$Type, arg1: $Object2IntMap$Type<($ResourceLocation$Type)>): $MissingMappingsEvent
public "getRegistryName"(): $ResourceLocation
public "getDelegateOrThrow"(rkey: $ResourceKey$Type<(any)>): $Holder$Reference<(any)>
public "getDelegateOrThrow"(value: any): $Holder$Reference<(any)>
public "getDelegateOrThrow"(location: $ResourceLocation$Type): $Holder$Reference<(any)>
public "getHolder"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder<(V)>)>
public "getHolder"(arg0: $ResourceLocation$Type): $Optional<($Holder<(V)>)>
public "getHolder"(arg0: V): $Optional<($Holder<(V)>)>
public "getDefaultKey"(): $ResourceLocation
public "setSlaveMap"(arg0: $ResourceLocation$Type, arg1: any): void
public "makeSnapshot"(): $ForgeRegistry$Snapshot
public "getValues"(): $Collection<(V)>
public "spliterator"(): $Spliterator<(V)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<V>;
get "empty"(): boolean
get "entries"(): $Set<($Map$Entry<($ResourceKey<(V)>), (V)>)>
get "locked"(): boolean
get "keys"(): $Set<($ResourceLocation)>
get "codec"(): $Codec<(V)>
get "registryKey"(): $ResourceKey<($Registry<(V)>)>
get "registryName"(): $ResourceLocation
get "defaultKey"(): $ResourceLocation
get "values"(): $Collection<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeRegistry$Type<V> = ($ForgeRegistry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeRegistry_<V> = $ForgeRegistry$Type<(V)>;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent$ChannelRegistrationChangeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NetworkEvent, $NetworkEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent"
import {$NetworkEvent$RegistrationChangeType, $NetworkEvent$RegistrationChangeType$Type} from "packages/net/minecraftforge/network/$NetworkEvent$RegistrationChangeType"

export class $NetworkEvent$ChannelRegistrationChangeEvent extends $NetworkEvent {

constructor()

public "getRegistrationChangeType"(): $NetworkEvent$RegistrationChangeType
public "getListenerList"(): $ListenerList
get "registrationChangeType"(): $NetworkEvent$RegistrationChangeType
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$ChannelRegistrationChangeEvent$Type = ($NetworkEvent$ChannelRegistrationChangeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent$ChannelRegistrationChangeEvent_ = $NetworkEvent$ChannelRegistrationChangeEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $PlayerEvent extends $LivingEvent {

constructor()
constructor(arg0: $Player$Type)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$Type = ($PlayerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent_ = $PlayerEvent$Type;
}}
declare module "packages/net/minecraftforge/items/$IItemHandlerModifiable" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export interface $IItemHandlerModifiable extends $IItemHandler {

 "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
 "kjs$self"(): $IItemHandler
 "getBlock"(level: $Level$Type): $BlockContainerJS
 "getSlots"(): integer
 "getStackInSlot"(arg0: integer): $ItemStack
 "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
 "getSlots"(): integer
 "getStackInSlot"(i: integer): $ItemStack
 "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
 "isMutable"(): boolean
 "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
 "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
 "getSlotLimit"(i: integer): integer
 "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
 "setChanged"(): void
 "asContainer"(): $Container
 "countNonEmpty"(ingredient: $Ingredient$Type): integer
 "countNonEmpty"(): integer
 "getAllItems"(): $List<($ItemStack)>
 "getHeight"(): integer
 "find"(ingredient: $Ingredient$Type): integer
 "find"(): integer
 "getWidth"(): integer
 "clear"(): void
 "clear"(ingredient: $Ingredient$Type): void
 "count"(ingredient: $Ingredient$Type): integer
 "count"(): integer
 "isEmpty"(): boolean
}

export namespace $IItemHandlerModifiable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemHandlerModifiable$Type = ($IItemHandlerModifiable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemHandlerModifiable_ = $IItemHandlerModifiable$Type;
}}
declare module "packages/net/minecraftforge/client/$DimensionSpecialEffectsManager" {
import {$DimensionSpecialEffects, $DimensionSpecialEffects$Type} from "packages/net/minecraft/client/renderer/$DimensionSpecialEffects"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DimensionSpecialEffectsManager {


public static "init"(): void
public static "getForType"(arg0: $ResourceLocation$Type): $DimensionSpecialEffects
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionSpecialEffectsManager$Type = ($DimensionSpecialEffectsManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionSpecialEffectsManager_ = $DimensionSpecialEffectsManager$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelFile" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ModelFile {


public "getLocation"(): $ResourceLocation
public "assertExistence"(): void
public "getUncheckedLocation"(): $ResourceLocation
get "location"(): $ResourceLocation
get "uncheckedLocation"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelFile$Type = ($ModelFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelFile_ = $ModelFile$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterNamedRenderTypesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $RegisterNamedRenderTypesEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Map$Type<($ResourceLocation$Type), ($RenderTypeGroup$Type)>)

public "register"(arg0: string, arg1: $RenderType$Type, arg2: $RenderType$Type, arg3: $RenderType$Type): void
public "register"(arg0: string, arg1: $RenderType$Type, arg2: $RenderType$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterNamedRenderTypesEvent$Type = ($RegisterNamedRenderTypesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterNamedRenderTypesEvent_ = $RegisterNamedRenderTypesEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/$DynamicFluidContainerModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $DynamicFluidContainerModel implements $IUnbakedGeometry<($DynamicFluidContainerModel)> {


public static "getLayerRenderTypes"(arg0: boolean): $RenderTypeGroup
public "withFluid"(arg0: $Fluid$Type): $DynamicFluidContainerModel
public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicFluidContainerModel$Type = ($DynamicFluidContainerModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicFluidContainerModel_ = $DynamicFluidContainerModel$Type;
}}
declare module "packages/net/minecraftforge/event/$TagsUpdatedEvent" {
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$TagsUpdatedEvent$UpdateCause, $TagsUpdatedEvent$UpdateCause$Type} from "packages/net/minecraftforge/event/$TagsUpdatedEvent$UpdateCause"

export class $TagsUpdatedEvent extends $Event {

constructor()
constructor(arg0: $RegistryAccess$Type, arg1: boolean, arg2: boolean)

public "isCancelable"(): boolean
public "getRegistryAccess"(): $RegistryAccess
public "getUpdateCause"(): $TagsUpdatedEvent$UpdateCause
public "shouldUpdateStaticData"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "registryAccess"(): $RegistryAccess
get "updateCause"(): $TagsUpdatedEvent$UpdateCause
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagsUpdatedEvent$Type = ($TagsUpdatedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagsUpdatedEvent_ = $TagsUpdatedEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$SpawnPlacementRegisterEvent$MergedSpawnPredicate" {
import {$SpawnPlacements$Type, $SpawnPlacements$Type$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$Type"
import {$SpawnPlacements$SpawnPredicate, $SpawnPlacements$SpawnPredicate$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$SpawnPredicate"
import {$Heightmap$Types, $Heightmap$Types$Type} from "packages/net/minecraft/world/level/levelgen/$Heightmap$Types"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SpawnPlacementRegisterEvent$MergedSpawnPredicate<T extends $Entity> {

constructor(arg0: $SpawnPlacements$SpawnPredicate$Type<(T)>, arg1: $SpawnPlacements$Type$Type, arg2: $Heightmap$Types$Type)

public "build"(): $SpawnPlacements$SpawnPredicate<(T)>
public "getSpawnType"(): $SpawnPlacements$Type
public "getHeightmapType"(): $Heightmap$Types
get "spawnType"(): $SpawnPlacements$Type
get "heightmapType"(): $Heightmap$Types
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnPlacementRegisterEvent$MergedSpawnPredicate$Type<T> = ($SpawnPlacementRegisterEvent$MergedSpawnPredicate<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpawnPlacementRegisterEvent$MergedSpawnPredicate_<T> = $SpawnPlacementRegisterEvent$MergedSpawnPredicate$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/level/$SaplingGrowTreeEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SaplingGrowTreeEvent extends $LevelEvent {

constructor()
constructor(arg0: $LevelAccessor$Type, arg1: $RandomSource$Type, arg2: $BlockPos$Type, arg3: $Holder$Type<($ConfiguredFeature$Type<(any), (any)>)>)

public "getFeature"(): $Holder<($ConfiguredFeature<(any), (any)>)>
public "setFeature"(arg0: $ResourceKey$Type<($ConfiguredFeature$Type<(any), (any)>)>): void
public "setFeature"(arg0: $Holder$Type<($ConfiguredFeature$Type<(any), (any)>)>): void
public "getRandomSource"(): $RandomSource
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "feature"(): $Holder<($ConfiguredFeature<(any), (any)>)>
set "feature"(value: $ResourceKey$Type<($ConfiguredFeature$Type<(any), (any)>)>)
set "feature"(value: $Holder$Type<($ConfiguredFeature$Type<(any), (any)>)>)
get "randomSource"(): $RandomSource
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SaplingGrowTreeEvent$Type = ($SaplingGrowTreeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SaplingGrowTreeEvent_ = $SaplingGrowTreeEvent$Type;
}}
declare module "packages/net/minecraftforge/event/level/$SleepFinishedTimeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $SleepFinishedTimeEvent extends $LevelEvent {

constructor()
constructor(arg0: $ServerLevel$Type, arg1: long, arg2: long)

public "setTimeAddition"(arg0: long): boolean
public "getNewTime"(): long
public "getListenerList"(): $ListenerList
set "timeAddition"(value: long)
get "newTime"(): long
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SleepFinishedTimeEvent$Type = ($SleepFinishedTimeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SleepFinishedTimeEvent_ = $SleepFinishedTimeEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjTokenizer" {
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $ObjTokenizer implements $AutoCloseable {

constructor(arg0: $InputStream$Type)

public "close"(): void
public "readAndSplitLine"(arg0: boolean): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjTokenizer$Type = ($ObjTokenizer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjTokenizer_ = $ObjTokenizer$Type;
}}
declare module "packages/net/minecraftforge/network/$ConfigSync" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HandshakeMessages$S2CConfigData, $HandshakeMessages$S2CConfigData$Type} from "packages/net/minecraftforge/network/$HandshakeMessages$S2CConfigData"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ConfigSync {
static readonly "INSTANCE": $ConfigSync


public "syncConfigs"(arg0: boolean): $List<($Pair<(string), ($HandshakeMessages$S2CConfigData)>)>
public "receiveSyncedConfig"(arg0: $HandshakeMessages$S2CConfigData$Type, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigSync$Type = ($ConfigSync);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigSync_ = $ConfigSync$Type;
}}
declare module "packages/net/minecraftforge/client/event/$EntityRenderersEvent$RegisterRenderers" {
import {$EntityRendererProvider, $EntityRendererProvider$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityRenderersEvent, $EntityRenderersEvent$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityRendererProvider, $BlockEntityRendererProvider$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityRenderersEvent$RegisterRenderers extends $EntityRenderersEvent {

constructor()

public "registerEntityRenderer"<T extends $Entity>(arg0: $EntityType$Type<(any)>, arg1: $EntityRendererProvider$Type<(T)>): void
public "registerBlockEntityRenderer"<T extends $BlockEntity>(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockEntityRendererProvider$Type<(T)>): void
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRenderersEvent$RegisterRenderers$Type = ($EntityRenderersEvent$RegisterRenderers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRenderersEvent$RegisterRenderers_ = $EntityRenderersEvent$RegisterRenderers$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingUseTotemEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingUseTotemEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $ItemStack$Type, arg3: $InteractionHand$Type)
constructor()

public "getSource"(): $DamageSource
public "isCancelable"(): boolean
public "getTotem"(): $ItemStack
public "getHandHolding"(): $InteractionHand
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "cancelable"(): boolean
get "totem"(): $ItemStack
get "handHolding"(): $InteractionHand
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingUseTotemEvent$Type = ($LivingUseTotemEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingUseTotemEvent_ = $LivingUseTotemEvent$Type;
}}
declare module "packages/net/minecraftforge/client/settings/$KeyModifier" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IKeyConflictContext, $IKeyConflictContext$Type} from "packages/net/minecraftforge/client/settings/$IKeyConflictContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"

export class $KeyModifier extends $Enum<($KeyModifier)> {
static readonly "CONTROL": $KeyModifier
static readonly "SHIFT": $KeyModifier
static readonly "ALT": $KeyModifier
static readonly "NONE": $KeyModifier
/**
 * 
 * @deprecated
 */
static readonly "MODIFIER_VALUES": ($KeyModifier)[]


public static "values"(): ($KeyModifier)[]
public static "valueOf"(arg0: string): $KeyModifier
public "matches"(arg0: $InputConstants$Key$Type): boolean
public "isActive"(arg0: $IKeyConflictContext$Type): boolean
/**
 * 
 * @deprecated
 */
public static "getActiveModifier"(): $KeyModifier
public static "valueFromString"(arg0: string): $KeyModifier
public "getCombinedName"(arg0: $InputConstants$Key$Type, arg1: $Supplier$Type<($Component$Type)>): $Component
public static "isKeyCodeModifier"(arg0: $InputConstants$Key$Type): boolean
public static "getModifier"(arg0: $InputConstants$Key$Type): $KeyModifier
public static "getValues"(arg0: boolean): $List<($KeyModifier)>
get "activeModifier"(): $KeyModifier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyModifier$Type = (("shift") | ("alt") | ("control") | ("none")) | ($KeyModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyModifier_ = $KeyModifier$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistryModifiable" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Holder$Reference, $Holder$Reference$Type} from "packages/net/minecraft/core/$Holder$Reference"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ITagManager, $ITagManager$Type} from "packages/net/minecraftforge/registries/tags/$ITagManager"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $IForgeRegistryModifiable<V> extends $IForgeRegistry<(V)> {

 "remove"(arg0: $ResourceLocation$Type): V
 "clear"(): void
 "isLocked"(): boolean
 "getValue"(arg0: $ResourceLocation$Type): V
 "isEmpty"(): boolean
 "getKey"(arg0: V): $ResourceLocation
 "register"(arg0: $ResourceLocation$Type, arg1: V): void
 "register"(arg0: string, arg1: V): void
 "containsKey"(arg0: $ResourceLocation$Type): boolean
 "containsValue"(arg0: V): boolean
 "getEntries"(): $Set<($Map$Entry<($ResourceKey<(V)>), (V)>)>
 "getKeys"(): $Set<($ResourceLocation)>
 "tags"(): $ITagManager<(V)>
 "getDelegate"(arg0: V): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder$Reference<(V)>)>
 "getDelegate"(arg0: $ResourceLocation$Type): $Optional<($Holder$Reference<(V)>)>
 "getResourceKey"(arg0: V): $Optional<($ResourceKey<(V)>)>
 "getCodec"(): $Codec<(V)>
 "getSlaveMap"<T>(arg0: $ResourceLocation$Type, arg1: $Class$Type<(T)>): T
 "getRegistryKey"(): $ResourceKey<($Registry<(V)>)>
 "getRegistryName"(): $ResourceLocation
 "getDelegateOrThrow"(arg0: $ResourceKey$Type<(V)>): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: $ResourceLocation$Type): $Holder$Reference<(V)>
 "getDelegateOrThrow"(arg0: V): $Holder$Reference<(V)>
 "getHolder"(arg0: $ResourceLocation$Type): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: $ResourceKey$Type<(V)>): $Optional<($Holder<(V)>)>
 "getHolder"(arg0: V): $Optional<($Holder<(V)>)>
 "getDefaultKey"(): $ResourceLocation
 "getValues"(): $Collection<(V)>
 "iterator"(): $Iterator<(V)>
 "spliterator"(): $Spliterator<(V)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $IForgeRegistryModifiable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistryModifiable$Type<V> = ($IForgeRegistryModifiable<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistryModifiable_<V> = $IForgeRegistryModifiable$Type<(V)>;
}}
declare module "packages/net/minecraftforge/common/util/$HexDumper" {
import {$ByteBuf, $ByteBuf$Type} from "packages/io/netty/buffer/$ByteBuf"

export class $HexDumper {

constructor()

public static "dump"(arg0: $ByteBuf$Type): string
public static "dump"(arg0: (byte)[], arg1: integer): string
public static "dump"(arg0: (byte)[]): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HexDumper$Type = ($HexDumper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HexDumper_ = $HexDumper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$SpreadPlayersCommand" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityTeleportEvent$SpreadPlayersCommand extends $EntityTeleportEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: double, arg2: double, arg3: double)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$SpreadPlayersCommand$Type = ($EntityTeleportEvent$SpreadPlayersCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent$SpreadPlayersCommand_ = $EntityTeleportEvent$SpreadPlayersCommand$Type;
}}
declare module "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Source" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$ForgeFlowingFluid$Properties, $ForgeFlowingFluid$Properties$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid$Properties"
import {$ForgeFlowingFluid, $ForgeFlowingFluid$Type} from "packages/net/minecraftforge/fluids/$ForgeFlowingFluid"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"

export class $ForgeFlowingFluid$Source extends $ForgeFlowingFluid {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>

constructor(arg0: $ForgeFlowingFluid$Properties$Type)

public "getAmount"(arg0: $FluidState$Type): integer
public "isSource"(arg0: $FluidState$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFlowingFluid$Source$Type = ($ForgeFlowingFluid$Source);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFlowingFluid$Source_ = $ForgeFlowingFluid$Source$Type;
}}
declare module "packages/net/minecraftforge/common/$BiomeManager$BiomeEntry" {
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $BiomeManager$BiomeEntry {

constructor(arg0: $ResourceKey$Type<($Biome$Type)>, arg1: integer)

public "getKey"(): $ResourceKey<($Biome)>
get "key"(): $ResourceKey<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$BiomeEntry$Type = ($BiomeManager$BiomeEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeManager$BiomeEntry_ = $BiomeManager$BiomeEntry$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityMobGriefingEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityMobGriefingEvent extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type)

public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityMobGriefingEvent$Type = ($EntityMobGriefingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityMobGriefingEvent_ = $EntityMobGriefingEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$ItemDecoratorHandler" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ItemDecoratorHandler {


public static "of"(arg0: $ItemStack$Type): $ItemDecoratorHandler
public static "init"(): void
public "render"(arg0: $GuiGraphics$Type, arg1: $Font$Type, arg2: $ItemStack$Type, arg3: integer, arg4: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDecoratorHandler$Type = ($ItemDecoratorHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDecoratorHandler_ = $ItemDecoratorHandler$Type;
}}
declare module "packages/net/minecraftforge/items/$VanillaHopperItemHandler" {
import {$HopperBlockEntity, $HopperBlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$HopperBlockEntity"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$InvWrapper, $InvWrapper$Type} from "packages/net/minecraftforge/items/wrapper/$InvWrapper"

export class $VanillaHopperItemHandler extends $InvWrapper {

constructor(arg0: $HopperBlockEntity$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaHopperItemHandler$Type = ($VanillaHopperItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaHopperItemHandler_ = $VanillaHopperItemHandler$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$PartBuilder" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $CompositeRenderable$PartBuilder<T> {


public "end"(): T
public "child"(arg0: string): $CompositeRenderable$PartBuilder<($CompositeRenderable$PartBuilder<(T)>)>
public "addMesh"(arg0: $ResourceLocation$Type, arg1: $List$Type<($BakedQuad$Type)>): $CompositeRenderable$PartBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeRenderable$PartBuilder$Type<T> = ($CompositeRenderable$PartBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeRenderable$PartBuilder_<T> = $CompositeRenderable$PartBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $CustomizeGuiOverlayEvent extends $Event {

constructor()

public "getPartialTick"(): float
public "isCancelable"(): boolean
public "getWindow"(): $Window
public "getGuiGraphics"(): $GuiGraphics
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "partialTick"(): float
get "cancelable"(): boolean
get "window"(): $Window
get "guiGraphics"(): $GuiGraphics
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomizeGuiOverlayEvent$Type = ($CustomizeGuiOverlayEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomizeGuiOverlayEvent_ = $CustomizeGuiOverlayEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$FMLLoadCompleteEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $FMLLoadCompleteEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FMLLoadCompleteEvent$Type = ($FMLLoadCompleteEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FMLLoadCompleteEvent_ = $FMLLoadCompleteEvent$Type;
}}
declare module "packages/net/minecraftforge/client/gui/widget/$UnicodeGlyphButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ExtendedButton, $ExtendedButton$Type} from "packages/net/minecraftforge/client/gui/widget/$ExtendedButton"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $UnicodeGlyphButton extends $ExtendedButton {
 "glyph": string
 "glyphScale": float
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Component$Type, arg5: string, arg6: float, arg7: $Button$OnPress$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnicodeGlyphButton$Type = ($UnicodeGlyphButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnicodeGlyphButton_ = $UnicodeGlyphButton$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$BakeCallback" {
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"

export interface $IForgeRegistry$BakeCallback<V> {

 "onBake"(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void

(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void
}

export namespace $IForgeRegistry$BakeCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$BakeCallback$Type<V> = ($IForgeRegistry$BakeCallback<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$BakeCallback_<V> = $IForgeRegistry$BakeCallback$Type<(V)>;
}}
declare module "packages/net/minecraftforge/client/event/$RenderGuiOverlayEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NamedGuiOverlay, $NamedGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay"
import {$RenderGuiOverlayEvent, $RenderGuiOverlayEvent$Type} from "packages/net/minecraftforge/client/event/$RenderGuiOverlayEvent"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RenderGuiOverlayEvent$Post extends $RenderGuiOverlayEvent {

constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: $NamedGuiOverlay$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderGuiOverlayEvent$Post$Type = ($RenderGuiOverlayEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderGuiOverlayEvent$Post_ = $RenderGuiOverlayEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$TrueCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $TrueCondition implements $ICondition {
static readonly "INSTANCE": $TrueCondition


public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrueCondition$Type = ($TrueCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TrueCondition_ = $TrueCondition$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ItemModelBuilder$OverrideBuilder" {
import {$ItemModelBuilder, $ItemModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ItemModelBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"

export class $ItemModelBuilder$OverrideBuilder {

constructor(arg0: $ItemModelBuilder$Type)

public "end"(): $ItemModelBuilder
public "predicate"(arg0: $ResourceLocation$Type, arg1: float): $ItemModelBuilder$OverrideBuilder
public "model"(arg0: $ModelFile$Type): $ItemModelBuilder$OverrideBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelBuilder$OverrideBuilder$Type = ($ItemModelBuilder$OverrideBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModelBuilder$OverrideBuilder_ = $ItemModelBuilder$OverrideBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeEntityTypeTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$EntityTypeTagsProvider, $EntityTypeTagsProvider$Type} from "packages/net/minecraft/data/tags/$EntityTypeTagsProvider"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"

export class $ForgeEntityTypeTagsProvider extends $EntityTypeTagsProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "m_6577_"(arg0: $HolderLookup$Provider$Type): void
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEntityTypeTagsProvider$Type = ($ForgeEntityTypeTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEntityTypeTagsProvider_ = $ForgeEntityTypeTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/event/entity/item/$ItemExpireEvent" {
import {$ItemEvent, $ItemEvent$Type} from "packages/net/minecraftforge/event/entity/item/$ItemEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $ItemExpireEvent extends $ItemEvent {

constructor()
constructor(arg0: $ItemEntity$Type, arg1: integer)

public "isCancelable"(): boolean
public "getExtraLife"(): integer
public "setExtraLife"(arg0: integer): void
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "extraLife"(): integer
set "extraLife"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemExpireEvent$Type = ($ItemExpireEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemExpireEvent_ = $ItemExpireEvent$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$Event" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event$Result, $Event$Result$Type} from "packages/net/minecraftforge/eventbus/api/$Event$Result"
import {$EventPriority, $EventPriority$Type} from "packages/net/minecraftforge/eventbus/api/$EventPriority"

export class $Event {

constructor()

public "setResult"(arg0: $Event$Result$Type): void
public "getResult"(): $Event$Result
public "setPhase"(arg0: $EventPriority$Type): void
public "setCanceled"(arg0: boolean): void
public "isCanceled"(): boolean
public "isCancelable"(): boolean
public "getPhase"(): $EventPriority
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
set "result"(value: $Event$Result$Type)
get "result"(): $Event$Result
set "phase"(value: $EventPriority$Type)
set "canceled"(value: boolean)
get "canceled"(): boolean
get "cancelable"(): boolean
get "phase"(): $EventPriority
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Event$Type = ($Event);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Event_ = $Event$Type;
}}
declare module "packages/net/minecraftforge/event/entity/item/$ItemEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $ItemEvent extends $EntityEvent {

constructor()
constructor(arg0: $ItemEntity$Type)

public "getEntity"(): $ItemEntity
public "getListenerList"(): $ListenerList
get "entity"(): $ItemEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEvent$Type = ($ItemEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEvent_ = $ItemEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$BabyEntitySpawnEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AgeableMob, $AgeableMob$Type} from "packages/net/minecraft/world/entity/$AgeableMob"

export class $BabyEntitySpawnEvent extends $Event {

constructor()
constructor(arg0: $Mob$Type, arg1: $Mob$Type, arg2: $AgeableMob$Type)

public "getChild"(): $AgeableMob
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getParentB"(): $Mob
public "getCausedByPlayer"(): $Player
public "getParentA"(): $Mob
public "setChild"(arg0: $AgeableMob$Type): void
get "child"(): $AgeableMob
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "parentB"(): $Mob
get "causedByPlayer"(): $Player
get "parentA"(): $Mob
set "child"(value: $AgeableMob$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BabyEntitySpawnEvent$Type = ($BabyEntitySpawnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BabyEntitySpawnEvent_ = $BabyEntitySpawnEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$FMLConstructModEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $FMLConstructModEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FMLConstructModEvent$Type = ($FMLConstructModEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FMLConstructModEvent_ = $FMLConstructModEvent$Type;
}}
declare module "packages/net/minecraftforge/common/world/$BiomeSpecialEffectsBuilder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Music, $Music$Type} from "packages/net/minecraft/sounds/$Music"
import {$BiomeSpecialEffects$Builder, $BiomeSpecialEffects$Builder$Type} from "packages/net/minecraft/world/level/biome/$BiomeSpecialEffects$Builder"
import {$AmbientParticleSettings, $AmbientParticleSettings$Type} from "packages/net/minecraft/world/level/biome/$AmbientParticleSettings"
import {$AmbientMoodSettings, $AmbientMoodSettings$Type} from "packages/net/minecraft/world/level/biome/$AmbientMoodSettings"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$AmbientAdditionsSettings, $AmbientAdditionsSettings$Type} from "packages/net/minecraft/world/level/biome/$AmbientAdditionsSettings"
import {$OptionalInt, $OptionalInt$Type} from "packages/java/util/$OptionalInt"
import {$BiomeSpecialEffects, $BiomeSpecialEffects$Type} from "packages/net/minecraft/world/level/biome/$BiomeSpecialEffects"
import {$BiomeSpecialEffects$GrassColorModifier, $BiomeSpecialEffects$GrassColorModifier$Type} from "packages/net/minecraft/world/level/biome/$BiomeSpecialEffects$GrassColorModifier"

export class $BiomeSpecialEffectsBuilder extends $BiomeSpecialEffects$Builder {
 "fogColor": $OptionalInt
 "waterColor": $OptionalInt
 "waterFogColor": $OptionalInt
 "skyColor": $OptionalInt
 "foliageColorOverride": $Optional<(integer)>
 "grassColorOverride": $Optional<(integer)>
 "grassColorModifier": $BiomeSpecialEffects$GrassColorModifier
 "ambientParticle": $Optional<($AmbientParticleSettings)>
 "ambientLoopSoundEvent": $Optional<($Holder<($SoundEvent)>)>
 "ambientMoodSettings": $Optional<($AmbientMoodSettings)>
 "ambientAdditionsSettings": $Optional<($AmbientAdditionsSettings)>
 "backgroundMusic": $Optional<($Music)>


public static "copyOf"(arg0: $BiomeSpecialEffects$Type): $BiomeSpecialEffectsBuilder
public static "create"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $BiomeSpecialEffectsBuilder
public "getGrassColorOverride"(): $Optional<(integer)>
public "getAmbientMoodSound"(): $Optional<($AmbientMoodSettings)>
public "getFoliageColorOverride"(): $Optional<(integer)>
public "getAmbientAdditionsSound"(): $Optional<($AmbientAdditionsSettings)>
public "getAmbientLoopSound"(): $Optional<($Holder<($SoundEvent)>)>
public "getGrassColorModifier"(): $BiomeSpecialEffects$GrassColorModifier
public "waterColor"(): integer
public "getSkyColor"(): integer
public "getAmbientParticle"(): $Optional<($AmbientParticleSettings)>
public "getWaterFogColor"(): integer
public "getBackgroundMusic"(): $Optional<($Music)>
public "getFogColor"(): integer
get "grassColorOverride"(): $Optional<(integer)>
get "ambientMoodSound"(): $Optional<($AmbientMoodSettings)>
get "foliageColorOverride"(): $Optional<(integer)>
get "ambientAdditionsSound"(): $Optional<($AmbientAdditionsSettings)>
get "ambientLoopSound"(): $Optional<($Holder<($SoundEvent)>)>
get "grassColorModifier"(): $BiomeSpecialEffects$GrassColorModifier
get "skyColor"(): integer
get "ambientParticle"(): $Optional<($AmbientParticleSettings)>
get "waterFogColor"(): integer
get "backgroundMusic"(): $Optional<($Music)>
get "fogColor"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffectsBuilder$Type = ($BiomeSpecialEffectsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeSpecialEffectsBuilder_ = $BiomeSpecialEffectsBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderBlockScreenEffectEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RenderBlockScreenEffectEvent$OverlayType, $RenderBlockScreenEffectEvent$OverlayType$Type} from "packages/net/minecraftforge/client/event/$RenderBlockScreenEffectEvent$OverlayType"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $RenderBlockScreenEffectEvent extends $Event {

constructor(arg0: $Player$Type, arg1: $PoseStack$Type, arg2: $RenderBlockScreenEffectEvent$OverlayType$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type)
constructor()

public "isCancelable"(): boolean
public "getPoseStack"(): $PoseStack
public "getPlayer"(): $Player
public "getBlockPos"(): $BlockPos
public "getBlockState"(): $BlockState
public "getOverlayType"(): $RenderBlockScreenEffectEvent$OverlayType
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "poseStack"(): $PoseStack
get "player"(): $Player
get "blockPos"(): $BlockPos
get "blockState"(): $BlockState
get "overlayType"(): $RenderBlockScreenEffectEvent$OverlayType
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderBlockScreenEffectEvent$Type = ($RenderBlockScreenEffectEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderBlockScreenEffectEvent_ = $RenderBlockScreenEffectEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/tags/$ITag" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $ITag<V> extends $Iterable<(V)> {

 "isEmpty"(): boolean
 "size"(): integer
 "stream"(): $Stream<(V)>
 "contains"(arg0: V): boolean
 "getKey"(): $TagKey<(V)>
 "isBound"(): boolean
 "getRandomElement"(arg0: $RandomSource$Type): $Optional<(V)>
 "iterator"(): $Iterator<(V)>
 "spliterator"(): $Spliterator<(V)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ITag {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITag$Type<V> = ($ITag<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITag_<V> = $ITag$Type<(V)>;
}}
declare module "packages/net/minecraftforge/client/gui/overlay/$ForgeGui" {
import {$Gui, $Gui$Type} from "packages/net/minecraft/client/gui/$Gui"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$PlayerRideableJumping, $PlayerRideableJumping$Type} from "packages/net/minecraft/world/entity/$PlayerRideableJumping"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ForgeGui extends $Gui {
static "rayTraceDistance": double
 "leftHeight": integer
 "rightHeight": integer
static readonly "GUI_ICONS_LOCATION": $ResourceLocation
readonly "minecraft": $Minecraft
 "vignetteBrightness": float
 "screenWidth": integer
 "screenHeight": integer

constructor(arg0: $Minecraft$Type)

public "render"(arg0: $GuiGraphics$Type, arg1: float): void
public "renderJumpMeter"(arg0: $PlayerRideableJumping$Type, arg1: $GuiGraphics$Type, arg2: integer): void
public "renderHealth"(arg0: integer, arg1: integer, arg2: $GuiGraphics$Type): void
public "renderFood"(arg0: integer, arg1: integer, arg2: $GuiGraphics$Type): void
public "getMinecraft"(): $Minecraft
public "clearCache"(): void
public "shouldDrawSurvivalElements"(): boolean
public "setupOverlayRenderState"(arg0: boolean, arg1: boolean): void
get "minecraft"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeGui$Type = ($ForgeGui);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeGui_ = $ForgeGui$Type;
}}
declare module "packages/net/minecraftforge/registries/$RegistryManager" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$ForgeRegistry$Snapshot, $ForgeRegistry$Snapshot$Type} from "packages/net/minecraftforge/registries/$ForgeRegistry$Snapshot"
import {$ForgeRegistry, $ForgeRegistry$Type} from "packages/net/minecraftforge/registries/$ForgeRegistry"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$HandshakeMessages$S2CRegistry, $HandshakeMessages$S2CRegistry$Type} from "packages/net/minecraftforge/network/$HandshakeMessages$S2CRegistry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegistryManager {
static readonly "ACTIVE": $RegistryManager
static readonly "VANILLA": $RegistryManager
static readonly "FROZEN": $RegistryManager

constructor(arg0: string)

public "getName"<V>(arg0: $IForgeRegistry$Type<(V)>): $ResourceLocation
public "getName"(): string
public "clean"(): void
public static "getVanillaRegistryKeys"(): $Set<($ResourceLocation)>
public static "generateRegistryPackets"(arg0: boolean): $List<($Pair<(string), ($HandshakeMessages$S2CRegistry)>)>
public static "getRegistryNamesForSyncToClient"(): $List<($ResourceLocation)>
public static "postNewRegistryEvent"(): void
public "takeSnapshot"(arg0: boolean): $Map<($ResourceLocation), ($ForgeRegistry$Snapshot)>
public "getRegistry"<V>(arg0: $ResourceLocation$Type): $ForgeRegistry<(V)>
public "getRegistry"<V>(arg0: $ResourceLocation$Type, arg1: $RegistryManager$Type): $ForgeRegistry<(V)>
public "getRegistry"<V>(arg0: $ResourceKey$Type<(any)>): $ForgeRegistry<(V)>
public "updateLegacyName"<V>(arg0: $ResourceLocation$Type): $ResourceLocation
get "name"(): string
get "vanillaRegistryKeys"(): $Set<($ResourceLocation)>
get "registryNamesForSyncToClient"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryManager$Type = ($RegistryManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryManager_ = $RegistryManager$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$Render$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$Render, $ScreenEvent$Render$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$Render"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ScreenEvent$Render$Post extends $ScreenEvent$Render {

constructor(arg0: $Screen$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: float)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Render$Post$Type = ($ScreenEvent$Render$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$Render$Post_ = $ScreenEvent$Render$Post$Type;
}}
declare module "packages/net/minecraftforge/registries/$IForgeRegistry$CreateCallback" {
import {$RegistryManager, $RegistryManager$Type} from "packages/net/minecraftforge/registries/$RegistryManager"
import {$IForgeRegistryInternal, $IForgeRegistryInternal$Type} from "packages/net/minecraftforge/registries/$IForgeRegistryInternal"

export interface $IForgeRegistry$CreateCallback<V> {

 "onCreate"(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void

(arg0: $IForgeRegistryInternal$Type<(V)>, arg1: $RegistryManager$Type): void
}

export namespace $IForgeRegistry$CreateCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeRegistry$CreateCallback$Type<V> = ($IForgeRegistry$CreateCallback<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeRegistry$CreateCallback_<V> = $IForgeRegistry$CreateCallback$Type<(V)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerSetSpawnEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlayerSetSpawnEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ResourceKey$Type<($Level$Type)>, arg2: $BlockPos$Type, arg3: boolean)

public "isCancelable"(): boolean
public "isForced"(): boolean
public "getNewSpawn"(): $BlockPos
public "getSpawnLevel"(): $ResourceKey<($Level)>
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "forced"(): boolean
get "newSpawn"(): $BlockPos
get "spawnLevel"(): $ResourceKey<($Level)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSetSpawnEvent$Type = ($PlayerSetSpawnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerSetSpawnEvent_ = $PlayerSetSpawnEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$IConfigEvent$ConfigConfig" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent, $IConfigEvent$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $IConfigEvent$ConfigConfig extends $Record {

constructor(loading: $Function$Type<($ModConfig$Type), ($IConfigEvent$Type)>, reloading: $Function$Type<($ModConfig$Type), ($IConfigEvent$Type)>, unloading: $Function$Type<($ModConfig$Type), ($IConfigEvent$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "reloading"(): $Function<($ModConfig), ($IConfigEvent)>
public "unloading"(): $Function<($ModConfig), ($IConfigEvent)>
public "loading"(): $Function<($ModConfig), ($IConfigEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConfigEvent$ConfigConfig$Type = ($IConfigEvent$ConfigConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConfigEvent$ConfigConfig_ = $IConfigEvent$ConfigConfig$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEvent extends $Event {

constructor(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type)
constructor()

public "getState"(): $BlockState
public "getLevel"(): $LevelAccessor
public "isCancelable"(): boolean
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "state"(): $BlockState
get "level"(): $LevelAccessor
get "cancelable"(): boolean
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$Type = ($BlockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent_ = $BlockEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderTooltipEvent" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ClientTooltipComponent, $ClientTooltipComponent$Type} from "packages/net/minecraft/client/gui/screens/inventory/tooltip/$ClientTooltipComponent"

export class $RenderTooltipEvent extends $Event {

constructor()

public "getY"(): integer
public "isCancelable"(): boolean
public "getGraphics"(): $GuiGraphics
public "getX"(): integer
public "getItemStack"(): $ItemStack
public "getFont"(): $Font
public "getComponents"(): $List<($ClientTooltipComponent)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "y"(): integer
get "cancelable"(): boolean
get "graphics"(): $GuiGraphics
get "x"(): integer
get "itemStack"(): $ItemStack
get "font"(): $Font
get "components"(): $List<($ClientTooltipComponent)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTooltipEvent$Type = ($RenderTooltipEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTooltipEvent_ = $RenderTooltipEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingDropsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingDropsEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type, arg1: $DamageSource$Type, arg2: $Collection$Type<($ItemEntity$Type)>, arg3: integer, arg4: boolean)
constructor()

public "getSource"(): $DamageSource
public "isRecentlyHit"(): boolean
public "isCancelable"(): boolean
public "getDrops"(): $Collection<($ItemEntity)>
public "getLootingLevel"(): integer
public "getListenerList"(): $ListenerList
get "source"(): $DamageSource
get "recentlyHit"(): boolean
get "cancelable"(): boolean
get "drops"(): $Collection<($ItemEntity)>
get "lootingLevel"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingDropsEvent$Type = ($LivingDropsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingDropsEvent_ = $LivingDropsEvent$Type;
}}
declare module "packages/net/minecraftforge/event/server/$ServerStoppedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLifecycleEvent, $ServerLifecycleEvent$Type} from "packages/net/minecraftforge/event/server/$ServerLifecycleEvent"

export class $ServerStoppedEvent extends $ServerLifecycleEvent {

constructor(arg0: $MinecraftServer$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStoppedEvent$Type = ($ServerStoppedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStoppedEvent_ = $ServerStoppedEvent$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions" {
import {$BlockEntityWithoutLevelRenderer, $BlockEntityWithoutLevelRenderer$Type} from "packages/net/minecraft/client/renderer/$BlockEntityWithoutLevelRenderer"
import {$HumanoidArm, $HumanoidArm$Type} from "packages/net/minecraft/world/entity/$HumanoidArm"
import {$HumanoidModel, $HumanoidModel$Type} from "packages/net/minecraft/client/model/$HumanoidModel"
import {$HumanoidModel$ArmPose, $HumanoidModel$ArmPose$Type} from "packages/net/minecraft/client/model/$HumanoidModel$ArmPose"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$IClientItemExtensions$FontContext, $IClientItemExtensions$FontContext$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions$FontContext"
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Model, $Model$Type} from "packages/net/minecraft/client/model/$Model"

export interface $IClientItemExtensions {

 "renderHelmetOverlay"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: integer, arg3: integer, arg4: float): void
 "getFont"(arg0: $ItemStack$Type, arg1: $IClientItemExtensions$FontContext$Type): $Font
 "getCustomRenderer"(): $BlockEntityWithoutLevelRenderer
 "getArmPose"(arg0: $LivingEntity$Type, arg1: $InteractionHand$Type, arg2: $ItemStack$Type): $HumanoidModel$ArmPose
 "getHumanoidArmorModel"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: $EquipmentSlot$Type, arg3: $HumanoidModel$Type<(any)>): $HumanoidModel<(any)>
 "applyForgeHandTransform"(arg0: $PoseStack$Type, arg1: $LocalPlayer$Type, arg2: $HumanoidArm$Type, arg3: $ItemStack$Type, arg4: float, arg5: float, arg6: float): boolean
 "getGenericArmorModel"(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: $EquipmentSlot$Type, arg3: $HumanoidModel$Type<(any)>): $Model
}

export namespace $IClientItemExtensions {
const DEFAULT: $IClientItemExtensions
function of(arg0: $ItemStack$Type): $IClientItemExtensions
function of(arg0: $Item$Type): $IClientItemExtensions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IClientItemExtensions$Type = ($IClientItemExtensions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IClientItemExtensions_ = $IClientItemExtensions$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingConversionEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingConversionEvent extends $LivingEvent {

constructor(arg0: $LivingEntity$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingConversionEvent$Type = ($LivingConversionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingConversionEvent_ = $LivingConversionEvent$Type;
}}
declare module "packages/net/minecraftforge/common/ticket/$AABBTicket" {
import {$SimpleTicket, $SimpleTicket$Type} from "packages/net/minecraftforge/common/ticket/$SimpleTicket"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $AABBTicket extends $SimpleTicket<($Vec3)> {
readonly "axisAlignedBB": $AABB

constructor(arg0: $AABB$Type)

public "matches"(arg0: $Vec3$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBTicket$Type = ($AABBTicket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AABBTicket_ = $AABBTicket$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $PlayerInteractEvent extends $PlayerEvent {

constructor()

public "getLevel"(): $Level
public "getSide"(): $LogicalSide
public "getFace"(): $Direction
public "getHand"(): $InteractionHand
public "getItemStack"(): $ItemStack
public "getPos"(): $BlockPos
public "getCancellationResult"(): $InteractionResult
public "setCancellationResult"(arg0: $InteractionResult$Type): void
public "getListenerList"(): $ListenerList
get "level"(): $Level
get "side"(): $LogicalSide
get "face"(): $Direction
get "hand"(): $InteractionHand
get "itemStack"(): $ItemStack
get "pos"(): $BlockPos
get "cancellationResult"(): $InteractionResult
set "cancellationResult"(value: $InteractionResult$Type)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$Type = ($PlayerInteractEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent_ = $PlayerInteractEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$MutableHashedLinkedMap$MergeFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $MutableHashedLinkedMap$MergeFunction<Key, Value> {

 "apply"(arg0: Key, arg1: Value, arg2: Value): Value

(arg0: Key, arg1: Value, arg2: Value): Value
}

export namespace $MutableHashedLinkedMap$MergeFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableHashedLinkedMap$MergeFunction$Type<Key, Value> = ($MutableHashedLinkedMap$MergeFunction<(Key), (Value)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableHashedLinkedMap$MergeFunction_<Key, Value> = $MutableHashedLinkedMap$MergeFunction$Type<(Key), (Value)>;
}}
declare module "packages/net/minecraftforge/registries/$IdMappingEvent$ModRemapping" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $IdMappingEvent$ModRemapping {
readonly "registry": $ResourceLocation
readonly "key": $ResourceLocation
readonly "oldId": integer
readonly "newId": integer


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdMappingEvent$ModRemapping$Type = ($IdMappingEvent$ModRemapping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdMappingEvent$ModRemapping_ = $IdMappingEvent$ModRemapping$Type;
}}
declare module "packages/net/minecraftforge/event/level/$NoteBlockEvent$Play" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NoteBlockInstrument, $NoteBlockInstrument$Type} from "packages/net/minecraft/world/level/block/state/properties/$NoteBlockInstrument"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$NoteBlockEvent, $NoteBlockEvent$Type} from "packages/net/minecraftforge/event/level/$NoteBlockEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $NoteBlockEvent$Play extends $NoteBlockEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: integer, arg4: $NoteBlockInstrument$Type)

public "isCancelable"(): boolean
public "setInstrument"(arg0: $NoteBlockInstrument$Type): void
public "getListenerList"(): $ListenerList
public "getInstrument"(): $NoteBlockInstrument
get "cancelable"(): boolean
set "instrument"(value: $NoteBlockInstrument$Type)
get "listenerList"(): $ListenerList
get "instrument"(): $NoteBlockInstrument
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockEvent$Play$Type = ($NoteBlockEvent$Play);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoteBlockEvent$Play_ = $NoteBlockEvent$Play$Type;
}}
declare module "packages/net/minecraftforge/client/model/pipeline/$RemappingVertexPipeline" {
import {$VertexFormatElement, $VertexFormatElement$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormatElement"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack$Pose, $PoseStack$Pose$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack$Pose"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$VertexFormat, $VertexFormat$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $RemappingVertexPipeline implements $VertexConsumer {

constructor(arg0: $VertexConsumer$Type, arg1: $VertexFormat$Type)

public "vertex"(arg0: double, arg1: double, arg2: double): $VertexConsumer
public "uv"(arg0: float, arg1: float): $VertexConsumer
public "color"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $VertexConsumer
public "normal"(arg0: float, arg1: float, arg2: float): $VertexConsumer
public "overlayCoords"(arg0: integer, arg1: integer): $VertexConsumer
public "uv2"(arg0: integer, arg1: integer): $VertexConsumer
public "defaultColor"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "unsetDefaultColor"(): void
public "misc"(arg0: $VertexFormatElement$Type, ...arg1: (integer)[]): $VertexConsumer
public "endVertex"(): void
public "overlayCoords"(arg0: integer): $VertexConsumer
public "uv2"(arg0: integer): $VertexConsumer
public "vertex"(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: integer, arg10: integer, arg11: float, arg12: float, arg13: float): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: integer): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: float, arg7: (integer)[], arg8: integer, arg9: boolean): void
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: (float)[], arg3: float, arg4: float, arg5: float, arg6: (integer)[], arg7: integer, arg8: boolean): void
public "color"(arg0: integer): $VertexConsumer
public "normal"(arg0: $Matrix3f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "vertex"(arg0: $Matrix4f$Type, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "color"(arg0: float, arg1: float, arg2: float, arg3: float): $VertexConsumer
public "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: integer, arg7: integer, arg8: boolean): void
public "applyBakedLighting"(arg0: integer, arg1: $ByteBuffer$Type): integer
public "applyBakedNormals"(arg0: $Vector3f$Type, arg1: $ByteBuffer$Type, arg2: $Matrix3f$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappingVertexPipeline$Type = ($RemappingVertexPipeline);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappingVertexPipeline_ = $RemappingVertexPipeline$Type;
}}
declare module "packages/net/minecraftforge/common/$IForgeShearable" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IForgeShearable {

 "isShearable"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
 "onSheared"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $Level$Type, arg3: $BlockPos$Type, arg4: integer): $List<($ItemStack)>
}

export namespace $IForgeShearable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeShearable$Type = ($IForgeShearable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeShearable_ = $IForgeShearable$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$ITextureRenderTypeLookup" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export interface $ITextureRenderTypeLookup {

 "get"(arg0: $ResourceLocation$Type): $RenderType

(arg0: $ResourceLocation$Type): $RenderType
}

export namespace $ITextureRenderTypeLookup {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITextureRenderTypeLookup$Type = ($ITextureRenderTypeLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITextureRenderTypeLookup_ = $ITextureRenderTypeLookup$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLevelStageEvent$Stage" {
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $RenderLevelStageEvent$Stage {
static readonly "AFTER_SKY": $RenderLevelStageEvent$Stage
static readonly "AFTER_SOLID_BLOCKS": $RenderLevelStageEvent$Stage
static readonly "AFTER_CUTOUT_MIPPED_BLOCKS_BLOCKS": $RenderLevelStageEvent$Stage
static readonly "AFTER_CUTOUT_BLOCKS": $RenderLevelStageEvent$Stage
static readonly "AFTER_ENTITIES": $RenderLevelStageEvent$Stage
static readonly "AFTER_BLOCK_ENTITIES": $RenderLevelStageEvent$Stage
static readonly "AFTER_TRANSLUCENT_BLOCKS": $RenderLevelStageEvent$Stage
static readonly "AFTER_TRIPWIRE_BLOCKS": $RenderLevelStageEvent$Stage
static readonly "AFTER_PARTICLES": $RenderLevelStageEvent$Stage
static readonly "AFTER_WEATHER": $RenderLevelStageEvent$Stage
static readonly "AFTER_LEVEL": $RenderLevelStageEvent$Stage


public "toString"(): string
public static "fromRenderType"(arg0: $RenderType$Type): $RenderLevelStageEvent$Stage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLevelStageEvent$Stage$Type = ($RenderLevelStageEvent$Stage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLevelStageEvent$Stage_ = $RenderLevelStageEvent$Stage$Type;
}}
declare module "packages/net/minecraftforge/client/$IItemDecorator" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export interface $IItemDecorator {

 "render"(arg0: $GuiGraphics$Type, arg1: $Font$Type, arg2: $ItemStack$Type, arg3: integer, arg4: integer): boolean

(arg0: $GuiGraphics$Type, arg1: $Font$Type, arg2: $ItemStack$Type, arg3: integer, arg4: integer): boolean
}

export namespace $IItemDecorator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemDecorator$Type = ($IItemDecorator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemDecorator_ = $IItemDecorator$Type;
}}
declare module "packages/net/minecraftforge/fml/core/$ModStateProvider" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModLoadingState, $IModLoadingState$Type} from "packages/net/minecraftforge/fml/$IModLoadingState"
import {$IModStateProvider, $IModStateProvider$Type} from "packages/net/minecraftforge/fml/$IModStateProvider"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModStateProvider implements $IModStateProvider {

constructor()

public "getAllStates"(): $List<($IModLoadingState)>
get "allStates"(): $List<($IModLoadingState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModStateProvider$Type = ($ModStateProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModStateProvider_ = $ModStateProvider$Type;
}}
declare module "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Loading" {
import {$ModConfigEvent, $ModConfigEvent$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModConfig, $ModConfig$Type} from "packages/net/minecraftforge/fml/config/$ModConfig"
import {$IConfigEvent, $IConfigEvent$Type} from "packages/net/minecraftforge/fml/config/$IConfigEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModConfigEvent$Loading extends $ModConfigEvent {

constructor(arg0: $ModConfig$Type)
constructor()

public "getListenerList"(): $ListenerList
public static "reloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "unloading"(arg0: $ModConfig$Type): $IConfigEvent
public static "loading"(arg0: $ModConfig$Type): $IConfigEvent
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModConfigEvent$Loading$Type = ($ModConfigEvent$Loading);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModConfigEvent$Loading_ = $ModConfigEvent$Loading$Type;
}}
declare module "packages/net/minecraftforge/fluids/$IFluidBlock" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IFluidBlock {

 "drain"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $IFluidHandler$FluidAction$Type): $FluidStack
 "place"(arg0: $Level$Type, arg1: $BlockPos$Type, arg2: $FluidStack$Type, arg3: $IFluidHandler$FluidAction$Type): integer
 "canDrain"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
 "getFluid"(): $Fluid
 "getFilledPercentage"(arg0: $Level$Type, arg1: $BlockPos$Type): float
}

export namespace $IFluidBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidBlock$Type = ($IFluidBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidBlock_ = $IFluidBlock$Type;
}}
declare module "packages/net/minecraftforge/client/event/$EntityRenderersEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

export class $EntityRenderersEvent extends $Event implements $IModBusEvent {


public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRenderersEvent$Type = ($EntityRenderersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRenderersEvent_ = $EntityRenderersEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$BakedModelRenderable" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$IRenderable, $IRenderable$Type} from "packages/net/minecraftforge/client/model/renderable/$IRenderable"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BakedModelRenderable$Context, $BakedModelRenderable$Context$Type} from "packages/net/minecraftforge/client/model/renderable/$BakedModelRenderable$Context"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Unit, $Unit$Type} from "packages/net/minecraft/util/$Unit"
import {$ITextureRenderTypeLookup, $ITextureRenderTypeLookup$Type} from "packages/net/minecraftforge/client/model/renderable/$ITextureRenderTypeLookup"

export class $BakedModelRenderable implements $IRenderable<($BakedModelRenderable$Context)> {


public static "of"(arg0: $ResourceLocation$Type): $BakedModelRenderable
public static "of"(arg0: $BakedModel$Type): $BakedModelRenderable
public "withContext"(arg0: $ModelData$Type): $IRenderable<($Unit)>
public "render"(arg0: $PoseStack$Type, arg1: $MultiBufferSource$Type, arg2: $ITextureRenderTypeLookup$Type, arg3: integer, arg4: integer, arg5: float, arg6: $BakedModelRenderable$Context$Type): void
public "withModelDataContext"(): $IRenderable<($ModelData)>
public "withContext"(arg0: $BakedModelRenderable$Context$Type): $IRenderable<($Unit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BakedModelRenderable$Type = ($BakedModelRenderable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BakedModelRenderable_ = $BakedModelRenderable$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$ElementShader$RenderType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ElementShader$RenderType extends $Enum<($ElementShader$RenderType)> {
static readonly "FONT": $ElementShader$RenderType
static readonly "TEXTURE": $ElementShader$RenderType
static readonly "BAR": $ElementShader$RenderType


public static "values"(): ($ElementShader$RenderType)[]
public static "valueOf"(arg0: string): $ElementShader$RenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElementShader$RenderType$Type = (("bar") | ("texture") | ("font")) | ($ElementShader$RenderType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElementShader$RenderType_ = $ElementShader$RenderType$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeAdvancementProvider$AdvancementGenerator" {
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AdvancementSubProvider, $AdvancementSubProvider$Type} from "packages/net/minecraft/data/advancements/$AdvancementSubProvider"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export interface $ForgeAdvancementProvider$AdvancementGenerator {

 "generate"(arg0: $HolderLookup$Provider$Type, arg1: $Consumer$Type<($Advancement$Type)>, arg2: $ExistingFileHelper$Type): void
 "toSubProvider"(arg0: $ExistingFileHelper$Type): $AdvancementSubProvider

(arg0: $HolderLookup$Provider$Type, arg1: $Consumer$Type<($Advancement$Type)>, arg2: $ExistingFileHelper$Type): void
}

export namespace $ForgeAdvancementProvider$AdvancementGenerator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeAdvancementProvider$AdvancementGenerator$Type = ($ForgeAdvancementProvider$AdvancementGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeAdvancementProvider$AdvancementGenerator_ = $ForgeAdvancementProvider$AdvancementGenerator$Type;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$EntityPlaceEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BlockSnapshot, $BlockSnapshot$Type} from "packages/net/minecraftforge/common/util/$BlockSnapshot"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $BlockEvent$EntityPlaceEvent extends $BlockEvent {

constructor(arg0: $BlockSnapshot$Type, arg1: $BlockState$Type, arg2: $Entity$Type)
constructor()

public "isCancelable"(): boolean
public "getEntity"(): $Entity
public "getBlockSnapshot"(): $BlockSnapshot
public "getPlacedAgainst"(): $BlockState
public "getPlacedBlock"(): $BlockState
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "entity"(): $Entity
get "blockSnapshot"(): $BlockSnapshot
get "placedAgainst"(): $BlockState
get "placedBlock"(): $BlockState
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$EntityPlaceEvent$Type = ($BlockEvent$EntityPlaceEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$EntityPlaceEvent_ = $BlockEvent$EntityPlaceEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$GeometryLoaderManager" {
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GeometryLoaderManager {


public static "get"(arg0: $ResourceLocation$Type): $IGeometryLoader<(any)>
public static "init"(): void
public static "getLoaderList"(): string
get "loaderList"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeometryLoaderManager$Type = ($GeometryLoaderManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeometryLoaderManager_ = $GeometryLoaderManager$Type;
}}
declare module "packages/net/minecraftforge/common/util/$NonNullSupplier" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $NonNullSupplier<T> {

 "get"(): T

(): T
}

export namespace $NonNullSupplier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonNullSupplier$Type<T> = ($NonNullSupplier<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonNullSupplier_<T> = $NonNullSupplier$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/model/data/$MultipartModelData$Builder" {
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$MultipartModelData, $MultipartModelData$Type} from "packages/net/minecraftforge/client/model/data/$MultipartModelData"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"

export class $MultipartModelData$Builder {

constructor()

public "build"(): $MultipartModelData
public "with"(arg0: $BakedModel$Type, arg1: $ModelData$Type): $MultipartModelData$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartModelData$Builder$Type = ($MultipartModelData$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartModelData$Builder_ = $MultipartModelData$Builder$Type;
}}
declare module "packages/net/minecraftforge/network/simple/$IndexedMessageCodec$MessageHandler" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IndexedMessageCodec, $IndexedMessageCodec$Type} from "packages/net/minecraftforge/network/simple/$IndexedMessageCodec"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export class $IndexedMessageCodec$MessageHandler<MSG> {

constructor(arg0: $IndexedMessageCodec$Type, arg1: integer, arg2: $Class$Type<(any)>, arg3: $BiConsumer$Type<(any), (any)>, arg4: $Function$Type<(any), (any)>, arg5: $BiConsumer$Type<(any), (any)>, arg6: $Optional$Type<(any)>)

public "getLoginIndexGetter"(): $Optional<($Function<(MSG), (integer)>)>
get "loginIndexGetter"(): $Optional<($Function<(MSG), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexedMessageCodec$MessageHandler$Type<MSG> = ($IndexedMessageCodec$MessageHandler<(MSG)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexedMessageCodec$MessageHandler_<MSG> = $IndexedMessageCodec$MessageHandler$Type<(MSG)>;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeFluidState" {
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Boat, $Boat$Type} from "packages/net/minecraft/world/entity/vehicle/$Boat"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IForgeFluidState {

 "move"(arg0: $LivingEntity$Type, arg1: $Vec3$Type, arg2: double): boolean
 "getBlockPathType"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Mob$Type, arg3: boolean): $BlockPathTypes
 "getExplosionResistance"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Explosion$Type): float
 "getAdjacentBlockPathType"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $Mob$Type, arg3: $BlockPathTypes$Type): $BlockPathTypes
 "shouldUpdateWhileBoating"(arg0: $Boat$Type, arg1: $Entity$Type): boolean
 "getFluidType"(): $FluidType
 "supportsBoating"(arg0: $Boat$Type): boolean
 "canConvertToSource"(arg0: $Level$Type, arg1: $BlockPos$Type): boolean
 "canExtinguish"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): boolean
 "canHydrate"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BlockPos$Type): boolean
}

export namespace $IForgeFluidState {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeFluidState$Type = ($IForgeFluidState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeFluidState_ = $IForgeFluidState$Type;
}}
declare module "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent$BossEventProgress" {
import {$CustomizeGuiOverlayEvent, $CustomizeGuiOverlayEvent$Type} from "packages/net/minecraftforge/client/event/$CustomizeGuiOverlayEvent"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Window, $Window$Type} from "packages/com/mojang/blaze3d/platform/$Window"
import {$LerpingBossEvent, $LerpingBossEvent$Type} from "packages/net/minecraft/client/gui/components/$LerpingBossEvent"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $CustomizeGuiOverlayEvent$BossEventProgress extends $CustomizeGuiOverlayEvent {

constructor()
constructor(arg0: $Window$Type, arg1: $GuiGraphics$Type, arg2: float, arg3: $LerpingBossEvent$Type, arg4: integer, arg5: integer, arg6: integer)

public "getY"(): integer
public "isCancelable"(): boolean
public "getX"(): integer
public "getIncrement"(): integer
public "getBossEvent"(): $LerpingBossEvent
public "setIncrement"(arg0: integer): void
public "getListenerList"(): $ListenerList
get "y"(): integer
get "cancelable"(): boolean
get "x"(): integer
get "increment"(): integer
get "bossEvent"(): $LerpingBossEvent
set "increment"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomizeGuiOverlayEvent$BossEventProgress$Type = ($CustomizeGuiOverlayEvent$BossEventProgress);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomizeGuiOverlayEvent$BossEventProgress_ = $CustomizeGuiOverlayEvent$BossEventProgress$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$ConditionalRecipe" {
import {$ConditionalRecipe$Builder, $ConditionalRecipe$Builder$Type} from "packages/net/minecraftforge/common/crafting/$ConditionalRecipe$Builder"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ConditionalRecipe {
static "SERIALZIER": $RecipeSerializer<($Recipe<(any)>)>

constructor()

public static "builder"(): $ConditionalRecipe$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalRecipe$Type = ($ConditionalRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalRecipe_ = $ConditionalRecipe$Type;
}}
declare module "packages/net/minecraftforge/common/util/$Size2i" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Size2i {
readonly "width": integer
readonly "height": integer

constructor(arg0: integer, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Size2i$Type = ($Size2i);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Size2i_ = $Size2i$Type;
}}
declare module "packages/net/minecraftforge/event/level/$LevelEvent" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$EventHandlerImplCommon$LevelEventAttachment, $EventHandlerImplCommon$LevelEventAttachment$Type} from "packages/dev/architectury/event/forge/$EventHandlerImplCommon$LevelEventAttachment"

export class $LevelEvent extends $Event implements $EventHandlerImplCommon$LevelEventAttachment {

constructor()
constructor(arg0: $LevelAccessor$Type)

public "getLevel"(): $LevelAccessor
public "isCancelable"(): boolean
public "architectury$getAttachedLevel"(): $LevelAccessor
public "architectury$attachLevel"(level: $LevelAccessor$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $LevelAccessor
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEvent$Type = ($LevelEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEvent_ = $LevelEvent$Type;
}}
declare module "packages/net/minecraftforge/event/village/$WandererTradesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"

export class $WandererTradesEvent extends $Event {

constructor()
constructor(arg0: $List$Type<($VillagerTrades$ItemListing$Type)>, arg1: $List$Type<($VillagerTrades$ItemListing$Type)>)

public "isCancelable"(): boolean
public "getGenericTrades"(): $List<($VillagerTrades$ItemListing)>
public "getRareTrades"(): $List<($VillagerTrades$ItemListing)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "genericTrades"(): $List<($VillagerTrades$ItemListing)>
get "rareTrades"(): $List<($VillagerTrades$ItemListing)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WandererTradesEvent$Type = ($WandererTradesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WandererTradesEvent_ = $WandererTradesEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeHandler$HandshakeConsumer" {
import {$HandshakeHandler, $HandshakeHandler$Type} from "packages/net/minecraftforge/network/$HandshakeHandler"
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $HandshakeHandler$HandshakeConsumer<MSG extends $IntSupplier> {

 "accept"(arg0: $HandshakeHandler$Type, arg1: MSG, arg2: $Supplier$Type<($NetworkEvent$Context$Type)>): void

(arg0: $HandshakeHandler$Type, arg1: MSG, arg2: $Supplier$Type<($NetworkEvent$Context$Type)>): void
}

export namespace $HandshakeHandler$HandshakeConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeHandler$HandshakeConsumer$Type<MSG> = ($HandshakeHandler$HandshakeConsumer<(MSG)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeHandler$HandshakeConsumer_<MSG> = $HandshakeHandler$HandshakeConsumer$Type<(MSG)>;
}}
declare module "packages/net/minecraftforge/client/event/$ClientChatEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"

export class $ClientChatEvent extends $Event {

constructor(arg0: string)
constructor()

public "getMessage"(): string
public "isCancelable"(): boolean
public "setMessage"(arg0: string): void
public "getOriginalMessage"(): string
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "message"(): string
get "cancelable"(): boolean
set "message"(value: string)
get "originalMessage"(): string
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientChatEvent$Type = ($ClientChatEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientChatEvent_ = $ClientChatEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$TextureStitchEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$TextureAtlas, $TextureAtlas$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlas"
import {$TextureStitchEvent, $TextureStitchEvent$Type} from "packages/net/minecraftforge/client/event/$TextureStitchEvent"

export class $TextureStitchEvent$Post extends $TextureStitchEvent {

constructor(arg0: $TextureAtlas$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureStitchEvent$Post$Type = ($TextureStitchEvent$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureStitchEvent$Post_ = $TextureStitchEvent$Post$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeTransformation" {
import {$Vector4f, $Vector4f$Type} from "packages/org/joml/$Vector4f"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IForgeTransformation {

 "isIdentity"(): boolean
 "transformPosition"(arg0: $Vector4f$Type): void
 "applyOrigin"(arg0: $Vector3f$Type): $Transformation
 "rotateTransform"(arg0: $Direction$Type): $Direction
 "transformNormal"(arg0: $Vector3f$Type): void
 "blockCenterToCorner"(): $Transformation
 "blockCornerToCenter"(): $Transformation
}

export namespace $IForgeTransformation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeTransformation$Type = ($IForgeTransformation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeTransformation_ = $IForgeTransformation$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$PushReaction, $PushReaction$Type} from "packages/net/minecraft/world/level/material/$PushReaction"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$SpawnPlacements$Type, $SpawnPlacements$Type$Type} from "packages/net/minecraft/world/entity/$SpawnPlacements$Type"
import {$SignalGetter, $SignalGetter$Type} from "packages/net/minecraft/world/level/$SignalGetter"
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IPlantable, $IPlantable$Type} from "packages/net/minecraftforge/common/$IPlantable"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $IForgeBlock {

 "rotate"(arg0: $BlockState$Type, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type, arg3: $Rotation$Type): $BlockState
 "isSlimeBlock"(arg0: $BlockState$Type): boolean
 "addLandingEffects"(arg0: $BlockState$Type, arg1: $ServerLevel$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $LivingEntity$Type, arg5: integer): boolean
 "isPortalFrame"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "getExpDrop"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $RandomSource$Type, arg3: $BlockPos$Type, arg4: integer, arg5: integer): integer
 "getBlockPathType"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type): $BlockPathTypes
 "hidesNeighborFace"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BlockState$Type, arg4: $Direction$Type): boolean
 "canSustainPlant"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type, arg4: $IPlantable$Type): boolean
 "isBurning"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "isLadder"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $LivingEntity$Type): boolean
 "canHarvestBlock"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Player$Type): boolean
 "isFertile"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "isConduitFrame"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): boolean
 "onTreeGrow"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BiConsumer$Type<($BlockPos$Type), ($BlockState$Type)>, arg3: $RandomSource$Type, arg4: $BlockPos$Type, arg5: $TreeConfiguration$Type): boolean
 "isValidSpawn"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $SpawnPlacements$Type$Type, arg4: $EntityType$Type<(any)>): boolean
 "onNeighborChange"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): void
 "getWeakChanges"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
 "getRespawnPosition"(arg0: $BlockState$Type, arg1: $EntityType$Type<(any)>, arg2: $LevelReader$Type, arg3: $BlockPos$Type, arg4: float, arg5: $LivingEntity$Type): $Optional<($Vec3)>
 "getExplosionResistance"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Explosion$Type): float
 "getEnchantPowerBonus"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): float
 "canDropFromExplosion"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Explosion$Type): boolean
 "shouldDisplayFluidOverlay"(arg0: $BlockState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type): boolean
 "getToolModifiedState"(arg0: $BlockState$Type, arg1: $UseOnContext$Type, arg2: $ToolAction$Type, arg3: boolean): $BlockState
 "getBeaconColorMultiplier"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockPos$Type): (float)[]
 "getPistonPushReaction"(arg0: $BlockState$Type): $PushReaction
 "getAdjacentBlockPathType"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Mob$Type, arg4: $BlockPathTypes$Type): $BlockPathTypes
 "makesOpenTrapdoorAboveClimbable"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type): boolean
 "getStateAtViewpoint"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Vec3$Type): $BlockState
 "onDestroyedByPlayer"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Player$Type, arg4: boolean, arg5: $FluidState$Type): boolean
 "supportsExternalFaceHiding"(arg0: $BlockState$Type): boolean
 "getSoundType"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): $SoundType
 "getFriction"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): float
 "isScaffolding"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $LivingEntity$Type): boolean
 "isBed"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
 "setBedOccupied"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $LivingEntity$Type, arg4: boolean): void
 "getBedDirection"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): $Direction
 "getCloneItemStack"(arg0: $BlockState$Type, arg1: $HitResult$Type, arg2: $BlockGetter$Type, arg3: $BlockPos$Type, arg4: $Player$Type): $ItemStack
 "addRunningEffects"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
 "getLightEmission"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): integer
 "onBlockStateChange"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $BlockState$Type): void
 "shouldCheckWeakPower"(arg0: $BlockState$Type, arg1: $SignalGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): boolean
 "isFlammable"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): boolean
 "isFireSource"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): boolean
 "canEntityDestroy"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean
 "onBlockExploded"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Explosion$Type): void
 "canStickTo"(arg0: $BlockState$Type, arg1: $BlockState$Type): boolean
 "getFireSpreadSpeed"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): integer
 "getFlammability"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): integer
 "onCaughtFire"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $Direction$Type, arg4: $LivingEntity$Type): void
 "isStickyBlock"(arg0: $BlockState$Type): boolean
 "canConnectRedstone"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type): boolean
 "canBeHydrated"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $FluidState$Type, arg4: $BlockPos$Type): boolean
 "getMapColor"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $MapColor$Type): $MapColor
 "getAppearance"(arg0: $BlockState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type, arg3: $Direction$Type, arg4: $BlockState$Type, arg5: $BlockPos$Type): $BlockState
 "collisionExtendsVertically"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $Entity$Type): boolean

(arg0: $BlockState$Type, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type, arg3: $Rotation$Type): $BlockState
}

export namespace $IForgeBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBlock$Type = ($IForgeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBlock_ = $IForgeBlock$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ModelEvent$RegisterAdditional" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ModelEvent, $ModelEvent$Type} from "packages/net/minecraftforge/client/event/$ModelEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ModelEvent$RegisterAdditional extends $ModelEvent implements $IModBusEvent {

constructor()
constructor(arg0: $Set$Type<($ResourceLocation$Type)>)

public "register"(arg0: $ResourceLocation$Type): void
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelEvent$RegisterAdditional$Type = ($ModelEvent$RegisterAdditional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelEvent$RegisterAdditional_ = $ModelEvent$RegisterAdditional$Type;
}}
declare module "packages/net/minecraftforge/fml/$IExtensionPoint$DisplayTest" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IExtensionPoint, $IExtensionPoint$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $IExtensionPoint$DisplayTest extends $Record implements $IExtensionPoint<($IExtensionPoint$DisplayTest)> {
static readonly "IGNORESERVERONLY": string
static readonly "IGNORE_SERVER_VERSION": $Supplier<($IExtensionPoint$DisplayTest)>
static readonly "IGNORE_ALL_VERSION": $Supplier<($IExtensionPoint$DisplayTest)>

constructor(arg0: string, arg1: $BiPredicate$Type<(string), (boolean)>)
constructor(suppliedVersion: $Supplier$Type<(string)>, remoteVersionTest: $BiPredicate$Type<(string), (boolean)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "remoteVersionTest"(): $BiPredicate<(string), (boolean)>
public "suppliedVersion"(): $Supplier<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtensionPoint$DisplayTest$Type = ($IExtensionPoint$DisplayTest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtensionPoint$DisplayTest_ = $IExtensionPoint$DisplayTest$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ParticleDescriptionProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"

export class $ParticleDescriptionProvider implements $DataProvider {


public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleDescriptionProvider$Type = ($ParticleDescriptionProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleDescriptionProvider_ = $ParticleDescriptionProvider$Type;
}}
declare module "packages/net/minecraftforge/client/model/$IModelBuilder" {
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$RenderTypeGroup, $RenderTypeGroup$Type} from "packages/net/minecraftforge/client/$RenderTypeGroup"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export interface $IModelBuilder<T extends $IModelBuilder<(T)>> {

 "build"(): $BakedModel
 "addCulledFace"(arg0: $Direction$Type, arg1: $BakedQuad$Type): T
 "addUnculledFace"(arg0: $BakedQuad$Type): T
}

export namespace $IModelBuilder {
function of(arg0: boolean, arg1: boolean, arg2: boolean, arg3: $ItemTransforms$Type, arg4: $ItemOverrides$Type, arg5: $TextureAtlasSprite$Type, arg6: $RenderTypeGroup$Type): $IModelBuilder<(any)>
function collecting(arg0: $List$Type<($BakedQuad$Type)>): $IModelBuilder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModelBuilder$Type<T> = ($IModelBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModelBuilder_<T> = $IModelBuilder$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/loot/$LootModifierManager" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$SimpleJsonResourceReloadListener, $SimpleJsonResourceReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$SimpleJsonResourceReloadListener"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$IGlobalLootModifier, $IGlobalLootModifier$Type} from "packages/net/minecraftforge/common/loot/$IGlobalLootModifier"

export class $LootModifierManager extends $SimpleJsonResourceReloadListener {
static readonly "LOGGER": $Logger
static readonly "GSON_INSTANCE": $Gson

constructor()

public "getAllLootMods"(): $Collection<($IGlobalLootModifier)>
get "allLootMods"(): $Collection<($IGlobalLootModifier)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootModifierManager$Type = ($LootModifierManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootModifierManager_ = $LootModifierManager$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/wrappers/$BlockWrapper" {
import {$VoidFluidHandler, $VoidFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/templates/$VoidFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockWrapper extends $VoidFluidHandler {
static readonly "INSTANCE": $VoidFluidHandler

constructor(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$Type = ($BlockWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockWrapper_ = $BlockWrapper$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$HolderSetType" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $HolderSetType {

 "makeCodec"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>

(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>
}

export namespace $HolderSetType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolderSetType$Type = ($HolderSetType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolderSetType_ = $HolderSetType$Type;
}}
declare module "packages/net/minecraftforge/common/data/$ForgeBlockTagsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$Type} from "packages/net/minecraft/core/$HolderLookup$Provider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$BlockTagsProvider, $BlockTagsProvider$Type} from "packages/net/minecraftforge/common/data/$BlockTagsProvider"

export class $ForgeBlockTagsProvider extends $BlockTagsProvider {

constructor(arg0: $PackOutput$Type, arg1: $CompletableFuture$Type<($HolderLookup$Provider$Type)>, arg2: $ExistingFileHelper$Type)

public "m_6577_"(arg0: $HolderLookup$Provider$Type): void
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBlockTagsProvider$Type = ($ForgeBlockTagsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBlockTagsProvider_ = $ForgeBlockTagsProvider$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeFont" {
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"

export interface $IForgeFont {

 "self"(): $Font
 "ellipsize"(arg0: $FormattedText$Type, arg1: integer): $FormattedText

(): $Font
}

export namespace $IForgeFont {
const ELLIPSIS: $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeFont$Type = ($IForgeFont);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeFont_ = $IForgeFont$Type;
}}
declare module "packages/net/minecraftforge/common/util/$TextTable$Column" {
import {$TextTable$Alignment, $TextTable$Alignment$Type} from "packages/net/minecraftforge/common/util/$TextTable$Alignment"

export class $TextTable$Column {

constructor(arg0: string)
constructor(arg0: string, arg1: $TextTable$Alignment$Type)

public "format"(arg0: string, arg1: string): string
public "getSeparator"(arg0: character): string
public "fit"(arg0: string): void
public "getWidth"(): integer
public "formatHeader"(arg0: string): string
public "resetWidth"(): void
get "width"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextTable$Column$Type = ($TextTable$Column);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextTable$Column_ = $TextTable$Column$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$IForgeItemMixin, $IForgeItemMixin$Type} from "packages/org/violetmoon/quark/mixin/mixins/$IForgeItemMixin"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IForgeItem extends $IForgeItemMixin {

 "getHighlightTip"(arg0: $ItemStack$Type, arg1: $Component$Type): $Component
 "getEnchantmentLevel"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): integer
 "canDisableShield"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $LivingEntity$Type, arg3: $LivingEntity$Type): boolean
 "canPerformAction"(arg0: $ItemStack$Type, arg1: $ToolAction$Type): boolean
 "getSweepHitBox"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $Entity$Type): $AABB
 "canElytraFly"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
 "isCorrectToolForDrops"(arg0: $ItemStack$Type, arg1: $BlockState$Type): boolean
 "shouldCauseReequipAnimation"(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: boolean): boolean
 "makesPiglinsNeutral"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
 "canWalkOnPowderedSnow"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
 "hasCraftingRemainingItem"(arg0: $ItemStack$Type): boolean
 "getCraftingRemainingItem"(arg0: $ItemStack$Type): $ItemStack
 "canGrindstoneRepair"(arg0: $ItemStack$Type): boolean
 "getEnchantmentValue"(arg0: $ItemStack$Type): integer
 "getAttributeModifiers"(arg0: $EquipmentSlot$Type, arg1: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "getDefaultTooltipHideFlags"(arg0: $ItemStack$Type): integer
 "canApplyAtEnchantingTable"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
 "isNotReplaceableByPickAction"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: integer): boolean
 "shouldCauseBlockBreakReset"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "onEntitySwing"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): boolean
 "elytraFlightTick"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: integer): boolean
 "getFoodProperties"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type): $FoodProperties
 "canContinueUsing"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "onStopUsing"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: integer): void
 "getEquipmentSlot"(arg0: $ItemStack$Type): $EquipmentSlot
 "createEntity"(arg0: $Level$Type, arg1: $Entity$Type, arg2: $ItemStack$Type): $Entity
 "isRepairable"(arg0: $ItemStack$Type): boolean
 "isDamageable"(arg0: $ItemStack$Type): boolean
 "getMaxDamage"(arg0: $ItemStack$Type): integer
 "onDroppedByPlayer"(arg0: $ItemStack$Type, arg1: $Player$Type): boolean
 "onItemUseFirst"(arg0: $ItemStack$Type, arg1: $UseOnContext$Type): $InteractionResult
 "isPiglinCurrency"(arg0: $ItemStack$Type): boolean
 "isBookEnchantable"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "hasCustomEntity"(arg0: $ItemStack$Type): boolean
 "getArmorTexture"(arg0: $ItemStack$Type, arg1: $Entity$Type, arg2: $EquipmentSlot$Type, arg3: string): string
 "readShareTag"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): void
 "getXpRepairRatio"(arg0: $ItemStack$Type): float
 "isDamaged"(arg0: $ItemStack$Type): boolean
 "setDamage"(arg0: $ItemStack$Type, arg1: integer): void
 "getShareTag"(arg0: $ItemStack$Type): $CompoundTag
 "onLeftClickEntity"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $Entity$Type): boolean
 "doesSneakBypassUse"(arg0: $ItemStack$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type, arg3: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
 "onArmorTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Player$Type): void
 "onInventoryTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Player$Type, arg3: integer, arg4: integer): void
 "canEquip"(arg0: $ItemStack$Type, arg1: $EquipmentSlot$Type, arg2: $Entity$Type): boolean
 "onBlockStartBreak"(arg0: $ItemStack$Type, arg1: $BlockPos$Type, arg2: $Player$Type): boolean
 "damageItem"<T extends $LivingEntity>(arg0: $ItemStack$Type, arg1: integer, arg2: T, arg3: $Consumer$Type<(T)>): integer
 "getBurnTime"(arg0: $ItemStack$Type, arg1: $RecipeType$Type<(any)>): integer
 "onHorseArmorTick"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $Mob$Type): void
 "isEnderMask"(arg0: $ItemStack$Type, arg1: $Player$Type, arg2: $EnderMan$Type): boolean
 "getCreatorModId"(arg0: $ItemStack$Type): string
 "getDamage"(arg0: $ItemStack$Type): integer
 "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
 "getAllEnchantments"(arg0: $ItemStack$Type): $Map<($Enchantment), (integer)>
 "getEntityLifespan"(arg0: $ItemStack$Type, arg1: $Level$Type): integer
 "onEntityItemUpdate"(arg0: $ItemStack$Type, arg1: $ItemEntity$Type): boolean
 "onDestroyed"(arg0: $ItemEntity$Type, arg1: $DamageSource$Type): void
 "getMaxStackSize"(arg0: $ItemStack$Type): integer

(arg0: $ItemStack$Type, arg1: $Component$Type): $Component
}

export namespace $IForgeItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeItem$Type = ($IForgeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeItem_ = $IForgeItem$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ViewportEvent$RenderFog" {
import {$FogShape, $FogShape$Type} from "packages/com/mojang/blaze3d/shaders/$FogShape"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$FogType, $FogType$Type} from "packages/net/minecraft/world/level/material/$FogType"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$ViewportEvent, $ViewportEvent$Type} from "packages/net/minecraftforge/client/event/$ViewportEvent"
import {$FogRenderer$FogMode, $FogRenderer$FogMode$Type} from "packages/net/minecraft/client/renderer/$FogRenderer$FogMode"

export class $ViewportEvent$RenderFog extends $ViewportEvent {

constructor()
constructor(arg0: $FogRenderer$FogMode$Type, arg1: $FogType$Type, arg2: $Camera$Type, arg3: float, arg4: float, arg5: float, arg6: $FogShape$Type)

public "getType"(): $FogType
public "getFogShape"(): $FogShape
public "isCancelable"(): boolean
public "getMode"(): $FogRenderer$FogMode
public "setFarPlaneDistance"(arg0: float): void
public "scaleFarPlaneDistance"(arg0: float): void
public "scaleNearPlaneDistance"(arg0: float): void
public "setNearPlaneDistance"(arg0: float): void
public "getNearPlaneDistance"(): float
public "getFarPlaneDistance"(): float
public "getListenerList"(): $ListenerList
public "setFogShape"(arg0: $FogShape$Type): void
get "type"(): $FogType
get "fogShape"(): $FogShape
get "cancelable"(): boolean
get "mode"(): $FogRenderer$FogMode
set "farPlaneDistance"(value: float)
set "nearPlaneDistance"(value: float)
get "nearPlaneDistance"(): float
get "farPlaneDistance"(): float
get "listenerList"(): $ListenerList
set "fogShape"(value: $FogShape$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewportEvent$RenderFog$Type = ($ViewportEvent$RenderFog);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewportEvent$RenderFog_ = $ViewportEvent$RenderFog$Type;
}}
declare module "packages/net/minecraftforge/common/command/$EntitySelectorManager" {
import {$EntitySelectorParser, $EntitySelectorParser$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelectorParser"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$IEntitySelectorType, $IEntitySelectorType$Type} from "packages/net/minecraftforge/common/command/$IEntitySelectorType"
import {$EntitySelector, $EntitySelector$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelector"

export class $EntitySelectorManager {

constructor()

public static "register"(arg0: string, arg1: $IEntitySelectorType$Type): void
public static "parseSelector"(arg0: $EntitySelectorParser$Type): $EntitySelector
public static "fillSelectorSuggestions"(arg0: $SuggestionsBuilder$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySelectorManager$Type = ($EntitySelectorManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySelectorManager_ = $EntitySelectorManager$Type;
}}
declare module "packages/net/minecraftforge/common/brewing/$BrewingRecipeRegistry" {
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BrewingRecipeRegistryAccessor, $BrewingRecipeRegistryAccessor$Type} from "packages/com/almostreliable/morejs/mixin/$BrewingRecipeRegistryAccessor"
import {$IBrewingRecipe, $IBrewingRecipe$Type} from "packages/net/minecraftforge/common/brewing/$IBrewingRecipe"

export class $BrewingRecipeRegistry implements $BrewingRecipeRegistryAccessor {

constructor()

public static "brewPotions"(arg0: $NonNullList$Type<($ItemStack$Type)>, arg1: $ItemStack$Type, arg2: (integer)[]): void
public static "canBrew"(arg0: $NonNullList$Type<($ItemStack$Type)>, arg1: $ItemStack$Type, arg2: (integer)[]): boolean
public static "isValidInput"(arg0: $ItemStack$Type): boolean
public static "isValidIngredient"(arg0: $ItemStack$Type): boolean
public static "hasOutput"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
public static "addRecipe"(arg0: $IBrewingRecipe$Type): boolean
public static "addRecipe"(arg0: $Ingredient$Type, arg1: $Ingredient$Type, arg2: $ItemStack$Type): boolean
public static "getRecipes"(): $List<($IBrewingRecipe)>
public static "getOutput"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $ItemStack
get "recipes"(): $List<($IBrewingRecipe)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrewingRecipeRegistry$Type = ($BrewingRecipeRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BrewingRecipeRegistry_ = $BrewingRecipeRegistry$Type;
}}
declare module "packages/net/minecraftforge/client/textures/$TextureAtlasSpriteLoaderManager" {
import {$ITextureAtlasSpriteLoader, $ITextureAtlasSpriteLoader$Type} from "packages/net/minecraftforge/client/textures/$ITextureAtlasSpriteLoader"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TextureAtlasSpriteLoaderManager {


public static "get"(arg0: $ResourceLocation$Type): $ITextureAtlasSpriteLoader
public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureAtlasSpriteLoaderManager$Type = ($TextureAtlasSpriteLoaderManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureAtlasSpriteLoaderManager_ = $TextureAtlasSpriteLoaderManager$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkConstants" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $NetworkConstants {
static readonly "FMLNETMARKER": string
static readonly "FMLNETVERSION": integer
static readonly "NETVERSION": string
static readonly "NOVERSION": string
static readonly "IGNORESERVERONLY": string

constructor()

public static "init"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkConstants$Type = ($NetworkConstants);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkConstants_ = $NetworkConstants$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ForgeBiomeModifiers {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeModifiers$Type = ($ForgeBiomeModifiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeModifiers_ = $ForgeBiomeModifiers$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfig$Common" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ForgeConfig$Common {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfig$Common$Type = ($ForgeConfig$Common);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfig$Common_ = $ForgeConfig$Common$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModLoadingWarning" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModLoadingWarning {

constructor(arg0: $IModInfo$Type, arg1: $ModLoadingStage$Type, arg2: string, ...arg3: (any)[])

public "formatToString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModLoadingWarning$Type = ($ModLoadingWarning);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModLoadingWarning_ = $ModLoadingWarning$Type;
}}
declare module "packages/net/minecraftforge/registries/$RegisterEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RegisterEvent$RegisterHelper, $RegisterEvent$RegisterHelper$Type} from "packages/net/minecraftforge/registries/$RegisterEvent$RegisterHelper"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $RegisterEvent extends $Event implements $IModBusEvent {

constructor()

public "toString"(): string
public "register"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $ResourceLocation$Type, arg2: $Supplier$Type<(T)>): void
public "register"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Consumer$Type<($RegisterEvent$RegisterHelper$Type<(T)>)>): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getRegistryKey"(): $ResourceKey<(any)>
public "getForgeRegistry"<T>(): $IForgeRegistry<(T)>
public "getVanillaRegistry"<T>(): $Registry<(T)>
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "registryKey"(): $ResourceKey<(any)>
get "forgeRegistry"(): $IForgeRegistry<(T)>
get "vanillaRegistry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterEvent$Type = ($RegisterEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterEvent_ = $RegisterEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterParticleProvidersEvent" {
import {$ParticleProvider, $ParticleProvider$Type} from "packages/net/minecraft/client/particle/$ParticleProvider"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleEngine$SpriteParticleRegistration, $ParticleEngine$SpriteParticleRegistration$Type} from "packages/net/minecraft/client/particle/$ParticleEngine$SpriteParticleRegistration"
import {$ParticleEngine, $ParticleEngine$Type} from "packages/net/minecraft/client/particle/$ParticleEngine"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$ParticleProvider$Sprite, $ParticleProvider$Sprite$Type} from "packages/net/minecraft/client/particle/$ParticleProvider$Sprite"

export class $RegisterParticleProvidersEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $ParticleEngine$Type)

public "registerSprite"<T extends $ParticleOptions>(arg0: $ParticleType$Type<(T)>, arg1: $ParticleProvider$Sprite$Type<(T)>): void
public "registerSpecial"<T extends $ParticleOptions>(arg0: $ParticleType$Type<(T)>, arg1: $ParticleProvider$Type<(T)>): void
public "registerSpriteSet"<T extends $ParticleOptions>(arg0: $ParticleType$Type<(T)>, arg1: $ParticleEngine$SpriteParticleRegistration$Type<(T)>): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterParticleProvidersEvent$Type = ($RegisterParticleProvidersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterParticleProvidersEvent_ = $RegisterParticleProvidersEvent$Type;
}}
declare module "packages/net/minecraftforge/network/filters/$VanillaPacketFilter" {
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$MessageToMessageEncoder, $MessageToMessageEncoder$Type} from "packages/io/netty/handler/codec/$MessageToMessageEncoder"

export class $VanillaPacketFilter extends $MessageToMessageEncoder<($Packet<(any)>)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaPacketFilter$Type = ($VanillaPacketFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaPacketFilter_ = $VanillaPacketFilter$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ModelEvent$BakingCompleted" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ModelEvent, $ModelEvent$Type} from "packages/net/minecraftforge/client/event/$ModelEvent"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBakery, $ModelBakery$Type} from "packages/net/minecraft/client/resources/model/$ModelBakery"
import {$ModelManager, $ModelManager$Type} from "packages/net/minecraft/client/resources/model/$ModelManager"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ModelEvent$BakingCompleted extends $ModelEvent implements $IModBusEvent {

constructor()
constructor(arg0: $ModelManager$Type, arg1: $Map$Type<($ResourceLocation$Type), ($BakedModel$Type)>, arg2: $ModelBakery$Type)

public "getModels"(): $Map<($ResourceLocation), ($BakedModel)>
public "getModelManager"(): $ModelManager
public "getModelBakery"(): $ModelBakery
public "getListenerList"(): $ListenerList
get "models"(): $Map<($ResourceLocation), ($BakedModel)>
get "modelManager"(): $ModelManager
get "modelBakery"(): $ModelBakery
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelEvent$BakingCompleted$Type = ($ModelEvent$BakingCompleted);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelEvent$BakingCompleted_ = $ModelEvent$BakingCompleted$Type;
}}
declare module "packages/net/minecraftforge/common/util/$LogicalSidedProvider" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockableEventLoop, $BlockableEventLoop$Type} from "packages/net/minecraft/util/thread/$BlockableEventLoop"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $LogicalSidedProvider<T> {
static readonly "WORKQUEUE": $LogicalSidedProvider<($BlockableEventLoop<(any)>)>
static readonly "CLIENTWORLD": $LogicalSidedProvider<($Optional<($Level)>)>


public "get"(arg0: $LogicalSide$Type): T
public static "setClient"(arg0: $Supplier$Type<($Minecraft$Type)>): void
public static "setServer"(arg0: $Supplier$Type<($MinecraftServer$Type)>): void
set "client"(value: $Supplier$Type<($Minecraft$Type)>)
set "server"(value: $Supplier$Type<($MinecraftServer$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogicalSidedProvider$Type<T> = ($LogicalSidedProvider<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogicalSidedProvider_<T> = $LogicalSidedProvider$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/ticket/$SimpleTicket" {
import {$ITicketManager, $ITicketManager$Type} from "packages/net/minecraftforge/common/ticket/$ITicketManager"

export class $SimpleTicket<T> {

constructor()

public "matches"(arg0: T): boolean
public "validate"(): void
public "unload"(arg0: $ITicketManager$Type<(T)>): boolean
public "isValid"(): boolean
public "invalidate"(): void
public "setManager"(arg0: $ITicketManager$Type<(T)>, ...arg1: ($ITicketManager$Type<(T)>)[]): void
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleTicket$Type<T> = ($SimpleTicket<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleTicket_<T> = $SimpleTicket$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/level/$BlockEvent$BlockToolModificationEvent" {
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"

export class $BlockEvent$BlockToolModificationEvent extends $BlockEvent {

constructor(arg0: $BlockState$Type, arg1: $UseOnContext$Type, arg2: $ToolAction$Type, arg3: boolean)
constructor()

public "getContext"(): $UseOnContext
public "isCancelable"(): boolean
public "getHeldItemStack"(): $ItemStack
public "getToolAction"(): $ToolAction
public "getPlayer"(): $Player
public "setFinalState"(arg0: $BlockState$Type): void
public "isSimulated"(): boolean
public "getFinalState"(): $BlockState
public "getListenerList"(): $ListenerList
get "context"(): $UseOnContext
get "cancelable"(): boolean
get "heldItemStack"(): $ItemStack
get "toolAction"(): $ToolAction
get "player"(): $Player
set "finalState"(value: $BlockState$Type)
get "simulated"(): boolean
get "finalState"(): $BlockState
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvent$BlockToolModificationEvent$Type = ($BlockEvent$BlockToolModificationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvent$BlockToolModificationEvent_ = $BlockEvent$BlockToolModificationEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$AnvilUpdateEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AnvilUpdateEvent extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: string, arg3: integer, arg4: $Player$Type)

public "getName"(): string
public "getMaterialCost"(): integer
public "isCancelable"(): boolean
public "getRight"(): $ItemStack
public "getLeft"(): $ItemStack
public "setOutput"(arg0: $ItemStack$Type): void
public "setCost"(arg0: integer): void
public "setMaterialCost"(arg0: integer): void
public "getPlayer"(): $Player
public "getCost"(): integer
public "getOutput"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "name"(): string
get "materialCost"(): integer
get "cancelable"(): boolean
get "right"(): $ItemStack
get "left"(): $ItemStack
set "output"(value: $ItemStack$Type)
set "cost"(value: integer)
set "materialCost"(value: integer)
get "player"(): $Player
get "cost"(): integer
get "output"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilUpdateEvent$Type = ($AnvilUpdateEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilUpdateEvent_ = $AnvilUpdateEvent$Type;
}}
declare module "packages/net/minecraftforge/fml/$IModStateTransition$EventGenerator" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IModStateTransition$EventGenerator<T extends ($Event) & ($IModBusEvent)> extends $Function<($ModContainer), (T)> {

 "apply"(arg0: $ModContainer$Type): $ModContainer
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($ModContainer)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($ModContainer), (V)>

(arg0: $Function$Type<($ModContainer$Type), (FN)>): $IModStateTransition$EventGenerator<(FN)>
}

export namespace $IModStateTransition$EventGenerator {
function fromFunction<FN>(arg0: $Function$Type<($ModContainer$Type), (FN)>): $IModStateTransition$EventGenerator<(FN)>
function identity<T>(): $Function<($ModContainer), ($ModContainer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModStateTransition$EventGenerator$Type<T> = ($IModStateTransition$EventGenerator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModStateTransition$EventGenerator_<T> = $IModStateTransition$EventGenerator$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent$Block" {
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$RegisterColorHandlersEvent, $RegisterColorHandlersEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterColorHandlersEvent"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $RegisterColorHandlersEvent$Block extends $RegisterColorHandlersEvent {

constructor()
constructor(arg0: $BlockColors$Type)

public "register"(arg0: $BlockColor$Type, ...arg1: ($Block$Type)[]): void
public "getBlockColors"(): $BlockColors
public "getListenerList"(): $ListenerList
get "blockColors"(): $BlockColors
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterColorHandlersEvent$Block$Type = ($RegisterColorHandlersEvent$Block);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterColorHandlersEvent$Block_ = $RegisterColorHandlersEvent$Block$Type;
}}
declare module "packages/net/minecraftforge/common/util/$RecipeMatcher" {
import {$List, $List$Type} from "packages/java/util/$List"

export class $RecipeMatcher {

constructor()

public static "findMatches"<T>(arg0: $List$Type<(T)>, arg1: $List$Type<(any)>): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMatcher$Type = ($RecipeMatcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeMatcher_ = $RecipeMatcher$Type;
}}
declare module "packages/net/minecraftforge/common/brewing/$BrewingRecipe" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IBrewingRecipe, $IBrewingRecipe$Type} from "packages/net/minecraftforge/common/brewing/$IBrewingRecipe"

export class $BrewingRecipe implements $IBrewingRecipe {

constructor(arg0: $Ingredient$Type, arg1: $Ingredient$Type, arg2: $ItemStack$Type)

public "getInput"(): $Ingredient
public "getIngredient"(): $Ingredient
public "isIngredient"(arg0: $ItemStack$Type): boolean
public "isInput"(arg0: $ItemStack$Type): boolean
public "getOutput"(): $ItemStack
public "getOutput"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): $ItemStack
get "input"(): $Ingredient
get "ingredient"(): $Ingredient
get "output"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrewingRecipe$Type = ($BrewingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BrewingRecipe_ = $BrewingRecipe$Type;
}}
declare module "packages/net/minecraftforge/fml/earlydisplay/$RenderElement$DisplayContext" {
import {$ColourScheme, $ColourScheme$Type} from "packages/net/minecraftforge/fml/earlydisplay/$ColourScheme"
import {$PerformanceInfo, $PerformanceInfo$Type} from "packages/net/minecraftforge/fml/earlydisplay/$PerformanceInfo"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ElementShader, $ElementShader$Type} from "packages/net/minecraftforge/fml/earlydisplay/$ElementShader"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $RenderElement$DisplayContext extends $Record {

constructor(width: integer, height: integer, scale: integer, elementShader: $ElementShader$Type, colourScheme: $ColourScheme$Type, performance: $PerformanceInfo$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "scale"(): integer
public "width"(): integer
public "height"(): integer
public "elementShader"(): $ElementShader
public "scaledHeight"(): integer
public "scaledWidth"(): integer
public "colourScheme"(): $ColourScheme
public "performance"(): $PerformanceInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderElement$DisplayContext$Type = ($RenderElement$DisplayContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderElement$DisplayContext_ = $RenderElement$DisplayContext$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$ICondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ICondition {

 "test"(arg0: $ICondition$IContext$Type): boolean
 "getID"(): $ResourceLocation
}

export namespace $ICondition {
function shouldRegisterEntry(arg0: $JsonElement$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICondition$Type = ($ICondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICondition_ = $ICondition$Type;
}}
declare module "packages/net/minecraftforge/registries/$ForgeDeferredRegistriesSetup" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"

export class $ForgeDeferredRegistriesSetup {

constructor()

public static "setup"(arg0: $IEventBus$Type): void
set "up"(value: $IEventBus$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeDeferredRegistriesSetup$Type = ($ForgeDeferredRegistriesSetup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeDeferredRegistriesSetup_ = $ForgeDeferredRegistriesSetup$Type;
}}
declare module "packages/net/minecraftforge/forge/snapshots/$ForgeSnapshotsMod" {
import {$Options$FieldAccess, $Options$FieldAccess$Type} from "packages/net/minecraft/client/$Options$FieldAccess"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$CrashReport, $CrashReport$Type} from "packages/net/minecraft/$CrashReport"

export class $ForgeSnapshotsMod {
static readonly "BRANDING_NAME": string
static readonly "BRANDING_ID": string

constructor()

public static "processOptions"(arg0: $Options$FieldAccess$Type): void
public static "logStartupWarning"(): void
public static "addCrashReportHeader"(arg0: $StringBuilder$Type, arg1: $CrashReport$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSnapshotsMod$Type = ($ForgeSnapshotsMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSnapshotsMod_ = $ForgeSnapshotsMod$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingExperienceDropEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingExperienceDropEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $Player$Type, arg2: integer)

public "getAttackingPlayer"(): $Player
public "isCancelable"(): boolean
public "getOriginalExperience"(): integer
public "setDroppedExperience"(arg0: integer): void
public "getDroppedExperience"(): integer
public "getListenerList"(): $ListenerList
get "attackingPlayer"(): $Player
get "cancelable"(): boolean
get "originalExperience"(): integer
set "droppedExperience"(value: integer)
get "droppedExperience"(): integer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingExperienceDropEvent$Type = ($LivingExperienceDropEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingExperienceDropEvent_ = $LivingExperienceDropEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$MavenVersionStringHelper" {
import {$VersionRange, $VersionRange$Type} from "packages/org/apache/maven/artifact/versioning/$VersionRange"
import {$ArtifactVersion, $ArtifactVersion$Type} from "packages/org/apache/maven/artifact/versioning/$ArtifactVersion"
import {$StringBuffer, $StringBuffer$Type} from "packages/java/lang/$StringBuffer"
import {$Restriction, $Restriction$Type} from "packages/org/apache/maven/artifact/versioning/$Restriction"

export class $MavenVersionStringHelper {

constructor()

public static "restrictionToString"(arg0: $Restriction$Type): string
public static "parseFeatureBoundValue"(arg0: $StringBuffer$Type, arg1: any): void
public static "artifactVersionToString"(arg0: $ArtifactVersion$Type): string
public static "versionRangeToString"(arg0: $VersionRange$Type): string
public static "parseVersionRange"(arg0: $StringBuffer$Type, arg1: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MavenVersionStringHelper$Type = ($MavenVersionStringHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MavenVersionStringHelper_ = $MavenVersionStringHelper$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$AnvilRepairEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $AnvilRepairEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: $ItemStack$Type)

public "getRight"(): $ItemStack
public "getLeft"(): $ItemStack
public "getBreakChance"(): float
public "setBreakChance"(arg0: float): void
public "getOutput"(): $ItemStack
public "getListenerList"(): $ListenerList
get "right"(): $ItemStack
get "left"(): $ItemStack
get "breakChance"(): float
set "breakChance"(value: float)
get "output"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilRepairEvent$Type = ($AnvilRepairEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnvilRepairEvent_ = $AnvilRepairEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerChangedDimensionEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $PlayerEvent$PlayerChangedDimensionEvent extends $PlayerEvent {

constructor(arg0: $Player$Type, arg1: $ResourceKey$Type<($Level$Type)>, arg2: $ResourceKey$Type<($Level$Type)>)
constructor()

public "getFrom"(): $ResourceKey<($Level)>
public "getTo"(): $ResourceKey<($Level)>
public "getListenerList"(): $ListenerList
get "from"(): $ResourceKey<($Level)>
get "to"(): $ResourceKey<($Level)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$PlayerChangedDimensionEvent$Type = ($PlayerEvent$PlayerChangedDimensionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$PlayerChangedDimensionEvent_ = $PlayerEvent$PlayerChangedDimensionEvent$Type;
}}
declare module "packages/net/minecraftforge/client/$ChunkRenderTypeSet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $ChunkRenderTypeSet implements $Iterable<($RenderType)> {


public "isEmpty"(): boolean
public "iterator"(): $Iterator<(any)>
public static "of"(...arg0: ($RenderType$Type)[]): $ChunkRenderTypeSet
public static "of"(arg0: $Collection$Type<($RenderType$Type)>): $ChunkRenderTypeSet
public "contains"(arg0: $RenderType$Type): boolean
public "asList"(): $List<(any)>
public static "all"(): $ChunkRenderTypeSet
public static "union"(arg0: $Iterable$Type<(any)>): $ChunkRenderTypeSet
public static "union"(arg0: $Collection$Type<($ChunkRenderTypeSet$Type)>): $ChunkRenderTypeSet
public static "union"(...arg0: ($ChunkRenderTypeSet$Type)[]): $ChunkRenderTypeSet
public static "none"(): $ChunkRenderTypeSet
public static "intersection"(...arg0: ($ChunkRenderTypeSet$Type)[]): $ChunkRenderTypeSet
public static "intersection"(arg0: $Collection$Type<($ChunkRenderTypeSet$Type)>): $ChunkRenderTypeSet
public static "intersection"(arg0: $Iterable$Type<(any)>): $ChunkRenderTypeSet
public "spliterator"(): $Spliterator<($RenderType)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkRenderTypeSet$Type = ($ChunkRenderTypeSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkRenderTypeSet_ = $ChunkRenderTypeSet$Type;
}}
declare module "packages/net/minecraftforge/registries/tags/$IReverseTag" {
import {$ITag, $ITag$Type} from "packages/net/minecraftforge/registries/tags/$ITag"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $IReverseTag<V> {

 "getTagKeys"(): $Stream<($TagKey<(V)>)>
 "containsTag"(arg0: $TagKey$Type<(V)>): boolean
 "containsTag"(arg0: $ITag$Type<(V)>): boolean
}

export namespace $IReverseTag {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IReverseTag$Type<V> = ($IReverseTag<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IReverseTag_<V> = $IReverseTag$Type<(V)>;
}}
declare module "packages/net/minecraftforge/registries/$MissingMappingsEvent" {
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$MissingMappingsEvent$Mapping, $MissingMappingsEvent$Mapping$Type} from "packages/net/minecraftforge/registries/$MissingMappingsEvent$Mapping"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $MissingMappingsEvent extends $Event {

constructor()
constructor(arg0: $ResourceKey$Type<(any)>, arg1: $IForgeRegistry$Type<(any)>, arg2: $Collection$Type<($MissingMappingsEvent$Mapping$Type<(any)>)>)

public "getKey"(): $ResourceKey<(any)>
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getRegistry"(): $IForgeRegistry<(any)>
public "getAllMappings"<T>(arg0: $ResourceKey$Type<(any)>): $List<($MissingMappingsEvent$Mapping<(T)>)>
public "getMappings"<T>(arg0: $ResourceKey$Type<(any)>, arg1: string): $List<($MissingMappingsEvent$Mapping<(T)>)>
get "key"(): $ResourceKey<(any)>
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "registry"(): $IForgeRegistry<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MissingMappingsEvent$Type = ($MissingMappingsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MissingMappingsEvent_ = $MissingMappingsEvent$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$VanillaIngredientSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export class $VanillaIngredientSerializer implements $IIngredientSerializer<($Ingredient)> {
static readonly "INSTANCE": $VanillaIngredientSerializer

constructor()

public "write"(arg0: $FriendlyByteBuf$Type, arg1: $Ingredient$Type): void
public "parse"(arg0: $JsonObject$Type): $Ingredient
public "parse"(arg0: $FriendlyByteBuf$Type): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VanillaIngredientSerializer$Type = ($VanillaIngredientSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VanillaIngredientSerializer_ = $VanillaIngredientSerializer$Type;
}}
declare module "packages/net/minecraftforge/common/util/$NonNullPredicate" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $NonNullPredicate<T> {

 "test"(arg0: T): boolean

(arg0: T): boolean
}

export namespace $NonNullPredicate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonNullPredicate$Type<T> = ($NonNullPredicate<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonNullPredicate_<T> = $NonNullPredicate$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerLoggedInEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerEvent$PlayerLoggedInEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$PlayerLoggedInEvent$Type = ($PlayerEvent$PlayerLoggedInEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$PlayerLoggedInEvent_ = $PlayerEvent$PlayerLoggedInEvent$Type;
}}
declare module "packages/net/minecraftforge/common/data/$SoundDefinition$Sound" {
import {$SoundDefinition$SoundType, $SoundDefinition$SoundType$Type} from "packages/net/minecraftforge/common/data/$SoundDefinition$SoundType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $SoundDefinition$Sound {


public "stream"(): $SoundDefinition$Sound
public "stream"(arg0: boolean): $SoundDefinition$Sound
public "attenuationDistance"(arg0: integer): $SoundDefinition$Sound
public "pitch"(arg0: float): $SoundDefinition$Sound
public "pitch"(arg0: double): $SoundDefinition$Sound
public "volume"(arg0: double): $SoundDefinition$Sound
public "volume"(arg0: float): $SoundDefinition$Sound
public static "sound"(arg0: $ResourceLocation$Type, arg1: $SoundDefinition$SoundType$Type): $SoundDefinition$Sound
public "preload"(): $SoundDefinition$Sound
public "preload"(arg0: boolean): $SoundDefinition$Sound
public "weight"(arg0: integer): $SoundDefinition$Sound
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundDefinition$Sound$Type = ($SoundDefinition$Sound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundDefinition$Sound_ = $SoundDefinition$Sound$Type;
}}
declare module "packages/net/minecraftforge/client/settings/$IKeyConflictContext" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IKeyConflictContext {

 "isActive"(): boolean
 "conflicts"(arg0: $IKeyConflictContext$Type): boolean
}

export namespace $IKeyConflictContext {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IKeyConflictContext$Type = ($IKeyConflictContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IKeyConflictContext_ = $IKeyConflictContext$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent$Context" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$NetworkEvent$PacketDispatcher, $NetworkEvent$PacketDispatcher$Type} from "packages/net/minecraftforge/network/$NetworkEvent$PacketDispatcher"
import {$AttributeKey, $AttributeKey$Type} from "packages/io/netty/util/$AttributeKey"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Attribute, $Attribute$Type} from "packages/io/netty/util/$Attribute"

export class $NetworkEvent$Context {


public "attr"<T>(arg0: $AttributeKey$Type<(T)>): $Attribute<(T)>
public "getDirection"(): $NetworkDirection
public "getPacketHandled"(): boolean
public "enqueueWork"(arg0: $Runnable$Type): $CompletableFuture<(void)>
public "getSender"(): $ServerPlayer
public "getPacketDispatcher"(): $NetworkEvent$PacketDispatcher
public "getNetworkManager"(): $Connection
public "setPacketHandled"(arg0: boolean): void
get "direction"(): $NetworkDirection
get "packetHandled"(): boolean
get "sender"(): $ServerPlayer
get "packetDispatcher"(): $NetworkEvent$PacketDispatcher
get "networkManager"(): $Connection
set "packetHandled"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$Context$Type = ($NetworkEvent$Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent$Context_ = $NetworkEvent$Context$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityEvent extends $Event {

constructor()
constructor(arg0: $Entity$Type)

public "isCancelable"(): boolean
public "getEntity"(): $Entity
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "entity"(): $Entity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEvent$Type = ($EntityEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEvent_ = $EntityEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ViewportEvent$ComputeFogColor" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$ViewportEvent, $ViewportEvent$Type} from "packages/net/minecraftforge/client/event/$ViewportEvent"

export class $ViewportEvent$ComputeFogColor extends $ViewportEvent {

constructor(arg0: $Camera$Type, arg1: float, arg2: float, arg3: float, arg4: float)
constructor()

public "setBlue"(arg0: float): void
public "getRed"(): float
public "getGreen"(): float
public "getBlue"(): float
public "getListenerList"(): $ListenerList
public "setGreen"(arg0: float): void
public "setRed"(arg0: float): void
set "blue"(value: float)
get "red"(): float
get "green"(): float
get "blue"(): float
get "listenerList"(): $ListenerList
set "green"(value: float)
set "red"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewportEvent$ComputeFogColor$Type = ($ViewportEvent$ComputeFogColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewportEvent$ComputeFogColor_ = $ViewportEvent$ComputeFogColor$Type;
}}
declare module "packages/net/minecraftforge/client/event/$EntityRenderersEvent$CreateSkullModels" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$SkullModelBase, $SkullModelBase$Type} from "packages/net/minecraft/client/model/$SkullModelBase"
import {$EntityRenderersEvent, $EntityRenderersEvent$Type} from "packages/net/minecraftforge/client/event/$EntityRenderersEvent"
import {$EntityModelSet, $EntityModelSet$Type} from "packages/net/minecraft/client/model/geom/$EntityModelSet"
import {$SkullBlock$Type, $SkullBlock$Type$Type} from "packages/net/minecraft/world/level/block/$SkullBlock$Type"
import {$ImmutableMap$Builder, $ImmutableMap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMap$Builder"

export class $EntityRenderersEvent$CreateSkullModels extends $EntityRenderersEvent {

constructor()
constructor(arg0: $ImmutableMap$Builder$Type<($SkullBlock$Type$Type), ($SkullModelBase$Type)>, arg1: $EntityModelSet$Type)

public "getEntityModelSet"(): $EntityModelSet
public "registerSkullModel"(arg0: $SkullBlock$Type$Type, arg1: $SkullModelBase$Type): void
public "getListenerList"(): $ListenerList
get "entityModelSet"(): $EntityModelSet
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRenderersEvent$CreateSkullModels$Type = ($EntityRenderersEvent$CreateSkullModels);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRenderersEvent$CreateSkullModels_ = $EntityRenderersEvent$CreateSkullModels$Type;
}}
declare module "packages/net/minecraftforge/server/command/$EnumArgument$Info" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$EnumArgument, $EnumArgument$Type} from "packages/net/minecraftforge/server/command/$EnumArgument"
import {$ArgumentTypeInfo, $ArgumentTypeInfo$Type} from "packages/net/minecraft/commands/synchronization/$ArgumentTypeInfo"
import {$EnumArgument$Info$Template, $EnumArgument$Info$Template$Type} from "packages/net/minecraftforge/server/command/$EnumArgument$Info$Template"

export class $EnumArgument$Info<T extends $Enum<(T)>> implements $ArgumentTypeInfo<($EnumArgument<(T)>), ($EnumArgument$Info$Template<>)> {

constructor()

public "unpack"(arg0: $EnumArgument$Type<(T)>): $EnumArgument$Info$Template<>
public "deserializeFromNetwork"(arg0: $FriendlyByteBuf$Type): $EnumArgument$Info$Template<>
public "serializeToJson"(arg0: $EnumArgument$Info$Template$Type<>, arg1: $JsonObject$Type): void
public "serializeToNetwork"(arg0: $EnumArgument$Info$Template$Type<>, arg1: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumArgument$Info$Type<T> = ($EnumArgument$Info<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumArgument$Info_<T> = $EnumArgument$Info$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/gui/$LoadingErrorScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ModLoadingWarning, $ModLoadingWarning$Type} from "packages/net/minecraftforge/fml/$ModLoadingWarning"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LoadingFailedException, $LoadingFailedException$Type} from "packages/net/minecraftforge/fml/$LoadingFailedException"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ErrorScreen, $ErrorScreen$Type} from "packages/net/minecraft/client/gui/screens/$ErrorScreen"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$File, $File$Type} from "packages/java/io/$File"
import {$List, $List$Type} from "packages/java/util/$List"

export class $LoadingErrorScreen extends $ErrorScreen {
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(arg0: $LoadingFailedException$Type, arg1: $List$Type<($ModLoadingWarning$Type)>, arg2: $File$Type)

public "m_7856_"(): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadingErrorScreen$Type = ($LoadingErrorScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoadingErrorScreen_ = $LoadingErrorScreen$Type;
}}
declare module "packages/net/minecraftforge/common/util/$BlockSnapshot" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockSnapshot {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "create"(arg0: $ResourceKey$Type<($Level$Type)>, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type, arg3: integer): $BlockSnapshot
public static "create"(arg0: $ResourceKey$Type<($Level$Type)>, arg1: $LevelAccessor$Type, arg2: $BlockPos$Type): $BlockSnapshot
public "getLevel"(): $LevelAccessor
public "getTag"(): $CompoundTag
public "getBlockEntity"(): $BlockEntity
public "restore"(arg0: boolean): boolean
public "restore"(): boolean
public "restore"(arg0: boolean, arg1: boolean): boolean
public "restoreToLocation"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: boolean, arg3: boolean): boolean
public "getCurrentBlock"(): $BlockState
public "getReplacedBlock"(): $BlockState
public "getPos"(): $BlockPos
public "getFlag"(): integer
get "level"(): $LevelAccessor
get "tag"(): $CompoundTag
get "blockEntity"(): $BlockEntity
get "currentBlock"(): $BlockState
get "replacedBlock"(): $BlockState
get "pos"(): $BlockPos
get "flag"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSnapshot$Type = ($BlockSnapshot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockSnapshot_ = $BlockSnapshot$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderLivingEvent$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityRenderer, $LivingEntityRenderer$Type} from "packages/net/minecraft/client/renderer/entity/$LivingEntityRenderer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$RenderLivingEvent, $RenderLivingEvent$Type} from "packages/net/minecraftforge/client/event/$RenderLivingEvent"
import {$EntityModel, $EntityModel$Type} from "packages/net/minecraft/client/model/$EntityModel"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $RenderLivingEvent$Post<T extends $LivingEntity, M extends $EntityModel<(T)>> extends $RenderLivingEvent<(T), (M)> {

constructor(arg0: $LivingEntity$Type, arg1: $LivingEntityRenderer$Type<(T), (M)>, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderLivingEvent$Post$Type<T, M> = ($RenderLivingEvent$Post<(T), (M)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderLivingEvent$Post_<T, M> = $RenderLivingEvent$Post$Type<(T), (M)>;
}}
declare module "packages/net/minecraftforge/event/$RegisterStructureConversionsEvent" {
import {$StructuresBecomeConfiguredFix$Conversion, $StructuresBecomeConfiguredFix$Conversion$Type} from "packages/net/minecraft/util/datafix/fixes/$StructuresBecomeConfiguredFix$Conversion"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterStructureConversionsEvent extends $Event {

constructor()
constructor(arg0: $Map$Type<(string), ($StructuresBecomeConfiguredFix$Conversion$Type)>)

public "register"(arg0: string, arg1: $StructuresBecomeConfiguredFix$Conversion$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterStructureConversionsEvent$Type = ($RegisterStructureConversionsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterStructureConversionsEvent_ = $RegisterStructureConversionsEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkDirection" {
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$NetworkEvent, $NetworkEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ICustomPacket, $ICustomPacket$Type} from "packages/net/minecraftforge/network/$ICustomPacket"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $NetworkDirection extends $Enum<($NetworkDirection)> {
static readonly "PLAY_TO_SERVER": $NetworkDirection
static readonly "PLAY_TO_CLIENT": $NetworkDirection
static readonly "LOGIN_TO_SERVER": $NetworkDirection
static readonly "LOGIN_TO_CLIENT": $NetworkDirection


public static "values"(): ($NetworkDirection)[]
public static "valueOf"(arg0: string): $NetworkDirection
public "buildPacket"<T extends $Packet<(any)>>(arg0: $Pair$Type<($FriendlyByteBuf$Type), (integer)>, arg1: $ResourceLocation$Type): $ICustomPacket<(T)>
public "reply"(): $NetworkDirection
public "getEvent"(arg0: $ICustomPacket$Type<(any)>, arg1: $Supplier$Type<($NetworkEvent$Context$Type)>): $NetworkEvent
public "getOriginationSide"(): $LogicalSide
public "getReceptionSide"(): $LogicalSide
public static "directionFor"<T extends $ICustomPacket<(any)>>(arg0: $Class$Type<(T)>): $NetworkDirection
get "originationSide"(): $LogicalSide
get "receptionSide"(): $LogicalSide
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkDirection$Type = (("play_to_server") | ("login_to_client") | ("play_to_client") | ("login_to_server")) | ($NetworkDirection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkDirection_ = $NetworkDirection$Type;
}}
declare module "packages/net/minecraftforge/client/$CreativeModeTabSearchRegistry" {
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SearchRegistry$Key, $SearchRegistry$Key$Type} from "packages/net/minecraft/client/searchtree/$SearchRegistry$Key"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CreativeModeTabSearchRegistry {

constructor()

public static "getNameSearchKeys"(): $Map<($CreativeModeTab), ($SearchRegistry$Key<($ItemStack)>)>
public static "getTagSearchKeys"(): $Map<($CreativeModeTab), ($SearchRegistry$Key<($ItemStack)>)>
public static "createSearchTrees"(): void
public static "getNameSearchKey"(arg0: $CreativeModeTab$Type): $SearchRegistry$Key<($ItemStack)>
public static "getTagSearchKey"(arg0: $CreativeModeTab$Type): $SearchRegistry$Key<($ItemStack)>
get "nameSearchKeys"(): $Map<($CreativeModeTab), ($SearchRegistry$Key<($ItemStack)>)>
get "tagSearchKeys"(): $Map<($CreativeModeTab), ($SearchRegistry$Key<($ItemStack)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabSearchRegistry$Type = ($CreativeModeTabSearchRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeModeTabSearchRegistry_ = $CreativeModeTabSearchRegistry$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$AddSpawnsBiomeModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ForgeBiomeModifiers$AddSpawnsBiomeModifier extends $Record implements $BiomeModifier {

constructor(biomes: $HolderSet$Type<($Biome$Type)>, spawners: $List$Type<($MobSpawnSettings$SpawnerData$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "spawners"(): $List<($MobSpawnSettings$SpawnerData)>
public "biomes"(): $HolderSet<($Biome)>
public static "singleSpawn"(arg0: $HolderSet$Type<($Biome$Type)>, arg1: $MobSpawnSettings$SpawnerData$Type): $ForgeBiomeModifiers$AddSpawnsBiomeModifier
public "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeModifiers$AddSpawnsBiomeModifier$Type = ($ForgeBiomeModifiers$AddSpawnsBiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeModifiers$AddSpawnsBiomeModifier_ = $ForgeBiomeModifiers$AddSpawnsBiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityEvent$Size" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityEvent, $EntityEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityEvent"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$Pose, $Pose$Type} from "packages/net/minecraft/world/entity/$Pose"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * 
 * @deprecated
 */
export class $EntityEvent$Size extends $EntityEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: $Pose$Type, arg2: $EntityDimensions$Type, arg3: $EntityDimensions$Type, arg4: float, arg5: float)
constructor(arg0: $Entity$Type, arg1: $Pose$Type, arg2: $EntityDimensions$Type)
constructor(arg0: $Entity$Type, arg1: $Pose$Type, arg2: $EntityDimensions$Type, arg3: float)

public "getOriginalSize"(): $EntityDimensions
public "setNewSize"(arg0: $EntityDimensions$Type, arg1: boolean): void
public "setNewSize"(arg0: $EntityDimensions$Type): void
public "getOldSize"(): $EntityDimensions
public "setNewEyeHeight"(arg0: float): void
public "getOldEyeHeight"(): float
public "getPose"(): $Pose
public "getNewEyeHeight"(): float
public "getNewSize"(): $EntityDimensions
public "getListenerList"(): $ListenerList
get "originalSize"(): $EntityDimensions
set "newSize"(value: $EntityDimensions$Type)
get "oldSize"(): $EntityDimensions
set "newEyeHeight"(value: float)
get "oldEyeHeight"(): float
get "pose"(): $Pose
get "newEyeHeight"(): float
get "newSize"(): $EntityDimensions
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEvent$Size$Type = ($EntityEvent$Size);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEvent$Size_ = $EntityEvent$Size$Type;
}}
declare module "packages/net/minecraftforge/client/event/$MovementInputUpdateEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Input, $Input$Type} from "packages/net/minecraft/client/player/$Input"

export class $MovementInputUpdateEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Input$Type)

public "getInput"(): $Input
public "getListenerList"(): $ListenerList
get "input"(): $Input
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MovementInputUpdateEvent$Type = ($MovementInputUpdateEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MovementInputUpdateEvent_ = $MovementInputUpdateEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjMaterialLibrary" {
import {$ObjMaterialLibrary$Material, $ObjMaterialLibrary$Material$Type} from "packages/net/minecraftforge/client/model/obj/$ObjMaterialLibrary$Material"
import {$ObjTokenizer, $ObjTokenizer$Type} from "packages/net/minecraftforge/client/model/obj/$ObjTokenizer"

export class $ObjMaterialLibrary {
static readonly "EMPTY": $ObjMaterialLibrary

constructor(arg0: $ObjTokenizer$Type)

public "getMaterial"(arg0: string): $ObjMaterialLibrary$Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjMaterialLibrary$Type = ($ObjMaterialLibrary);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjMaterialLibrary_ = $ObjMaterialLibrary$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$AbstractIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"

export class $AbstractIngredient extends $Ingredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "isSimple"(): boolean
public "toJson"(): $JsonElement
/**
 * 
 * @deprecated
 */
public static "of"(...arg0: ($ItemStack$Type)[]): $Ingredient
/**
 * 
 * @deprecated
 */
public static "fromValues"(arg0: $Stream$Type<(any)>): $Ingredient
/**
 * 
 * @deprecated
 */
public static "of"(): $Ingredient
/**
 * 
 * @deprecated
 */
public static "fromNetwork"(arg0: $FriendlyByteBuf$Type): $Ingredient
/**
 * 
 * @deprecated
 */
public static "fromJson"(arg0: $JsonElement$Type): $Ingredient
public "getSerializer"(): $IIngredientSerializer<(any)>
/**
 * 
 * @deprecated
 */
public static "of"(arg0: $Stream$Type<($ItemStack$Type)>): $Ingredient
/**
 * 
 * @deprecated
 */
public static "of"(...arg0: ($ItemLike$Type)[]): $Ingredient
/**
 * 
 * @deprecated
 */
public static "of"(arg0: $TagKey$Type<($Item$Type)>): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIngredient$Type = ($AbstractIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIngredient_ = $AbstractIngredient$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelFile$ExistingModelFile" {
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelFile, $ModelFile$Type} from "packages/net/minecraftforge/client/model/generators/$ModelFile"

export class $ModelFile$ExistingModelFile extends $ModelFile {

constructor(arg0: $ResourceLocation$Type, arg1: $ExistingFileHelper$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelFile$ExistingModelFile$Type = ($ModelFile$ExistingModelFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelFile$ExistingModelFile_ = $ModelFile$ExistingModelFile$Type;
}}
declare module "packages/net/minecraftforge/common/data/$SoundDefinitionsProvider" {
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"

export class $SoundDefinitionsProvider implements $DataProvider {


public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public "registerSounds"(): void
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundDefinitionsProvider$Type = ($SoundDefinitionsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundDefinitionsProvider_ = $SoundDefinitionsProvider$Type;
}}
declare module "packages/net/minecraftforge/network/$HandshakeMessages$S2CRegistry" {
import {$HandshakeMessages$LoginIndexedMessage, $HandshakeMessages$LoginIndexedMessage$Type} from "packages/net/minecraftforge/network/$HandshakeMessages$LoginIndexedMessage"
import {$ForgeRegistry$Snapshot, $ForgeRegistry$Snapshot$Type} from "packages/net/minecraftforge/registries/$ForgeRegistry$Snapshot"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $HandshakeMessages$S2CRegistry extends $HandshakeMessages$LoginIndexedMessage {

constructor(arg0: $ResourceLocation$Type, arg1: $ForgeRegistry$Snapshot$Type)

public static "decode"(arg0: $FriendlyByteBuf$Type): $HandshakeMessages$S2CRegistry
public "getSnapshot"(): $ForgeRegistry$Snapshot
public "hasSnapshot"(): boolean
public "getRegistryName"(): $ResourceLocation
get "snapshot"(): $ForgeRegistry$Snapshot
get "registryName"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeMessages$S2CRegistry$Type = ($HandshakeMessages$S2CRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeMessages$S2CRegistry_ = $HandshakeMessages$S2CRegistry$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$AddFeaturesBiomeModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$PlacedFeature, $PlacedFeature$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacedFeature"
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ForgeBiomeModifiers$AddFeaturesBiomeModifier extends $Record implements $BiomeModifier {

constructor(biomes: $HolderSet$Type<($Biome$Type)>, features: $HolderSet$Type<($PlacedFeature$Type)>, step: $GenerationStep$Decoration$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "step"(): $GenerationStep$Decoration
public "features"(): $HolderSet<($PlacedFeature)>
public "biomes"(): $HolderSet<($Biome)>
public "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeModifiers$AddFeaturesBiomeModifier$Type = ($ForgeBiomeModifiers$AddFeaturesBiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeModifiers$AddFeaturesBiomeModifier_ = $ForgeBiomeModifiers$AddFeaturesBiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeStatesProvider" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModLoadingState, $IModLoadingState$Type} from "packages/net/minecraftforge/fml/$IModLoadingState"
import {$IModStateProvider, $IModStateProvider$Type} from "packages/net/minecraftforge/fml/$IModStateProvider"

export class $ForgeStatesProvider implements $IModStateProvider {

constructor()

public "getAllStates"(): $List<($IModLoadingState)>
get "allStates"(): $List<($IModLoadingState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeStatesProvider$Type = ($ForgeStatesProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeStatesProvider_ = $ForgeStatesProvider$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$ItemExistsCondition" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $ItemExistsCondition implements $ICondition {

constructor(arg0: $ResourceLocation$Type)
constructor(arg0: string, arg1: string)
constructor(arg0: string)

public "toString"(): string
public "test"(arg0: $ICondition$IContext$Type): boolean
public "getID"(): $ResourceLocation
public static "shouldRegisterEntry"(arg0: $JsonElement$Type): boolean
get "iD"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemExistsCondition$Type = ($ItemExistsCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemExistsCondition_ = $ItemExistsCondition$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$FaceRotation" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ModelBuilder$FaceRotation extends $Enum<($ModelBuilder$FaceRotation)> {
static readonly "ZERO": $ModelBuilder$FaceRotation
static readonly "CLOCKWISE_90": $ModelBuilder$FaceRotation
static readonly "UPSIDE_DOWN": $ModelBuilder$FaceRotation
static readonly "COUNTERCLOCKWISE_90": $ModelBuilder$FaceRotation


public static "values"(): ($ModelBuilder$FaceRotation)[]
public static "valueOf"(arg0: string): $ModelBuilder$FaceRotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$FaceRotation$Type = (("zero") | ("clockwise_90") | ("counterclockwise_90") | ("upside_down")) | ($ModelBuilder$FaceRotation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$FaceRotation_ = $ModelBuilder$FaceRotation$Type;
}}
declare module "packages/net/minecraftforge/common/world/$MobSpawnSettingsBuilder" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$MobSpawnSettings, $MobSpawnSettings$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MobSpawnSettings$Builder, $MobSpawnSettings$Builder$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MobSpawnSettings$MobSpawnCost, $MobSpawnSettings$MobSpawnCost$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$MobSpawnCost"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MobSpawnSettingsBuilder extends $MobSpawnSettings$Builder {
readonly "spawners": $Map<($MobCategory), ($List<($MobSpawnSettings$SpawnerData)>)>
readonly "mobSpawnCosts": $Map<($EntityType<(any)>), ($MobSpawnSettings$MobSpawnCost)>
 "creatureGenerationProbability": float

constructor(arg0: $MobSpawnSettings$Type)

public "getEntityTypes"(): $Set<($EntityType<(any)>)>
public "getSpawnerTypes"(): $Set<($MobCategory)>
public "disablePlayerSpawn"(): $MobSpawnSettingsBuilder
public "getCost"(arg0: $EntityType$Type<(any)>): $MobSpawnSettings$MobSpawnCost
public "getSpawner"(arg0: $MobCategory$Type): $List<($MobSpawnSettings$SpawnerData)>
public "getProbability"(): float
get "entityTypes"(): $Set<($EntityType<(any)>)>
get "spawnerTypes"(): $Set<($MobCategory)>
get "probability"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettingsBuilder$Type = ($MobSpawnSettingsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobSpawnSettingsBuilder_ = $MobSpawnSettingsBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/gui/overlay/$NamedGuiOverlay" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IGuiOverlay, $IGuiOverlay$Type} from "packages/net/minecraftforge/client/gui/overlay/$IGuiOverlay"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $NamedGuiOverlay extends $Record {

constructor(id: $ResourceLocation$Type, overlay: $IGuiOverlay$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "overlay"(): $IGuiOverlay
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedGuiOverlay$Type = ($NamedGuiOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedGuiOverlay_ = $NamedGuiOverlay$Type;
}}
declare module "packages/net/minecraftforge/server/$ServerLifecycleHooks" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$RepositorySource, $RepositorySource$Type} from "packages/net/minecraft/server/packs/repository/$RepositorySource"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ClientIntentionPacket, $ClientIntentionPacket$Type} from "packages/net/minecraft/network/protocol/handshake/$ClientIntentionPacket"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServerLifecycleHooks {

constructor()

public static "handleServerStarting"(arg0: $MinecraftServer$Type): boolean
public static "handleServerAboutToStart"(arg0: $MinecraftServer$Type): boolean
public static "getCurrentServer"(): $MinecraftServer
public static "handleExit"(arg0: integer): void
public static "buildPackFinder"(arg0: $Map$Type<($IModFile$Type), (any)>): $RepositorySource
public static "handleServerLogin"(arg0: $ClientIntentionPacket$Type, arg1: $Connection$Type): boolean
public static "handleServerStarted"(arg0: $MinecraftServer$Type): void
public static "handleServerStopping"(arg0: $MinecraftServer$Type): void
public static "expectServerStopped"(): void
public static "handleServerStopped"(arg0: $MinecraftServer$Type): void
get "currentServer"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLifecycleHooks$Type = ($ServerLifecycleHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerLifecycleHooks_ = $ServerLifecycleHooks$Type;
}}
declare module "packages/net/minecraftforge/fml/$IExtensionPoint" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IExtensionPoint<T extends $Record> {

}

export namespace $IExtensionPoint {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtensionPoint$Type<T> = ($IExtensionPoint<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtensionPoint_<T> = $IExtensionPoint$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$PlayerTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent$PlayerTickEvent extends $TickEvent {
readonly "player": $Player
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor(arg0: $TickEvent$Phase$Type, arg1: $Player$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$PlayerTickEvent$Type = ($TickEvent$PlayerTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$PlayerTickEvent_ = $TickEvent$PlayerTickEvent$Type;
}}
declare module "packages/net/minecraftforge/network/simple/$SimpleChannel$MessageBuilder$ToBooleanBiFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SimpleChannel$MessageBuilder$ToBooleanBiFunction<T, U> {

 "applyAsBool"(arg0: T, arg1: U): boolean

(arg0: T, arg1: U): boolean
}

export namespace $SimpleChannel$MessageBuilder$ToBooleanBiFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleChannel$MessageBuilder$ToBooleanBiFunction$Type<T, U> = ($SimpleChannel$MessageBuilder$ToBooleanBiFunction<(T), (U)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleChannel$MessageBuilder$ToBooleanBiFunction_<T, U> = $SimpleChannel$MessageBuilder$ToBooleanBiFunction$Type<(T), (U)>;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeAbstractMinecart" {
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IForgeAbstractMinecart {

 "canUseRail"(): boolean
 "canBeRidden"(): boolean
 "getSlopeAdjustment"(): double
 "getDragAir"(): double
 "moveMinecartOnRail"(arg0: $BlockPos$Type): void
 "isPoweredCart"(): boolean
 "setCanUseRail"(arg0: boolean): void
 "setDragAir"(arg0: double): void
 "getMaxSpeedAirLateral"(): float
 "getMaxCartSpeedOnRail"(): float
 "getCurrentCartSpeedCapOnRail"(): float
 "getMaxSpeedAirVertical"(): float
 "setMaxSpeedAirVertical"(arg0: float): void
 "getMaxSpeedWithRail"(): double
 "getCurrentRailPosition"(): $BlockPos
 "shouldDoRailFunctions"(): boolean
 "setMaxSpeedAirLateral"(arg0: float): void
 "setCurrentCartSpeedCapOnRail"(arg0: float): void
 "getComparatorLevel"(): integer
}

export namespace $IForgeAbstractMinecart {
const DEFAULT_MAX_SPEED_AIR_LATERAL: float
const DEFAULT_MAX_SPEED_AIR_VERTICAL: float
const DEFAULT_AIR_DRAG: double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeAbstractMinecart$Type = ($IForgeAbstractMinecart);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeAbstractMinecart_ = $IForgeAbstractMinecart$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderBlockScreenEffectEvent$OverlayType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $RenderBlockScreenEffectEvent$OverlayType extends $Enum<($RenderBlockScreenEffectEvent$OverlayType)> {
static readonly "FIRE": $RenderBlockScreenEffectEvent$OverlayType
static readonly "BLOCK": $RenderBlockScreenEffectEvent$OverlayType
static readonly "WATER": $RenderBlockScreenEffectEvent$OverlayType


public static "values"(): ($RenderBlockScreenEffectEvent$OverlayType)[]
public static "valueOf"(arg0: string): $RenderBlockScreenEffectEvent$OverlayType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderBlockScreenEffectEvent$OverlayType$Type = (("fire") | ("block") | ("water")) | ($RenderBlockScreenEffectEvent$OverlayType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderBlockScreenEffectEvent$OverlayType_ = $RenderBlockScreenEffectEvent$OverlayType$Type;
}}
declare module "packages/net/minecraftforge/event/level/$LevelEvent$Unload" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LevelEvent, $LevelEvent$Type} from "packages/net/minecraftforge/event/level/$LevelEvent"

export class $LevelEvent$Unload extends $LevelEvent {

constructor(arg0: $LevelAccessor$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEvent$Unload$Type = ($LevelEvent$Unload);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEvent$Unload_ = $LevelEvent$Unload$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyPressed" {
import {$ScreenEvent$KeyInput, $ScreenEvent$KeyInput$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyInput"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$KeyPressed extends $ScreenEvent$KeyInput {

constructor()
constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyPressed$Type = ($ScreenEvent$KeyPressed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyPressed_ = $ScreenEvent$KeyPressed$Type;
}}
declare module "packages/net/minecraftforge/network/event/$EventNetworkChannel" {
import {$NetworkEvent, $NetworkEvent$Type} from "packages/net/minecraftforge/network/$NetworkEvent"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$NetworkInstance, $NetworkInstance$Type} from "packages/net/minecraftforge/network/$NetworkInstance"

export class $EventNetworkChannel {

constructor(arg0: $NetworkInstance$Type)

public "registerObject"(arg0: any): void
public "isRemotePresent"(arg0: $Connection$Type): boolean
public "unregisterObject"(arg0: any): void
public "addListener"<T extends $NetworkEvent>(arg0: $Consumer$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventNetworkChannel$Type = ($EventNetworkChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventNetworkChannel_ = $EventNetworkChannel$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderPlayerEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$PlayerRenderer, $PlayerRenderer$Type} from "packages/net/minecraft/client/renderer/entity/player/$PlayerRenderer"

export class $RenderPlayerEvent extends $PlayerEvent {

constructor()

public "getPartialTick"(): float
public "getPoseStack"(): $PoseStack
public "getMultiBufferSource"(): $MultiBufferSource
public "getPackedLight"(): integer
public "getRenderer"(): $PlayerRenderer
public "getListenerList"(): $ListenerList
get "partialTick"(): float
get "poseStack"(): $PoseStack
get "multiBufferSource"(): $MultiBufferSource
get "packedLight"(): integer
get "renderer"(): $PlayerRenderer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderPlayerEvent$Type = ($RenderPlayerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderPlayerEvent_ = $RenderPlayerEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$KeyReleased$Post" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ScreenEvent$KeyReleased, $ScreenEvent$KeyReleased$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$KeyReleased"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent$KeyReleased$Post extends $ScreenEvent$KeyReleased {

constructor(arg0: $Screen$Type, arg1: integer, arg2: integer, arg3: integer)
constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$KeyReleased$Post$Type = ($ScreenEvent$KeyReleased$Post);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$KeyReleased$Post_ = $ScreenEvent$KeyReleased$Post$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeMenuType" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$IContainerFactory, $IContainerFactory$Type} from "packages/net/minecraftforge/network/$IContainerFactory"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export interface $IForgeMenuType<T> {

 "create"(arg0: integer, arg1: $Inventory$Type, arg2: $FriendlyByteBuf$Type): T

(arg0: $IContainerFactory$Type<(T)>): $MenuType<(T)>
}

export namespace $IForgeMenuType {
function create<T>(arg0: $IContainerFactory$Type<(T)>): $MenuType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeMenuType$Type<T> = ($IForgeMenuType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeMenuType_<T> = $IForgeMenuType$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableStructureInfo" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ModifiableStructureInfo$StructureInfo, $ModifiableStructureInfo$StructureInfo$Type} from "packages/net/minecraftforge/common/world/$ModifiableStructureInfo$StructureInfo"
import {$StructureModifier, $StructureModifier$Type} from "packages/net/minecraftforge/common/world/$StructureModifier"

export class $ModifiableStructureInfo {

constructor(arg0: $ModifiableStructureInfo$StructureInfo$Type)

public "get"(): $ModifiableStructureInfo$StructureInfo
public "getOriginalStructureInfo"(): $ModifiableStructureInfo$StructureInfo
public "applyStructureModifiers"(arg0: $Holder$Type<($Structure$Type)>, arg1: $List$Type<($StructureModifier$Type)>): void
public "getModifiedStructureInfo"(): $ModifiableStructureInfo$StructureInfo
get "originalStructureInfo"(): $ModifiableStructureInfo$StructureInfo
get "modifiedStructureInfo"(): $ModifiableStructureInfo$StructureInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableStructureInfo$Type = ($ModifiableStructureInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableStructureInfo_ = $ModifiableStructureInfo$Type;
}}
declare module "packages/net/minecraftforge/fluids/$FluidType$Properties" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$SoundAction, $SoundAction$Type} from "packages/net/minecraftforge/common/$SoundAction"
import {$BlockPathTypes, $BlockPathTypes$Type} from "packages/net/minecraft/world/level/pathfinder/$BlockPathTypes"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"

export class $FluidType$Properties {


public static "create"(): $FluidType$Properties
public "lightLevel"(arg0: integer): $FluidType$Properties
public "sound"(arg0: $SoundAction$Type, arg1: $SoundEvent$Type): $FluidType$Properties
public "descriptionId"(arg0: string): $FluidType$Properties
public "viscosity"(arg0: integer): $FluidType$Properties
public "canDrown"(arg0: boolean): $FluidType$Properties
public "adjacentPathType"(arg0: $BlockPathTypes$Type): $FluidType$Properties
public "pathType"(arg0: $BlockPathTypes$Type): $FluidType$Properties
public "fallDistanceModifier"(arg0: float): $FluidType$Properties
public "rarity"(arg0: $Rarity$Type): $FluidType$Properties
public "density"(arg0: integer): $FluidType$Properties
public "temperature"(arg0: integer): $FluidType$Properties
public "supportsBoating"(arg0: boolean): $FluidType$Properties
public "canConvertToSource"(arg0: boolean): $FluidType$Properties
public "canSwim"(arg0: boolean): $FluidType$Properties
public "canExtinguish"(arg0: boolean): $FluidType$Properties
public "canHydrate"(arg0: boolean): $FluidType$Properties
public "canPushEntity"(arg0: boolean): $FluidType$Properties
public "motionScale"(arg0: double): $FluidType$Properties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidType$Properties$Type = ($FluidType$Properties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidType$Properties_ = $FluidType$Properties$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$VariantBlockStateBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$BlockStateProvider$ConfiguredModelList, $BlockStateProvider$ConfiguredModelList$Type} from "packages/net/minecraftforge/client/model/generators/$BlockStateProvider$ConfiguredModelList"
import {$IGeneratedBlockState, $IGeneratedBlockState$Type} from "packages/net/minecraftforge/client/model/generators/$IGeneratedBlockState"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$VariantBlockStateBuilder$PartialBlockstate, $VariantBlockStateBuilder$PartialBlockstate$Type} from "packages/net/minecraftforge/client/model/generators/$VariantBlockStateBuilder$PartialBlockstate"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ConfiguredModel, $ConfiguredModel$Type} from "packages/net/minecraftforge/client/model/generators/$ConfiguredModel"

export class $VariantBlockStateBuilder implements $IGeneratedBlockState {


public "getOwner"(): $Block
public "getModels"(): $Map<($VariantBlockStateBuilder$PartialBlockstate), ($BlockStateProvider$ConfiguredModelList)>
public "toJson"(): $JsonObject
public "setModels"(arg0: $VariantBlockStateBuilder$PartialBlockstate$Type, ...arg1: ($ConfiguredModel$Type)[]): $VariantBlockStateBuilder
public "forAllStates"(arg0: $Function$Type<($BlockState$Type), (($ConfiguredModel$Type)[])>): $VariantBlockStateBuilder
public "addModels"(arg0: $VariantBlockStateBuilder$PartialBlockstate$Type, ...arg1: ($ConfiguredModel$Type)[]): $VariantBlockStateBuilder
public "forAllStatesExcept"(arg0: $Function$Type<($BlockState$Type), (($ConfiguredModel$Type)[])>, ...arg1: ($Property$Type<(any)>)[]): $VariantBlockStateBuilder
public "partialState"(): $VariantBlockStateBuilder$PartialBlockstate
get "owner"(): $Block
get "models"(): $Map<($VariantBlockStateBuilder$PartialBlockstate), ($BlockStateProvider$ConfiguredModelList)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateBuilder$Type = ($VariantBlockStateBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateBuilder_ = $VariantBlockStateBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeVertexConsumer" {
import {$VertexFormatElement, $VertexFormatElement$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormatElement"
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack$Pose, $PoseStack$Pose$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack$Pose"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export interface $IForgeVertexConsumer {

 "putBulkData"(arg0: $PoseStack$Pose$Type, arg1: $BakedQuad$Type, arg2: float, arg3: float, arg4: float, arg5: float, arg6: integer, arg7: integer, arg8: boolean): void
 "applyBakedLighting"(arg0: integer, arg1: $ByteBuffer$Type): integer
 "applyBakedNormals"(arg0: $Vector3f$Type, arg1: $ByteBuffer$Type, arg2: $Matrix3f$Type): void
 "misc"(arg0: $VertexFormatElement$Type, ...arg1: (integer)[]): $VertexConsumer
}

export namespace $IForgeVertexConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeVertexConsumer$Type = ($IForgeVertexConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeVertexConsumer_ = $IForgeVertexConsumer$Type;
}}
declare module "packages/net/minecraftforge/client/model/lighting/$FlatQuadLighter" {
import {$BlockColors, $BlockColors$Type} from "packages/net/minecraft/client/color/block/$BlockColors"
import {$QuadLighter, $QuadLighter$Type} from "packages/net/minecraftforge/client/model/lighting/$QuadLighter"

export class $FlatQuadLighter extends $QuadLighter {

constructor(arg0: $BlockColors$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlatQuadLighter$Type = ($FlatQuadLighter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlatQuadLighter_ = $FlatQuadLighter$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue" {
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfigSpec$BooleanValue extends $ForgeConfigSpec$ConfigValue<(boolean)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$BooleanValue$Type = ($ForgeConfigSpec$BooleanValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$BooleanValue_ = $ForgeConfigSpec$BooleanValue$Type;
}}
declare module "packages/net/minecraftforge/fml/$VersionChecker$Status" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VersionChecker$Status extends $Enum<($VersionChecker$Status)> {
static readonly "PENDING": $VersionChecker$Status
static readonly "FAILED": $VersionChecker$Status
static readonly "UP_TO_DATE": $VersionChecker$Status
static readonly "OUTDATED": $VersionChecker$Status
static readonly "AHEAD": $VersionChecker$Status
static readonly "BETA": $VersionChecker$Status
static readonly "BETA_OUTDATED": $VersionChecker$Status


public static "values"(): ($VersionChecker$Status)[]
public static "valueOf"(arg0: string): $VersionChecker$Status
public "getSheetOffset"(): integer
public "isAnimated"(): boolean
public "shouldDraw"(): boolean
get "sheetOffset"(): integer
get "animated"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VersionChecker$Status$Type = (("beta_outdated") | ("outdated") | ("ahead") | ("pending") | ("up_to_date") | ("failed") | ("beta")) | ($VersionChecker$Status);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VersionChecker$Status_ = $VersionChecker$Status$Type;
}}
declare module "packages/net/minecraftforge/client/model/$ExtendedBlockModelDeserializer" {
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockModel$Deserializer, $BlockModel$Deserializer$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel$Deserializer"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"

export class $ExtendedBlockModelDeserializer extends $BlockModel$Deserializer {
static readonly "INSTANCE": $Gson

constructor()

public "deserialize"(arg0: $JsonElement$Type, arg1: $Type$Type, arg2: $JsonDeserializationContext$Type): $BlockModel
public static "deserializeGeometry"(arg0: $JsonDeserializationContext$Type, arg1: $JsonObject$Type): $IUnbakedGeometry<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtendedBlockModelDeserializer$Type = ($ExtendedBlockModelDeserializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtendedBlockModelDeserializer_ = $ExtendedBlockModelDeserializer$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerSleepInBedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Player$BedSleepingProblem, $Player$BedSleepingProblem$Type} from "packages/net/minecraft/world/entity/player/$Player$BedSleepingProblem"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlayerSleepInBedEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Optional$Type<($BlockPos$Type)>)

public "setResult"(arg0: $Player$BedSleepingProblem$Type): void
public "getResultStatus"(): $Player$BedSleepingProblem
public "getOptionalPos"(): $Optional<($BlockPos)>
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
set "result"(value: $Player$BedSleepingProblem$Type)
get "resultStatus"(): $Player$BedSleepingProblem
get "optionalPos"(): $Optional<($BlockPos)>
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSleepInBedEvent$Type = ($PlayerSleepInBedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerSleepInBedEvent_ = $PlayerSleepInBedEvent$Type;
}}
declare module "packages/net/minecraftforge/common/world/$PieceBeardifierModifier" {
import {$BoundingBox, $BoundingBox$Type} from "packages/net/minecraft/world/level/levelgen/structure/$BoundingBox"
import {$TerrainAdjustment, $TerrainAdjustment$Type} from "packages/net/minecraft/world/level/levelgen/structure/$TerrainAdjustment"

export interface $PieceBeardifierModifier {

 "getTerrainAdjustment"(): $TerrainAdjustment
 "getBeardifierBox"(): $BoundingBox
 "getGroundLevelDelta"(): integer
}

export namespace $PieceBeardifierModifier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PieceBeardifierModifier$Type = ($PieceBeardifierModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PieceBeardifierModifier_ = $PieceBeardifierModifier$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeLevel" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PartEntity, $PartEntity$Type} from "packages/net/minecraftforge/entity/$PartEntity"

export interface $IForgeLevel extends $ICapabilityProvider {

 "getPartEntities"(): $Collection<($PartEntity<(any)>)>
 "getMaxEntityRadius"(): double
 "increaseMaxEntityRadius"(arg0: double): double
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}

export namespace $IForgeLevel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeLevel$Type = ($IForgeLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeLevel_ = $IForgeLevel$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IForgeHolderSet$SerializationType extends $Enum<($IForgeHolderSet$SerializationType)> {
static readonly "UNKNOWN": $IForgeHolderSet$SerializationType
static readonly "STRING": $IForgeHolderSet$SerializationType
static readonly "LIST": $IForgeHolderSet$SerializationType
static readonly "OBJECT": $IForgeHolderSet$SerializationType


public static "values"(): ($IForgeHolderSet$SerializationType)[]
public static "valueOf"(arg0: string): $IForgeHolderSet$SerializationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeHolderSet$SerializationType$Type = (("string") | ("list") | ("unknown") | ("object")) | ($IForgeHolderSet$SerializationType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeHolderSet$SerializationType_ = $IForgeHolderSet$SerializationType$Type;
}}
declare module "packages/net/minecraftforge/fml/event/lifecycle/$InterModEnqueueEvent" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ParallelDispatchEvent, $ParallelDispatchEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$ParallelDispatchEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $InterModEnqueueEvent extends $ParallelDispatchEvent {

constructor(arg0: $ModContainer$Type, arg1: $ModLoadingStage$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterModEnqueueEvent$Type = ($InterModEnqueueEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterModEnqueueEvent_ = $InterModEnqueueEvent$Type;
}}
declare module "packages/net/minecraftforge/common/data/$SoundDefinition$SoundType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SoundDefinition$SoundType extends $Enum<($SoundDefinition$SoundType)> {
static readonly "SOUND": $SoundDefinition$SoundType
static readonly "EVENT": $SoundDefinition$SoundType


public static "values"(): ($SoundDefinition$SoundType)[]
public static "valueOf"(arg0: string): $SoundDefinition$SoundType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundDefinition$SoundType$Type = (("sound") | ("event")) | ($SoundDefinition$SoundType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundDefinition$SoundType_ = $SoundDefinition$SoundType$Type;
}}
declare module "packages/net/minecraftforge/common/util/$DummySavedData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SavedData, $SavedData$Type} from "packages/net/minecraft/world/level/saveddata/$SavedData"

export class $DummySavedData extends $SavedData {
static readonly "DUMMY": $DummySavedData


public "save"(arg0: $CompoundTag$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DummySavedData$Type = ($DummySavedData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DummySavedData_ = $DummySavedData$Type;
}}
declare module "packages/net/minecraftforge/common/$BasicItemListing" {
import {$MerchantOffer, $MerchantOffer$Type} from "packages/net/minecraft/world/item/trading/$MerchantOffer"
import {$TradeFilter$Filterable, $TradeFilter$Filterable$Type} from "packages/com/almostreliable/morejs/features/villager/$TradeFilter$Filterable"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$TradeFilter, $TradeFilter$Type} from "packages/com/almostreliable/morejs/features/villager/$TradeFilter"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $BasicItemListing implements $VillagerTrades$ItemListing, $TradeFilter$Filterable {

constructor(arg0: integer, arg1: $ItemStack$Type, arg2: integer, arg3: integer)
constructor(arg0: integer, arg1: $ItemStack$Type, arg2: integer, arg3: integer, arg4: float)
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: integer, arg3: integer, arg4: float)
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $ItemStack$Type, arg3: integer, arg4: integer, arg5: float)

public "getOffer"(arg0: $Entity$Type, arg1: $RandomSource$Type): $MerchantOffer
public "matchesTradeFilter"(arg0: $TradeFilter$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicItemListing$Type = ($BasicItemListing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicItemListing_ = $BasicItemListing$Type;
}}
declare module "packages/net/minecraftforge/fml/config/$IConfigSpec" {
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ConfigFormat, $ConfigFormat$Type} from "packages/com/electronwill/nightconfig/core/$ConfigFormat"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$OptionalLong, $OptionalLong$Type} from "packages/java/util/$OptionalLong"
import {$EnumGetMethod, $EnumGetMethod$Type} from "packages/com/electronwill/nightconfig/core/$EnumGetMethod"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$OptionalInt, $OptionalInt$Type} from "packages/java/util/$OptionalInt"
import {$CommentedConfig, $CommentedConfig$Type} from "packages/com/electronwill/nightconfig/core/$CommentedConfig"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$UnmodifiableConfig, $UnmodifiableConfig$Type} from "packages/com/electronwill/nightconfig/core/$UnmodifiableConfig"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IConfigSpec<T extends $IConfigSpec<(T)>> extends $UnmodifiableConfig {

 "self"(): T
 "isCorrect"(arg0: $CommentedConfig$Type): boolean
 "correct"(arg0: $CommentedConfig$Type): integer
 "acceptConfig"(arg0: $CommentedConfig$Type): void
 "isCorrecting"(): boolean
 "afterReload"(): void
 "get"<T>(arg0: string): T
 "get"<T>(arg0: $List$Type<(string)>): T
 "getByte"(arg0: $List$Type<(string)>): byte
 "getByte"(arg0: string): byte
 "getShort"(arg0: string): short
 "getShort"(arg0: $List$Type<(string)>): short
 "getChar"(arg0: string): character
 "getChar"(arg0: $List$Type<(string)>): character
 "getInt"(arg0: string): integer
 "getInt"(arg0: $List$Type<(string)>): integer
 "getLong"(arg0: string): long
 "getLong"(arg0: $List$Type<(string)>): long
 "isEmpty"(): boolean
 "size"(): integer
 "apply"<T>(arg0: string): T
 "apply"<T>(arg0: $List$Type<(string)>): T
 "contains"(arg0: string): boolean
 "contains"(arg0: $List$Type<(string)>): boolean
 "entrySet"(): $Set<(any)>
 "isNull"(arg0: string): boolean
 "isNull"(arg0: $List$Type<(string)>): boolean
 "getIntOrElse"(arg0: $List$Type<(string)>, arg1: $IntSupplier$Type): integer
 "getIntOrElse"(arg0: string, arg1: integer): integer
 "getIntOrElse"(arg0: $List$Type<(string)>, arg1: integer): integer
 "getIntOrElse"(arg0: string, arg1: $IntSupplier$Type): integer
 "getOptionalInt"(arg0: $List$Type<(string)>): $OptionalInt
 "getOptionalInt"(arg0: string): $OptionalInt
 "getShortOrElse"(arg0: string, arg1: short): short
 "getShortOrElse"(arg0: $List$Type<(string)>, arg1: short): short
 "getLongOrElse"(arg0: $List$Type<(string)>, arg1: $LongSupplier$Type): long
 "getLongOrElse"(arg0: string, arg1: $LongSupplier$Type): long
 "getLongOrElse"(arg0: $List$Type<(string)>, arg1: long): long
 "getLongOrElse"(arg0: string, arg1: long): long
 "getOptionalLong"(arg0: $List$Type<(string)>): $OptionalLong
 "getOptionalLong"(arg0: string): $OptionalLong
 "getByteOrElse"(arg0: string, arg1: byte): byte
 "getByteOrElse"(arg0: $List$Type<(string)>, arg1: byte): byte
 "getCharOrElse"(arg0: string, arg1: character): character
 "getCharOrElse"(arg0: $List$Type<(string)>, arg1: character): character
 "getOptional"<T>(arg0: $List$Type<(string)>): $Optional<(T)>
 "getOptional"<T>(arg0: string): $Optional<(T)>
 "getRaw"<T>(arg0: string): T
 "getRaw"<T>(arg0: $List$Type<(string)>): T
 "getOrElse"<T>(arg0: $List$Type<(string)>, arg1: $Supplier$Type<(T)>): T
 "getOrElse"<T>(arg0: $List$Type<(string)>, arg1: T): T
 "getOrElse"<T>(arg0: string, arg1: $Supplier$Type<(T)>): T
 "getOrElse"<T>(arg0: string, arg1: T): T
 "getOptionalEnum"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>): $Optional<(T)>
 "getOptionalEnum"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type): $Optional<(T)>
 "getOptionalEnum"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>): $Optional<(T)>
 "getOptionalEnum"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type): $Optional<(T)>
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: T): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: string, arg1: T): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: T, arg2: $EnumGetMethod$Type): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: string, arg1: T, arg2: $EnumGetMethod$Type): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>, arg2: $Supplier$Type<(T)>): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type, arg3: $Supplier$Type<(T)>): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type, arg3: $Supplier$Type<(T)>): T
 "getEnumOrElse"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>, arg2: $Supplier$Type<(T)>): T
 "configFormat"(): $ConfigFormat<(any)>
 "getEnum"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>): T
 "getEnum"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type): T
 "getEnum"<T extends $Enum<(T)>>(arg0: $List$Type<(string)>, arg1: $Class$Type<(T)>): T
 "getEnum"<T extends $Enum<(T)>>(arg0: string, arg1: $Class$Type<(T)>, arg2: $EnumGetMethod$Type): T
 "valueMap"(): $Map<(string), (any)>
}

export namespace $IConfigSpec {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConfigSpec$Type<T> = ($IConfigSpec<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConfigSpec_<T> = $IConfigSpec$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$RightClickEmpty" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"

export class $PlayerInteractEvent$RightClickEmpty extends $PlayerInteractEvent {

constructor(arg0: $Player$Type, arg1: $InteractionHand$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$RightClickEmpty$Type = ($PlayerInteractEvent$RightClickEmpty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$RightClickEmpty_ = $PlayerInteractEvent$RightClickEmpty$Type;
}}
declare module "packages/net/minecraftforge/network/$ConnectionType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ConnectionType extends $Enum<($ConnectionType)> {
static readonly "MODDED": $ConnectionType
static readonly "VANILLA": $ConnectionType


public static "values"(): ($ConnectionType)[]
public static "valueOf"(arg0: string): $ConnectionType
public static "forVersionFlag"(arg0: string): $ConnectionType
public "getFMLVersionNumber"(arg0: string): integer
public "isVanilla"(): boolean
get "vanilla"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionType$Type = (("modded") | ("vanilla")) | ($ConnectionType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionType_ = $ConnectionType$Type;
}}
declare module "packages/net/minecraftforge/common/$IPlantable" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$PlantType, $PlantType$Type} from "packages/net/minecraftforge/common/$PlantType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IPlantable {

 "getPlant"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): $BlockState
 "getPlantType"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): $PlantType

(arg0: $BlockGetter$Type, arg1: $BlockPos$Type): $BlockState
}

export namespace $IPlantable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPlantable$Type = ($IPlantable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPlantable_ = $IPlantable$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeDimensionSpecialEffects" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Camera, $Camera$Type} from "packages/net/minecraft/client/$Camera"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$LightTexture, $LightTexture$Type} from "packages/net/minecraft/client/renderer/$LightTexture"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $IForgeDimensionSpecialEffects {

 "tickRain"(arg0: $ClientLevel$Type, arg1: integer, arg2: $Camera$Type): boolean
 "renderSnowAndRain"(arg0: $ClientLevel$Type, arg1: integer, arg2: float, arg3: $LightTexture$Type, arg4: double, arg5: double, arg6: double): boolean
 "renderSky"(arg0: $ClientLevel$Type, arg1: integer, arg2: float, arg3: $PoseStack$Type, arg4: $Camera$Type, arg5: $Matrix4f$Type, arg6: boolean, arg7: $Runnable$Type): boolean
 "adjustLightmapColors"(arg0: $ClientLevel$Type, arg1: float, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: integer, arg7: $Vector3f$Type): void
 "renderClouds"(arg0: $ClientLevel$Type, arg1: integer, arg2: float, arg3: $PoseStack$Type, arg4: double, arg5: double, arg6: double, arg7: $Matrix4f$Type): boolean
}

export namespace $IForgeDimensionSpecialEffects {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeDimensionSpecialEffects$Type = ($IForgeDimensionSpecialEffects);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeDimensionSpecialEffects_ = $IForgeDimensionSpecialEffects$Type;
}}
declare module "packages/net/minecraftforge/client/model/$EmptyModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$SimpleUnbakedGeometry, $SimpleUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$SimpleUnbakedGeometry"
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $EmptyModel extends $SimpleUnbakedGeometry<($EmptyModel)> {
static readonly "BAKED": $BakedModel
static readonly "INSTANCE": $EmptyModel
static readonly "LOADER": $IGeometryLoader<($EmptyModel)>


public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyModel$Type = ($EmptyModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyModel_ = $EmptyModel$Type;
}}
declare module "packages/net/minecraftforge/network/simple/$SimpleChannel$MessageBuilder" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$NetworkEvent$Context, $NetworkEvent$Context$Type} from "packages/net/minecraftforge/network/$NetworkEvent$Context"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$SimpleChannel$MessageBuilder$ToBooleanBiFunction, $SimpleChannel$MessageBuilder$ToBooleanBiFunction$Type} from "packages/net/minecraftforge/network/simple/$SimpleChannel$MessageBuilder$ToBooleanBiFunction"

export class $SimpleChannel$MessageBuilder<MSG> {

constructor()

public "add"(): void
public "encoder"(arg0: $BiConsumer$Type<(MSG), ($FriendlyByteBuf$Type)>): $SimpleChannel$MessageBuilder<(MSG)>
public "decoder"(arg0: $Function$Type<($FriendlyByteBuf$Type), (MSG)>): $SimpleChannel$MessageBuilder<(MSG)>
public "loginIndex"(arg0: $Function$Type<(MSG), (integer)>, arg1: $BiConsumer$Type<(MSG), (integer)>): $SimpleChannel$MessageBuilder<(MSG)>
public "noResponse"(): $SimpleChannel$MessageBuilder<(MSG)>
public "markAsLoginPacket"(): $SimpleChannel$MessageBuilder<(MSG)>
public "consumerMainThread"(arg0: $BiConsumer$Type<(MSG), ($Supplier$Type<($NetworkEvent$Context$Type)>)>): $SimpleChannel$MessageBuilder<(MSG)>
public "buildLoginPacketList"(arg0: $Function$Type<(boolean), ($List$Type<($Pair$Type<(string), (MSG)>)>)>): $SimpleChannel$MessageBuilder<(MSG)>
public "consumerNetworkThread"(arg0: $SimpleChannel$MessageBuilder$ToBooleanBiFunction$Type<(MSG), ($Supplier$Type<($NetworkEvent$Context$Type)>)>): $SimpleChannel$MessageBuilder<(MSG)>
public "consumerNetworkThread"(arg0: $BiConsumer$Type<(MSG), ($Supplier$Type<($NetworkEvent$Context$Type)>)>): $SimpleChannel$MessageBuilder<(MSG)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleChannel$MessageBuilder$Type<MSG> = ($SimpleChannel$MessageBuilder<(MSG)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleChannel$MessageBuilder_<MSG> = $SimpleChannel$MessageBuilder$Type<(MSG)>;
}}
declare module "packages/net/minecraftforge/event/level/$ChunkWatchEvent" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $ChunkWatchEvent extends $Event {

constructor()
constructor(arg0: $ServerPlayer$Type, arg1: $ChunkPos$Type, arg2: $ServerLevel$Type)

public "getLevel"(): $ServerLevel
public "isCancelable"(): boolean
public "getPlayer"(): $ServerPlayer
public "getPos"(): $ChunkPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $ServerLevel
get "cancelable"(): boolean
get "player"(): $ServerPlayer
get "pos"(): $ChunkPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkWatchEvent$Type = ($ChunkWatchEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkWatchEvent_ = $ChunkWatchEvent$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeGuiGraphics" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IForgeGuiGraphics {

 "getColorFromFormattingCharacter"(arg0: character, arg1: boolean): integer
 "blitNineSlicedSized"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer): void
 "blitNineSlicedSized"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer): void
 "blitNineSlicedSized"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer): void
 "blitWithBorder"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): void
 "blitWithBorder"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer): void
 "blitInscribed"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): void
 "blitInscribed"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: boolean, arg8: boolean): void
}

export namespace $IForgeGuiGraphics {
const DEFAULT_BACKGROUND_COLOR: integer
const DEFAULT_BORDER_COLOR_START: integer
const DEFAULT_BORDER_COLOR_END: integer
const UNDO_CHAR: string
const RESET_CHAR: string
const VALID: string
const INVALID: string
const TEXT_COLOR_CODES: (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeGuiGraphics$Type = ($IForgeGuiGraphics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeGuiGraphics_ = $IForgeGuiGraphics$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$EnumValue" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfigSpec$EnumValue<T extends $Enum<(T)>> extends $ForgeConfigSpec$ConfigValue<(T)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$EnumValue$Type<T> = ($ForgeConfigSpec$EnumValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$EnumValue_<T> = $ForgeConfigSpec$EnumValue$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/$RegisterCommandsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$Commands$CommandSelection, $Commands$CommandSelection$Type} from "packages/net/minecraft/commands/$Commands$CommandSelection"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $RegisterCommandsEvent extends $Event {

constructor()
constructor(arg0: $CommandDispatcher$Type<($CommandSourceStack$Type)>, arg1: $Commands$CommandSelection$Type, arg2: $CommandBuildContext$Type)

public "isCancelable"(): boolean
public "getDispatcher"(): $CommandDispatcher<($CommandSourceStack)>
public "getBuildContext"(): $CommandBuildContext
public "getCommandSelection"(): $Commands$CommandSelection
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "dispatcher"(): $CommandDispatcher<($CommandSourceStack)>
get "buildContext"(): $CommandBuildContext
get "commandSelection"(): $Commands$CommandSelection
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterCommandsEvent$Type = ($RegisterCommandsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterCommandsEvent_ = $RegisterCommandsEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$ItemStackedOnOtherEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$SlotAccess, $SlotAccess$Type} from "packages/net/minecraft/world/entity/$SlotAccess"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ClickAction, $ClickAction$Type} from "packages/net/minecraft/world/inventory/$ClickAction"

export class $ItemStackedOnOtherEvent extends $Event {

constructor()
constructor(arg0: $ItemStack$Type, arg1: $ItemStack$Type, arg2: $Slot$Type, arg3: $ClickAction$Type, arg4: $Player$Type, arg5: $SlotAccess$Type)

public "getSlot"(): $Slot
public "isCancelable"(): boolean
public "getPlayer"(): $Player
public "getCarriedSlotAccess"(): $SlotAccess
public "getClickAction"(): $ClickAction
public "getCarriedItem"(): $ItemStack
public "getStackedOnItem"(): $ItemStack
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "slot"(): $Slot
get "cancelable"(): boolean
get "player"(): $Player
get "carriedSlotAccess"(): $SlotAccess
get "clickAction"(): $ClickAction
get "carriedItem"(): $ItemStack
get "stackedOnItem"(): $ItemStack
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackedOnOtherEvent$Type = ($ItemStackedOnOtherEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackedOnOtherEvent_ = $ItemStackedOnOtherEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjModel$ModelSettings" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ObjModel$ModelSettings extends $Record {

constructor(modelLocation: $ResourceLocation$Type, automaticCulling: boolean, shadeQuads: boolean, flipV: boolean, emissiveAmbient: boolean, mtlOverride: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "emissiveAmbient"(): boolean
public "mtlOverride"(): string
public "shadeQuads"(): boolean
public "automaticCulling"(): boolean
public "flipV"(): boolean
public "modelLocation"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjModel$ModelSettings$Type = ($ObjModel$ModelSettings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjModel$ModelSettings_ = $ObjModel$ModelSettings$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$ConditionalAdvancement$Builder" {
import {$Advancement$Builder, $Advancement$Builder$Type} from "packages/net/minecraft/advancements/$Advancement$Builder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $ConditionalAdvancement$Builder {

constructor()

public "write"(): $JsonObject
public "addCondition"(arg0: $ICondition$Type): $ConditionalAdvancement$Builder
public "addAdvancement"(arg0: $Advancement$Builder$Type): $ConditionalAdvancement$Builder
public "addAdvancement"(arg0: $FinishedRecipe$Type): $ConditionalAdvancement$Builder
public "addAdvancement"(arg0: $Consumer$Type<($Consumer$Type<($Advancement$Builder$Type)>)>): $ConditionalAdvancement$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalAdvancement$Builder$Type = ($ConditionalAdvancement$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalAdvancement$Builder_ = $ConditionalAdvancement$Builder$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $LivingEntityUseItemEvent extends $LivingEvent {

constructor()

public "getDuration"(): integer
public "getItem"(): $ItemStack
public "setDuration"(arg0: integer): void
public "getListenerList"(): $ListenerList
get "duration"(): integer
get "item"(): $ItemStack
set "duration"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityUseItemEvent$Type = ($LivingEntityUseItemEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityUseItemEvent_ = $LivingEntityUseItemEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$PlaySoundEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraftforge/client/event/sound/$SoundEvent"

export class $PlaySoundEvent extends $SoundEvent {

constructor(arg0: $SoundEngine$Type, arg1: $SoundInstance$Type)
constructor()

public "getName"(): string
public "setSound"(arg0: $SoundInstance$Type): void
public "getOriginalSound"(): $SoundInstance
public "getSound"(): $SoundInstance
public "getListenerList"(): $ListenerList
get "name"(): string
set "sound"(value: $SoundInstance$Type)
get "originalSound"(): $SoundInstance
get "sound"(): $SoundInstance
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlaySoundEvent$Type = ($PlaySoundEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlaySoundEvent_ = $PlaySoundEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeItemStack" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ICapabilitySerializable, $ICapabilitySerializable$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilitySerializable"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IForgeItemStack extends $ICapabilitySerializable<($CompoundTag)> {

 "equals"(arg0: $ItemStack$Type, arg1: boolean): boolean
 "getHighlightTip"(arg0: $Component$Type): $Component
 "getEnchantmentLevel"(arg0: $Enchantment$Type): integer
 "canDisableShield"(arg0: $ItemStack$Type, arg1: $LivingEntity$Type, arg2: $LivingEntity$Type): boolean
 "canPerformAction"(arg0: $ToolAction$Type): boolean
 "getSweepHitBox"(arg0: $Player$Type, arg1: $Entity$Type): $AABB
 "canElytraFly"(arg0: $LivingEntity$Type): boolean
 "makesPiglinsNeutral"(arg0: $LivingEntity$Type): boolean
 "canWalkOnPowderedSnow"(arg0: $LivingEntity$Type): boolean
 "hasCraftingRemainingItem"(): boolean
 "getCraftingRemainingItem"(): $ItemStack
 "canGrindstoneRepair"(): boolean
 "getEnchantmentValue"(): integer
 "canApplyAtEnchantingTable"(arg0: $Enchantment$Type): boolean
 "isNotReplaceableByPickAction"(arg0: $Player$Type, arg1: integer): boolean
 "shouldCauseBlockBreakReset"(arg0: $ItemStack$Type): boolean
 "onEntitySwing"(arg0: $LivingEntity$Type): boolean
 "elytraFlightTick"(arg0: $LivingEntity$Type, arg1: integer): boolean
 "getFoodProperties"(arg0: $LivingEntity$Type): $FoodProperties
 "onStopUsing"(arg0: $LivingEntity$Type, arg1: integer): void
 "getEquipmentSlot"(): $EquipmentSlot
 "isRepairable"(): boolean
 "onDroppedByPlayer"(arg0: $Player$Type): boolean
 "onItemUseFirst"(arg0: $UseOnContext$Type): $InteractionResult
 "isPiglinCurrency"(): boolean
 "isBookEnchantable"(arg0: $ItemStack$Type): boolean
 "readShareTag"(arg0: $CompoundTag$Type): void
 "getXpRepairRatio"(): float
 "getShareTag"(): $CompoundTag
 "doesSneakBypassUse"(arg0: $LevelReader$Type, arg1: $BlockPos$Type, arg2: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
 "onArmorTick"(arg0: $Level$Type, arg1: $Player$Type): void
 "onInventoryTick"(arg0: $Level$Type, arg1: $Player$Type, arg2: integer, arg3: integer): void
 "canEquip"(arg0: $EquipmentSlot$Type, arg1: $Entity$Type): boolean
 "onBlockStartBreak"(arg0: $BlockPos$Type, arg1: $Player$Type): boolean
 "getBurnTime"(arg0: $RecipeType$Type<(any)>): integer
 "onHorseArmorTick"(arg0: $Level$Type, arg1: $Mob$Type): void
 "isEnderMask"(arg0: $Player$Type, arg1: $EnderMan$Type): boolean
 "areShareTagsEqual"(arg0: $ItemStack$Type): boolean
 "getAllEnchantments"(): $Map<($Enchantment), (integer)>
 "getEntityLifespan"(arg0: $Level$Type): integer
 "onEntityItemUpdate"(arg0: $ItemEntity$Type): boolean
 "onDestroyed"(arg0: $ItemEntity$Type, arg1: $DamageSource$Type): void
 "serializeNBT"(): $CompoundTag
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
 "deserializeNBT"(arg0: $CompoundTag$Type): void
}

export namespace $IForgeItemStack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeItemStack$Type = ($IForgeItemStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeItemStack_ = $IForgeItemStack$Type;
}}
declare module "packages/net/minecraftforge/common/data/$JsonCodecProvider" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$CachedOutput, $CachedOutput$Type} from "packages/net/minecraft/data/$CachedOutput"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$DataProvider, $DataProvider$Type} from "packages/net/minecraft/data/$DataProvider"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$PackOutput, $PackOutput$Type} from "packages/net/minecraft/data/$PackOutput"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ICondition, $ICondition$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition"

export class $JsonCodecProvider<T> implements $DataProvider {

constructor(arg0: $PackOutput$Type, arg1: $ExistingFileHelper$Type, arg2: string, arg3: $DynamicOps$Type<($JsonElement$Type)>, arg4: $PackType$Type, arg5: string, arg6: $Codec$Type<(T)>, arg7: $Map$Type<($ResourceLocation$Type), (T)>)

public "setConditions"(arg0: $Map$Type<($ResourceLocation$Type), (($ICondition$Type)[])>): $JsonCodecProvider<(T)>
public "run"(arg0: $CachedOutput$Type): $CompletableFuture<(any)>
public "getName"(): string
public static "saveStable"(arg0: $CachedOutput$Type, arg1: $JsonElement$Type, arg2: $Path$Type): $CompletableFuture<(any)>
set "conditions"(value: $Map$Type<($ResourceLocation$Type), (($ICondition$Type)[])>)
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonCodecProvider$Type<T> = ($JsonCodecProvider<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonCodecProvider_<T> = $JsonCodecProvider$Type<(T)>;
}}
declare module "packages/net/minecraftforge/fml/core/$ParallelTransition" {
import {$ModLoadingStage, $ModLoadingStage$Type} from "packages/net/minecraftforge/fml/$ModLoadingStage"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModStateTransition, $IModStateTransition$Type} from "packages/net/minecraftforge/fml/$IModStateTransition"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"
import {$ProgressMeter, $ProgressMeter$Type} from "packages/net/minecraftforge/fml/loading/progress/$ProgressMeter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ThreadSelector, $ThreadSelector$Type} from "packages/net/minecraftforge/fml/$ThreadSelector"
import {$IModStateTransition$EventGenerator, $IModStateTransition$EventGenerator$Type} from "packages/net/minecraftforge/fml/$IModStateTransition$EventGenerator"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ParallelTransition extends $Record implements $IModStateTransition {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "event"(): $Class<(any)>
public "stage"(): $ModLoadingStage
public "postDispatchHook"(): $BiFunction<($Executor), (any), ($CompletableFuture<(void)>)>
public "preDispatchHook"(): $BiFunction<($Executor), (any), ($CompletableFuture<(void)>)>
public "threadSelector"(): $ThreadSelector
public "eventFunctionStream"(): $Supplier<($Stream<($IModStateTransition$EventGenerator<(any)>)>)>
public "finalActivityGenerator"(): $BiFunction<($Executor), ($CompletableFuture<(void)>), ($CompletableFuture<(void)>)>
public "build"<T extends ($Event) & ($IModBusEvent)>(arg0: string, arg1: $Executor$Type, arg2: $Executor$Type, arg3: $ProgressMeter$Type, arg4: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>, arg5: $Function$Type<($Executor$Type), ($CompletableFuture$Type<(void)>)>): $CompletableFuture<(void)>
public "nextModLoadingStage"(): $BiFunction<($ModLoadingStage), ($Throwable), ($ModLoadingStage)>
public static "buildNoopTransition"(): $IModStateTransition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParallelTransition$Type = ($ParallelTransition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParallelTransition_ = $ParallelTransition$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerRespawnEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerEvent$PlayerRespawnEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: boolean)

public "isEndConquered"(): boolean
public "getListenerList"(): $ListenerList
get "endConquered"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$PlayerRespawnEvent$Type = ($PlayerEvent$PlayerRespawnEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$PlayerRespawnEvent_ = $PlayerEvent$PlayerRespawnEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$PlaySoundSourceEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Channel, $Channel$Type} from "packages/com/mojang/blaze3d/audio/$Channel"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"
import {$SoundEvent$SoundSourceEvent, $SoundEvent$SoundSourceEvent$Type} from "packages/net/minecraftforge/client/event/sound/$SoundEvent$SoundSourceEvent"

export class $PlaySoundSourceEvent extends $SoundEvent$SoundSourceEvent {

constructor(arg0: $SoundEngine$Type, arg1: $SoundInstance$Type, arg2: $Channel$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlaySoundSourceEvent$Type = ($PlaySoundSourceEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlaySoundSourceEvent_ = $PlaySoundSourceEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RenderPlayerEvent$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$PlayerRenderer, $PlayerRenderer$Type} from "packages/net/minecraft/client/renderer/entity/player/$PlayerRenderer"
import {$RenderPlayerEvent, $RenderPlayerEvent$Type} from "packages/net/minecraftforge/client/event/$RenderPlayerEvent"

export class $RenderPlayerEvent$Pre extends $RenderPlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $PlayerRenderer$Type, arg2: float, arg3: $PoseStack$Type, arg4: $MultiBufferSource$Type, arg5: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderPlayerEvent$Pre$Type = ($RenderPlayerEvent$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderPlayerEvent$Pre_ = $RenderPlayerEvent$Pre$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/$FluidHandlerBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $FluidHandlerBlockEntity extends $BlockEntity {
 "blockState": $BlockState

constructor(arg0: $BlockEntityType$Type<(any)>, arg1: $BlockPos$Type, arg2: $BlockState$Type)

public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "load"(arg0: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidHandlerBlockEntity$Type = ($FluidHandlerBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidHandlerBlockEntity_ = $FluidHandlerBlockEntity$Type;
}}
declare module "packages/net/minecraftforge/client/event/$RegisterKeyMappingsEvent" {
import {$KeyMapping, $KeyMapping$Type} from "packages/net/minecraft/client/$KeyMapping"
import {$Options, $Options$Type} from "packages/net/minecraft/client/$Options"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$IModBusEvent, $IModBusEvent$Type} from "packages/net/minecraftforge/fml/event/$IModBusEvent"

export class $RegisterKeyMappingsEvent extends $Event implements $IModBusEvent {

constructor()
constructor(arg0: $Options$Type)

public "register"(arg0: $KeyMapping$Type): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterKeyMappingsEvent$Type = ($RegisterKeyMappingsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterKeyMappingsEvent_ = $RegisterKeyMappingsEvent$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$MouseDragged$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$MouseDragged, $ScreenEvent$MouseDragged$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$MouseDragged"

export class $ScreenEvent$MouseDragged$Pre extends $ScreenEvent$MouseDragged {

constructor()
constructor(arg0: $Screen$Type, arg1: double, arg2: double, arg3: integer, arg4: double, arg5: double)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$MouseDragged$Pre$Type = ($ScreenEvent$MouseDragged$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$MouseDragged$Pre_ = $ScreenEvent$MouseDragged$Pre$Type;
}}
declare module "packages/net/minecraftforge/server/command/$ChunkGenWorker" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$WorldWorkerManager$IWorker, $WorldWorkerManager$IWorker$Type} from "packages/net/minecraftforge/common/$WorldWorkerManager$IWorker"

export class $ChunkGenWorker implements $WorldWorkerManager$IWorker {

constructor(arg0: $CommandSourceStack$Type, arg1: $BlockPos$Type, arg2: integer, arg3: $ServerLevel$Type, arg4: integer)

public "doWork"(): boolean
public "getStartMessage"(arg0: $CommandSourceStack$Type): $MutableComponent
public "hasWork"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkGenWorker$Type = ($ChunkGenWorker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkGenWorker_ = $ChunkGenWorker$Type;
}}
declare module "packages/net/minecraftforge/event/level/$NoteBlockEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$NoteBlockEvent$Octave, $NoteBlockEvent$Octave$Type} from "packages/net/minecraftforge/event/level/$NoteBlockEvent$Octave"
import {$NoteBlockEvent$Note, $NoteBlockEvent$Note$Type} from "packages/net/minecraftforge/event/level/$NoteBlockEvent$Note"
import {$BlockEvent, $BlockEvent$Type} from "packages/net/minecraftforge/event/level/$BlockEvent"

export class $NoteBlockEvent extends $BlockEvent {

constructor()

public "getNote"(): $NoteBlockEvent$Note
public "getOctave"(): $NoteBlockEvent$Octave
public "setNote"(arg0: $NoteBlockEvent$Note$Type, arg1: $NoteBlockEvent$Octave$Type): void
public "getListenerList"(): $ListenerList
public "getVanillaNoteId"(): integer
get "note"(): $NoteBlockEvent$Note
get "octave"(): $NoteBlockEvent$Octave
get "listenerList"(): $ListenerList
get "vanillaNoteId"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockEvent$Type = ($NoteBlockEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoteBlockEvent_ = $NoteBlockEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerSpawnPhantomsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event$Result, $Event$Result$Type} from "packages/net/minecraftforge/eventbus/api/$Event$Result"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerSpawnPhantomsEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: integer)

public "setResult"(arg0: $Event$Result$Type): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "setPhantomsToSpawn"(arg0: integer): void
public "getPhantomsToSpawn"(): integer
set "result"(value: $Event$Result$Type)
get "listenerList"(): $ListenerList
set "phantomsToSpawn"(value: integer)
get "phantomsToSpawn"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSpawnPhantomsEvent$Type = ($PlayerSpawnPhantomsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerSpawnPhantomsEvent_ = $PlayerSpawnPhantomsEvent$Type;
}}
declare module "packages/net/minecraftforge/entity/$IEntityAdditionalSpawnData" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export interface $IEntityAdditionalSpawnData {

 "writeSpawnData"(arg0: $FriendlyByteBuf$Type): void
 "readSpawnData"(arg0: $FriendlyByteBuf$Type): void
}

export namespace $IEntityAdditionalSpawnData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEntityAdditionalSpawnData$Type = ($IEntityAdditionalSpawnData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEntityAdditionalSpawnData_ = $IEntityAdditionalSpawnData$Type;
}}
declare module "packages/net/minecraftforge/network/$ServerStatusPing" {
import {$ServerStatusPing$ChannelData, $ServerStatusPing$ChannelData$Type} from "packages/net/minecraftforge/network/$ServerStatusPing$ChannelData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ByteBuf, $ByteBuf$Type} from "packages/io/netty/buffer/$ByteBuf"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServerStatusPing extends $Record {
static readonly "CODEC": $Codec<($ServerStatusPing)>

constructor()
constructor(channels: $Map$Type<($ResourceLocation$Type), ($ServerStatusPing$ChannelData$Type)>, mods: $Map$Type<(string), (string)>, fmlNetworkVer: integer, truncated: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "mods"(): $Map<(string), (string)>
public "truncated"(): boolean
public "channels"(): $Map<($ResourceLocation), ($ServerStatusPing$ChannelData)>
public "toBuf"(): $ByteBuf
public "fmlNetworkVer"(): integer
public "isTruncated"(): boolean
public "getRemoteChannels"(): $Map<($ResourceLocation), ($ServerStatusPing$ChannelData)>
public "getRemoteModData"(): $Map<(string), (string)>
public "getFMLNetworkVersion"(): integer
get "remoteChannels"(): $Map<($ResourceLocation), ($ServerStatusPing$ChannelData)>
get "remoteModData"(): $Map<(string), (string)>
get "fMLNetworkVersion"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStatusPing$Type = ($ServerStatusPing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStatusPing_ = $ServerStatusPing$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfig$Server" {
import {$ForgeConfigSpec$BooleanValue, $ForgeConfigSpec$BooleanValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$BooleanValue"
import {$ForgeConfigSpec$DoubleValue, $ForgeConfigSpec$DoubleValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$DoubleValue"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"

export class $ForgeConfig$Server {
readonly "removeErroringBlockEntities": $ForgeConfigSpec$BooleanValue
readonly "removeErroringEntities": $ForgeConfigSpec$BooleanValue
readonly "fullBoundingBoxLadders": $ForgeConfigSpec$BooleanValue
readonly "zombieBaseSummonChance": $ForgeConfigSpec$DoubleValue
readonly "zombieBabyChance": $ForgeConfigSpec$DoubleValue
readonly "permissionHandler": $ForgeConfigSpec$ConfigValue<(string)>
readonly "advertiseDedicatedServerToLan": $ForgeConfigSpec$BooleanValue


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfig$Server$Type = ($ForgeConfig$Server);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfig$Server_ = $ForgeConfig$Server$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$AnyHolderSet" {
import {$IForgeHolderSet$SerializationType, $IForgeHolderSet$SerializationType$Type} from "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$Type} from "packages/net/minecraft/core/$HolderLookup$RegistryLookup"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ICustomHolderSet, $ICustomHolderSet$Type} from "packages/net/minecraftforge/registries/holdersets/$ICustomHolderSet"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $AnyHolderSet<T> extends $Record implements $ICustomHolderSet<(T)> {

constructor(registryLookup: $HolderLookup$RegistryLookup$Type<(T)>)

public "type"(): $HolderSetType
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "iterator"(): $Iterator<($Holder<(T)>)>
public "registryLookup"(): $HolderLookup$RegistryLookup<(T)>
public "contains"(arg0: $Holder$Type<(T)>): boolean
public "stream"(): $Stream<($Holder<(T)>)>
public "canSerializeIn"(arg0: $HolderOwner$Type<(T)>): boolean
public "size"(): integer
public "get"(arg0: integer): $Holder<(T)>
public "unwrapKey"(): $Optional<($TagKey<(T)>)>
public "getRandomElement"(arg0: $RandomSource$Type): $Optional<($Holder<(T)>)>
public static "codec"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>
public "unwrap"(): $Either<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "serializationType"(): $IForgeHolderSet$SerializationType
public static "direct"<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
public static "direct"<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
/**
 * 
 * @deprecated
 */
public static "emptyNamed"<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
public "spliterator"(): $Spliterator<($Holder<(T)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "addInvalidationListener"(arg0: $Runnable$Type): void
[Symbol.iterator](): IterableIterator<$Holder<(T)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyHolderSet$Type<T> = ($AnyHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnyHolderSet_<T> = $AnyHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/event/server/$ServerStartedEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLifecycleEvent, $ServerLifecycleEvent$Type} from "packages/net/minecraftforge/event/server/$ServerLifecycleEvent"

export class $ServerStartedEvent extends $ServerLifecycleEvent {

constructor(arg0: $MinecraftServer$Type)
constructor()

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerStartedEvent$Type = ($ServerStartedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerStartedEvent_ = $ServerStartedEvent$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeBaseRailBlock" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$AbstractMinecart, $AbstractMinecart$Type} from "packages/net/minecraft/world/entity/vehicle/$AbstractMinecart"
import {$RailShape, $RailShape$Type} from "packages/net/minecraft/world/level/block/state/properties/$RailShape"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IForgeBaseRailBlock {

 "getRailDirection"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type, arg3: $AbstractMinecart$Type): $RailShape
 "getRailMaxSpeed"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $AbstractMinecart$Type): float
 "isValidRailShape"(arg0: $RailShape$Type): boolean
 "canMakeSlopes"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "isFlexibleRail"(arg0: $BlockState$Type, arg1: $BlockGetter$Type, arg2: $BlockPos$Type): boolean
 "onMinecartPass"(arg0: $BlockState$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $AbstractMinecart$Type): void
}

export namespace $IForgeBaseRailBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBaseRailBlock$Type = ($IForgeBaseRailBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBaseRailBlock_ = $IForgeBaseRailBlock$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/$ItemFluidContainer" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemFluidContainer extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(arg0: $Item$Properties$Type, arg1: integer)

public "initCapabilities"(arg0: $ItemStack$Type, arg1: $CompoundTag$Type): $ICapabilityProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFluidContainer$Type = ($ItemFluidContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFluidContainer_ = $ItemFluidContainer$Type;
}}
declare module "packages/net/minecraftforge/event/village/$VillagerTradesEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$List, $List$Type} from "packages/java/util/$List"
import {$VillagerTrades$ItemListing, $VillagerTrades$ItemListing$Type} from "packages/net/minecraft/world/entity/npc/$VillagerTrades$ItemListing"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$VillagerProfession, $VillagerProfession$Type} from "packages/net/minecraft/world/entity/npc/$VillagerProfession"

export class $VillagerTradesEvent extends $Event {

constructor(arg0: $Int2ObjectMap$Type<($List$Type<($VillagerTrades$ItemListing$Type)>)>, arg1: $VillagerProfession$Type)
constructor()

public "getType"(): $VillagerProfession
public "isCancelable"(): boolean
public "getTrades"(): $Int2ObjectMap<($List<($VillagerTrades$ItemListing)>)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "type"(): $VillagerProfession
get "cancelable"(): boolean
get "trades"(): $Int2ObjectMap<($List<($VillagerTrades$ItemListing)>)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTradesEvent$Type = ($VillagerTradesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerTradesEvent_ = $VillagerTradesEvent$Type;
}}
declare module "packages/net/minecraftforge/client/extensions/$IForgeBlockAndTintGetter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IForgeBlockAndTintGetter {

 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
}

export namespace $IForgeBlockAndTintGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeBlockAndTintGetter$Type = ($IForgeBlockAndTintGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeBlockAndTintGetter_ = $IForgeBlockAndTintGetter$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeLivingEntity" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Boat, $Boat$Type} from "packages/net/minecraft/world/entity/vehicle/$Boat"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$SoundAction, $SoundAction$Type} from "packages/net/minecraftforge/common/$SoundAction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Pose, $Pose$Type} from "packages/net/minecraft/world/entity/$Pose"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IForgeEntity, $IForgeEntity$Type} from "packages/net/minecraftforge/common/extensions/$IForgeEntity"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$PartEntity, $PartEntity$Type} from "packages/net/minecraftforge/entity/$PartEntity"

export interface $IForgeLivingEntity extends $IForgeEntity {

 "self"(): $LivingEntity
 "sinkInFluid"(arg0: $FluidType$Type): void
 "moveInFluid"(arg0: $FluidState$Type, arg1: $Vec3$Type, arg2: double): boolean
 "jumpInFluid"(arg0: $FluidType$Type): void
 "canDrownInFluidType"(arg0: $FluidType$Type): boolean
 "canSwimInFluidType"(arg0: $FluidType$Type): boolean
 "getPickedResult"(arg0: $HitResult$Type): $ItemStack
 "getPersistentData"(): $CompoundTag
 "isInFluidType"(arg0: $BiPredicate$Type<($FluidType$Type), (double)>): boolean
 "isInFluidType"(arg0: $FluidType$Type): boolean
 "isInFluidType"(arg0: $FluidState$Type): boolean
 "isInFluidType"(): boolean
 "isInFluidType"(arg0: $BiPredicate$Type<($FluidType$Type), (double)>, arg1: boolean): boolean
 "captureDrops"(arg0: $Collection$Type<($ItemEntity$Type)>): $Collection<($ItemEntity)>
 "captureDrops"(): $Collection<($ItemEntity)>
 "getFluidTypeHeight"(arg0: $FluidType$Type): double
 "canFluidExtinguish"(arg0: $FluidType$Type): boolean
 "getMaxHeightFluidType"(): $FluidType
 "hasCustomOutlineRendering"(arg0: $Player$Type): boolean
 "getFluidFallDistanceModifier"(arg0: $FluidType$Type): float
 "shouldUpdateFluidWhileBoating"(arg0: $FluidState$Type, arg1: $Boat$Type): boolean
 "canBeRiddenUnderFluidType"(arg0: $FluidType$Type, arg1: $Entity$Type): boolean
 "getFluidMotionScale"(arg0: $FluidType$Type): double
 "getSoundFromFluidType"(arg0: $FluidType$Type, arg1: $SoundAction$Type): $SoundEvent
 "canHydrateInFluidType"(arg0: $FluidType$Type): boolean
 "canTrample"(arg0: $BlockState$Type, arg1: $BlockPos$Type, arg2: float): boolean
 "canRiderInteract"(): boolean
 "getClassification"(arg0: boolean): $MobCategory
 "deserializeNBT"(arg0: $CompoundTag$Type): void
 "serializeNBT"(): $CompoundTag
 "canUpdate"(arg0: boolean): void
 "canUpdate"(): boolean
 "shouldRiderSit"(): boolean
 "getStepHeight"(): float
/**
 * 
 * @deprecated
 */
 "getEyeHeightForge"(arg0: $Pose$Type, arg1: $EntityDimensions$Type): float
 "getEyeInFluidType"(): $FluidType
 "isAddedToWorld"(): boolean
 "isEyeInFluidType"(arg0: $FluidType$Type): boolean
 "isPushedByFluid"(arg0: $FluidType$Type): boolean
 "canStartSwimming"(): boolean
 "isMultipartEntity"(): boolean
 "getParts"(): ($PartEntity<(any)>)[]
 "revive"(): void
 "onAddedToWorld"(): void
 "onRemovedFromWorld"(): void
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}

export namespace $IForgeLivingEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeLivingEntity$Type = ($IForgeLivingEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeLivingEntity_ = $IForgeLivingEntity$Type;
}}
declare module "packages/net/minecraftforge/client/$ConfigScreenHandler$ConfigScreenFactory" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$IExtensionPoint, $IExtensionPoint$Type} from "packages/net/minecraftforge/fml/$IExtensionPoint"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $ConfigScreenHandler$ConfigScreenFactory extends $Record implements $IExtensionPoint<($ConfigScreenHandler$ConfigScreenFactory)> {

constructor(screenFunction: $BiFunction$Type<($Minecraft$Type), ($Screen$Type), ($Screen$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "screenFunction"(): $BiFunction<($Minecraft), ($Screen), ($Screen)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigScreenHandler$ConfigScreenFactory$Type = ($ConfigScreenHandler$ConfigScreenFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigScreenHandler$ConfigScreenFactory_ = $ConfigScreenHandler$ConfigScreenFactory$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/$CompoundIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $CompoundIngredient extends $AbstractIngredient {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(arg0: $ItemStack$Type): boolean
public static "of"(...arg0: ($Ingredient$Type)[]): $Ingredient
public "getChildren"(): $Collection<($Ingredient)>
public "isSimple"(): boolean
public "toJson"(): $JsonElement
public "getStackingIds"(): $IntList
public "isEmpty"(): boolean
public "getSerializer"(): $IIngredientSerializer<(any)>
public "canBeUsedForMatching"(): boolean
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "children"(): $Collection<($Ingredient)>
get "simple"(): boolean
get "stackingIds"(): $IntList
get "empty"(): boolean
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompoundIngredient$Type = ($CompoundIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompoundIngredient_ = $CompoundIngredient$Type;
}}
declare module "packages/net/minecraftforge/event/level/$NoteBlockEvent$Octave" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $NoteBlockEvent$Octave extends $Enum<($NoteBlockEvent$Octave)> {
static readonly "LOW": $NoteBlockEvent$Octave
static readonly "MID": $NoteBlockEvent$Octave
static readonly "HIGH": $NoteBlockEvent$Octave


public static "values"(): ($NoteBlockEvent$Octave)[]
public static "valueOf"(arg0: string): $NoteBlockEvent$Octave
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockEvent$Octave$Type = (("high") | ("low") | ("mid")) | ($NoteBlockEvent$Octave);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoteBlockEvent$Octave_ = $NoteBlockEvent$Octave$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ModelBuilder$ElementBuilder$RotationBuilder, $ModelBuilder$ElementBuilder$RotationBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder$RotationBuilder"
import {$ModelBuilder$ElementBuilder$FaceBuilder, $ModelBuilder$ElementBuilder$FaceBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$ElementBuilder$FaceBuilder"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $ModelBuilder$ElementBuilder {

constructor(arg0: $ModelBuilder$Type<(any)>)

public "end"(): T
public "to"(arg0: float, arg1: float, arg2: float): $ModelBuilder$ElementBuilder<>
public "from"(arg0: float, arg1: float, arg2: float): $ModelBuilder$ElementBuilder<>
public "ao"(arg0: boolean): $ModelBuilder$ElementBuilder<>
public "color"(arg0: integer): $ModelBuilder$ElementBuilder<>
public "calculateNormals"(arg0: boolean): $ModelBuilder$ElementBuilder<>
public "cube"(arg0: string): $ModelBuilder$ElementBuilder<>
public "rotation"(): $ModelBuilder$ElementBuilder$RotationBuilder<>
public "textureAll"(arg0: string): $ModelBuilder$ElementBuilder<>
public "face"(arg0: $Direction$Type): $ModelBuilder$ElementBuilder$FaceBuilder<>
public "shade"(arg0: boolean): $ModelBuilder$ElementBuilder<>
public "allFaces"(arg0: $BiConsumer$Type<($Direction$Type), ($ModelBuilder$ElementBuilder$FaceBuilder$Type<>)>): $ModelBuilder$ElementBuilder<>
public "texture"(arg0: string): $ModelBuilder$ElementBuilder<>
public "emissivity"(arg0: integer, arg1: integer): $ModelBuilder$ElementBuilder<>
public "faces"(arg0: $BiConsumer$Type<($Direction$Type), ($ModelBuilder$ElementBuilder$FaceBuilder$Type<>)>): $ModelBuilder$ElementBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$ElementBuilder$Type = ($ModelBuilder$ElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$ElementBuilder_ = $ModelBuilder$ElementBuilder$Type;
}}
declare module "packages/net/minecraftforge/client/model/geometry/$StandaloneGeometryBakingContext$Builder" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$Object2BooleanMap, $Object2BooleanMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanMap"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$Transformation, $Transformation$Type} from "packages/com/mojang/math/$Transformation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$StandaloneGeometryBakingContext, $StandaloneGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$StandaloneGeometryBakingContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StandaloneGeometryBakingContext$Builder {


public "build"(arg0: $ResourceLocation$Type): $StandaloneGeometryBakingContext
public "withGui3d"(arg0: boolean): $StandaloneGeometryBakingContext$Builder
public "withUseBlockLight"(arg0: boolean): $StandaloneGeometryBakingContext$Builder
public "withMaterials"(arg0: $Map$Type<(string), ($Material$Type)>, arg1: $Material$Type): $StandaloneGeometryBakingContext$Builder
public "withTransforms"(arg0: $ItemTransforms$Type): $StandaloneGeometryBakingContext$Builder
public "withTextures"(arg0: $Map$Type<(string), ($ResourceLocation$Type)>, arg1: $ResourceLocation$Type): $StandaloneGeometryBakingContext$Builder
public "withTextures"(arg0: $ResourceLocation$Type, arg1: $Map$Type<(string), ($ResourceLocation$Type)>, arg2: $ResourceLocation$Type): $StandaloneGeometryBakingContext$Builder
public "withRootTransform"(arg0: $Transformation$Type): $StandaloneGeometryBakingContext$Builder
public "withRenderTypeHint"(arg0: $ResourceLocation$Type): $StandaloneGeometryBakingContext$Builder
public "withUseAmbientOcclusion"(arg0: boolean): $StandaloneGeometryBakingContext$Builder
public "withVisibleComponents"(arg0: $Object2BooleanMap$Type<(string)>): $StandaloneGeometryBakingContext$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandaloneGeometryBakingContext$Builder$Type = ($StandaloneGeometryBakingContext$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StandaloneGeometryBakingContext$Builder_ = $StandaloneGeometryBakingContext$Builder$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingChangeTargetEvent$ILivingTargetType, $LivingChangeTargetEvent$ILivingTargetType$Type} from "packages/net/minecraftforge/event/entity/living/$LivingChangeTargetEvent$ILivingTargetType"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingChangeTargetEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $LivingEntity$Type, arg2: $LivingChangeTargetEvent$ILivingTargetType$Type)

public "isCancelable"(): boolean
public "getTargetType"(): $LivingChangeTargetEvent$ILivingTargetType
public "setNewTarget"(arg0: $LivingEntity$Type): void
public "getOriginalTarget"(): $LivingEntity
public "getNewTarget"(): $LivingEntity
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "targetType"(): $LivingChangeTargetEvent$ILivingTargetType
set "newTarget"(value: $LivingEntity$Type)
get "originalTarget"(): $LivingEntity
get "newTarget"(): $LivingEntity
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingChangeTargetEvent$Type = ($LivingChangeTargetEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingChangeTargetEvent_ = $LivingChangeTargetEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingDrownEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingDrownEvent extends $LivingEvent {

constructor()
/**
 * 
 * @deprecated
 */
constructor(arg0: $LivingEntity$Type, arg1: boolean)
constructor(arg0: $LivingEntity$Type, arg1: boolean, arg2: float, arg3: integer)

public "getDamageAmount"(): float
public "setCanceled"(arg0: boolean): void
public "isCancelable"(): boolean
public "setDamageAmount"(arg0: float): void
public "isDrowning"(): boolean
public "getBubbleCount"(): integer
public "setDrowning"(arg0: boolean): void
public "setBubbleCount"(arg0: integer): void
public "getListenerList"(): $ListenerList
get "damageAmount"(): float
set "canceled"(value: boolean)
get "cancelable"(): boolean
set "damageAmount"(value: float)
get "drowning"(): boolean
get "bubbleCount"(): integer
set "drowning"(value: boolean)
set "bubbleCount"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingDrownEvent$Type = ($LivingDrownEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingDrownEvent_ = $LivingDrownEvent$Type;
}}
declare module "packages/net/minecraftforge/server/command/$ModListCommand" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ModListCommand {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModListCommand$Type = ($ModListCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModListCommand_ = $ModListCommand$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ExplosionEvent$Start" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$ExplosionEvent, $ExplosionEvent$Type} from "packages/net/minecraftforge/event/level/$ExplosionEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"

export class $ExplosionEvent$Start extends $ExplosionEvent {

constructor()
constructor(arg0: $Level$Type, arg1: $Explosion$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEvent$Start$Type = ($ExplosionEvent$Start);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEvent$Start_ = $ExplosionEvent$Start$Type;
}}
declare module "packages/net/minecraftforge/client/gui/$CreativeTabsScreenPage" {
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$List, $List$Type} from "packages/java/util/$List"

export class $CreativeTabsScreenPage {

constructor(arg0: $List$Type<($CreativeModeTab$Type)>)

public "getVisibleTabs"(): $List<($CreativeModeTab)>
public "isTop"(arg0: $CreativeModeTab$Type): boolean
public "getColumn"(arg0: $CreativeModeTab$Type): integer
public "getDefaultTab"(): $CreativeModeTab
get "visibleTabs"(): $List<($CreativeModeTab)>
get "defaultTab"(): $CreativeModeTab
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabsScreenPage$Type = ($CreativeTabsScreenPage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabsScreenPage_ = $CreativeTabsScreenPage$Type;
}}
declare module "packages/net/minecraftforge/fml/$ModList" {
import {$ModContainer, $ModContainer$Type} from "packages/net/minecraftforge/fml/$ModContainer"
import {$ModFile, $ModFile$Type} from "packages/net/minecraftforge/fml/loading/moddiscovery/$ModFile"
import {$ModFileScanData, $ModFileScanData$Type} from "packages/net/minecraftforge/forgespi/language/$ModFileScanData"
import {$IModFileInfo, $IModFileInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModFileInfo"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IModInfo, $IModInfo$Type} from "packages/net/minecraftforge/forgespi/language/$IModInfo"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ModInfo, $ModInfo$Type} from "packages/net/minecraftforge/fml/loading/moddiscovery/$ModInfo"
import {$IModFile, $IModFile$Type} from "packages/net/minecraftforge/forgespi/locating/$IModFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ModList {


public static "get"(): $ModList
public "size"(): integer
public static "of"(arg0: $List$Type<($ModFile$Type)>, arg1: $List$Type<($ModInfo$Type)>): $ModList
public "isLoaded"(arg0: string): boolean
public "getMods"(): $List<($IModInfo)>
public "getModContainerByObject"(arg0: any): $Optional<(any)>
public "applyForEachModContainer"<T>(arg0: $Function$Type<($ModContainer$Type), (T)>): $Stream<(T)>
public "forEachModContainer"(arg0: $BiConsumer$Type<(string), ($ModContainer$Type)>): void
public "getModContainerById"(arg0: string): $Optional<(any)>
public "applyForEachModFile"<T>(arg0: $Function$Type<($IModFile$Type), (T)>): $Stream<(T)>
public "getModObjectById"<T>(arg0: string): $Optional<(T)>
public "forEachModFile"(arg0: $Consumer$Type<($IModFile$Type)>): void
public "forEachModInOrder"(arg0: $Consumer$Type<($ModContainer$Type)>): void
public "getAllScanData"(): $List<($ModFileScanData)>
public "getModFileById"(arg0: string): $IModFileInfo
public "getModFiles"(): $List<($IModFileInfo)>
get "mods"(): $List<($IModInfo)>
get "allScanData"(): $List<($ModFileScanData)>
get "modFiles"(): $List<($IModFileInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModList$Type = ($ModList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModList_ = $ModList$Type;
}}
declare module "packages/net/minecraftforge/client/model/obj/$ObjLoader" {
import {$ObjModel$ModelSettings, $ObjModel$ModelSettings$Type} from "packages/net/minecraftforge/client/model/obj/$ObjModel$ModelSettings"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PreparableReloadListener$PreparationBarrier, $PreparableReloadListener$PreparationBarrier$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener$PreparationBarrier"
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$ResourceManagerReloadListener, $ResourceManagerReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManagerReloadListener"
import {$ObjModel, $ObjModel$Type} from "packages/net/minecraftforge/client/model/obj/$ObjModel"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ObjMaterialLibrary, $ObjMaterialLibrary$Type} from "packages/net/minecraftforge/client/model/obj/$ObjMaterialLibrary"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$ProfilerFiller, $ProfilerFiller$Type} from "packages/net/minecraft/util/profiling/$ProfilerFiller"

export class $ObjLoader implements $IGeometryLoader<($ObjModel)>, $ResourceManagerReloadListener {
static "INSTANCE": $ObjLoader

constructor()

public "loadMaterialLibrary"(arg0: $ResourceLocation$Type): $ObjMaterialLibrary
public "loadModel"(arg0: $ObjModel$ModelSettings$Type): $ObjModel
public "onResourceManagerReload"(arg0: $ResourceManager$Type): void
public "reload"(arg0: $PreparableReloadListener$PreparationBarrier$Type, arg1: $ResourceManager$Type, arg2: $ProfilerFiller$Type, arg3: $ProfilerFiller$Type, arg4: $Executor$Type, arg5: $Executor$Type): $CompletableFuture<(void)>
public "getName"(): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjLoader$Type = ($ObjLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjLoader_ = $ObjLoader$Type;
}}
declare module "packages/net/minecraftforge/server/timings/$TimeTracker" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$ForgeTimings, $ForgeTimings$Type} from "packages/net/minecraftforge/server/timings/$ForgeTimings"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $TimeTracker<T> {
static readonly "BLOCK_ENTITY_UPDATE": $TimeTracker<($BlockEntity)>
static readonly "ENTITY_UPDATE": $TimeTracker<($Entity)>

constructor()

public "reset"(): void
public "enable"(arg0: integer): void
public "trackStart"(arg0: T): void
public "trackEnd"(arg0: T): void
public "getTimingData"(): $ImmutableList<($ForgeTimings<(T)>)>
get "timingData"(): $ImmutableList<($ForgeTimings<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeTracker$Type<T> = ($TimeTracker<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeTracker_<T> = $TimeTracker$Type<(T)>;
}}
declare module "packages/net/minecraftforge/items/$ItemStackHandler" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$List, $List$Type} from "packages/java/util/$List"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandlerModifiable, $IItemHandlerModifiable$Type} from "packages/net/minecraftforge/items/$IItemHandlerModifiable"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $ItemStackHandler implements $IItemHandler, $IItemHandlerModifiable, $INBTSerializable<($CompoundTag)> {

constructor(arg0: $NonNullList$Type<($ItemStack$Type)>)
constructor(arg0: integer)
constructor()

public "setSize"(arg0: integer): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getSlotLimit"(arg0: integer): integer
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
set "size"(value: integer)
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackHandler$Type = ($ItemStackHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackHandler_ = $ItemStackHandler$Type;
}}
declare module "packages/net/minecraftforge/event/$OnDatapackSyncEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerList, $PlayerList$Type} from "packages/net/minecraft/server/players/$PlayerList"

export class $OnDatapackSyncEvent extends $Event {

constructor()
constructor(arg0: $PlayerList$Type, arg1: $ServerPlayer$Type)

public "isCancelable"(): boolean
public "getPlayerList"(): $PlayerList
public "getPlayer"(): $ServerPlayer
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "playerList"(): $PlayerList
get "player"(): $ServerPlayer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OnDatapackSyncEvent$Type = ($OnDatapackSyncEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OnDatapackSyncEvent_ = $OnDatapackSyncEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$PlayerLoggedOutEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"

export class $PlayerEvent$PlayerLoggedOutEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type)

public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$PlayerLoggedOutEvent$Type = ($PlayerEvent$PlayerLoggedOutEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$PlayerLoggedOutEvent_ = $PlayerEvent$PlayerLoggedOutEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$AdvancementEvent$AdvancementProgressEvent$ProgressType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AdvancementEvent$AdvancementProgressEvent$ProgressType extends $Enum<($AdvancementEvent$AdvancementProgressEvent$ProgressType)> {
static readonly "GRANT": $AdvancementEvent$AdvancementProgressEvent$ProgressType
static readonly "REVOKE": $AdvancementEvent$AdvancementProgressEvent$ProgressType


public static "values"(): ($AdvancementEvent$AdvancementProgressEvent$ProgressType)[]
public static "valueOf"(arg0: string): $AdvancementEvent$AdvancementProgressEvent$ProgressType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementEvent$AdvancementProgressEvent$ProgressType$Type = (("revoke") | ("grant")) | ($AdvancementEvent$AdvancementProgressEvent$ProgressType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdvancementEvent$AdvancementProgressEvent$ProgressType_ = $AdvancementEvent$AdvancementProgressEvent$ProgressType$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkHooks" {
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ChannelHandlerContext, $ChannelHandlerContext$Type} from "packages/io/netty/channel/$ChannelHandlerContext"
import {$ConnectionType, $ConnectionType$Type} from "packages/net/minecraftforge/network/$ConnectionType"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$NetworkDirection, $NetworkDirection$Type} from "packages/net/minecraftforge/network/$NetworkDirection"
import {$ClientIntentionPacket, $ClientIntentionPacket$Type} from "packages/net/minecraft/network/protocol/handshake/$ClientIntentionPacket"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$ConnectionData$ModMismatchData, $ConnectionData$ModMismatchData$Type} from "packages/net/minecraftforge/network/$ConnectionData$ModMismatchData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ServerLoginPacketListenerImpl, $ServerLoginPacketListenerImpl$Type} from "packages/net/minecraft/server/network/$ServerLoginPacketListenerImpl"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ICustomPacket, $ICustomPacket$Type} from "packages/net/minecraftforge/network/$ICustomPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ConnectionData, $ConnectionData$Type} from "packages/net/minecraftforge/network/$ConnectionData"
import {$MCRegisterPacketHandler$ChannelList, $MCRegisterPacketHandler$ChannelList$Type} from "packages/net/minecraftforge/network/$MCRegisterPacketHandler$ChannelList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $NetworkHooks {

constructor()

public static "getModMismatchData"(arg0: $Connection$Type): $ConnectionData$ModMismatchData
public static "tickNegotiation"(arg0: $ServerLoginPacketListenerImpl$Type, arg1: $Connection$Type, arg2: $ServerPlayer$Type): boolean
public static "handleClientLoginSuccess"(arg0: $Connection$Type): void
public static "isVanillaConnection"(arg0: $Connection$Type): boolean
public static "openScreen"(arg0: $ServerPlayer$Type, arg1: $MenuProvider$Type, arg2: $BlockPos$Type): void
public static "openScreen"(arg0: $ServerPlayer$Type, arg1: $MenuProvider$Type): void
public static "openScreen"(arg0: $ServerPlayer$Type, arg1: $MenuProvider$Type, arg2: $Consumer$Type<($FriendlyByteBuf$Type)>): void
public static "getEntitySpawningPacket"(arg0: $Entity$Type): $Packet<($ClientGamePacketListener)>
public static "registerClientLoginChannel"(arg0: $Connection$Type): void
public static "sendMCRegistryPackets"(arg0: $Connection$Type, arg1: string): void
public static "getFMLVersion"(arg0: string): string
public static "registerServerLoginChannel"(arg0: $Connection$Type, arg1: $ClientIntentionPacket$Type): void
public static "getConnectionData"(arg0: $Connection$Type): $ConnectionData
public static "getChannelList"(arg0: $Connection$Type): $MCRegisterPacketHandler$ChannelList
public static "getConnectionType"(arg0: $ChannelHandlerContext$Type): $ConnectionType
public static "getConnectionType"(arg0: $Supplier$Type<($Connection$Type)>): $ConnectionType
public static "validatePacketDirection"(arg0: $NetworkDirection$Type, arg1: $Optional$Type<($NetworkDirection$Type)>, arg2: $Connection$Type): void
public static "onCustomPayload"(arg0: $ICustomPacket$Type<(any)>, arg1: $Connection$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkHooks$Type = ($NetworkHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkHooks_ = $NetworkHooks$Type;
}}
declare module "packages/net/minecraftforge/fml/loading/progress/$Message" {
import {$Message$MessageType, $Message$MessageType$Type} from "packages/net/minecraftforge/fml/loading/progress/$Message$MessageType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $Message {

constructor(arg0: string, arg1: $Message$MessageType$Type)

public "getText"(): string
public "getTypeColour"(): (float)[]
get "text"(): string
get "typeColour"(): (float)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Message$Type = ($Message);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Message_ = $Message$Type;
}}
declare module "packages/net/minecraftforge/eventbus/api/$BusBuilder" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IEventExceptionHandler, $IEventExceptionHandler$Type} from "packages/net/minecraftforge/eventbus/api/$IEventExceptionHandler"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $BusBuilder {

 "build"(): $IEventBus
 "useModLauncher"(): $BusBuilder
 "startShutdown"(): $BusBuilder
 "markerType"(arg0: $Class$Type<(any)>): $BusBuilder
 "setTrackPhases"(arg0: boolean): $BusBuilder
 "setExceptionHandler"(arg0: $IEventExceptionHandler$Type): $BusBuilder
 "checkTypesOnDispatch"(): $BusBuilder
}

export namespace $BusBuilder {
function builder(): $BusBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BusBuilder$Type = ($BusBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BusBuilder_ = $BusBuilder$Type;
}}
declare module "packages/net/minecraftforge/server/command/$EnumArgument$Info$Template" {
import {$EnumArgument, $EnumArgument$Type} from "packages/net/minecraftforge/server/command/$EnumArgument"
import {$ArgumentTypeInfo, $ArgumentTypeInfo$Type} from "packages/net/minecraft/commands/synchronization/$ArgumentTypeInfo"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$ArgumentTypeInfo$Template, $ArgumentTypeInfo$Template$Type} from "packages/net/minecraft/commands/synchronization/$ArgumentTypeInfo$Template"

export class $EnumArgument$Info$Template implements $ArgumentTypeInfo$Template<($EnumArgument<(T)>)> {


public "instantiate"(arg0: $CommandBuildContext$Type): $EnumArgument<(T)>
public "type"(): $ArgumentTypeInfo<($EnumArgument<(T)>), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumArgument$Info$Template$Type = ($EnumArgument$Info$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumArgument$Info$Template_ = $EnumArgument$Info$Template$Type;
}}
declare module "packages/net/minecraftforge/client/model/$SeparateTransformsModel" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$BlockModel, $BlockModel$Type} from "packages/net/minecraft/client/renderer/block/model/$BlockModel"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $SeparateTransformsModel implements $IUnbakedGeometry<($SeparateTransformsModel)> {

constructor(arg0: $BlockModel$Type, arg1: $ImmutableMap$Type<($ItemDisplayContext$Type), ($BlockModel$Type)>)

public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
public "bake"(arg0: $IGeometryBakingContext$Type, arg1: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg3: $ModelState$Type, arg4: $ItemOverrides$Type, arg5: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeparateTransformsModel$Type = ($SeparateTransformsModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeparateTransformsModel_ = $SeparateTransformsModel$Type;
}}
declare module "packages/net/minecraftforge/client/event/sound/$SoundEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$SoundEngine, $SoundEngine$Type} from "packages/net/minecraft/client/sounds/$SoundEngine"

export class $SoundEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "getEngine"(): $SoundEngine
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "engine"(): $SoundEngine
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEvent$Type = ($SoundEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEvent_ = $SoundEvent$Type;
}}
declare module "packages/net/minecraftforge/eventbus/$BusBuilderImpl" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IEventExceptionHandler, $IEventExceptionHandler$Type} from "packages/net/minecraftforge/eventbus/api/$IEventExceptionHandler"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BusBuilder, $BusBuilder$Type} from "packages/net/minecraftforge/eventbus/api/$BusBuilder"

export class $BusBuilderImpl implements $BusBuilder {

constructor()

public "build"(): $IEventBus
public "useModLauncher"(): $BusBuilder
public "startShutdown"(): $BusBuilder
public "markerType"(arg0: $Class$Type<(any)>): $BusBuilder
public "setTrackPhases"(arg0: boolean): $BusBuilder
public "setExceptionHandler"(arg0: $IEventExceptionHandler$Type): $BusBuilder
public "checkTypesOnDispatch"(): $BusBuilder
public static "builder"(): $BusBuilder
set "trackPhases"(value: boolean)
set "exceptionHandler"(value: $IEventExceptionHandler$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BusBuilderImpl$Type = ($BusBuilderImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BusBuilderImpl_ = $BusBuilderImpl$Type;
}}
declare module "packages/net/minecraftforge/registries/holdersets/$NotHolderSet" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$IForgeHolderSet$SerializationType, $IForgeHolderSet$SerializationType$Type} from "packages/net/minecraftforge/common/extensions/$IForgeHolderSet$SerializationType"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$Type} from "packages/net/minecraft/core/$HolderLookup$RegistryLookup"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$HolderSetType, $HolderSetType$Type} from "packages/net/minecraftforge/registries/holdersets/$HolderSetType"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ICustomHolderSet, $ICustomHolderSet$Type} from "packages/net/minecraftforge/registries/holdersets/$ICustomHolderSet"
import {$HolderSet$Direct, $HolderSet$Direct$Type} from "packages/net/minecraft/core/$HolderSet$Direct"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HolderSet$Named, $HolderSet$Named$Type} from "packages/net/minecraft/core/$HolderSet$Named"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $NotHolderSet<T> implements $ICustomHolderSet<(T)> {

constructor(arg0: $HolderLookup$RegistryLookup$Type<(T)>, arg1: $HolderSet$Type<(T)>)

public "type"(): $HolderSetType
public "value"(): $HolderSet<(T)>
public "toString"(): string
public "iterator"(): $Iterator<($Holder<(T)>)>
public "registryLookup"(): $HolderLookup$RegistryLookup<(T)>
public "contains"(arg0: $Holder$Type<(T)>): boolean
public "addInvalidationListener"(arg0: $Runnable$Type): void
public "stream"(): $Stream<($Holder<(T)>)>
public "canSerializeIn"(arg0: $HolderOwner$Type<(T)>): boolean
public "size"(): integer
public "get"(arg0: integer): $Holder<(T)>
public "unwrapKey"(): $Optional<($TagKey<(T)>)>
public "getRandomElement"(arg0: $RandomSource$Type): $Optional<($Holder<(T)>)>
public static "codec"<T>(arg0: $ResourceKey$Type<(any)>, arg1: $Codec$Type<($Holder$Type<(T)>)>, arg2: boolean): $Codec<(any)>
public "unwrap"(): $Either<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "serializationType"(): $IForgeHolderSet$SerializationType
public static "direct"<T>(...arg0: ($Holder$Type<(T)>)[]): $HolderSet$Direct<(T)>
public static "direct"<T>(arg0: $List$Type<(any)>): $HolderSet$Direct<(T)>
/**
 * 
 * @deprecated
 */
public static "emptyNamed"<T>(arg0: $HolderOwner$Type<(T)>, arg1: $TagKey$Type<(T)>): $HolderSet$Named<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, arg1: $List$Type<(E)>): $HolderSet$Direct<(T)>
public static "direct"<E, T>(arg0: $Function$Type<(E), ($Holder$Type<(T)>)>, ...arg1: (E)[]): $HolderSet$Direct<(T)>
public "spliterator"(): $Spliterator<($Holder<(T)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Holder<(T)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotHolderSet$Type<T> = ($NotHolderSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotHolderSet_<T> = $NotHolderSet$Type<(T)>;
}}
declare module "packages/net/minecraftforge/common/world/$BiomeGenerationSettingsBuilder" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$PlacedFeature, $PlacedFeature$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacedFeature"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$Type} from "packages/net/minecraft/world/level/biome/$BiomeGenerationSettings"
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BiomeGenerationSettings$PlainBuilder, $BiomeGenerationSettings$PlainBuilder$Type} from "packages/net/minecraft/world/level/biome/$BiomeGenerationSettings$PlainBuilder"
import {$ConfiguredWorldCarver, $ConfiguredWorldCarver$Type} from "packages/net/minecraft/world/level/levelgen/carver/$ConfiguredWorldCarver"
import {$GenerationStep$Carving, $GenerationStep$Carving$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Carving"

export class $BiomeGenerationSettingsBuilder extends $BiomeGenerationSettings$PlainBuilder {
readonly "features": $List<($List<($Holder<($PlacedFeature)>)>)>

constructor(arg0: $BiomeGenerationSettings$Type)

public "getFeatures"(arg0: $GenerationStep$Decoration$Type): $List<($Holder<($PlacedFeature)>)>
public "getCarvers"(arg0: $GenerationStep$Carving$Type): $List<($Holder<($ConfiguredWorldCarver<(any)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeGenerationSettingsBuilder$Type = ($BiomeGenerationSettingsBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeGenerationSettingsBuilder_ = $BiomeGenerationSettingsBuilder$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ForgeBiomeModifiers$RemoveFeaturesBiomeModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier, $BiomeModifier$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$PlacedFeature, $PlacedFeature$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacedFeature"
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier extends $Record implements $BiomeModifier {

constructor(biomes: $HolderSet$Type<($Biome$Type)>, features: $HolderSet$Type<($PlacedFeature$Type)>, steps: $Set$Type<($GenerationStep$Decoration$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "steps"(): $Set<($GenerationStep$Decoration)>
public "features"(): $HolderSet<($PlacedFeature)>
public "biomes"(): $HolderSet<($Biome)>
public static "allSteps"(arg0: $HolderSet$Type<($Biome$Type)>, arg1: $HolderSet$Type<($PlacedFeature$Type)>): $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier
public "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
public "codec"(): $Codec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier$Type = ($ForgeBiomeModifiers$RemoveFeaturesBiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier_ = $ForgeBiomeModifiers$RemoveFeaturesBiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEvent$LivingTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEvent$LivingTickEvent extends $LivingEvent {

constructor()
constructor(arg0: $LivingEntity$Type)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEvent$LivingTickEvent$Type = ($LivingEvent$LivingTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEvent$LivingTickEvent_ = $LivingEvent$LivingTickEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$SleepingTimeCheckEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SleepingTimeCheckEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Optional$Type<($BlockPos$Type)>)

public "getSleepingLocation"(): $Optional<($BlockPos)>
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "sleepingLocation"(): $Optional<($BlockPos)>
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SleepingTimeCheckEvent$Type = ($SleepingTimeCheckEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SleepingTimeCheckEvent_ = $SleepingTimeCheckEvent$Type;
}}
declare module "packages/net/minecraftforge/network/$NetworkEvent$GatherLoginPayloadsEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$NetworkRegistry$LoginPayload, $NetworkRegistry$LoginPayload$Type} from "packages/net/minecraftforge/network/$NetworkRegistry$LoginPayload"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $NetworkEvent$GatherLoginPayloadsEvent extends $Event {

constructor(arg0: $List$Type<($NetworkRegistry$LoginPayload$Type)>, arg1: boolean)
constructor()

public "add"(arg0: $FriendlyByteBuf$Type, arg1: $ResourceLocation$Type, arg2: string, arg3: boolean): void
public "add"(arg0: $FriendlyByteBuf$Type, arg1: $ResourceLocation$Type, arg2: string): void
public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
public "isLocal"(): boolean
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
get "local"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvent$GatherLoginPayloadsEvent$Type = ($NetworkEvent$GatherLoginPayloadsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvent$GatherLoginPayloadsEvent_ = $NetworkEvent$GatherLoginPayloadsEvent$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerEvent$HarvestCheck" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export class $PlayerEvent$HarvestCheck extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $BlockState$Type, arg2: boolean)

public "getTargetBlock"(): $BlockState
public "canHarvest"(): boolean
public "setCanHarvest"(arg0: boolean): void
public "getListenerList"(): $ListenerList
get "targetBlock"(): $BlockState
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvent$HarvestCheck$Type = ($PlayerEvent$HarvestCheck);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvent$HarvestCheck_ = $PlayerEvent$HarvestCheck$Type;
}}
declare module "packages/net/minecraftforge/common/crafting/conditions/$ConditionContext" {
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$TagManager, $TagManager$Type} from "packages/net/minecraft/tags/$TagManager"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConditionContext implements $ICondition$IContext {

constructor(arg0: $TagManager$Type)

public "getAllTags"<T>(arg0: $ResourceKey$Type<(any)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "getTag"<T>(arg0: $TagKey$Type<(T)>): $Collection<($Holder<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionContext$Type = ($ConditionContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionContext_ = $ConditionContext$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerContainerEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"

export class $PlayerContainerEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $AbstractContainerMenu$Type)

public "getContainer"(): $AbstractContainerMenu
public "getListenerList"(): $ListenerList
get "container"(): $AbstractContainerMenu
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerContainerEvent$Type = ($PlayerContainerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerContainerEvent_ = $PlayerContainerEvent$Type;
}}
declare module "packages/net/minecraftforge/common/util/$NonNullFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $NonNullFunction<T, R> {

 "apply"(arg0: T): R

(arg0: T): R
}

export namespace $NonNullFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonNullFunction$Type<T, R> = ($NonNullFunction<(T), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonNullFunction_<T, R> = $NonNullFunction$Type<(T), (R)>;
}}
declare module "packages/net/minecraftforge/event/entity/player/$BonemealEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$PlayerEvent, $PlayerEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerEvent"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BonemealEvent extends $PlayerEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $Level$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $ItemStack$Type)

public "getStack"(): $ItemStack
public "getLevel"(): $Level
public "getBlock"(): $BlockState
public "isCancelable"(): boolean
public "getPos"(): $BlockPos
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "stack"(): $ItemStack
get "level"(): $Level
get "block"(): $BlockState
get "cancelable"(): boolean
get "pos"(): $BlockPos
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BonemealEvent$Type = ($BonemealEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BonemealEvent_ = $BonemealEvent$Type;
}}
declare module "packages/net/minecraftforge/common/ticket/$ITicketGetter" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$SimpleTicket, $SimpleTicket$Type} from "packages/net/minecraftforge/common/ticket/$SimpleTicket"
import {$ITicketManager, $ITicketManager$Type} from "packages/net/minecraftforge/common/ticket/$ITicketManager"

export interface $ITicketGetter<T> extends $ITicketManager<(T)> {

 "getTickets"(): $Collection<($SimpleTicket<(T)>)>
 "add"(arg0: $SimpleTicket$Type<(T)>): void
 "remove"(arg0: $SimpleTicket$Type<(T)>): void
}

export namespace $ITicketGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITicketGetter$Type<T> = ($ITicketGetter<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITicketGetter_<T> = $ITicketGetter$Type<(T)>;
}}
declare module "packages/net/minecraftforge/client/event/$ContainerScreenEvent$Render" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ContainerScreenEvent, $ContainerScreenEvent$Type} from "packages/net/minecraftforge/client/event/$ContainerScreenEvent"

export class $ContainerScreenEvent$Render extends $ContainerScreenEvent {

constructor()

public "getMouseX"(): integer
public "getMouseY"(): integer
public "getGuiGraphics"(): $GuiGraphics
public "getListenerList"(): $ListenerList
get "mouseX"(): integer
get "mouseY"(): integer
get "guiGraphics"(): $GuiGraphics
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerScreenEvent$Render$Type = ($ContainerScreenEvent$Render);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerScreenEvent$Render_ = $ContainerScreenEvent$Render$Type;
}}
declare module "packages/net/minecraftforge/fluids/capability/templates/$FluidHandlerItemStackSimple" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IFluidHandlerItem, $IFluidHandlerItem$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandlerItem"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $FluidHandlerItemStackSimple implements $IFluidHandlerItem, $ICapabilityProvider {
static readonly "FLUID_NBT_KEY": string

constructor(arg0: $ItemStack$Type, arg1: integer)

public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "canFillFluidType"(arg0: $FluidStack$Type): boolean
public "getContainer"(): $ItemStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "canDrainFluidType"(arg0: $FluidStack$Type): boolean
public "getTanks"(): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
public "getFluid"(): $FluidStack
public "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
get "container"(): $ItemStack
get "tanks"(): integer
get "fluid"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidHandlerItemStackSimple$Type = ($FluidHandlerItemStackSimple);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidHandlerItemStackSimple_ = $FluidHandlerItemStackSimple$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$BlockModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $BlockModelBuilder extends $ModelBuilder<($BlockModelBuilder)> {

constructor(arg0: $ResourceLocation$Type, arg1: $ExistingFileHelper$Type)

public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModelBuilder$Type = ($BlockModelBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockModelBuilder_ = $BlockModelBuilder$Type;
}}
declare module "packages/net/minecraftforge/registries/$DataPackRegistryEvent$NewRegistry" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$DataPackRegistryEvent, $DataPackRegistryEvent$Type} from "packages/net/minecraftforge/registries/$DataPackRegistryEvent"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $DataPackRegistryEvent$NewRegistry extends $DataPackRegistryEvent {

constructor()

public "dataPackRegistry"<T>(arg0: $ResourceKey$Type<($Registry$Type<(T)>)>, arg1: $Codec$Type<(T)>, arg2: $Codec$Type<(T)>): void
public "dataPackRegistry"<T>(arg0: $ResourceKey$Type<($Registry$Type<(T)>)>, arg1: $Codec$Type<(T)>): void
public "getListenerList"(): $ListenerList
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackRegistryEvent$NewRegistry$Type = ($DataPackRegistryEvent$NewRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataPackRegistryEvent$NewRegistry_ = $DataPackRegistryEvent$NewRegistry$Type;
}}
declare module "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder" {
import {$ModifiableBiomeInfo$BiomeInfo, $ModifiableBiomeInfo$BiomeInfo$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo"
import {$ClimateSettingsBuilder, $ClimateSettingsBuilder$Type} from "packages/net/minecraftforge/common/world/$ClimateSettingsBuilder"
import {$MobSpawnSettingsBuilder, $MobSpawnSettingsBuilder$Type} from "packages/net/minecraftforge/common/world/$MobSpawnSettingsBuilder"
import {$BiomeGenerationSettingsBuilder, $BiomeGenerationSettingsBuilder$Type} from "packages/net/minecraftforge/common/world/$BiomeGenerationSettingsBuilder"
import {$BiomeSpecialEffectsBuilder, $BiomeSpecialEffectsBuilder$Type} from "packages/net/minecraftforge/common/world/$BiomeSpecialEffectsBuilder"

export class $ModifiableBiomeInfo$BiomeInfo$Builder {


public static "copyOf"(arg0: $ModifiableBiomeInfo$BiomeInfo$Type): $ModifiableBiomeInfo$BiomeInfo$Builder
public "build"(): $ModifiableBiomeInfo$BiomeInfo
public "getMobSpawnSettings"(): $MobSpawnSettingsBuilder
public "getGenerationSettings"(): $BiomeGenerationSettingsBuilder
public "getClimateSettings"(): $ClimateSettingsBuilder
public "getSpecialEffects"(): $BiomeSpecialEffectsBuilder
get "mobSpawnSettings"(): $MobSpawnSettingsBuilder
get "generationSettings"(): $BiomeGenerationSettingsBuilder
get "climateSettings"(): $ClimateSettingsBuilder
get "specialEffects"(): $BiomeSpecialEffectsBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableBiomeInfo$BiomeInfo$Builder$Type = ($ModifiableBiomeInfo$BiomeInfo$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableBiomeInfo$BiomeInfo$Builder_ = $ModifiableBiomeInfo$BiomeInfo$Builder$Type;
}}
declare module "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent$EntityInteractSpecific" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerInteractEvent, $PlayerInteractEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerInteractEvent"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $PlayerInteractEvent$EntityInteractSpecific extends $PlayerInteractEvent {

constructor()
constructor(arg0: $Player$Type, arg1: $InteractionHand$Type, arg2: $Entity$Type, arg3: $Vec3$Type)

public "getTarget"(): $Entity
public "isCancelable"(): boolean
public "getLocalPos"(): $Vec3
public "getListenerList"(): $ListenerList
get "target"(): $Entity
get "cancelable"(): boolean
get "localPos"(): $Vec3
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInteractEvent$EntityInteractSpecific$Type = ($PlayerInteractEvent$EntityInteractSpecific);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInteractEvent$EntityInteractSpecific_ = $PlayerInteractEvent$EntityInteractSpecific$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfigSpec$Range" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ForgeConfigSpec$Range<V extends $Comparable<(any)>> implements $Predicate<(any)> {


public "toString"(): string
public "test"(arg0: any): boolean
public "getMin"(): V
public "getMax"(): V
public "getClazz"(): $Class<(any)>
public "correct"(arg0: any, arg1: any): any
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
public "negate"(): $Predicate<(any)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
public static "isEqual"<T>(arg0: any): $Predicate<(any)>
get "min"(): V
get "max"(): V
get "clazz"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfigSpec$Range$Type<V> = ($ForgeConfigSpec$Range<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfigSpec$Range_<V> = $ForgeConfigSpec$Range$Type<(V)>;
}}
declare module "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$InteractionInformation" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FluidInteractionRegistry$HasFluidInteraction, $FluidInteractionRegistry$HasFluidInteraction$Type} from "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$HasFluidInteraction"
import {$FluidInteractionRegistry$FluidInteraction, $FluidInteractionRegistry$FluidInteraction$Type} from "packages/net/minecraftforge/fluids/$FluidInteractionRegistry$FluidInteraction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"

export class $FluidInteractionRegistry$InteractionInformation extends $Record {

constructor(predicate: $FluidInteractionRegistry$HasFluidInteraction$Type, interaction: $FluidInteractionRegistry$FluidInteraction$Type)
constructor(arg0: $FluidInteractionRegistry$HasFluidInteraction$Type, arg1: $Function$Type<($FluidState$Type), ($BlockState$Type)>)
constructor(arg0: $FluidType$Type, arg1: $Function$Type<($FluidState$Type), ($BlockState$Type)>)
constructor(arg0: $FluidInteractionRegistry$HasFluidInteraction$Type, arg1: $BlockState$Type)
constructor(arg0: $FluidType$Type, arg1: $BlockState$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "predicate"(): $FluidInteractionRegistry$HasFluidInteraction
public "interaction"(): $FluidInteractionRegistry$FluidInteraction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInteractionRegistry$InteractionInformation$Type = ($FluidInteractionRegistry$InteractionInformation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInteractionRegistry$InteractionInformation_ = $FluidInteractionRegistry$InteractionInformation$Type;
}}
declare module "packages/net/minecraftforge/common/world/$BiomeModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$ModifiableBiomeInfo$BiomeInfo$Builder, $ModifiableBiomeInfo$BiomeInfo$Builder$Type} from "packages/net/minecraftforge/common/world/$ModifiableBiomeInfo$BiomeInfo$Builder"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$BiomeModifier$Phase, $BiomeModifier$Phase$Type} from "packages/net/minecraftforge/common/world/$BiomeModifier$Phase"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $BiomeModifier {

 "modify"(arg0: $Holder$Type<($Biome$Type)>, arg1: $BiomeModifier$Phase$Type, arg2: $ModifiableBiomeInfo$BiomeInfo$Builder$Type): void
 "codec"(): $Codec<(any)>
}

export namespace $BiomeModifier {
const DIRECT_CODEC: $Codec<($BiomeModifier)>
const REFERENCE_CODEC: $Codec<($Holder<($BiomeModifier)>)>
const LIST_CODEC: $Codec<($HolderSet<($BiomeModifier)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeModifier$Type = ($BiomeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeModifier_ = $BiomeModifier$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"

export class $ScreenEvent extends $Event {

constructor()

public "isCancelable"(): boolean
public "getScreen"(): $Screen
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "cancelable"(): boolean
get "screen"(): $Screen
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$Type = ($ScreenEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent_ = $ScreenEvent$Type;
}}
declare module "packages/net/minecraftforge/event/$TickEvent$ServerTickEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$TickEvent$Phase, $TickEvent$Phase$Type} from "packages/net/minecraftforge/event/$TickEvent$Phase"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$LogicalSide, $LogicalSide$Type} from "packages/net/minecraftforge/fml/$LogicalSide"

export class $TickEvent$ServerTickEvent extends $TickEvent {
readonly "type": $TickEvent$Type
readonly "side": $LogicalSide
readonly "phase": $TickEvent$Phase

constructor()
constructor(arg0: $TickEvent$Phase$Type, arg1: $BooleanSupplier$Type, arg2: $MinecraftServer$Type)

public "getServer"(): $MinecraftServer
public "haveTime"(): boolean
public "getListenerList"(): $ListenerList
get "server"(): $MinecraftServer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickEvent$ServerTickEvent$Type = ($TickEvent$ServerTickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickEvent$ServerTickEvent_ = $TickEvent$ServerTickEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ModelBuilder$TransformsBuilder$TransformVecBuilder" {
import {$ModelBuilder$TransformsBuilder, $ModelBuilder$TransformsBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder$TransformsBuilder"

export class $ModelBuilder$TransformsBuilder$TransformVecBuilder {


public "scale"(arg0: float, arg1: float, arg2: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
public "scale"(arg0: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
public "end"(): $ModelBuilder$TransformsBuilder<>
public "translation"(arg0: float, arg1: float, arg2: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
public "rotation"(arg0: float, arg1: float, arg2: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
public "leftRotation"(arg0: float, arg1: float, arg2: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
public "rightRotation"(arg0: float, arg1: float, arg2: float): $ModelBuilder$TransformsBuilder$TransformVecBuilder<>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelBuilder$TransformsBuilder$TransformVecBuilder$Type = ($ModelBuilder$TransformsBuilder$TransformVecBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelBuilder$TransformsBuilder$TransformVecBuilder_ = $ModelBuilder$TransformsBuilder$TransformVecBuilder$Type;
}}
declare module "packages/net/minecraftforge/event/level/$ExplosionEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"

export class $ExplosionEvent extends $Event {

constructor(arg0: $Level$Type, arg1: $Explosion$Type)
constructor()

public "getLevel"(): $Level
public "isCancelable"(): boolean
public "getExplosion"(): $Explosion
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "level"(): $Level
get "cancelable"(): boolean
get "explosion"(): $Explosion
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEvent$Type = ($ExplosionEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEvent_ = $ExplosionEvent$Type;
}}
declare module "packages/net/minecraftforge/client/model/$IQuadTransformer" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export interface $IQuadTransformer {

 "andThen"(arg0: $IQuadTransformer$Type): $IQuadTransformer
 "process"(arg0: $List$Type<($BakedQuad$Type)>): $List<($BakedQuad)>
 "process"(arg0: $BakedQuad$Type): $BakedQuad
 "processInPlace"(arg0: $List$Type<($BakedQuad$Type)>): void
 "processInPlace"(arg0: $BakedQuad$Type): void

(arg0: $IQuadTransformer$Type): $IQuadTransformer
}

export namespace $IQuadTransformer {
const STRIDE: integer
const POSITION: integer
const COLOR: integer
const UV0: integer
const UV1: integer
const UV2: integer
const NORMAL: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQuadTransformer$Type = ($IQuadTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQuadTransformer_ = $IQuadTransformer$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ScreenEvent$CharacterTyped$Pre" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScreenEvent$CharacterTyped, $ScreenEvent$CharacterTyped$Type} from "packages/net/minecraftforge/client/event/$ScreenEvent$CharacterTyped"

export class $ScreenEvent$CharacterTyped$Pre extends $ScreenEvent$CharacterTyped {

constructor()
constructor(arg0: $Screen$Type, arg1: character, arg2: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenEvent$CharacterTyped$Pre$Type = ($ScreenEvent$CharacterTyped$Pre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenEvent$CharacterTyped$Pre_ = $ScreenEvent$CharacterTyped$Pre$Type;
}}
declare module "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent$LoggingOut" {
import {$LocalPlayer, $LocalPlayer$Type} from "packages/net/minecraft/client/player/$LocalPlayer"
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$ClientPlayerNetworkEvent, $ClientPlayerNetworkEvent$Type} from "packages/net/minecraftforge/client/event/$ClientPlayerNetworkEvent"
import {$MultiPlayerGameMode, $MultiPlayerGameMode$Type} from "packages/net/minecraft/client/multiplayer/$MultiPlayerGameMode"

export class $ClientPlayerNetworkEvent$LoggingOut extends $ClientPlayerNetworkEvent {

constructor()
constructor(arg0: $MultiPlayerGameMode$Type, arg1: $LocalPlayer$Type, arg2: $Connection$Type)

public "getConnection"(): $Connection
public "getMultiPlayerGameMode"(): $MultiPlayerGameMode
public "getPlayer"(): $LocalPlayer
public "getListenerList"(): $ListenerList
get "connection"(): $Connection
get "multiPlayerGameMode"(): $MultiPlayerGameMode
get "player"(): $LocalPlayer
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerNetworkEvent$LoggingOut$Type = ($ClientPlayerNetworkEvent$LoggingOut);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerNetworkEvent$LoggingOut_ = $ClientPlayerNetworkEvent$LoggingOut$Type;
}}
declare module "packages/net/minecraftforge/client/model/generators/$ItemModelBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemModelBuilder$OverrideBuilder, $ItemModelBuilder$OverrideBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ItemModelBuilder$OverrideBuilder"
import {$ExistingFileHelper, $ExistingFileHelper$Type} from "packages/net/minecraftforge/common/data/$ExistingFileHelper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ModelBuilder, $ModelBuilder$Type} from "packages/net/minecraftforge/client/model/generators/$ModelBuilder"

export class $ItemModelBuilder extends $ModelBuilder<($ItemModelBuilder)> {

constructor(arg0: $ResourceLocation$Type, arg1: $ExistingFileHelper$Type)

public "override"(arg0: integer): $ItemModelBuilder$OverrideBuilder
public "override"(): $ItemModelBuilder$OverrideBuilder
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelBuilder$Type = ($ItemModelBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModelBuilder_ = $ItemModelBuilder$Type;
}}
declare module "packages/net/minecraftforge/internal/$BrandingControl" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$ResourceManagerReloadListener, $ResourceManagerReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManagerReloadListener"

export class $BrandingControl {

constructor()

public static "getClientBranding"(): string
public static "getServerBranding"(): string
public static "forEachLine"(arg0: boolean, arg1: boolean, arg2: $BiConsumer$Type<(integer), (string)>): void
public static "forEachAboveCopyrightLine"(arg0: $BiConsumer$Type<(integer), (string)>): void
public static "resourceManagerReloadListener"(): $ResourceManagerReloadListener
get "clientBranding"(): string
get "serverBranding"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrandingControl$Type = ($BrandingControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BrandingControl_ = $BrandingControl$Type;
}}
declare module "packages/net/minecraftforge/event/entity/$EntityTeleportEvent$TeleportCommand" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$EntityTeleportEvent, $EntityTeleportEvent$Type} from "packages/net/minecraftforge/event/entity/$EntityTeleportEvent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityTeleportEvent$TeleportCommand extends $EntityTeleportEvent {

constructor()
constructor(arg0: $Entity$Type, arg1: double, arg2: double, arg3: double)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTeleportEvent$TeleportCommand$Type = ($EntityTeleportEvent$TeleportCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTeleportEvent$TeleportCommand_ = $EntityTeleportEvent$TeleportCommand$Type;
}}
declare module "packages/net/minecraftforge/client/model/renderable/$CompositeRenderable$Transforms" {
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"

export class $CompositeRenderable$Transforms {
static readonly "EMPTY": $CompositeRenderable$Transforms


public static "of"(arg0: $ImmutableMap$Type<(string), ($Matrix4f$Type)>): $CompositeRenderable$Transforms
public "getTransform"(arg0: string): $Matrix4f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeRenderable$Transforms$Type = ($CompositeRenderable$Transforms);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompositeRenderable$Transforms_ = $CompositeRenderable$Transforms$Type;
}}
declare module "packages/net/minecraftforge/common/$ForgeConfig" {
import {$ForgeConfig$Server, $ForgeConfig$Server$Type} from "packages/net/minecraftforge/common/$ForgeConfig$Server"
import {$ModConfigEvent$Reloading, $ModConfigEvent$Reloading$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Reloading"
import {$ForgeConfig$Client, $ForgeConfig$Client$Type} from "packages/net/minecraftforge/common/$ForgeConfig$Client"
import {$ForgeConfig$Common, $ForgeConfig$Common$Type} from "packages/net/minecraftforge/common/$ForgeConfig$Common"
import {$ModConfigEvent$Loading, $ModConfigEvent$Loading$Type} from "packages/net/minecraftforge/fml/event/config/$ModConfigEvent$Loading"

export class $ForgeConfig {
static readonly "CLIENT": $ForgeConfig$Client
static readonly "COMMON": $ForgeConfig$Common
static readonly "SERVER": $ForgeConfig$Server

constructor()

public static "onLoad"(arg0: $ModConfigEvent$Loading$Type): void
public static "onFileChange"(arg0: $ModConfigEvent$Reloading$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeConfig$Type = ($ForgeConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeConfig_ = $ForgeConfig$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingPackSizeEvent" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEvent, $LivingEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEvent"
import {$Mob, $Mob$Type} from "packages/net/minecraft/world/entity/$Mob"

export class $LivingPackSizeEvent extends $LivingEvent {

constructor()
constructor(arg0: $Mob$Type)

public "getMaxPackSize"(): integer
public "setMaxPackSize"(arg0: integer): void
public "getListenerList"(): $ListenerList
public "hasResult"(): boolean
get "maxPackSize"(): integer
set "maxPackSize"(value: integer)
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingPackSizeEvent$Type = ($LivingPackSizeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingPackSizeEvent_ = $LivingPackSizeEvent$Type;
}}
declare module "packages/net/minecraftforge/registries/$DataPackRegistriesHooks" {
import {$RegistryDataLoader$RegistryData, $RegistryDataLoader$RegistryData$Type} from "packages/net/minecraft/resources/$RegistryDataLoader$RegistryData"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$RegistrySynchronization$NetworkedRegistryData, $RegistrySynchronization$NetworkedRegistryData$Type} from "packages/net/minecraft/core/$RegistrySynchronization$NetworkedRegistryData"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ImmutableMap$Builder, $ImmutableMap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMap$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DataPackRegistriesHooks {


public static "grabNetworkableRegistries"(arg0: $ImmutableMap$Builder$Type<($ResourceKey$Type<(any)>), ($RegistrySynchronization$NetworkedRegistryData$Type<(any)>)>): $Map<($ResourceKey<(any)>), ($RegistrySynchronization$NetworkedRegistryData<(any)>)>
public static "getDataPackRegistries"(): $List<($RegistryDataLoader$RegistryData<(any)>)>
public static "getDataPackRegistriesWithDimensions"(): $Stream<($RegistryDataLoader$RegistryData<(any)>)>
public static "getSyncedCustomRegistries"(): $Set<($ResourceKey<(any)>)>
get "dataPackRegistries"(): $List<($RegistryDataLoader$RegistryData<(any)>)>
get "dataPackRegistriesWithDimensions"(): $Stream<($RegistryDataLoader$RegistryData<(any)>)>
get "syncedCustomRegistries"(): $Set<($ResourceKey<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackRegistriesHooks$Type = ($DataPackRegistriesHooks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataPackRegistriesHooks_ = $DataPackRegistriesHooks$Type;
}}
declare module "packages/net/minecraftforge/client/$FireworkShapeFactoryRegistry$Factory" {
import {$FireworkParticles$Starter, $FireworkParticles$Starter$Type} from "packages/net/minecraft/client/particle/$FireworkParticles$Starter"

export interface $FireworkShapeFactoryRegistry$Factory {

 "build"(arg0: $FireworkParticles$Starter$Type, arg1: boolean, arg2: boolean, arg3: (integer)[], arg4: (integer)[]): void

(arg0: $FireworkParticles$Starter$Type, arg1: boolean, arg2: boolean, arg3: (integer)[], arg4: (integer)[]): void
}

export namespace $FireworkShapeFactoryRegistry$Factory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkShapeFactoryRegistry$Factory$Type = ($FireworkShapeFactoryRegistry$Factory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworkShapeFactoryRegistry$Factory_ = $FireworkShapeFactoryRegistry$Factory$Type;
}}
declare module "packages/net/minecraftforge/common/util/$LogMessageAdapter" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Message, $Message$Type} from "packages/org/apache/logging/log4j/message/$Message"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$StringBuilderFormattable, $StringBuilderFormattable$Type} from "packages/org/apache/logging/log4j/util/$StringBuilderFormattable"

export class $LogMessageAdapter extends $Record implements $Message, $StringBuilderFormattable {

constructor(builder: $Consumer$Type<($StringBuilder$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "builder"(): $Consumer<($StringBuilder)>
public "getParameters"(): (any)[]
public "formatTo"(arg0: $StringBuilder$Type): void
public "getFormat"(): string
public static "adapt"(arg0: $Consumer$Type<($StringBuilder$Type)>): $Message
public "getThrowable"(): $Throwable
public "getFormattedMessage"(): string
get "parameters"(): (any)[]
get "format"(): string
get "throwable"(): $Throwable
get "formattedMessage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogMessageAdapter$Type = ($LogMessageAdapter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogMessageAdapter_ = $LogMessageAdapter$Type;
}}
declare module "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent$Start" {
import {$ListenerList, $ListenerList$Type} from "packages/net/minecraftforge/eventbus/$ListenerList"
import {$LivingEntityUseItemEvent, $LivingEntityUseItemEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingEntityUseItemEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LivingEntityUseItemEvent$Start extends $LivingEntityUseItemEvent {

constructor()
constructor(arg0: $LivingEntity$Type, arg1: $ItemStack$Type, arg2: integer)

public "isCancelable"(): boolean
public "getListenerList"(): $ListenerList
get "cancelable"(): boolean
get "listenerList"(): $ListenerList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityUseItemEvent$Start$Type = ($LivingEntityUseItemEvent$Start);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityUseItemEvent$Start_ = $LivingEntityUseItemEvent$Start$Type;
}}
declare module "packages/net/minecraftforge/common/extensions/$IForgeEntity" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$SoundAction, $SoundAction$Type} from "packages/net/minecraftforge/common/$SoundAction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Pose, $Pose$Type} from "packages/net/minecraft/world/entity/$Pose"
import {$ICapabilitySerializable, $ICapabilitySerializable$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilitySerializable"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Boat, $Boat$Type} from "packages/net/minecraft/world/entity/vehicle/$Boat"
import {$EntityDimensions, $EntityDimensions$Type} from "packages/net/minecraft/world/entity/$EntityDimensions"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$PartEntity, $PartEntity$Type} from "packages/net/minecraftforge/entity/$PartEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IForgeEntity extends $ICapabilitySerializable<($CompoundTag)> {

 "getPickedResult"(arg0: $HitResult$Type): $ItemStack
 "getPersistentData"(): $CompoundTag
 "isInFluidType"(arg0: $BiPredicate$Type<($FluidType$Type), (double)>): boolean
 "isInFluidType"(arg0: $FluidType$Type): boolean
 "isInFluidType"(arg0: $FluidState$Type): boolean
 "isInFluidType"(): boolean
 "isInFluidType"(arg0: $BiPredicate$Type<($FluidType$Type), (double)>, arg1: boolean): boolean
 "captureDrops"(arg0: $Collection$Type<($ItemEntity$Type)>): $Collection<($ItemEntity)>
 "captureDrops"(): $Collection<($ItemEntity)>
 "getFluidTypeHeight"(arg0: $FluidType$Type): double
 "canFluidExtinguish"(arg0: $FluidType$Type): boolean
 "getMaxHeightFluidType"(): $FluidType
 "hasCustomOutlineRendering"(arg0: $Player$Type): boolean
 "getFluidFallDistanceModifier"(arg0: $FluidType$Type): float
 "shouldUpdateFluidWhileBoating"(arg0: $FluidState$Type, arg1: $Boat$Type): boolean
 "canBeRiddenUnderFluidType"(arg0: $FluidType$Type, arg1: $Entity$Type): boolean
 "getFluidMotionScale"(arg0: $FluidType$Type): double
 "getSoundFromFluidType"(arg0: $FluidType$Type, arg1: $SoundAction$Type): $SoundEvent
 "canHydrateInFluidType"(arg0: $FluidType$Type): boolean
 "canTrample"(arg0: $BlockState$Type, arg1: $BlockPos$Type, arg2: float): boolean
 "canSwimInFluidType"(arg0: $FluidType$Type): boolean
 "canRiderInteract"(): boolean
 "getClassification"(arg0: boolean): $MobCategory
 "deserializeNBT"(arg0: $CompoundTag$Type): void
 "serializeNBT"(): $CompoundTag
 "canUpdate"(arg0: boolean): void
 "canUpdate"(): boolean
 "shouldRiderSit"(): boolean
 "getStepHeight"(): float
/**
 * 
 * @deprecated
 */
 "getEyeHeightForge"(arg0: $Pose$Type, arg1: $EntityDimensions$Type): float
 "getEyeInFluidType"(): $FluidType
 "isAddedToWorld"(): boolean
 "isEyeInFluidType"(arg0: $FluidType$Type): boolean
 "isPushedByFluid"(arg0: $FluidType$Type): boolean
 "canStartSwimming"(): boolean
 "isMultipartEntity"(): boolean
 "getParts"(): ($PartEntity<(any)>)[]
 "revive"(): void
 "onAddedToWorld"(): void
 "onRemovedFromWorld"(): void
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
}

export namespace $IForgeEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IForgeEntity$Type = ($IForgeEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IForgeEntity_ = $IForgeEntity$Type;
}}
