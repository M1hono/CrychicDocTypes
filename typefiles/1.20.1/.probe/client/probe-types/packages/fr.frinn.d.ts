declare module "packages/fr/frinn/custommachinery/common/util/$Color" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $Color {
static readonly "MAP_CODEC": $NamedMapCodec<($Color)>
static readonly "ARRAY_CODEC": $NamedCodec<($Color)>
static readonly "CODEC": $NamedCodec<($Color)>
static readonly "WHITE": $Color
static readonly "TRANSPARENT_WHITE": $Color


public "getARGB"(): integer
public static "fromColors"(alpha: float, red: float, green: float, blue: float): $Color
public static "fromColors"(alpha: integer, red: integer, green: integer, blue: integer): $Color
public static "fromColors"(alpha: double, red: double, green: double, blue: double): $Color
public static "fromARGB"(colorARGB: integer): $Color
public "getRed"(): integer
public "getGreen"(): integer
public "getBlue"(): integer
public "getAlpha"(): integer
get "aRGB"(): integer
get "red"(): integer
get "green"(): integer
get "blue"(): integer
get "alpha"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Color$Type = ($Color);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Color_ = $Color$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$DurabilityRequirement" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $DurabilityRequirement extends $AbstractChanceableRequirement<($ItemComponentHandler)> implements $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($DurabilityRequirement)>

constructor(mode: $RequirementIOMode$Type, item: $IIngredient$Type<($Item$Type)>, amount: integer, nbt: $CompoundTag$Type, canBreak: boolean, slot: string)

public "test"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($DurabilityRequirement)>
public "processStart"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($DurabilityRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DurabilityRequirement$Type = ($DurabilityRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DurabilityRequirement_ = $DurabilityRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$IChanceableRequirement, $IChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IChanceableRequirement"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $AbstractChanceableRequirement<T extends $IMachineComponent> extends $AbstractRequirement<(T)> implements $IChanceableRequirement<(T)> {

constructor(mode: $RequirementIOMode$Type)

public "shouldSkip"(component: T, rand: $Random$Type, context: $ICraftingContext$Type): boolean
public "getChance"(): double
public "setChance"(chance: double): void
get "chance"(): double
set "chance"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChanceableRequirement$Type<T> = ($AbstractChanceableRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractChanceableRequirement_<T> = $AbstractChanceableRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ConfigGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ConfigGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "BASE_TEXTURE_HOVERED": $ResourceLocation
static readonly "BASE_TOOLTIPS": $List<($Component)>
static readonly "CODEC": $NamedCodec<($ConfigGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type)

public "getType"(): $GuiElementType<($ConfigGuiElement)>
get "type"(): $GuiElementType<($ConfigGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigGuiElement$Type = ($ConfigGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigGuiElement_ = $ConfigGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$GuiEditorWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ComponentPath, $ComponentPath$Type} from "packages/net/minecraft/client/gui/$ComponentPath"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$GuiEditorWidget$WidgetEditorWidget, $GuiEditorWidget$WidgetEditorWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$GuiEditorWidget$WidgetEditorWidget"
import {$FocusNavigationEvent, $FocusNavigationEvent$Type} from "packages/net/minecraft/client/gui/navigation/$FocusNavigationEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ContainerEventHandler, $ContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$ContainerEventHandler"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $GuiEditorWidget extends $AbstractWidget implements $ContainerEventHandler {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(parent: $MachineEditScreen$Type, x: integer, y: integer, width: integer, height: integer, baseElements: $List$Type<($IGuiElement$Type)>)

public "config"<T extends $IGuiElement>(widget: $GuiEditorWidget$WidgetEditorWidget$Type<(T)>): void
public "addElement"(element: $IGuiElement$Type): void
public "keyPressed"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "children"(): $List<(any)>
public "setDragging"(isDragging: boolean): void
public "setFocused"(focused: $GuiEventListener$Type): void
public "isDragging"(): boolean
public "getFocused"(): $GuiEventListener
public "hideButtons"(): void
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "getChildAt"(mouseX: double, mouseY: double): $Optional<($GuiEventListener)>
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "charTyped"(codePoint: character, modifiers: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, delta: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, dragX: double, dragY: double): boolean
public "keyReleased"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "setX"(x: integer): void
public "setY"(y: integer): void
public "showButtons"(widget: $GuiEditorWidget$WidgetEditorWidget$Type<(any)>): void
public "addCreatedElement"(element: $IGuiElement$Type): void
public "getCurrentFocusPath"(): $ComponentPath
public "nextFocusPath"(arg0: $FocusNavigationEvent$Type): $ComponentPath
public "setFocused"(arg0: boolean): void
public "isFocused"(): boolean
public "magicalSpecialHackyFocus"(arg0: $GuiEventListener$Type): void
set "dragging"(value: boolean)
set "focused"(value: $GuiEventListener$Type)
get "dragging"(): boolean
get "focused"(): $GuiEventListener
set "x"(value: integer)
set "y"(value: integer)
get "currentFocusPath"(): $ComponentPath
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiEditorWidget$Type = ($GuiEditorWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiEditorWidget_ = $GuiEditorWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$AppearancePropertyBuilderRegistry" {
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$IAppearancePropertyBuilder, $IAppearancePropertyBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder"

export class $AppearancePropertyBuilderRegistry {

constructor()

public static "init"(): void
public static "getBuilder"<T>(property: $MachineAppearanceProperty$Type<(T)>): $IAppearancePropertyBuilder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppearancePropertyBuilderRegistry$Type = ($AppearancePropertyBuilderRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AppearancePropertyBuilderRegistry_ = $AppearancePropertyBuilderRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$ResetGuiElementWidget" {
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ResetGuiElement, $ResetGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ResetGuiElement"

export class $ResetGuiElementWidget extends $TexturedGuiElementWidget<($ResetGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $ResetGuiElement$Type, screen: $IMachineScreen$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResetGuiElementWidget$Type = ($ResetGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResetGuiElementWidget_ = $ResetGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$ConfigGuiElementWidget" {
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ConfigGuiElement, $ConfigGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ConfigGuiElement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ConfigGuiElementWidget extends $AbstractGuiElementWidget<($ConfigGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $ConfigGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, i: integer, j: integer, f: float): void
public "onClick"(mouseX: double, mouseY: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigGuiElementWidget$Type = ($ConfigGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigGuiElementWidget_ = $ConfigGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/builder/$ModelAppearancePropertyBuilder" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineModelLocation, $MachineModelLocation$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineModelLocation"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IAppearancePropertyBuilder, $IAppearancePropertyBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder"

export class $ModelAppearancePropertyBuilder implements $IAppearancePropertyBuilder<($MachineModelLocation)> {

constructor(title: $Component$Type, type: $MachineAppearanceProperty$Type<($MachineModelLocation$Type)>)

public "getType"(): $MachineAppearanceProperty<($MachineModelLocation)>
public "makeWidget"(parent: $BaseScreen$Type, x: integer, y: integer, width: integer, height: integer, supplier: $Supplier$Type<($MachineModelLocation$Type)>, consumer: $Consumer$Type<($MachineModelLocation$Type)>): $AbstractWidget
public "title"(): $Component
get "type"(): $MachineAppearanceProperty<($MachineModelLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelAppearancePropertyBuilder$Type = ($ModelAppearancePropertyBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelAppearancePropertyBuilder_ = $ModelAppearancePropertyBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$FluidRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $FluidRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $FluidRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidRequirementCT$Type<T> = ($FluidRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidRequirementCT_<T> = $FluidRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$UpgradeManager, $UpgradeManager$Type} from "packages/fr/frinn/custommachinery/common/crafting/$UpgradeManager"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"

export class $CustomMachineTile extends $MachineTile implements $ISyncableStuff {
static readonly "DUMMY": $ResourceLocation
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getMessage"(): $Component
public "getId"(): $ResourceLocation
public "unload"(): void
public "setOwner"(entity: $LivingEntity$Type): void
public "isPaused"(): boolean
public static "clientTick"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, tile: $CustomMachineTile$Type): void
public "getMachine"(): $CustomMachine
public "getGuiElements"(): $List<($IGuiElement)>
public "resetProcess"(): void
public "setPaused"(paused: boolean): void
public "refreshMachine"(id: $ResourceLocation$Type): void
public "isUnloaded"(): boolean
public "setStatus"(status: $MachineStatus$Type, message: $Component$Type): void
public "getUpgradeManager"(): $UpgradeManager
public "startInteracting"(player: $ServerPlayer$Type): void
public "stopInteracting"(player: $ServerPlayer$Type): void
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "getStatus"(): $MachineStatus
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getOwnerName"(): $Component
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbt: $CompoundTag$Type): void
public "setLevel"(level: $Level$Type): void
public "setId"(id: $ResourceLocation$Type): void
public "getProcessor"(): $IProcessor
public "getOwnerId"(): $UUID
public static "serverTick"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, tile: $CustomMachineTile$Type): void
public "setCustomGuiElements"(customGuiElements: $List$Type<($IGuiElement$Type)>): void
public "setCustomAppearance"(customAppearance: $IMachineAppearance$Type): void
public "getUpdateTag"(): $CompoundTag
public "setRemoved"(): void
get "message"(): $Component
get "id"(): $ResourceLocation
set "owner"(value: $LivingEntity$Type)
get "paused"(): boolean
get "machine"(): $CustomMachine
get "guiElements"(): $List<($IGuiElement)>
set "paused"(value: boolean)
get "unloaded"(): boolean
get "upgradeManager"(): $UpgradeManager
get "status"(): $MachineStatus
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "ownerName"(): $Component
set "level"(value: $Level$Type)
set "id"(value: $ResourceLocation$Type)
get "processor"(): $IProcessor
get "ownerId"(): $UUID
set "customGuiElements"(value: $List$Type<($IGuiElement$Type)>)
set "customAppearance"(value: $IMachineAppearance$Type)
get "updateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineTile$Type = ($CustomMachineTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineTile_ = $CustomMachineTile$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomCraftRecipeJSBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$EnergyRequirementJS, $EnergyRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EnergyRequirementJS"
import {$DimensionRequirementJS, $DimensionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DimensionRequirementJS"
import {$FuelRequirementJS, $FuelRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FuelRequirementJS"
import {$RecipeFunction, $RecipeFunction$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$RecipeFunction"
import {$BiomeRequirementJS, $BiomeRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BiomeRequirementJS"
import {$CommandRequirementJS, $CommandRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$CommandRequirementJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemRequirementJS, $ItemRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemRequirementJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$StructureRequirement$Action, $StructureRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action"
import {$TimeRequirementJS, $TimeRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$TimeRequirementJS"
import {$BlockRequirement$ACTION, $BlockRequirement$ACTION$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement$ACTION"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$PositionRequirementJS, $PositionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$PositionRequirementJS"
import {$ButtonRequirementJS, $ButtonRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ButtonRequirementJS"
import {$ItemFilterRequirementJS, $ItemFilterRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemFilterRequirementJS"
import {$FunctionRequirementJS, $FunctionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FunctionRequirementJS"
import {$ItemTransformRequirementJS, $ItemTransformRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemTransformRequirementJS"
import {$ExperienceRequirementJS, $ExperienceRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ExperienceRequirementJS"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$BlockRequirementJS, $BlockRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BlockRequirementJS"
import {$EntityRequirementJS, $EntityRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EntityRequirementJS"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"
import {$WeatherRequirementJS, $WeatherRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$WeatherRequirementJS"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$DropRequirementJS, $DropRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DropRequirementJS"
import {$EffectRequirementJS, $EffectRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EffectRequirementJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$CustomCraftRecipeBuilder, $CustomCraftRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipeBuilder"
import {$DurabilityRequirementJS, $DurabilityRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DurabilityRequirementJS"
import {$LightRequirementJS, $LightRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LightRequirementJS"
import {$SkyRequirementJS, $SkyRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$SkyRequirementJS"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$FluidRequirementJS, $FluidRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FluidRequirementJS"
import {$StructureRequirementJS, $StructureRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$StructureRequirementJS"
import {$AbstractRecipeJSBuilder, $AbstractRecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/$AbstractRecipeJSBuilder"
import {$RedstoneRequirementJS, $RedstoneRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$RedstoneRequirementJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$LootTableRequirementJS, $LootTableRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LootTableRequirementJS"

export class $CustomCraftRecipeJSBuilder extends $AbstractRecipeJSBuilder<($CustomCraftRecipeBuilder)> implements $BiomeRequirementJS, $BlockRequirementJS, $CommandRequirementJS, $DimensionRequirementJS, $DropRequirementJS, $DurabilityRequirementJS, $EffectRequirementJS, $EnergyRequirementJS, $EntityRequirementJS, $FluidRequirementJS, $FuelRequirementJS, $FunctionRequirementJS, $ItemRequirementJS, $ItemTransformRequirementJS, $LightRequirementJS, $LootTableRequirementJS, $PositionRequirementJS, $RedstoneRequirementJS, $StructureRequirementJS, $TimeRequirementJS, $WeatherRequirementJS, $ButtonRequirementJS, $SkyRequirementJS, $ItemFilterRequirementJS, $ExperienceRequirementJS {
static readonly "IDS": $Map<($ResourceLocation), ($Map<($ResourceLocation), (integer)>)>
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "writeOutputItem"(value: $OutputItem$Type): $JsonElement
public "biomeBlacklist"(biomes: (string)[]): $RecipeJSBuilder
public "biomeWhitelist"(biomes: (string)[]): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "blockRequirement"(mode: $RequirementIOMode$Type, action: $BlockRequirement$ACTION$Type, block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string, stringFilter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "runCommandOnStart"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandOnStart"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandOnStart"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandOnStart"(command: string): $RecipeJSBuilder
public "runCommandEachTick"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandEachTick"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandEachTick"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandEachTick"(command: string): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandOnEnd"(command: string): $RecipeJSBuilder
public "dimensionWhitelist"(dimensions: (string)[]): $RecipeJSBuilder
public "dimensionBlacklist"(dimensions: (string)[]): $RecipeJSBuilder
public "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "consumeAnyDropOnStart"(amount: integer, radius: integer): $RecipeJSBuilder
public "consumeAnyDropOnEnd"(amount: integer, radius: integer): $RecipeJSBuilder
public "consumeDropOnEnd"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "dropItemOnStart"(stack: $ItemStack$Type): $RecipeJSBuilder
public "checkAnyDrop"(amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrop"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "consumeDropOnStart"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "dropItemOnEnd"(stack: $ItemStack$Type): $RecipeJSBuilder
public "repairItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "repairItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer): $RecipeJSBuilder
public "damageItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "damageItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer, levelOrFilter: any): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer): $RecipeJSBuilder
public "produceEnergy"(amount: integer): $RecipeJSBuilder
public "requireEnergy"(amount: integer): $RecipeJSBuilder
public "requireEntitiesHealth"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "consumeEntityHealthOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "consumeEntityHealthOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "killEntitiesOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "requireEntities"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "killEntitiesOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "produceFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "produceFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, tank: string): $RecipeJSBuilder
public "requireFuel"(): $RecipeJSBuilder
public "requireFuel"(amount: integer): $RecipeJSBuilder
public "requireFunctionOnStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionEachTick"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionOnEnd"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionToStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "produceItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
public "produceItem"(stack: $ItemStack$Type): $RecipeJSBuilder
public "requireItem"(stack: $ItemStack$Type): $RecipeJSBuilder
public "requireItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "requireItemTag"(tag: string): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string): $RecipeJSBuilder
public "requireBlockLight"(level: string): $RecipeJSBuilder
public "requireSkyLight"(level: string): $RecipeJSBuilder
public "lootTableOutput"(lootTable: string): $RecipeJSBuilder
public "lootTableOutput"(lootTable: string, luck: float): $RecipeJSBuilder
public "requirePosition"(xString: string, yString: string, zString: string): $RecipeJSBuilder
public "requireRedstone"(power: string): $RecipeJSBuilder
public "placeStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, drops: boolean): $RecipeJSBuilder
public "destroyStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, action: $StructureRequirement$Action$Type): $RecipeJSBuilder
public "breakStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "requireTime"(time: string): $RecipeJSBuilder
public "requireWeatherOnMachine"(weather: string): $RecipeJSBuilder
public "requireWeather"(weather: string): $RecipeJSBuilder
public "requireButtonReleased"(id: string): $RecipeJSBuilder
public "requireButtonPressed"(id: string): $RecipeJSBuilder
public "mustSeeSky"(): $RecipeJSBuilder
public "requireItemFilter"(ingredient: $Ingredient$Type): $RecipeJSBuilder
public "requireItemFilter"(ingredient: $Ingredient$Type, slot: string): $RecipeJSBuilder
public "produceXp"(xp: integer): $RecipeJSBuilder
public "requireLevel"(levels: integer): $RecipeJSBuilder
public "requireXp"(xp: integer): $RecipeJSBuilder
public "produceLevel"(levels: integer): $RecipeJSBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCraftRecipeJSBuilder$Type = ($CustomCraftRecipeJSBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCraftRecipeJSBuilder_ = $CustomCraftRecipeJSBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement$Orientation" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ProgressBarGuiElement$Orientation extends $Enum<($ProgressBarGuiElement$Orientation)> {
static readonly "RIGHT": $ProgressBarGuiElement$Orientation
static readonly "LEFT": $ProgressBarGuiElement$Orientation
static readonly "TOP": $ProgressBarGuiElement$Orientation
static readonly "BOTTOM": $ProgressBarGuiElement$Orientation


public static "values"(): ($ProgressBarGuiElement$Orientation)[]
public static "valueOf"(name: string): $ProgressBarGuiElement$Orientation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressBarGuiElement$Orientation$Type = (("top") | ("left") | ("bottom") | ("right")) | ($ProgressBarGuiElement$Orientation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressBarGuiElement$Orientation_ = $ProgressBarGuiElement$Orientation$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$IntRange" {
import {$Range, $Range$Type} from "packages/fr/frinn/custommachinery/impl/util/$Range"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $IntRange extends $Range<(integer)> {
static readonly "CODEC": $NamedCodec<($IntRange)>
static readonly "ALL": $IntRange


public static "of"(o: any): $IntRange
public static "createFromString"(spec: string): $IntRange
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntRange$Type = ($IntRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntRange_ = $IntRange$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$ResultItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ResultItemComponentVariant extends $ItemComponentVariant {
static readonly "INSTANCE": $ResultItemComponentVariant
static readonly "CODEC": $NamedCodec<($ResultItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "canOutput"(manager: $IMachineComponentManager$Type): boolean
public "shouldDrop"(manager: $IMachineComponentManager$Type): boolean
public "getCodec"(): $NamedCodec<($ResultItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResultItemComponentVariant$Type = ($ResultItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResultItemComponentVariant_ = $ResultItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance" {
import {$Function8, $Function8$Type} from "packages/com/mojang/datafixers/util/$Function8"
import {$Function7, $Function7$Type} from "packages/com/mojang/datafixers/util/$Function7"
import {$Function6, $Function6$Type} from "packages/com/mojang/datafixers/util/$Function6"
import {$Function5, $Function5$Type} from "packages/com/mojang/datafixers/util/$Function5"
import {$Function9, $Function9$Type} from "packages/com/mojang/datafixers/util/$Function9"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$NamedRecordCodec$Mu, $NamedRecordCodec$Mu$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Mu"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Applicative, $Applicative$Type} from "packages/com/mojang/datafixers/kinds/$Applicative"
import {$App, $App$Type} from "packages/com/mojang/datafixers/kinds/$App"
import {$K1, $K1$Type} from "packages/com/mojang/datafixers/kinds/$K1"
import {$Products$P10, $Products$P10$Type} from "packages/com/mojang/datafixers/$Products$P10"
import {$Products$P11, $Products$P11$Type} from "packages/com/mojang/datafixers/$Products$P11"
import {$Products$P14, $Products$P14$Type} from "packages/com/mojang/datafixers/$Products$P14"
import {$NamedRecordCodec$Instance$Mu, $NamedRecordCodec$Instance$Mu$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance$Mu"
import {$Products$P15, $Products$P15$Type} from "packages/com/mojang/datafixers/$Products$P15"
import {$Products$P12, $Products$P12$Type} from "packages/com/mojang/datafixers/$Products$P12"
import {$Products$P13, $Products$P13$Type} from "packages/com/mojang/datafixers/$Products$P13"
import {$Products$P3, $Products$P3$Type} from "packages/com/mojang/datafixers/$Products$P3"
import {$Products$P4, $Products$P4$Type} from "packages/com/mojang/datafixers/$Products$P4"
import {$Products$P16, $Products$P16$Type} from "packages/com/mojang/datafixers/$Products$P16"
import {$Products$P1, $Products$P1$Type} from "packages/com/mojang/datafixers/$Products$P1"
import {$Function16, $Function16$Type} from "packages/com/mojang/datafixers/util/$Function16"
import {$Products$P2, $Products$P2$Type} from "packages/com/mojang/datafixers/$Products$P2"
import {$Applicative$Mu, $Applicative$Mu$Type} from "packages/com/mojang/datafixers/kinds/$Applicative$Mu"
import {$Function11, $Function11$Type} from "packages/com/mojang/datafixers/util/$Function11"
import {$Function10, $Function10$Type} from "packages/com/mojang/datafixers/util/$Function10"
import {$Products$P9, $Products$P9$Type} from "packages/com/mojang/datafixers/$Products$P9"
import {$Function4, $Function4$Type} from "packages/com/mojang/datafixers/util/$Function4"
import {$Function15, $Function15$Type} from "packages/com/mojang/datafixers/util/$Function15"
import {$Products$P7, $Products$P7$Type} from "packages/com/mojang/datafixers/$Products$P7"
import {$Function3, $Function3$Type} from "packages/com/mojang/datafixers/util/$Function3"
import {$Function14, $Function14$Type} from "packages/com/mojang/datafixers/util/$Function14"
import {$Products$P8, $Products$P8$Type} from "packages/com/mojang/datafixers/$Products$P8"
import {$Function13, $Function13$Type} from "packages/com/mojang/datafixers/util/$Function13"
import {$Products$P5, $Products$P5$Type} from "packages/com/mojang/datafixers/$Products$P5"
import {$Function12, $Function12$Type} from "packages/com/mojang/datafixers/util/$Function12"
import {$Products$P6, $Products$P6$Type} from "packages/com/mojang/datafixers/$Products$P6"

export class $NamedRecordCodec$Instance<O> implements $Applicative<($NamedRecordCodec$Mu<(O)>), ($NamedRecordCodec$Instance$Mu<(O)>)> {

constructor()

public "map"<T, R>(func: $Function$Type<(any), (any)>, ts: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "point"<A>(a: A): $App<($NamedRecordCodec$Mu<(O)>), (A)>
public "ap2"<A, B, R>(func: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($BiFunction$Type<(A), (B), (R)>)>, a: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (A)>, b: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (B)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap3"<T1, T2, T3, R>(func: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function3$Type<(T1), (T2), (T3), (R)>)>, t1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, t2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, t3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "lift1"<A, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function$Type<(A), (R)>)>): $Function<($App<($NamedRecordCodec$Mu<(O)>), (A)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "ap4"<T1, T2, T3, T4, R>(func: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function4$Type<(T1), (T2), (T3), (T4), (R)>)>, t1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, t2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, t3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, t4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public static "unbox"<F extends $K1, Mu extends $Applicative$Mu>(arg0: $App$Type<($NamedRecordCodec$Instance$Mu$Type<(O)>), ($NamedRecordCodec$Mu$Type<(O)>)>): $Applicative<($NamedRecordCodec$Mu<(O)>), ($NamedRecordCodec$Instance$Mu<(O)>)>
public "ap"<A, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function$Type<(A), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (A)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap"<A, R>(arg0: $Function$Type<(A), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (A)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply3"<T1, T2, T3, R>(arg0: $Function3$Type<(T1), (T2), (T3), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply2"<A, B, R>(arg0: $BiFunction$Type<(A), (B), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (A)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (B)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "lift9"<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function9$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (R)>)>): $Function9<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (T5)>), ($App<($NamedRecordCodec$Mu<(O)>), (T6)>), ($App<($NamedRecordCodec$Mu<(O)>), (T7)>), ($App<($NamedRecordCodec$Mu<(O)>), (T8)>), ($App<($NamedRecordCodec$Mu<(O)>), (T9)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "ap8"<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function8$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap7"<T1, T2, T3, T4, T5, T6, T7, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function7$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap9"<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function9$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "lift3"<T1, T2, T3, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function3$Type<(T1), (T2), (T3), (R)>)>): $Function3<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "lift2"<A, B, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($BiFunction$Type<(A), (B), (R)>)>): $BiFunction<($App<($NamedRecordCodec$Mu<(O)>), (A)>), ($App<($NamedRecordCodec$Mu<(O)>), (B)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "lift5"<T1, T2, T3, T4, T5, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function5$Type<(T1), (T2), (T3), (T4), (T5), (R)>)>): $Function5<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (T5)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "lift6"<T1, T2, T3, T4, T5, T6, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function6$Type<(T1), (T2), (T3), (T4), (T5), (T6), (R)>)>): $Function6<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (T5)>), ($App<($NamedRecordCodec$Mu<(O)>), (T6)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "ap6"<T1, T2, T3, T4, T5, T6, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function6$Type<(T1), (T2), (T3), (T4), (T5), (T6), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "lift4"<T1, T2, T3, T4, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function4$Type<(T1), (T2), (T3), (T4), (R)>)>): $Function4<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "lift7"<T1, T2, T3, T4, T5, T6, T7, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function7$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (R)>)>): $Function7<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (T5)>), ($App<($NamedRecordCodec$Mu<(O)>), (T6)>), ($App<($NamedRecordCodec$Mu<(O)>), (T7)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "ap5"<T1, T2, T3, T4, T5, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function5$Type<(T1), (T2), (T3), (T4), (T5), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "lift8"<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function8$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (R)>)>): $Function8<($App<($NamedRecordCodec$Mu<(O)>), (T1)>), ($App<($NamedRecordCodec$Mu<(O)>), (T2)>), ($App<($NamedRecordCodec$Mu<(O)>), (T3)>), ($App<($NamedRecordCodec$Mu<(O)>), (T4)>), ($App<($NamedRecordCodec$Mu<(O)>), (T5)>), ($App<($NamedRecordCodec$Mu<(O)>), (T6)>), ($App<($NamedRecordCodec$Mu<(O)>), (T7)>), ($App<($NamedRecordCodec$Mu<(O)>), (T8)>), ($App<($NamedRecordCodec$Mu<(O)>), (R)>)>
public "ap11"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function11$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap10"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function10$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap13"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function13$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap12"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function12$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply7"<T1, T2, T3, T4, T5, T6, T7, R>(arg0: $Function7$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap14"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function14$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg14: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply6"<T1, T2, T3, T4, T5, T6, R>(arg0: $Function6$Type<(T1), (T2), (T3), (T4), (T5), (T6), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap15"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function15$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14), (T15), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg14: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>, arg15: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T15)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply4"<T1, T2, T3, T4, R>(arg0: $Function4$Type<(T1), (T2), (T3), (T4), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply8"<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: $Function8$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply5"<T1, T2, T3, T4, T5, R>(arg0: $Function5$Type<(T1), (T2), (T3), (T4), (T5), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "apply9"<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: $Function9$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (R)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "ap16"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), ($Function16$Type<(T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14), (T15), (T16), (R)>)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg14: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>, arg15: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T15)>, arg16: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T16)>): $App<($NamedRecordCodec$Mu<(O)>), (R)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>): $Products$P11<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>): $Products$P10<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>): $Products$P9<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>, arg14: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T15)>, arg15: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T16)>): $Products$P16<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14), (T15), (T16)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>, arg14: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T15)>): $Products$P15<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14), (T15)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>, arg13: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T14)>): $Products$P14<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13), (T14)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>, arg12: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T13)>): $Products$P13<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12), (T13)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>, arg8: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T9)>, arg9: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T10)>, arg10: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T11)>, arg11: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T12)>): $Products$P12<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8), (T9), (T10), (T11), (T12)>
public "group"<T1, T2, T3>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>): $Products$P3<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3)>
public "group"<T1, T2>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>): $Products$P2<($NamedRecordCodec$Mu<(O)>), (T1), (T2)>
public "group"<T1>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>): $Products$P1<($NamedRecordCodec$Mu<(O)>), (T1)>
public "group"<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>, arg7: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T8)>): $Products$P8<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7), (T8)>
public "group"<T1, T2, T3, T4, T5, T6, T7>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>, arg6: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T7)>): $Products$P7<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6), (T7)>
public "group"<T1, T2, T3, T4, T5, T6>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>, arg5: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T6)>): $Products$P6<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5), (T6)>
public "group"<T1, T2, T3, T4, T5>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>, arg4: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T5)>): $Products$P5<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4), (T5)>
public "group"<T1, T2, T3, T4>(arg0: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T1)>, arg1: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T2)>, arg2: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T3)>, arg3: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (T4)>): $Products$P4<($NamedRecordCodec$Mu<(O)>), (T1), (T2), (T3), (T4)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedRecordCodec$Instance$Type<O> = ($NamedRecordCodec$Instance<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedRecordCodec$Instance_<O> = $NamedRecordCodec$Instance$Type<(O)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$GuiElementJEIRendererRegistry" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $GuiElementJEIRendererRegistry {

constructor()

public static "init"(): void
public static "getJEIRenderer"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>): $IJEIElementRenderer<($IGuiElement)>
public static "hasJEIRenderer"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementJEIRendererRegistry$Type = ($GuiElementJEIRendererRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementJEIRendererRegistry_ = $GuiElementJEIRendererRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EnergyPerTickRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $EnergyPerTickRequirementJS extends $RecipeJSBuilder {

 "requireEnergyPerTick"(amount: integer): $RecipeJSBuilder
 "produceEnergyPerTick"(amount: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $EnergyPerTickRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyPerTickRequirementJS$Type = ($EnergyPerTickRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyPerTickRequirementJS_ = $EnergyPerTickRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$BarGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ProgressBarGuiElement$Orientation, $ProgressBarGuiElement$Orientation$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement$Orientation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $BarGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_EMPTY_TEXTURE": $ResourceLocation
static readonly "BASE_FILLED_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($BarGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, min: integer, max: integer, highlight: boolean, orientation: $ProgressBarGuiElement$Orientation$Type, emptyTexture: $ResourceLocation$Type, filledTexture: $ResourceLocation$Type)

public "getType"(): $GuiElementType<($BarGuiElement)>
public "getMin"(): integer
public "getMax"(): integer
public "getFilledTexture"(): $ResourceLocation
public "isHighlight"(): boolean
public "getEmptyTexture"(): $ResourceLocation
public "getOrientation"(): $ProgressBarGuiElement$Orientation
get "type"(): $GuiElementType<($BarGuiElement)>
get "min"(): integer
get "max"(): integer
get "filledTexture"(): $ResourceLocation
get "highlight"(): boolean
get "emptyTexture"(): $ResourceLocation
get "orientation"(): $ProgressBarGuiElement$Orientation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarGuiElement$Type = ($BarGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BarGuiElement_ = $BarGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ComponentIOMode extends $Enum<($ComponentIOMode)> {
static readonly "INPUT": $ComponentIOMode
static readonly "OUTPUT": $ComponentIOMode
static readonly "BOTH": $ComponentIOMode
static readonly "NONE": $ComponentIOMode
static readonly "CODEC": $NamedCodec<($ComponentIOMode)>


public static "value"(value: string): $ComponentIOMode
public "toString"(): string
public static "values"(): ($ComponentIOMode)[]
public static "valueOf"(name: string): $ComponentIOMode
public "isInput"(): boolean
public "isOutput"(): boolean
public "getBaseConfig"(): $SideConfig$Template
public "toComponent"(): $Component
get "input"(): boolean
get "output"(): boolean
get "baseConfig"(): $SideConfig$Template
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentIOMode$Type = (("output") | ("input") | ("none") | ("both")) | ($ComponentIOMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentIOMode_ = $ComponentIOMode$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$RedstoneComponentBuilder" {
import {$RedstoneMachineComponent, $RedstoneMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$RedstoneMachineComponent$Template, $RedstoneMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent$Template"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $RedstoneComponentBuilder implements $IMachineComponentBuilder<($RedstoneMachineComponent), ($RedstoneMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($RedstoneMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $RedstoneMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $RedstoneMachineComponent$Template$Type, onFinish: $Consumer$Type<($RedstoneMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneComponentBuilder$Type = ($RedstoneComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneComponentBuilder_ = $RedstoneComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$JEIIngredientRenderer" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IIngredientRenderer, $IIngredientRenderer$Type} from "packages/mezz/jei/api/ingredients/$IIngredientRenderer"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $JEIIngredientRenderer<T, E extends $IGuiElement> implements $IIngredientRenderer<(T)> {
readonly "element": E

constructor(element: E)

public "getType"(): $IIngredientType<(T)>
public "getElement"(): E
public "render"(arg0: $GuiGraphics$Type, arg1: T): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getFontRenderer"(arg0: $Minecraft$Type, arg1: T): $Font
public "getTooltip"(arg0: T, arg1: $TooltipFlag$Type): $List<($Component)>
get "type"(): $IIngredientType<(T)>
get "element"(): E
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEIIngredientRenderer$Type<T, E> = ($JEIIngredientRenderer<(T), (E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEIIngredientRenderer_<T, E> = $JEIIngredientRenderer$Type<(T), (E)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$FloatSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatData, $FloatData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$FloatData"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $FloatSyncable extends $AbstractSyncable<($FloatData), (float)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(float)>, consumer: $Consumer$Type<(float)>): $FloatSyncable
public "getData"(id: short): $FloatData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatSyncable$Type = ($FloatSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatSyncable_ = $FloatSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$LongData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $LongData extends $Data<(long)> {

constructor(id: short, value: long)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongData$Type = ($LongData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongData_ = $LongData$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$IComponentGuiElement, $IComponentGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"

export interface $IRecipeHelper {

 "getJeiHelpers"(): $IJeiHelpers
 "getMachine"(): $ICustomMachine
 "getComponentForElement"(arg0: $IComponentGuiElement$Type<(any)>): $Optional<($IMachineComponentTemplate<(any)>)>
 "getDummyManager"(): $IMachineComponentManager
}

export namespace $IRecipeHelper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeHelper$Type = ($IRecipeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeHelper_ = $IRecipeHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$DropRequirement" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$DropRequirement$Action, $DropRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$DropRequirement$Action"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DropMachineComponent, $DropMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$DropMachineComponent"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $DropRequirement extends $AbstractDelayedChanceableRequirement<($DropMachineComponent)> implements $ITickableRequirement<($DropMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($DropRequirement)>

constructor(mode: $RequirementIOMode$Type, action: $DropRequirement$Action$Type, input: $List$Type<($IIngredient$Type<($Item$Type)>)>, whitelist: boolean, output: $Item$Type, nbt: $CompoundTag$Type, amount: integer, radius: integer)

public "test"(component: $DropMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($DropMachineComponent)>
public "execute"(component: $DropMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($DropRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $DropMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $DropMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $DropMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($DropMachineComponent)>
get "type"(): $RequirementType<($DropRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropRequirement$Type = ($DropRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropRequirement_ = $DropRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ItemRequirementJS extends $RecipeJSBuilder {

 "produceItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
 "produceItem"(stack: $ItemStack$Type): $RecipeJSBuilder
 "requireItem"(stack: $ItemStack$Type): $RecipeJSBuilder
 "requireItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
 "requireItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "requireItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
 "requireItemTag"(tag: string): $RecipeJSBuilder
 "requireItemTag"(tag: string, amount: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ItemRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirementJS$Type = ($ItemRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRequirementJS_ = $ItemRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$SkyRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $SkyRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "mustSeeSky"(): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $SkyRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkyRequirementCT$Type<T> = ($SkyRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SkyRequirementCT_<T> = $SkyRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IVariableComponent" {
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"

export interface $IVariableComponent<T extends $IComponentVariant> {

 "getVariant"(): T

(): T
}

export namespace $IVariableComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IVariableComponent$Type<T> = ($IVariableComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IVariableComponent_<T> = $IVariableComponent$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$CMRecipeTypes" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"

export class $CMRecipeTypes {

constructor()

public static "get"<T extends $IMachineRecipe>(recipeClass: $Class$Type<(T)>, id: $ResourceLocation$Type): $RecipeType<(T)>
public static "create"<T extends $IMachineRecipe>(id: $ResourceLocation$Type, recipeClass: $Class$Type<(T)>): $RecipeType<(T)>
public static "fromID"(id: $ResourceLocation$Type): $RecipeType<(any)>
public static "machine"(id: $ResourceLocation$Type): $RecipeType<($CustomMachineRecipe)>
public static "craft"(id: $ResourceLocation$Type): $RecipeType<($CustomCraftRecipe)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMRecipeTypes$Type = ($CMRecipeTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMRecipeTypes_ = $CMRecipeTypes$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ExperienceRequirement" {
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ExperienceMachineComponent, $ExperienceMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Experience$Form, $Experience$Form$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience$Form"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"

export class $ExperienceRequirement extends $AbstractChanceableRequirement<($ExperienceMachineComponent)> implements $IJEIIngredientRequirement<($Experience)> {
static readonly "CODEC": $NamedCodec<($ExperienceRequirement)>

constructor(mode: $RequirementIOMode$Type, amount: integer, type: $Experience$Form$Type)

public "test"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($ExperienceMachineComponent)>
public "getType"(): $RequirementType<($ExperienceRequirement)>
public "processStart"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getForm"(): $Experience$Form
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($Experience)>)>
get "componentType"(): $MachineComponentType<($ExperienceMachineComponent)>
get "type"(): $RequirementType<($ExperienceRequirement)>
get "form"(): $Experience$Form
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceRequirement$Type = ($ExperienceRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceRequirement_ = $ExperienceRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/upgrade/$IMachineUpgradeManager" {
import {$IRecipeModifier, $IRecipeModifier$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"

export interface $IMachineUpgradeManager {

 "markDirty"(): void
 "getAllModifiers"(): $List<($Pair<($IRecipeModifier), (integer)>)>
}

export namespace $IMachineUpgradeManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineUpgradeManager$Type = ($IMachineUpgradeManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineUpgradeManager_ = $IMachineUpgradeManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$MachineList" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $MachineList {

constructor()

public static "refreshAllMachines"(): void
public static "setNeedRefresh"(): void
public static "findInSameChunk"(machine: $MachineTile$Type): $Optional<($MachineTile)>
public static "findNearest"(player: $Player$Type, machine: $ResourceLocation$Type, radius: integer): $Optional<($MachineTile)>
public static "addMachine"(tile: $MachineTile$Type): void
public static "getLoadedMachines"(): $List<($MachineTile)>
get "loadedMachines"(): $List<($MachineTile)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineList$Type = ($MachineList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineList_ = $MachineList$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$FluidPerTickRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $FluidPerTickRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $FluidPerTickRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPerTickRequirementCT$Type<T> = ($FluidPerTickRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPerTickRequirementCT_<T> = $FluidPerTickRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$BoxRenderer" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $BoxRenderer {

constructor(time: integer, box: $AABB$Type)

public "render"(matrix: $PoseStack$Type, buffer: $MultiBufferSource$Type, machineFacing: $Direction$Type): void
public "shouldRender"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxRenderer$Type = ($BoxRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxRenderer_ = $BoxRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/slot/$ResultSlotItemComponent" {
import {$SlotItemComponent, $SlotItemComponent$Type} from "packages/fr/frinn/custommachinery/common/util/slot/$SlotItemComponent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ResultSlotItemComponent extends $SlotItemComponent {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(component: $ItemMachineComponent$Type, index: integer, x: integer, y: integer)

public "remove"(amount: integer): $ItemStack
public "mayPlace"(stack: $ItemStack$Type): boolean
public "onTake"(player: $Player$Type, stack: $ItemStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResultSlotItemComponent$Type = ($ResultSlotItemComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResultSlotItemComponent_ = $ResultSlotItemComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/network/$Data" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export class $Data<T> implements $IData<(T)> {

constructor(type: $DataType$Type<(any), (T)>, id: short, value: T)

public "getValue"(): T
public "getType"(): $DataType<(any), (T)>
public "getID"(): short
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
public "writeData"(buffer: $FriendlyByteBuf$Type): void
get "value"(): T
get "type"(): $DataType<(any), (T)>
get "iD"(): short
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Data$Type<T> = ($Data<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Data_<T> = $Data$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$ExperienceGuiElementJeiRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ExperienceGuiElement, $ExperienceGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ExperienceGuiElementJeiRenderer implements $IJEIElementRenderer<($ExperienceGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $ExperienceGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $ExperienceGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $ExperienceGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElementJeiRenderer$Type = ($ExperienceGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElementJeiRenderer_ = $ExperienceGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$TimeRequirement" {
import {$IntRange, $IntRange$Type} from "packages/fr/frinn/custommachinery/impl/util/$IntRange"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$TimeMachineComponent, $TimeMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$TimeMachineComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $TimeRequirement extends $AbstractRequirement<($TimeMachineComponent)> implements $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($TimeRequirement)>

constructor(range: $IntRange$Type)

public "test"(component: $TimeMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($TimeMachineComponent)>
public "getType"(): $RequirementType<($TimeRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processStart"(component: $TimeMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $TimeMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($TimeMachineComponent)>
get "type"(): $RequirementType<($TimeRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeRequirement$Type = ($TimeRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeRequirement_ = $TimeRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$PartialBlockState" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockInWorld, $BlockInWorld$Type} from "packages/net/minecraft/world/level/block/state/pattern/$BlockInWorld"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $PartialBlockState implements $Predicate<($BlockInWorld)> {
static readonly "AIR": $PartialBlockState
static readonly "ANY": $PartialBlockState
static readonly "MACHINE": $PartialBlockState
static readonly "CODEC": $NamedCodec<($PartialBlockState)>

constructor(blockState: $BlockState$Type, properties: $List$Type<($Property$Type<(any)>)>, nbt: $CompoundTag$Type)
constructor(block: $Block$Type)

public "getName"(): $MutableComponent
public "equals"(o: any): boolean
public "toString"(): string
public "test"(cachedBlockInfo: $BlockInWorld$Type): boolean
public "getProperties"(): $List<(string)>
public "rotate"(rotation: $Rotation$Type): $PartialBlockState
public "getNbt"(): $CompoundTag
public "getBlockState"(): $BlockState
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockInWorld)>
public "negate"(): $Predicate<($BlockInWorld)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockInWorld)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BlockInWorld)>
public static "isEqual"<T>(arg0: any): $Predicate<($BlockInWorld)>
get "name"(): $MutableComponent
get "properties"(): $List<(string)>
get "nbt"(): $CompoundTag
get "blockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PartialBlockState$Type = ($PartialBlockState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PartialBlockState_ = $PartialBlockState$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent$Template" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $FluidMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($FluidMachineComponent)> {
static readonly "CODEC": $NamedCodec<($FluidMachineComponent$Template)>

constructor(id: string, capacity: long, maxInput: long, maxOutput: long, filter: $List$Type<($IIngredient$Type<($Fluid$Type)>)>, whitelist: boolean, mode: $ComponentIOMode$Type, config: $SideConfig$Template$Type, unique: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $List<($IIngredient<($Fluid)>)>
public "id"(): string
public "getId"(): string
public "getType"(): $MachineComponentType<($FluidMachineComponent)>
public "mode"(): $ComponentIOMode
public "capacity"(): long
public "config"(): $SideConfig$Template
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
public "unique"(): boolean
public "maxInput"(): long
public "maxOutput"(): long
public "whitelist"(): boolean
get "type"(): $MachineComponentType<($FluidMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMachineComponent$Template$Type = ($FluidMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidMachineComponent$Template_ = $FluidMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$EffectRequirement" {
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$EffectMachineComponent, $EffectMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EffectMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $EffectRequirement extends $AbstractDelayedChanceableRequirement<($EffectMachineComponent)> implements $ITickableRequirement<($EffectMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($EffectRequirement)>

constructor(effect: $MobEffect$Type, time: integer, level: integer, radius: integer, filter: $List$Type<($EntityType$Type<(any)>)>, applyAtEnd: boolean)

public "test"(component: $EffectMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($EffectMachineComponent)>
public "execute"(component: $EffectMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($EffectRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $EffectMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $EffectMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $EffectMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($EffectMachineComponent)>
get "type"(): $RequirementType<($EffectRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectRequirement$Type = ($EffectRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectRequirement_ = $EffectRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent$Template" {
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $ItemMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($ItemMachineComponent)> {
static readonly "CODEC": $NamedCodec<($ItemMachineComponent$Template)>

constructor(id: string, mode: $ComponentIOMode$Type, capacity: integer, maxInput: integer, maxOutput: integer, filter: $List$Type<($IIngredient$Type<($Item$Type)>)>, whitelist: boolean, variant: $ItemComponentVariant$Type, config: $SideConfig$Template$Type, locked: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $List<($IIngredient<($Item)>)>
public "id"(): string
public "getId"(): string
public "getType"(): $MachineComponentType<($ItemMachineComponent)>
public "mode"(): $ComponentIOMode
public "capacity"(): integer
public "getVariant"(): $ItemComponentVariant
public "variant"(): $ItemComponentVariant
public "config"(): $SideConfig$Template
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
public "maxInput"(): integer
public "maxOutput"(): integer
public "whitelist"(): boolean
public "locked"(): boolean
get "type"(): $MachineComponentType<($ItemMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMachineComponent$Template$Type = ($ItemMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMachineComponent$Template_ = $ItemMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ExperiencePerTickRequirement" {
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ExperienceMachineComponent, $ExperienceMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$Experience$Form, $Experience$Form$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience$Form"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"

export class $ExperiencePerTickRequirement extends $AbstractChanceableRequirement<($ExperienceMachineComponent)> implements $ITickableRequirement<($ExperienceMachineComponent)>, $IJEIIngredientRequirement<($Experience)> {
static readonly "CODEC": $NamedCodec<($ExperiencePerTickRequirement)>

constructor(mode: $RequirementIOMode$Type, amount: integer, type: $Experience$Form$Type)

public "test"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($ExperienceMachineComponent)>
public "getType"(): $RequirementType<($ExperiencePerTickRequirement)>
public "processTick"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ExperienceMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getForm"(): $Experience$Form
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($Experience)>)>
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($ExperienceMachineComponent)>
get "type"(): $RequirementType<($ExperiencePerTickRequirement)>
get "form"(): $Experience$Form
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperiencePerTickRequirement$Type = ($ExperiencePerTickRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperiencePerTickRequirement_ = $ExperiencePerTickRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$TextGuiElementWidget" {
import {$TextGuiElement, $TextGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TextGuiElementWidget extends $AbstractGuiElementWidget<($TextGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $TextGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextGuiElementWidget$Type = ($TextGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextGuiElementWidget_ = $TextGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DimensionRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $DimensionRequirementJS extends $RecipeJSBuilder {

 "dimensionWhitelist"(dimensions: (string)[]): $RecipeJSBuilder
 "dimensionBlacklist"(dimensions: (string)[]): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $DimensionRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionRequirementJS$Type = ($DimensionRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionRequirementJS_ = $DimensionRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$TextGuiElementJeiRenderer" {
import {$TextGuiElement, $TextGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TextGuiElementJeiRenderer implements $IJEIElementRenderer<($TextGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $TextGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $TextGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $TextGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextGuiElementJeiRenderer$Type = ($TextGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextGuiElementJeiRenderer_ = $TextGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement$ACTION" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $BlockRequirement$ACTION extends $Enum<($BlockRequirement$ACTION)> {
static readonly "CHECK": $BlockRequirement$ACTION
static readonly "BREAK": $BlockRequirement$ACTION
static readonly "DESTROY": $BlockRequirement$ACTION
static readonly "PLACE": $BlockRequirement$ACTION
static readonly "REPLACE_BREAK": $BlockRequirement$ACTION
static readonly "REPLACE_DESTROY": $BlockRequirement$ACTION
static readonly "CODEC": $NamedCodec<($BlockRequirement$ACTION)>


public static "value"(value: string): $BlockRequirement$ACTION
public static "values"(): ($BlockRequirement$ACTION)[]
public static "valueOf"(name: string): $BlockRequirement$ACTION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRequirement$ACTION$Type = (("replace_break") | ("replace_destroy") | ("break") | ("destroy") | ("check") | ("place")) | ($BlockRequirement$ACTION);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRequirement$ACTION_ = $BlockRequirement$ACTION$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$AppearanceTab" {
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"

export class $AppearanceTab extends $MachineEditTab {
readonly "parent": $MachineEditScreen

constructor(parent: $MachineEditScreen$Type)

public "initList"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppearanceTab$Type = ($AppearanceTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AppearanceTab_ = $AppearanceTab$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $CustomCraftRecipeSerializer implements $RecipeSerializer<($CustomCraftRecipe)> {

constructor()

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): $CustomCraftRecipe
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): $CustomCraftRecipe
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: $CustomCraftRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $CustomCraftRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCraftRecipeSerializer$Type = ($CustomCraftRecipeSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCraftRecipeSerializer_ = $CustomCraftRecipeSerializer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Result" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"

export class $Result {


public static "error"(error: $Component$Type): $Result
public static "success"(): $Result
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Result$Type = ($Result);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Result_ = $Result$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$AbstractRecipeCategory" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IRecipeSlotsView, $IRecipeSlotsView$Type} from "packages/mezz/jei/api/gui/ingredient/$IRecipeSlotsView"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$IDrawable, $IDrawable$Type} from "packages/mezz/jei/api/gui/drawable/$IDrawable"
import {$IFocusGroup, $IFocusGroup$Type} from "packages/mezz/jei/api/recipe/$IFocusGroup"
import {$InputConstants$Key, $InputConstants$Key$Type} from "packages/com/mojang/blaze3d/platform/$InputConstants$Key"

export class $AbstractRecipeCategory<T extends $IMachineRecipe> implements $IRecipeCategory<(T)> {

constructor(machine: $CustomMachine$Type, type: $RecipeType$Type<(T)>, helpers: $IJeiHelpers$Type)

public "getRecipeType"(): $RecipeType<(T)>
public "draw"(recipe: T, slotsView: $IRecipeSlotsView$Type, graphics: $GuiGraphics$Type, mouseX: double, mouseY: double): void
public "getIcon"(): $IDrawable
public "getTitle"(): $Component
public "handleInput"(recipe: T, mouseX: double, mouseY: double, mouseButton: $InputConstants$Key$Type): boolean
public "setRecipe"(builder: $IRecipeLayoutBuilder$Type, recipe: T, focuses: $IFocusGroup$Type): void
public "getBackground"(): $IDrawable
public "getTooltipStrings"(recipe: T, view: $IRecipeSlotsView$Type, mouseX: double, mouseY: double): $List<($Component)>
public "getWidth"(): integer
public "getHeight"(): integer
public "isHandled"(arg0: T): boolean
public "getRegistryName"(arg0: T): $ResourceLocation
get "recipeType"(): $RecipeType<(T)>
get "icon"(): $IDrawable
get "title"(): $Component
get "background"(): $IDrawable
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractRecipeCategory$Type<T> = ($AbstractRecipeCategory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractRecipeCategory_<T> = $AbstractRecipeCategory$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/utils/$ICMConfig" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ICMConfig {

 "logMissingOptional"(): boolean
 "logFirstEitherError"(): boolean
}

export namespace $ICMConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICMConfig$Type = ($ICMConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICMConfig_ = $ICMConfig$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$SoundManager" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$SoundInstance, $SoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $SoundManager {

constructor(pos: $BlockPos$Type)

public "stop"(): void
public "play"(): void
public "isPlaying"(): boolean
public "setSound"(sound: $SoundEvent$Type): void
public "getSoundID"(): $ResourceLocation
public "getSound"(): $Optional<($SoundInstance)>
get "playing"(): boolean
set "sound"(value: $SoundEvent$Type)
get "soundID"(): $ResourceLocation
get "sound"(): $Optional<($SoundInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundManager$Type = ($SoundManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundManager_ = $SoundManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ExperienceGuiElement$DisplayMode, $ExperienceGuiElement$DisplayMode$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement$DisplayMode"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ExperienceGuiElement$Mode, $ExperienceGuiElement$Mode$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement$Mode"

export class $ExperienceGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "BASE_TEXTURE_HOVERED": $ResourceLocation
static readonly "CODEC": $NamedCodec<($ExperienceGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, displayMode: $ExperienceGuiElement$DisplayMode$Type, mode: $ExperienceGuiElement$Mode$Type)

public "getType"(): $GuiElementType<($ExperienceGuiElement)>
public "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
public "getMode"(): $ExperienceGuiElement$Mode
public "getDisplayMode"(): $ExperienceGuiElement$DisplayMode
get "type"(): $GuiElementType<($ExperienceGuiElement)>
get "mode"(): $ExperienceGuiElement$Mode
get "displayMode"(): $ExperienceGuiElement$DisplayMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElement$Type = ($ExperienceGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElement_ = $ExperienceGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$WeatherRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$WeatherMachineComponent, $WeatherMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$WeatherMachineComponent$WeatherType, $WeatherMachineComponent$WeatherType$Type} from "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent$WeatherType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $WeatherRequirement extends $AbstractRequirement<($WeatherMachineComponent)> implements $ITickableRequirement<($WeatherMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($WeatherRequirement)>

constructor(weather: $WeatherMachineComponent$WeatherType$Type, onMachine: boolean)

public "test"(component: $WeatherMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($WeatherMachineComponent)>
public "getType"(): $RequirementType<($WeatherRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $WeatherMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $WeatherMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $WeatherMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($WeatherMachineComponent)>
get "type"(): $RequirementType<($WeatherRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatherRequirement$Type = ($WeatherRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeatherRequirement_ = $WeatherRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$CustomMachineModelLoader$CustomMachineModelGeometry" {
import {$Material, $Material$Type} from "packages/net/minecraft/client/resources/model/$Material"
import {$ModelBaker, $ModelBaker$Type} from "packages/net/minecraft/client/resources/model/$ModelBaker"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IGeometryBakingContext, $IGeometryBakingContext$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryBakingContext"
import {$IUnbakedGeometry, $IUnbakedGeometry$Type} from "packages/net/minecraftforge/client/model/geometry/$IUnbakedGeometry"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$UnbakedModel, $UnbakedModel$Type} from "packages/net/minecraft/client/resources/model/$UnbakedModel"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $CustomMachineModelLoader$CustomMachineModelGeometry implements $IUnbakedGeometry<($CustomMachineModelLoader$CustomMachineModelGeometry)> {

constructor(defaults: $Map$Type<($MachineStatus$Type), ($ResourceLocation$Type)>)

public "bake"(iGeometryBakingContext: $IGeometryBakingContext$Type, arg: $ModelBaker$Type, arg2: $Function$Type<($Material$Type), ($TextureAtlasSprite$Type)>, arg2: $ModelState$Type, arg3: $ItemOverrides$Type, arg4: $ResourceLocation$Type): $BakedModel
public "getConfigurableComponentNames"(): $Set<(string)>
public "resolveParents"(arg0: $Function$Type<($ResourceLocation$Type), ($UnbakedModel$Type)>, arg1: $IGeometryBakingContext$Type): void
get "configurableComponentNames"(): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineModelLoader$CustomMachineModelGeometry$Type = ($CustomMachineModelLoader$CustomMachineModelGeometry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineModelLoader$CustomMachineModelGeometry_ = $CustomMachineModelLoader$CustomMachineModelGeometry$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$ProgressGuiElementJeiRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$ProgressBarGuiElement, $ProgressBarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ProgressGuiElementJeiRenderer implements $IJEIElementRenderer<($ProgressBarGuiElement)> {

constructor()

public "getJEITooltips"(element: $ProgressBarGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $ProgressBarGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "isHoveredInJei"(element: $ProgressBarGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressGuiElementJeiRenderer$Type = ($ProgressGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressGuiElementJeiRenderer_ = $ProgressGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$RecipeChecker, $RecipeChecker$Type} from "packages/fr/frinn/custommachinery/common/crafting/$RecipeChecker"

export class $CustomCraftRecipe implements $Recipe<($Container)>, $IMachineRecipe {
static readonly "FORBIDDEN_REQUIREMENTS": $List<($RequirementType<(any)>)>

constructor(id: $ResourceLocation$Type, machine: $ResourceLocation$Type, output: $ItemStack$Type, requirements: $List$Type<($IRequirement$Type<(any)>)>, jeiRequirements: $List$Type<($IRequirement$Type<(any)>)>, priority: integer, jeiPriority: integer, hidden: boolean)

public "getPriority"(): integer
public "getJeiPriority"(): integer
public "getJeiRequirements"(): $List<($IRequirement<(any)>)>
public "showInJei"(): boolean
public "getMachineId"(): $ResourceLocation
public "getResultItem"(access: $RegistryAccess$Type): $ItemStack
public "shouldResetOnError"(): boolean
public "getRecipeId"(): $ResourceLocation
public "getRecipeTime"(): integer
public "checker"(): $RecipeChecker<($CustomCraftRecipe)>
public "canCraftInDimensions"(i: integer, j: integer): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
public "assemble"(container: $Container$Type, access: $RegistryAccess$Type): $ItemStack
public "getRequirements"(): $List<($IRequirement<(any)>)>
public "getId"(): $ResourceLocation
public "matches"(container: $Container$Type, level: $Level$Type): boolean
public "getOutput"(): $ItemStack
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getDisplayInfoRequirements"(): $List<($IRequirement<(any)>)>
public "getJEIIngredientRequirements"(): $List<($IJEIIngredientRequirement<(any)>)>
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "priority"(): integer
get "jeiPriority"(): integer
get "jeiRequirements"(): $List<($IRequirement<(any)>)>
get "machineId"(): $ResourceLocation
get "recipeId"(): $ResourceLocation
get "recipeTime"(): integer
get "serializer"(): $RecipeSerializer<(any)>
get "requirements"(): $List<($IRequirement<(any)>)>
get "id"(): $ResourceLocation
get "output"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "special"(): boolean
get "displayInfoRequirements"(): $List<($IRequirement<(any)>)>
get "jEIIngredientRequirements"(): $List<($IJEIIngredientRequirement<(any)>)>
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCraftRecipe$Type = ($CustomCraftRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCraftRecipe_ = $CustomCraftRecipe$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ForgeFluidHelper" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$IFluidHelper, $IFluidHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IFluidHelper"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ForgeFluidHelper implements $IFluidHelper {

constructor()

public "isFluidHandler"(stack: $ItemStack$Type): boolean
public "fillTanksFromStack"(tanks: $List$Type<($FluidMachineComponent$Type)>, slot: $ItemMachineComponent$Type): void
public "fillStackFromTanks"(slot: $ItemMachineComponent$Type, tanks: $List$Type<($FluidMachineComponent$Type)>): void
public "transferFluid"(stack: $ItemStack$Type, component: $FluidMachineComponent$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFluidHelper$Type = ($ForgeFluidHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFluidHelper_ = $ForgeFluidHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemTransformRequirementJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ItemTransformRequirementJS extends $RecipeJSBuilder {

 "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
 "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
 "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type): $RecipeJSBuilder
 "transformItem"(input: $ItemStack$Type): $RecipeJSBuilder
 "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
 "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type): $RecipeJSBuilder
 "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
 "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type): $RecipeJSBuilder
 "transformItemTag"(tag: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ItemTransformRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransformRequirementJS$Type = ($ItemTransformRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransformRequirementJS_ = $ItemTransformRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent" {
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ExperienceMachineComponent extends $AbstractMachineComponent implements $ITickableComponent, $ISerializableComponent, $ISyncableStuff {

constructor(manager: $IMachineComponentManager$Type, capacity: integer, retrieveFromSlots: boolean, slotIds: $List$Type<(string)>)

public "getType"(): $MachineComponentType<(any)>
public "getCapacity"(): integer
public "deserialize"(nbt: $CompoundTag$Type): void
public "getLevels"(): integer
public "extractXp"(maxExtract: integer, simulate: boolean): integer
public "slotsFromCanRetrieve"(): $List<(string)>
public "canRetrieveFromSlots"(): boolean
public "getCapacityLevels"(): integer
public "receiveLevel"(levels: integer, simulate: boolean): integer
public "receiveXp"(maxReceive: integer, simulate: boolean): integer
public "awardXP"(xp: integer, player: $Player$Type): void
public "addLevelToPlayer"(levelDiff: integer, player: $Player$Type): void
public "extractLevel"(levels: integer, simulate: boolean): integer
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
public "addAllLevelToPlayer"(give: boolean, player: $Player$Type): void
public "setXp"(xp: integer): void
public "getXp"(): integer
public "clientTick"(): void
public "serverTick"(): void
get "type"(): $MachineComponentType<(any)>
get "capacity"(): integer
get "levels"(): integer
get "capacityLevels"(): integer
set "xp"(value: integer)
get "xp"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceMachineComponent$Type = ($ExperienceMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceMachineComponent_ = $ExperienceMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$FluidGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$FluidGuiElement, $FluidGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $FluidGuiElementBuilder implements $IGuiElementBuilder<($FluidGuiElement)> {

constructor()

public "type"(): $GuiElementType<($FluidGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $FluidGuiElement$Type): $FluidGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $FluidGuiElement$Type, onFinish: $Consumer$Type<($FluidGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidGuiElementBuilder$Type = ($FluidGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidGuiElementBuilder_ = $FluidGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$StructureRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"
import {$StructureRequirement$Action, $StructureRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StructureRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "placeStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, drops: boolean): T
 "destroyStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): T
 "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): T
 "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, action: $StructureRequirement$Action$Type): T
 "breakStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $StructureRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureRequirementCT$Type<T> = ($StructureRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureRequirementCT_<T> = $StructureRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$TextComponentUtils" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Style, $Style$Type} from "packages/net/minecraft/network/chat/$Style"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export class $TextComponentUtils {
static readonly "COLOR_CODEC": $NamedCodec<($TextColor)>
static readonly "STYLE_CODEC": $NamedMapCodec<($Style)>
static readonly "TEXT_COMPONENT_CODEC": $NamedCodec<($Component)>
static readonly "CODEC": $NamedCodec<($Component)>

constructor()

public static "fromJsonString"(jsonString: string): $Component
public static "toJsonString"(component: $Component$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponentUtils$Type = ($TextComponentUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponentUtils_ = $TextComponentUtils$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IDisplayInfo$TooltipPredicate, $IDisplayInfo$TooltipPredicate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$TooltipPredicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IDisplayInfo$ClickAction, $IDisplayInfo$ClickAction$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$ClickAction"

export interface $IDisplayInfo {

 "setItemIcon"(item: $Item$Type): $IDisplayInfo
 "setItemIcon"(arg0: $ItemStack$Type): $IDisplayInfo
 "setSpriteIcon"(arg0: $ResourceLocation$Type, arg1: $ResourceLocation$Type): $IDisplayInfo
 "setClickAction"(arg0: $IDisplayInfo$ClickAction$Type): void
 "setTextureIcon"(arg0: $ResourceLocation$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $IDisplayInfo
 "setTextureIcon"(texture: $ResourceLocation$Type, width: integer, height: integer): $IDisplayInfo
 "setTextureIcon"(texture: $ResourceLocation$Type): $IDisplayInfo
 "addTooltip"(text: $Component$Type): $IDisplayInfo
 "addTooltip"(arg0: $Component$Type, arg1: $IDisplayInfo$TooltipPredicate$Type): $IDisplayInfo
}

export namespace $IDisplayInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDisplayInfo$Type = ($IDisplayInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDisplayInfo_ = $IDisplayInfo$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/popup/$ComponentConfigPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"
import {$MachineConfigScreen, $MachineConfigScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$MachineConfigScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $ComponentConfigPopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineConfigScreen$Type, config: $SideConfig$Type)

public "renderBackground"(graphics: $GuiGraphics$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentConfigPopup$Type = ($ComponentConfigPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentConfigPopup_ = $ComponentConfigPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$FuelGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$FuelGuiElement, $FuelGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FuelGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $FuelGuiElementBuilder implements $IGuiElementBuilder<($FuelGuiElement)> {

constructor()

public "type"(): $GuiElementType<($FuelGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $FuelGuiElement$Type): $FuelGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $FuelGuiElement$Type, onFinish: $Consumer$Type<($FuelGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelGuiElementBuilder$Type = ($FuelGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelGuiElementBuilder_ = $FuelGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$CustomMachineModelLoader" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$IGeometryLoader, $IGeometryLoader$Type} from "packages/net/minecraftforge/client/model/geometry/$IGeometryLoader"
import {$JsonDeserializationContext, $JsonDeserializationContext$Type} from "packages/com/google/gson/$JsonDeserializationContext"
import {$CustomMachineModelLoader$CustomMachineModelGeometry, $CustomMachineModelLoader$CustomMachineModelGeometry$Type} from "packages/fr/frinn/custommachinery/forge/client/$CustomMachineModelLoader$CustomMachineModelGeometry"

export class $CustomMachineModelLoader implements $IGeometryLoader<($CustomMachineModelLoader$CustomMachineModelGeometry)> {
static readonly "INSTANCE": $CustomMachineModelLoader

constructor()

public "read"(json: $JsonObject$Type, deserializationContext: $JsonDeserializationContext$Type): $CustomMachineModelLoader$CustomMachineModelGeometry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineModelLoader$Type = ($CustomMachineModelLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineModelLoader_ = $CustomMachineModelLoader$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateUpgradesPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MachineUpgrade, $MachineUpgrade$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$MachineUpgrade"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateUpgradesPacket extends $BaseS2CMessage {

constructor(upgrades: $List$Type<($MachineUpgrade$Type)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateUpgradesPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateUpgradesPacket$Type = ($SUpdateUpgradesPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateUpgradesPacket_ = $SUpdateUpgradesPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"
import {$IDelayedRequirement, $IDelayedRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IDelayedRequirement"

export class $AbstractDelayedRequirement<T extends $IMachineComponent> extends $AbstractRequirement<(T)> implements $IDelayedRequirement<(T)> {

constructor(mode: $RequirementIOMode$Type)

public "isDelayed"(): boolean
public "getDelay"(): double
public "setDelay"(delay: double): void
public "execute"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
get "delayed"(): boolean
get "delay"(): double
set "delay"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDelayedRequirement$Type<T> = ($AbstractDelayedRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractDelayedRequirement_<T> = $AbstractDelayedRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineUpgradeJSBuilder$UpgradeEvent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CustomMachineUpgradeJSBuilder, $CustomMachineUpgradeJSBuilder$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineUpgradeJSBuilder"

export class $CustomMachineUpgradeJSBuilder$UpgradeEvent extends $EventJS {

constructor()

public "create"(item: $Item$Type, maxAmount: integer): $CustomMachineUpgradeJSBuilder
public "create"(item: $Item$Type): $CustomMachineUpgradeJSBuilder
public "getBuilders"(): $List<($CustomMachineUpgradeJSBuilder)>
get "builders"(): $List<($CustomMachineUpgradeJSBuilder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineUpgradeJSBuilder$UpgradeEvent$Type = ($CustomMachineUpgradeJSBuilder$UpgradeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineUpgradeJSBuilder$UpgradeEvent_ = $CustomMachineUpgradeJSBuilder$UpgradeEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$IDelayedRequirement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export interface $IDelayedRequirement<T extends $IMachineComponent> extends $IRequirement<(T)> {

 "execute"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "getDelay"(): double
 "setDelay"(arg0: double): void
 "test"(arg0: T, arg1: $ICraftingContext$Type): boolean
 "getComponentType"(): $MachineComponentType<(T)>
 "getType"(): $RequirementType<(any)>
 "getDisplayInfo"(info: $IDisplayInfo$Type): void
 "getMode"(): $RequirementIOMode
 "processStart"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "processEnd"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "getDisplayInfoTemplate"(): $DisplayInfoTemplate
 "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
}

export namespace $IDelayedRequirement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDelayedRequirement$Type<T> = ($IDelayedRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDelayedRequirement_<T> = $IDelayedRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$FunctionRequirement" {
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$FunctionMachineComponent, $FunctionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FunctionMachineComponent"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$FunctionRequirement$Phase, $FunctionRequirement$Phase$Type} from "packages/fr/frinn/custommachinery/common/requirement/$FunctionRequirement$Phase"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $FunctionRequirement extends $AbstractDelayedChanceableRequirement<($FunctionMachineComponent)> implements $ITickableRequirement<($FunctionMachineComponent)> {
static readonly "CODEC": $NamedCodec<($FunctionRequirement)>

constructor(phase: $FunctionRequirement$Phase$Type, arg1: $Function$Type<($ICraftingContext$Type), ($CraftingResult$Type)>, logger: $Consumer$Type<($Throwable$Type)>)

public "test"(component: $FunctionMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($FunctionMachineComponent)>
public "execute"(component: $FunctionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($FunctionRequirement)>
public "processTick"(component: $FunctionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $FunctionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $FunctionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "setDelay"(delay: double): void
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($FunctionMachineComponent)>
get "type"(): $RequirementType<($FunctionRequirement)>
set "delay"(value: double)
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionRequirement$Type = ($FunctionRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionRequirement_ = $FunctionRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$IProcessorTemplate" {
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"

export interface $IProcessorTemplate<T extends $IProcessor> {

 "getType"(): $ProcessorType<(T)>
 "build"(arg0: $MachineTile$Type): T
}

export namespace $IProcessorTemplate {
const CODEC: $NamedCodec<($IProcessorTemplate<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProcessorTemplate$Type<T> = ($IProcessorTemplate<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProcessorTemplate_<T> = $IProcessorTemplate$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$SideConfigData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export class $SideConfigData extends $Data<($SideConfig)> {

constructor(id: short, value: $SideConfig$Type)

public static "readData"(id: short, buffer: $FriendlyByteBuf$Type): $SideConfigData
public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideConfigData$Type = ($SideConfigData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideConfigData_ = $SideConfigData$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$GuiElementCreationPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $GuiElementCreationPopup extends $PopupScreen {
static readonly "CONFIRM": $Component
static readonly "CANCEL": $Component
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineEditScreen$Type, onChange: $Consumer$Type<($IGuiElement$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementCreationPopup$Type = ($GuiElementCreationPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementCreationPopup_ = $GuiElementCreationPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CAddMachinePacket" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CAddMachinePacket extends $BaseC2SMessage {

constructor(id: string, name: $Component$Type, kubejs: boolean)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CAddMachinePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CAddMachinePacket$Type = ($CAddMachinePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CAddMachinePacket_ = $CAddMachinePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonItemHandler" {
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"

export interface $ICommonItemHandler {

 "tick"(): void
 "invalidate"(): void
 "configChanged"(arg0: $RelativeSide$Type, arg1: $SideMode$Type, arg2: $SideMode$Type): void
}

export namespace $ICommonItemHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICommonItemHandler$Type = ($ICommonItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICommonItemHandler_ = $ICommonItemHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/slot/$SlotItemComponent" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $SlotItemComponent extends $Slot {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(component: $ItemMachineComponent$Type, index: integer, x: integer, y: integer)

public "getComponent"(): $ItemMachineComponent
public "remove"(amount: integer): $ItemStack
public "getItem"(): $ItemStack
public "mayPlace"(stack: $ItemStack$Type): boolean
public "mayPickup"(player: $Player$Type): boolean
public "setChanged"(): void
public "set"(stack: $ItemStack$Type): void
public "getMaxStackSize"(): integer
get "component"(): $ItemMachineComponent
get "item"(): $ItemStack
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotItemComponent$Type = ($SlotItemComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotItemComponent_ = $SlotItemComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$BooleanSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BooleanData, $BooleanData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$BooleanData"

export class $BooleanSyncable extends $AbstractSyncable<($BooleanData), (boolean)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(boolean)>, consumer: $Consumer$Type<(boolean)>): $BooleanSyncable
public "getData"(id: short): $BooleanData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanSyncable$Type = ($BooleanSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanSyncable_ = $BooleanSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateMachineGuiElementsPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateMachineGuiElementsPacket extends $BaseS2CMessage {

constructor(pos: $BlockPos$Type, guiElements: $List$Type<($IGuiElement$Type)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateMachineGuiElementsPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateMachineGuiElementsPacket$Type = ($SUpdateMachineGuiElementsPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateMachineGuiElementsPacket_ = $SUpdateMachineGuiElementsPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/$MachineAppearanceBuilderCT" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MachineAppearanceBuilderCT {

constructor()

public "miningLevel"(key: string): $MachineAppearanceBuilderCT
public "block"(block: string): $MachineAppearanceBuilderCT
public "color"(color: integer): $MachineAppearanceBuilderCT
public "build"(): $MachineAppearance
public "item"(item: string): $MachineAppearanceBuilderCT
public "requiresTool"(requires: boolean): $MachineAppearanceBuilderCT
public "light"(light: integer): $MachineAppearanceBuilderCT
public "hardness"(hardness: float): $MachineAppearanceBuilderCT
public "ambientSound"(sound: $SoundEvent$Type): $MachineAppearanceBuilderCT
public "interactionSound"(sound: $Block$Type): $MachineAppearanceBuilderCT
public "toolType"(tools: (string)[]): $MachineAppearanceBuilderCT
public "resistance"(resistance: float): $MachineAppearanceBuilderCT
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearanceBuilderCT$Type = ($MachineAppearanceBuilderCT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearanceBuilderCT_ = $MachineAppearanceBuilderCT$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$SidedItemHandler" {
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemSlot, $ItemSlot$Type} from "packages/fr/frinn/custommachinery/forge/transfer/$ItemSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $SidedItemHandler implements $IItemHandler {

constructor(direction: $Direction$Type, handler: $ItemComponentHandler$Type)

public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "getSlotList"(): $List<($ItemSlot)>
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "slotList"(): $List<($ItemSlot)>
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedItemHandler$Type = ($SidedItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedItemHandler_ = $SidedItemHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IMachineRecipe {

 "getDisplayInfoRequirements"(): $List<($IRequirement<(any)>)>
 "getJEIIngredientRequirements"(): $List<($IJEIIngredientRequirement<(any)>)>
 "getPriority"(): integer
 "getJeiPriority"(): integer
 "getJeiRequirements"(): $List<($IRequirement<(any)>)>
 "showInJei"(): boolean
 "getMachineId"(): $ResourceLocation
 "shouldResetOnError"(): boolean
 "getRecipeId"(): $ResourceLocation
 "getRecipeTime"(): integer
 "getRequirements"(): $List<($IRequirement<(any)>)>
}

export namespace $IMachineRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineRecipe$Type = ($IMachineRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineRecipe_ = $IMachineRecipe$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"

export interface $ICraftingContext {

 "getModifiedSpeed"(): double
 "getModifiedValue"(arg0: double, arg1: $IRequirement$Type<(any)>, arg2: string): double
 "getMachineTile"(): $MachineTile
 "getBaseSpeed"(): double
 "getRemainingTime"(): double
 "setBaseSpeed"(arg0: double): void
 "getIntegerModifiedValue"(arg0: double, arg1: $IRequirement$Type<(any)>, arg2: string): long
 "getPerTickIntegerModifiedValue"(arg0: double, arg1: $IRequirement$Type<(any)>, arg2: string): long
 "getPerTickModifiedValue"(arg0: double, arg1: $IRequirement$Type<(any)>, arg2: string): double
 "getRecipe"(): $IMachineRecipe
}

export namespace $ICraftingContext {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICraftingContext$Type = ($ICraftingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICraftingContext_ = $ICraftingContext$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CSetFilterSlotItemPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CSetFilterSlotItemPacket extends $BaseC2SMessage {

constructor(stack: $ItemStack$Type, pos: $BlockPos$Type, slotID: string)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CSetFilterSlotItemPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CSetFilterSlotItemPacket$Type = ($CSetFilterSlotItemPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CSetFilterSlotItemPacket_ = $CSetFilterSlotItemPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ProgressBarGuiElement$Orientation, $ProgressBarGuiElement$Orientation$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement$Orientation"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ProgressBarGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_EMPTY_TEXTURE": $ResourceLocation
static readonly "BASE_FILLED_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($ProgressBarGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, emptyTexture: $ResourceLocation$Type, filledTexture: $ResourceLocation$Type, orientation: $ProgressBarGuiElement$Orientation$Type, start: float, end: float)

public "getType"(): $GuiElementType<($ProgressBarGuiElement)>
public "getFilledTexture"(): $ResourceLocation
public "getEnd"(): float
public "getEmptyTexture"(): $ResourceLocation
public "getDirection"(): $ProgressBarGuiElement$Orientation
public "getStart"(): float
get "type"(): $GuiElementType<($ProgressBarGuiElement)>
get "filledTexture"(): $ResourceLocation
get "end"(): float
get "emptyTexture"(): $ResourceLocation
get "direction"(): $ProgressBarGuiElement$Orientation
get "start"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressBarGuiElement$Type = ($ProgressBarGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressBarGuiElement_ = $ProgressBarGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$EnergyRequirement" {
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $EnergyRequirement extends $AbstractChanceableRequirement<($EnergyMachineComponent)> implements $IJEIIngredientRequirement<($Energy)> {
static readonly "CODEC": $NamedCodec<($EnergyRequirement)>

constructor(mode: $RequirementIOMode$Type, amount: integer)

public "test"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($EnergyMachineComponent)>
public "getType"(): $RequirementType<($EnergyRequirement)>
public "processStart"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($Energy)>)>
get "componentType"(): $MachineComponentType<($EnergyMachineComponent)>
get "type"(): $RequirementType<($EnergyRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyRequirement$Type = ($EnergyRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyRequirement_ = $EnergyRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$Color3F" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Color3F {


public static "of"(colorARGB: integer): $Color3F
public static "of"(red: integer, green: integer, blue: integer): $Color3F
public static "of"(red: float, green: float, blue: float): $Color3F
public "getRed"(): float
public "getGreen"(): float
public "getBlue"(): float
get "red"(): float
get "green"(): float
get "blue"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Color3F$Type = ($Color3F);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Color3F_ = $Color3F$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SOpenFilePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SOpenFilePacket extends $BaseS2CMessage {

constructor(path: string)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SOpenFilePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SOpenFilePacket$Type = ($SOpenFilePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SOpenFilePacket_ = $SOpenFilePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CMLogger" {
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$Level, $Level$Type} from "packages/org/apache/logging/log4j/$Level"

export class $CMLogger {
static readonly "INSTANCE": $Logger
static readonly "NAME": string

constructor()

public static "init"(): void
public static "reset"(): void
public static "setDebugLevel"(level: $Level$Type): void
set "debugLevel"(value: $Level$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMLogger$Type = ($CMLogger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMLogger_ = $CMLogger$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $IAppearancePropertyBuilder<T> {

 "getType"(): $MachineAppearanceProperty<(T)>
 "makeWidget"(arg0: $BaseScreen$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $Supplier$Type<(T)>, arg6: $Consumer$Type<(T)>): $AbstractWidget
 "title"(): $Component
}

export namespace $IAppearancePropertyBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAppearancePropertyBuilder$Type<T> = ($IAppearancePropertyBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAppearancePropertyBuilder_<T> = $IAppearancePropertyBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$SlotGuiElementWidget" {
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$SlotGuiElement, $SlotGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$SlotGuiElement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $SlotGuiElementWidget extends $TexturedGuiElementWidget<($SlotGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $SlotGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotGuiElementWidget$Type = ($SlotGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotGuiElementWidget_ = $SlotGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/transfer/$IEnergyHelper" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IEnergyHelper {

 "unit"(): $Component
 "fillStackFromBuffer"(arg0: $ItemMachineComponent$Type, arg1: $EnergyMachineComponent$Type): void
 "fillBufferFromStack"(arg0: $EnergyMachineComponent$Type, arg1: $ItemMachineComponent$Type): void
 "isEnergyHandler"(arg0: $ItemStack$Type): boolean
}

export namespace $IEnergyHelper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEnergyHelper$Type = ($IEnergyHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEnergyHelper_ = $IEnergyHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export interface $IJEIIngredientWrapper<T> {

 "setupRecipe"(arg0: $IRecipeLayoutBuilder$Type, arg1: integer, arg2: integer, arg3: $IGuiElement$Type, arg4: $IRecipeHelper$Type): boolean
 "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole

(arg0: $IRecipeLayoutBuilder$Type, arg1: integer, arg2: integer, arg3: $IGuiElement$Type, arg4: $IRecipeHelper$Type): boolean
}

export namespace $IJEIIngredientWrapper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJEIIngredientWrapper$Type<T> = ($IJEIIngredientWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJEIIngredientWrapper_<T> = $IJEIIngredientWrapper$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ItemRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ItemRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ItemRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirementCT$Type<T> = ($ItemRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRequirementCT_<T> = $ItemRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$EntityRequirement" {
import {$EntityMachineComponent, $EntityMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EntityMachineComponent"
import {$EntityRequirement$ACTION, $EntityRequirement$ACTION$Type} from "packages/fr/frinn/custommachinery/common/requirement/$EntityRequirement$ACTION"
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $EntityRequirement extends $AbstractDelayedChanceableRequirement<($EntityMachineComponent)> implements $ITickableRequirement<($EntityMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($EntityRequirement)>

constructor(mode: $RequirementIOMode$Type, action: $EntityRequirement$ACTION$Type, amount: integer, radius: integer, filter: $List$Type<($EntityType$Type<(any)>)>, whitelist: boolean)

public "test"(component: $EntityMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($EntityMachineComponent)>
public "execute"(component: $EntityMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($EntityRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $EntityMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $EntityMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $EntityMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($EntityMachineComponent)>
get "type"(): $RequirementType<($EntityRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRequirement$Type = ($EntityRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRequirement_ = $EntityRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$RomanNumber" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RomanNumber {

constructor()

public static "toRoman"(number: integer): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RomanNumber$Type = ($RomanNumber);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RomanNumber_ = $RomanNumber$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$Result" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"

export class $Result {

constructor()

public static "error"(error: string): $CraftingResult
public static "error"(error: $Component$Type): $CraftingResult
public static "success"(): $CraftingResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Result$Type = ($Result);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Result_ = $Result$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$BooleanData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $BooleanData extends $Data<(boolean)> {

constructor(id: short, value: boolean)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanData$Type = ($BooleanData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanData_ = $BooleanData$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$ResetGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResetGuiElement, $ResetGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ResetGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $ResetGuiElementBuilder implements $IGuiElementBuilder<($ResetGuiElement)> {

constructor()

public "type"(): $GuiElementType<($ResetGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $ResetGuiElement$Type): $ResetGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $ResetGuiElement$Type, onFinish: $Consumer$Type<($ResetGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResetGuiElementBuilder$Type = ($ResetGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResetGuiElementBuilder_ = $ResetGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$RedstoneRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $RedstoneRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireRedstone"(power: string): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $RedstoneRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequirementCT$Type<T> = ($RedstoneRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneRequirementCT_<T> = $RedstoneRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ForgeItemHandler" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$ICommonItemHandler, $ICommonItemHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonItemHandler"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $ForgeItemHandler implements $ICommonItemHandler {

constructor(handler: $ItemComponentHandler$Type)

public "tick"(): void
public "invalidate"(): void
public "getCapability"(side: $Direction$Type): $LazyOptional<($IItemHandler)>
public "configChanged"(side: $RelativeSide$Type, oldMode: $SideMode$Type, newMode: $SideMode$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeItemHandler$Type = ($ForgeItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeItemHandler_ = $ForgeItemHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$CustomMachineOverrideList" {
import {$ClientLevel, $ClientLevel$Type} from "packages/net/minecraft/client/multiplayer/$ClientLevel"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $CustomMachineOverrideList extends $ItemOverrides {
static readonly "EMPTY": $ItemOverrides
static readonly "NO_OVERRIDE": float

constructor()

public "resolve"(model: $BakedModel$Type, stack: $ItemStack$Type, world: $ClientLevel$Type, livingEntity: $LivingEntity$Type, seed: integer): $BakedModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineOverrideList$Type = ($CustomMachineOverrideList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineOverrideList_ = $CustomMachineOverrideList$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ChunkloadRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ChunkloadRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "chunkload"(radius: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ChunkloadRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadRequirementCT$Type<T> = ($ChunkloadRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadRequirementCT_<T> = $ChunkloadRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$BiomeRequirement" {
import {$PositionMachineComponent, $PositionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$PositionMachineComponent"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $BiomeRequirement extends $AbstractRequirement<($PositionMachineComponent)> implements $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($BiomeRequirement)>

constructor(filter: $List$Type<($ResourceLocation$Type)>, blacklist: boolean)

public "test"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($PositionMachineComponent)>
public "getType"(): $RequirementType<($BiomeRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processStart"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($PositionMachineComponent)>
get "type"(): $RequirementType<($BiomeRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeRequirement$Type = ($BiomeRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeRequirement_ = $BiomeRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export interface $IMachineComponentBuilder<C extends $IMachineComponent, T extends $IMachineComponentTemplate<(C)>> {

 "type"(): $MachineComponentType<(C)>
 "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: T): void
 "makePopup"(arg0: $MachineEditScreen$Type, arg1: T, arg2: $Consumer$Type<(T)>): $PopupScreen
}

export namespace $IMachineComponentBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineComponentBuilder$Type<C, T> = ($IMachineComponentBuilder<(C), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineComponentBuilder_<C, T> = $IMachineComponentBuilder$Type<(C), (T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$SuggestedEditBox" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Suggestion, $Suggestion$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestion"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$EditBox, $EditBox$Type} from "packages/net/minecraft/client/gui/components/$EditBox"

export class $SuggestedEditBox extends $EditBox {
static readonly "BACKWARDS": integer
static readonly "FORWARDS": integer
static readonly "DEFAULT_TEXT_COLOR": integer
readonly "font": $Font
 "displayPos": integer
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(font: $Font$Type, x: integer, y: integer, width: integer, height: integer, message: $Component$Type, suggestionLineLimit: integer)

public "keyPressed"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "setFocused"(focused: boolean): void
public "clearSuggestions"(): void
public "addSuggestions"(suggestions: $List$Type<(string)>): void
public "hideSuggestions"(): void
public "render"(guiGraphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "mouseClicked"(mouseX: double, mouseY: double, mouseButton: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, delta: double): boolean
public "setResponder"(responder: $Consumer$Type<(string)>): void
public "setX"(x: integer): void
public "setY"(y: integer): void
public "getSuggestions"(): $List<($Suggestion)>
public "updateSuggestions"(): void
public "showSuggestions"(narrateFirstSuggestion: boolean): void
public "setAnchorToBottom"(): void
set "focused"(value: boolean)
set "responder"(value: $Consumer$Type<(string)>)
set "x"(value: integer)
set "y"(value: integer)
get "suggestions"(): $List<($Suggestion)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuggestedEditBox$Type = ($SuggestedEditBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuggestedEditBox_ = $SuggestedEditBox$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$IntegerSlider$Builder" {
import {$IntegerSlider, $IntegerSlider$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$IntegerSlider"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export class $IntegerSlider$Builder {

constructor()

public "bounds"(min: integer, max: integer): $IntegerSlider$Builder
public "defaultValue"(defaultValue: integer): $IntegerSlider$Builder
public "create"(x: integer, y: integer, width: integer, height: integer, message: $Component$Type): $IntegerSlider
public "setResponder"(responder: $Consumer$Type<(integer)>): $IntegerSlider$Builder
public "displayOnlyValue"(): $IntegerSlider$Builder
set "responder"(value: $Consumer$Type<(integer)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerSlider$Builder$Type = ($IntegerSlider$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerSlider$Builder_ = $IntegerSlider$Builder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$SkyMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $SkyMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($SkyMachineComponent)>
public "canSeeSky"(): boolean
get "type"(): $MachineComponentType<($SkyMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkyMachineComponent$Type = ($SkyMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SkyMachineComponent_ = $SkyMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$LRU" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LRU$LRUIterator, $LRU$LRUIterator$Type} from "packages/fr/frinn/custommachinery/common/util/$LRU$LRUIterator"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"

export class $LRU<T> extends $AbstractCollection<(T)> {

constructor()

public "add"(element: T): boolean
public "remove"(element: any): boolean
public "size"(): integer
public "iterator"(): $LRU$LRUIterator<>
public "contains"(element: any): boolean
public "descendingIterator"(): $LRU$LRUIterator<>
public "moveUp"(element: T): void
public "reverseIterate"(callback: $Consumer$Type<(T)>): void
public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LRU$Type<T> = ($LRU<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LRU_<T> = $LRU$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$DumpGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DumpGuiElement, $DumpGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$DumpGuiElement"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DumpGuiElementWidget extends $TexturedGuiElementWidget<($DumpGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $DumpGuiElement$Type, screen: $IMachineScreen$Type)

public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DumpGuiElementWidget$Type = ($DumpGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DumpGuiElementWidget_ = $DumpGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/crafting/$AbstractRecipeBuilder" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IRecipeBuilder, $IRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IRecipeBuilder"

export class $AbstractRecipeBuilder<T extends $IMachineRecipe> implements $IRecipeBuilder<(T)> {

constructor(machine: $ResourceLocation$Type)
constructor(recipe: T)

public "isHidden"(): boolean
public "getPriority"(): integer
public "getJeiPriority"(): integer
public "getJeiRequirements"(): $List<($IRequirement<(any)>)>
public "getMachine"(): $ResourceLocation
public "withPriority"(priority: integer): $AbstractRecipeBuilder<(T)>
public "getRequirements"(): $List<($IRequirement<(any)>)>
public "build"(arg0: $ResourceLocation$Type): T
get "hidden"(): boolean
get "priority"(): integer
get "jeiPriority"(): integer
get "jeiRequirements"(): $List<($IRequirement<(any)>)>
get "machine"(): $ResourceLocation
get "requirements"(): $List<($IRequirement<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractRecipeBuilder$Type<T> = ($AbstractRecipeBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractRecipeBuilder_<T> = $AbstractRecipeBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$OptionalFieldCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $OptionalFieldCodec<A> extends $NamedMapCodec<($Optional<(A)>)> {


public "name"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: $MapLike$Type<(T)>): $DataResult<($Optional<(A)>)>
public "encode"<T>(input: $Optional$Type<(A)>, ops: $DynamicOps$Type<(T)>, prefix: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(fieldName: string, elementCodec: $NamedCodec$Type<(A)>, name: string): $NamedMapCodec<($Optional<(A)>)>
public "keys"<T>(ops: $DynamicOps$Type<(T)>): $Stream<(T)>
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OptionalFieldCodec$Type<A> = ($OptionalFieldCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OptionalFieldCodec_<A> = $OptionalFieldCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/$BaseScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $BaseScreen extends $Screen {
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(component: $Component$Type, xSize: integer, ySize: integer)

public "keyPressed"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "isMouseOver"(mouseX: double, mouseY: double): boolean
public "setFocused"(focused: $GuiEventListener$Type): void
public "removed"(): void
public "openPopup"(popup: $PopupScreen$Type): void
public "openPopup"(popup: $PopupScreen$Type, id: string): void
public "closePopup"(popup: $PopupScreen$Type): void
public "getPopupUnderMouse"(mouseX: double, mouseY: double): $PopupScreen
public static "drawScaledString"(graphics: $GuiGraphics$Type, font: $Font$Type, text: $Component$Type, x: integer, y: integer, scale: float, color: integer, shadow: boolean): void
public static "drawCenteredString"(graphics: $GuiGraphics$Type, font: $Font$Type, text: $Component$Type, x: integer, y: integer, color: integer, shadow: boolean): void
public static "blankBackground"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer): void
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "isPauseScreen"(): boolean
public "resize"(minecraft: $Minecraft$Type, width: integer, height: integer): void
public "tick"(): void
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "charTyped"(codePoint: character, modifiers: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, delta: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, dragX: double, dragY: double): boolean
public "keyReleased"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "popups"(): $Collection<($PopupScreen)>
public static "drawCenteredScaledString"(graphics: $GuiGraphics$Type, font: $Font$Type, text: $Component$Type, x: integer, y: integer, scale: float, color: integer, shadow: boolean): void
set "focused"(value: $GuiEventListener$Type)
get "pauseScreen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseScreen$Type = ($BaseScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseScreen_ = $BaseScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$SpeedRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $SpeedRequirement extends $AbstractRequirement<($AbstractMachineComponent)> {
static readonly "CODEC": $NamedCodec<($SpeedRequirement)>

constructor()

public "test"(component: $AbstractMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($AbstractMachineComponent)>
public "getType"(): $RequirementType<($SpeedRequirement)>
public "processStart"(component: $AbstractMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $AbstractMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($AbstractMachineComponent)>
get "type"(): $RequirementType<($SpeedRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpeedRequirement$Type = ($SpeedRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpeedRequirement_ = $SpeedRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen" {
import {$Tooltip, $Tooltip$Type} from "packages/net/minecraft/client/gui/components/$Tooltip"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $PopupScreen extends $BaseScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, xSize: integer, ySize: integer)

public "closed"(): void
public "move"(movedX: integer, movedY: integer): void
public "renderBackground"(graphics: $GuiGraphics$Type): void
public "isMouseOver"(mouseX: double, mouseY: double): boolean
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltip"(mouseX: integer, mouseY: integer): $Tooltip
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, deltaX: double, deltaY: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PopupScreen$Type = ($PopupScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PopupScreen_ = $PopupScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$ComponentNotFoundException" {
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"

export class $ComponentNotFoundException extends $RuntimeException {

constructor(currentRecipe: $IMachineRecipe$Type, machine: $ICustomMachine$Type, requirementType: $RequirementType$Type<(any)>)

public "fillInStackTrace"(): $Throwable
public "getMessage"(): string
get "message"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentNotFoundException$Type = ($ComponentNotFoundException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentNotFoundException_ = $ComponentNotFoundException$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$SidedEnergyStorage" {
import {$IEnergyStorage, $IEnergyStorage$Type} from "packages/net/minecraftforge/energy/$IEnergyStorage"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $SidedEnergyStorage implements $IEnergyStorage {

constructor(mode: $Supplier$Type<($SideMode$Type)>, component: $EnergyMachineComponent$Type)

public "getEnergyStored"(): integer
public "getMaxEnergyStored"(): integer
public "canExtract"(): boolean
public "receiveEnergy"(maxReceive: integer, simulate: boolean): integer
public "canReceive"(): boolean
public "extractEnergy"(maxExtract: integer, simulate: boolean): integer
get "energyStored"(): integer
get "maxEnergyStored"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedEnergyStorage$Type = ($SidedEnergyStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedEnergyStorage_ = $SidedEnergyStorage$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$StringData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $StringData extends $Data<(string)> {

constructor(id: short, value: string)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringData$Type = ($StringData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringData_ = $StringData$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/$CraftingContext" {
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$IMachineUpgradeManager, $IMachineUpgradeManager$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IMachineUpgradeManager"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $CraftingContext implements $ICraftingContext {

constructor(manager: $IProcessor$Type, upgrades: $IMachineUpgradeManager$Type, recipe: $IMachineRecipe$Type)

public "getModifiedSpeed"(): double
public "getModifiedValue"(value: double, requirement: $IRequirement$Type<(any)>, target: string): double
public "getMachineTile"(): $MachineTile
public "getBaseSpeed"(): double
public "getRemainingTime"(): double
public "setBaseSpeed"(baseSpeed: double): void
public "getIntegerModifiedValue"(value: double, requirement: $IRequirement$Type<(any)>, target: string): long
public "getPerTickIntegerModifiedValue"(value: double, requirement: $IRequirement$Type<(any)>, target: string): long
public "getPerTickModifiedValue"(value: double, requirement: $IRequirement$Type<(any)>, target: string): double
public "getRecipe"(): $IMachineRecipe
get "modifiedSpeed"(): double
get "machineTile"(): $MachineTile
get "baseSpeed"(): double
get "remainingTime"(): double
set "baseSpeed"(value: double)
get "recipe"(): $IMachineRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingContext$Type = ($CraftingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingContext_ = $CraftingContext$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UnboundedMapCodec<K, V> implements $NamedCodec<($Map<(K), (V)>)> {


public "name"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<($Map<(K), (V)>), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: $Map$Type<(K), (V)>, prefix: T): $DataResult<(T)>
public static "of"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<($Map$Type<(K), (V)>)>): $NamedCodec<($Map<(K), (V)>)>
public static "of"<A>(codec: $Codec$Type<($Map$Type<(K), (V)>)>, name: string): $NamedCodec<($Map<(K), (V)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Map$Type<(K), (V)>)>, name: string): $NamedCodec<($List<($Map<(K), (V)>)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Map$Type<(K), (V)>)>): $NamedCodec<($List<($Map<(K), (V)>)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Map<(K), (V)>)>
public "copy"(input: $Map$Type<(K), (V)>): $Map<(K), (V)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<($Map$Type<(K), (V)>)>, name: string): $NamedCodec<($Map<(K), (V)>)>
public static "unit"<A>(defaultValue: $Map$Type<(K), (V)>, name: string): $NamedCodec<($Map<(K), (V)>)>
public static "unit"<A>(defaultValue: $Map$Type<(K), (V)>): $NamedCodec<($Map<(K), (V)>)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<($Map$Type<(K), (V)>)>)>, name: string): $NamedCodec<($Map<(K), (V)>)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): $Map<(K), (V)>
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<($Map<(K), (V)>)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<($Map<(K), (V)>)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Map$Type<(K), (V)>): $NamedMapCodec<($Map<(K), (V)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<($Map$Type<(K), (V)>)>): $NamedMapCodec<($Map<(K), (V)>)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: $Map$Type<(K), (V)>): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: $Map$Type<(K), (V)>, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<($Map<(K), (V)>)>)>
public "listOf"(name: string): $NamedCodec<($List<($Map<(K), (V)>)>)>
public static "registrar"<A>(registrar: $Registrar$Type<($Map$Type<(K), (V)>)>): $NamedCodec<($Map<(K), (V)>)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<($Map<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnboundedMapCodec$Type<K, V> = ($UnboundedMapCodec<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnboundedMapCodec_<K, V> = $UnboundedMapCodec$Type<(K), (V)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$SkyRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $SkyRequirementJS extends $RecipeJSBuilder {

 "mustSeeSky"(): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $SkyRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkyRequirementJS$Type = ($SkyRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SkyRequirementJS_ = $SkyRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent$Template" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$ExperienceMachineComponent, $ExperienceMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ExperienceMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($ExperienceMachineComponent)> {
static readonly "CODEC": $NamedCodec<($ExperienceMachineComponent$Template)>

constructor(capacity: integer, retrieve: boolean, slots: $List$Type<(string)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getId"(): string
public "getType"(): $MachineComponentType<($ExperienceMachineComponent)>
public "slots"(): $List<(string)>
public "capacity"(): integer
public "build"(manager: $IMachineComponentManager$Type): $ExperienceMachineComponent
public "retrieve"(): boolean
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
get "id"(): string
get "type"(): $MachineComponentType<($ExperienceMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceMachineComponent$Template$Type = ($ExperienceMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceMachineComponent$Template_ = $ExperienceMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$TextureGuiElementWidget" {
import {$TextureGuiElement, $TextureGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextureGuiElement"
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TextureGuiElementWidget extends $TexturedGuiElementWidget<($TextureGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $TextureGuiElement$Type, screen: $IMachineScreen$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureGuiElementWidget$Type = ($TextureGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureGuiElementWidget_ = $TextureGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ForgeEnergyHandler" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$IEnergyStorage, $IEnergyStorage$Type} from "packages/net/minecraftforge/energy/$IEnergyStorage"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ICommonEnergyHandler, $ICommonEnergyHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonEnergyHandler"

export class $ForgeEnergyHandler implements $ICommonEnergyHandler {

constructor(component: $EnergyMachineComponent$Type)

public "tick"(): void
public "invalidate"(): void
public "getCapability"(side: $Direction$Type): $LazyOptional<($IEnergyStorage)>
public "configChanged"(side: $RelativeSide$Type, oldMode: $SideMode$Type, newMode: $SideMode$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEnergyHandler$Type = ($ForgeEnergyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEnergyHandler_ = $ForgeEnergyHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CustomMachineBuilder, $CustomMachineBuilder$Type} from "packages/fr/frinn/custommachinery/common/machine/builder/$CustomMachineBuilder"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineCreationScreen, $MachineCreationScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineCreationScreen"

export class $MachineEditScreen extends $BaseScreen {
static readonly "WIDGETS": $ResourceLocation
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineCreationScreen$Type, xSize: integer, ySize: integer, builder: $CustomMachineBuilder$Type)

public "save"(): void
public "cancel"(): void
public "getBuilder"(): $CustomMachineBuilder
public "onClose"(): void
public "addRenderableWidget"<T extends ($GuiEventListener) & ($Renderable) & ($NarratableEntry)>(widget: T): T
public "m_169411_"(listener: $GuiEventListener$Type): void
public "m_267719_"(): void
public "renderBackground"(graphics: $GuiGraphics$Type): void
public "wiki"(): void
public "setChanged"(): void
get "builder"(): $CustomMachineBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineEditScreen$Type = ($MachineEditScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineEditScreen_ = $MachineEditScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$DimensionRequirement" {
import {$PositionMachineComponent, $PositionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$PositionMachineComponent"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $DimensionRequirement extends $AbstractRequirement<($PositionMachineComponent)> implements $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($DimensionRequirement)>

constructor(filter: $List$Type<($ResourceLocation$Type)>, blacklist: boolean)

public "test"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($PositionMachineComponent)>
public "getType"(): $RequirementType<($DimensionRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processStart"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($PositionMachineComponent)>
get "type"(): $RequirementType<($DimensionRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionRequirement$Type = ($DimensionRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionRequirement_ = $DimensionRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$StructureCreatorRenderer" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"

export class $StructureCreatorRenderer {

constructor()

public static "renderSelectedBlocks"(pose: $PoseStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCreatorRenderer$Type = ($StructureCreatorRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureCreatorRenderer_ = $StructureCreatorRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LightRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $LightRequirementJS extends $RecipeJSBuilder {

 "requireBlockLight"(level: string): $RecipeJSBuilder
 "requireSkyLight"(level: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $LightRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightRequirementJS$Type = ($LightRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LightRequirementJS_ = $LightRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/craft/$CraftRecipeFinder" {
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"
import {$CraftingContext$Mutable, $CraftingContext$Mutable$Type} from "packages/fr/frinn/custommachinery/common/crafting/$CraftingContext$Mutable"

export class $CraftRecipeFinder {

constructor(tile: $MachineTile$Type, baseCooldown: integer)

public "init"(): void
public "findRecipe"(context: $CraftingContext$Mutable$Type, immediately: boolean): $Optional<($CustomCraftRecipe)>
public "setInventoryChanged"(changed: boolean): void
set "inventoryChanged"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftRecipeFinder$Type = ($CraftRecipeFinder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftRecipeFinder_ = $CraftRecipeFinder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$FluidTagIngredient" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $FluidTagIngredient implements $IIngredient<($Fluid)> {
static readonly "CODEC": $NamedCodec<($FluidTagIngredient)>


public "toString"(): string
public "test"(fluid: $Fluid$Type): boolean
public static "create"(tag: $TagKey$Type<($Fluid$Type)>): $FluidTagIngredient
public static "create"(s: string): $FluidTagIngredient
public "getAll"(): $List<($Fluid)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public "negate"(): $Predicate<($Fluid)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public static "isEqual"<T>(arg0: any): $Predicate<($Fluid)>
get "all"(): $List<($Fluid)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTagIngredient$Type = ($FluidTagIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTagIngredient_ = $FluidTagIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$CustomCraftRecipeCategory" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$AbstractRecipeCategory, $AbstractRecipeCategory$Type} from "packages/fr/frinn/custommachinery/client/integration/jei/$AbstractRecipeCategory"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"

export class $CustomCraftRecipeCategory extends $AbstractRecipeCategory<($CustomCraftRecipe)> {

constructor(machine: $CustomMachine$Type, type: $RecipeType$Type<($CustomCraftRecipe$Type)>, helpers: $IJeiHelpers$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCraftRecipeCategory$Type = ($CustomCraftRecipeCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCraftRecipeCategory_ = $CustomCraftRecipeCategory$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/$CraftingContext$Mutable" {
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$CraftingContext, $CraftingContext$Type} from "packages/fr/frinn/custommachinery/common/crafting/$CraftingContext"
import {$IMachineUpgradeManager, $IMachineUpgradeManager$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IMachineUpgradeManager"

export class $CraftingContext$Mutable extends $CraftingContext {

constructor(manager: $IProcessor$Type, upgrades: $IMachineUpgradeManager$Type)

public "setRecipe"(recipe: $IMachineRecipe$Type): $CraftingContext$Mutable
public "getRecipe"(): $IMachineRecipe
set "recipe"(value: $IMachineRecipe$Type)
get "recipe"(): $IMachineRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingContext$Mutable$Type = ($CraftingContext$Mutable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingContext$Mutable_ = $CraftingContext$Mutable$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$FluidGuiElementJeiRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FluidGuiElement, $FluidGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $FluidGuiElementJeiRenderer implements $IJEIElementRenderer<($FluidGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $FluidGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $FluidGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $FluidGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidGuiElementJeiRenderer$Type = ($FluidGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidGuiElementJeiRenderer_ = $FluidGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$WeatherRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $WeatherRequirementJS extends $RecipeJSBuilder {

 "requireWeatherOnMachine"(weather: string): $RecipeJSBuilder
 "requireWeather"(weather: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $WeatherRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatherRequirementJS$Type = ($WeatherRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeatherRequirementJS_ = $WeatherRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$CustomIngredientTypes" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"

export class $CustomIngredientTypes {
static readonly "ENERGY": $IIngredientType<($Energy)>
static readonly "EXPERIENCE": $IIngredientType<($Experience)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientTypes$Type = ($CustomIngredientTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomIngredientTypes_ = $CustomIngredientTypes$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$BlockMachineComponent" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $BlockMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($BlockMachineComponent)>
public "replaceBlock"(box: $AABB$Type, block: $PartialBlockState$Type, amount: integer, drop: boolean, filter: $List$Type<($IIngredient$Type<($PartialBlockState$Type)>)>, whitelist: boolean): boolean
public "getBlockAmount"(box: $AABB$Type, filter: $List$Type<($IIngredient$Type<($PartialBlockState$Type)>)>, whitelist: boolean): long
public "placeBlock"(box: $AABB$Type, block: $PartialBlockState$Type, amount: integer): boolean
public "breakBlock"(box: $AABB$Type, filter: $List$Type<($IIngredient$Type<($PartialBlockState$Type)>)>, whitelist: boolean, amount: integer, drop: boolean): boolean
get "type"(): $MachineComponentType<($BlockMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMachineComponent$Type = ($BlockMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockMachineComponent_ = $BlockMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$IRecipeBuilder" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IRecipeBuilder<T extends $IMachineRecipe> {

 "build"(arg0: $ResourceLocation$Type): T
 "hide"(): $IRecipeBuilder<(T)>
 "withJeiPriority"(arg0: integer): $IRecipeBuilder<(T)>
 "withRequirement"(arg0: $IRequirement$Type<(any)>): $IRecipeBuilder<(T)>
 "withPriority"(arg0: integer): $IRecipeBuilder<(T)>
 "withJeiRequirement"(arg0: $IRequirement$Type<(any)>): $IRecipeBuilder<(T)>
}

export namespace $IRecipeBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeBuilder$Type<T> = ($IRecipeBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeBuilder_<T> = $IRecipeBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentCreationPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $ComponentCreationPopup extends $PopupScreen {
static readonly "CONFIRM": $Component
static readonly "CANCEL": $Component
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineEditScreen$Type, onChange: $Runnable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentCreationPopup$Type = ($ComponentCreationPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentCreationPopup_ = $ComponentCreationPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent" {
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $RedstoneMachineComponent extends $AbstractMachineComponent implements $ITickableComponent {

constructor(manager: $IMachineComponentManager$Type, powerToPause: integer, craftingPowerOutput: integer, idlePowerOutput: integer, erroredPowerOutput: integer, pausedPowerOutput: integer, comparatorInputType: $MachineComponentType$Type<(any)>, comparatorInputID: string)
constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($RedstoneMachineComponent)>
public "getMachinePower"(): integer
public "getPowerToPause"(): integer
public "getComparatorInput"(): integer
public "getPowerOutput"(): integer
public "serverTick"(): void
public "clientTick"(): void
get "type"(): $MachineComponentType<($RedstoneMachineComponent)>
get "machinePower"(): integer
get "powerToPause"(): integer
get "comparatorInput"(): integer
get "powerOutput"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneMachineComponent$Type = ($RedstoneMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneMachineComponent_ = $RedstoneMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$PositionMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PositionMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($PositionMachineComponent)>
public "getPosition"(): $BlockPos
public "getDimension"(): $ResourceKey<($Level)>
public "getBiome"(): $Biome
get "type"(): $MachineComponentType<($PositionMachineComponent)>
get "position"(): $BlockPos
get "dimension"(): $ResourceKey<($Level)>
get "biome"(): $Biome
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionMachineComponent$Type = ($PositionMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PositionMachineComponent_ = $PositionMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$BackgroundGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$AbstractGuiElement, $AbstractGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement"

export class $BackgroundGuiElement extends $AbstractGuiElement {
static readonly "BASE_BACKGROUND": $ResourceLocation
static readonly "CODEC": $NamedCodec<($BackgroundGuiElement)>

constructor(texture: $ResourceLocation$Type, width: integer, height: integer)

public "getType"(): $GuiElementType<($BackgroundGuiElement)>
public "getTexture"(): $ResourceLocation
public "getWidth"(): integer
public "getHeight"(): integer
get "type"(): $GuiElementType<($BackgroundGuiElement)>
get "texture"(): $ResourceLocation
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BackgroundGuiElement$Type = ($BackgroundGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BackgroundGuiElement_ = $BackgroundGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$ItemIngredient" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $ItemIngredient implements $IIngredient<($Item)> {

constructor(item: $Item$Type)

public "toString"(): string
public "test"(item: $Item$Type): boolean
public "getAll"(): $List<($Item)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public "negate"(): $Predicate<($Item)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public static "isEqual"<T>(arg0: any): $Predicate<($Item)>
get "all"(): $List<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemIngredient$Type = ($ItemIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemIngredient_ = $ItemIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$RedstoneRequirement" {
import {$RedstoneMachineComponent, $RedstoneMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent"
import {$IntRange, $IntRange$Type} from "packages/fr/frinn/custommachinery/impl/util/$IntRange"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $RedstoneRequirement extends $AbstractRequirement<($RedstoneMachineComponent)> implements $ITickableRequirement<($RedstoneMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($RedstoneRequirement)>

constructor(powerLevel: $IntRange$Type)

public "test"(component: $RedstoneMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($RedstoneMachineComponent)>
public "getType"(): $RequirementType<($RedstoneRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $RedstoneMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $RedstoneMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $RedstoneMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($RedstoneMachineComponent)>
get "type"(): $RequirementType<($RedstoneRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequirement$Type = ($RedstoneRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneRequirement_ = $RedstoneRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CMCollectors" {
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$List, $List$Type} from "packages/java/util/$List"

export class $CMCollectors {

constructor()

public static "toImmutableList"<T>(): $Collector<(T), ($List<(T)>), ($List<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMCollectors$Type = ($CMCollectors);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMCollectors_ = $CMCollectors$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/builder/$CustomMachineBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineLocation, $MachineLocation$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineLocation"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IProcessorTemplate, $IProcessorTemplate$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessorTemplate"
import {$MachineAppearanceBuilder, $MachineAppearanceBuilder$Type} from "packages/fr/frinn/custommachinery/common/machine/builder/$MachineAppearanceBuilder"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export class $CustomMachineBuilder {

constructor()
constructor(machine: $CustomMachine$Type)

public "getName"(): $Component
public "getLocation"(): $MachineLocation
public "setName"(name: $Component$Type): $CustomMachineBuilder
public "build"(): $CustomMachine
public "getGuiElements"(): $List<($IGuiElement)>
public "setLocation"(location: $MachineLocation$Type): $CustomMachineBuilder
public "setId"(id: $ResourceLocation$Type): $CustomMachineBuilder
public "getAppearance"(status: $MachineStatus$Type): $MachineAppearanceBuilder
public "setProcessor"(type: $ProcessorType$Type<(any)>): void
public "getComponents"(): $List<($IMachineComponentTemplate<(any)>)>
public "getProcessor"(): $IProcessorTemplate<(any)>
public "withAppearance"(status: $MachineStatus$Type, builder: $MachineAppearanceBuilder$Type): $CustomMachineBuilder
public "withGuiElement"(element: $IGuiElement$Type): $CustomMachineBuilder
public "getAppearanceBuilders"(): $Collection<($MachineAppearanceBuilder)>
get "name"(): $Component
get "location"(): $MachineLocation
set "name"(value: $Component$Type)
get "guiElements"(): $List<($IGuiElement)>
set "location"(value: $MachineLocation$Type)
set "id"(value: $ResourceLocation$Type)
set "processor"(value: $ProcessorType$Type<(any)>)
get "components"(): $List<($IMachineComponentTemplate<(any)>)>
get "processor"(): $IProcessorTemplate<(any)>
get "appearanceBuilders"(): $Collection<($MachineAppearanceBuilder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineBuilder$Type = ($CustomMachineBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineBuilder_ = $CustomMachineBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateMachinesPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateMachinesPacket extends $BaseS2CMessage {

constructor(machines: $Map$Type<($ResourceLocation$Type), ($CustomMachine$Type)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateMachinesPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateMachinesPacket$Type = ($SUpdateMachinesPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateMachinesPacket_ = $SUpdateMachinesPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $RelativeSide extends $Enum<($RelativeSide)> {
static readonly "TOP": $RelativeSide
static readonly "BOTTOM": $RelativeSide
static readonly "FRONT": $RelativeSide
static readonly "RIGHT": $RelativeSide
static readonly "BACK": $RelativeSide
static readonly "LEFT": $RelativeSide
static readonly "CODEC": $NamedCodec<($RelativeSide)>


public static "values"(): ($RelativeSide)[]
public static "valueOf"(name: string): $RelativeSide
public static "fromDirections"(facing: $Direction$Type, side: $Direction$Type): $RelativeSide
public "getDirection"(facing: $Direction$Type): $Direction
public "getTranslationName"(): $Component
get "translationName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeSide$Type = (("top") | ("left") | ("bottom") | ("back") | ("front") | ("right")) | ($RelativeSide);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RelativeSide_ = $RelativeSide$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$NarrationElementOutput, $NarrationElementOutput$Type} from "packages/net/minecraft/client/gui/narration/$NarrationElementOutput"

export class $AbstractGuiElementWidget<T extends $IGuiElement> extends $AbstractWidget {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: T, screen: $IMachineScreen$Type, title: $Component$Type)

public "getElement"(): T
public "getScreen"(): $IMachineScreen
public "render"(guiGraphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "setHeight"(height: integer): void
public "m_168797_"(output: $NarrationElementOutput$Type): void
public "getTooltips"(): $List<($Component)>
get "element"(): T
get "screen"(): $IMachineScreen
set "height"(value: integer)
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractGuiElementWidget$Type<T> = ($AbstractGuiElementWidget<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractGuiElementWidget_<T> = $AbstractGuiElementWidget$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"

export class $AbstractSyncable<D extends $IData<(any)>, T> implements $ISyncable<(D), (T)> {
 "lastKnownValue": T

constructor()

public "needSync"(): boolean
public "get"(): T
public "set"(arg0: T): void
public "getData"(arg0: short): D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSyncable$Type<D, T> = ($AbstractSyncable<(D), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractSyncable_<D, T> = $AbstractSyncable$Type<(D), (T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$SideConfigSyncable" {
import {$SideConfigData, $SideConfigData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$SideConfigData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export class $SideConfigSyncable extends $AbstractSyncable<($SideConfigData), ($SideConfig)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<($SideConfig$Type)>, consumer: $Consumer$Type<($SideConfig$Type)>): $SideConfigSyncable
public "needSync"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideConfigSyncable$Type = ($SideConfigSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideConfigSyncable_ = $SideConfigSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$RegistrarCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegistrarCodec<V> implements $NamedCodec<(V)> {
static readonly "ITEM": $NamedCodec<($Item)>
static readonly "BLOCK": $NamedCodec<($Block)>
static readonly "FLUID": $NamedCodec<($Fluid)>
static readonly "ENTITY": $NamedCodec<($EntityType<(any)>)>
static readonly "ENCHANTMENT": $NamedCodec<($Enchantment)>
static readonly "EFFECT": $NamedCodec<($MobEffect)>
static readonly "MACHINE_COMPONENT": $NamedCodec<($MachineComponentType<(any)>)>
static readonly "REQUIREMENT": $NamedCodec<($RequirementType<(any)>)>
static readonly "GUI_ELEMENT": $NamedCodec<($GuiElementType<(any)>)>
static readonly "APPEARANCE_PROPERTY": $NamedCodec<($MachineAppearanceProperty<(any)>)>
static readonly "DATA": $NamedCodec<($DataType<(any), (any)>)>
static readonly "CRAFTING_PROCESSOR": $NamedCodec<($ProcessorType<(any)>)>
static readonly "CM_LOC_CODEC": $NamedCodec<($ResourceLocation)>


public "name"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<(V), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: V, prefix: T): $DataResult<(T)>
public static "of"<V>(registrar: $Registrar$Type<(V)>, isCM: boolean): $RegistrarCodec<(V)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(V)>): $NamedCodec<(V)>
public static "of"<A>(codec: $Codec$Type<(V)>, name: string): $NamedCodec<(V)>
public static "list"<A>(codec: $NamedCodec$Type<(V)>, name: string): $NamedCodec<($List<(V)>)>
public static "list"<A>(codec: $NamedCodec$Type<(V)>): $NamedCodec<($List<(V)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(V)>
public "copy"(input: V): V
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(V)>, name: string): $NamedCodec<(V)>
public static "unit"<A>(defaultValue: V, name: string): $NamedCodec<(V)>
public static "unit"<A>(defaultValue: V): $NamedCodec<(V)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(V)>)>, name: string): $NamedCodec<(V)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): V
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<(V)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(V)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: V): $NamedMapCodec<(V)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(V)>): $NamedMapCodec<(V)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: V): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: V, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<(V)>)>
public "listOf"(name: string): $NamedCodec<($List<(V)>)>
public static "registrar"<A>(registrar: $Registrar$Type<(V)>): $NamedCodec<(V)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistrarCodec$Type<V> = ($RegistrarCodec<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistrarCodec_<V> = $RegistrarCodec$Type<(V)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$ComponentEditBox" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Style, $Style$Type} from "packages/net/minecraft/network/chat/$Style"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ChatFormatting, $ChatFormatting$Type} from "packages/net/minecraft/$ChatFormatting"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$EditBox, $EditBox$Type} from "packages/net/minecraft/client/gui/components/$EditBox"

export class $ComponentEditBox extends $EditBox {
static readonly "BUTTON_TEXTURE": $ResourceLocation
static readonly "BACKWARDS": integer
static readonly "FORWARDS": integer
static readonly "DEFAULT_TEXT_COLOR": integer
readonly "font": $Font
 "displayPos": integer
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(font: $Font$Type, x: integer, y: integer, width: integer, height: integer, message: $Component$Type)

public "invert"(format: $ChatFormatting$Type): void
public "getComponent"(): $Component
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "renderWidget"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "setX"(x: integer): void
public "setY"(y: integer): void
public "setStyle"(style: $Style$Type): void
public "getWidth"(): integer
public "setComponentResponder"(responder: $Consumer$Type<($MutableComponent$Type)>): void
public "getStyle"(): $Style
public "setComponent"(component: $Component$Type): void
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
get "component"(): $Component
set "x"(value: integer)
set "y"(value: integer)
set "style"(value: $Style$Type)
get "width"(): integer
set "componentResponder"(value: $Consumer$Type<($MutableComponent$Type)>)
get "style"(): $Style
set "component"(value: $Component$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentEditBox$Type = ($ComponentEditBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentEditBox_ = $ComponentEditBox$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$StatusGuiElementWidget" {
import {$StatusGuiElement, $StatusGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$StatusGuiElement"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $StatusGuiElementWidget extends $AbstractGuiElementWidget<($StatusGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $StatusGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatusGuiElementWidget$Type = ($StatusGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatusGuiElementWidget_ = $StatusGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$FileUtils" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$MachineLocation, $MachineLocation$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineLocation"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"

export class $FileUtils {
static readonly "GSON": $Gson

constructor()

public static "deleteMachineJson"(server: $MinecraftServer$Type, location: $MachineLocation$Type): void
public static "writeMachineJson"(server: $MinecraftServer$Type, machine: $CustomMachine$Type): void
public static "writeNewMachineJson"(server: $MinecraftServer$Type, machine: $CustomMachine$Type, kubejs: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FileUtils$Type = ($FileUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FileUtils_ = $FileUtils$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$LootTableRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $LootTableRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "lootTableOutput"(lootTable: string, luck: float): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $LootTableRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableRequirementCT$Type<T> = ($LootTableRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableRequirementCT_<T> = $LootTableRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$ConfigurationCardItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConfigurationCardItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(properties: $Item$Properties$Type)

public static "pasteConfiguration"(level: $Level$Type, player: $Player$Type, machine: $CustomMachineTile$Type, stack: $ItemStack$Type): $InteractionResult
public "use"(level: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigurationCardItem$Type = ($ConfigurationCardItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigurationCardItem_ = $ConfigurationCardItem$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/network/$DataType" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $DataType<D extends $IData<(T)>, T> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($DataType<(any), (any)>)>)>


public "getId"(): $ResourceLocation
public static "create"<T, D extends $IData<(T)>>(type: $Class$Type<(T)>, builder: $BiFunction$Type<($Supplier$Type<(T)>), ($Consumer$Type<(T)>), ($ISyncable$Type<(D), (T)>)>, reader: $BiFunction$Type<(short), ($FriendlyByteBuf$Type), (D)>): $DataType<(D), (T)>
public "readData"(id: short, buffer: $FriendlyByteBuf$Type): D
public static "createSyncable"<T>(type: $Class$Type<(T)>, supplier: $Supplier$Type<(T)>, consumer: $Consumer$Type<(T)>): $ISyncable<($IData<(T)>), (T)>
public "createSyncable"(supplier: $Supplier$Type<(T)>, consumer: $Consumer$Type<(T)>): $ISyncable<(D), (T)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataType$Type<D, T> = ($DataType<(D), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataType_<D, T> = $DataType$Type<(D), (T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget$Entry" {
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ComponentPath, $ComponentPath$Type} from "packages/net/minecraft/client/gui/$ComponentPath"
import {$FocusNavigationEvent, $FocusNavigationEvent$Type} from "packages/net/minecraft/client/gui/navigation/$FocusNavigationEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ContainerEventHandler, $ContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$ContainerEventHandler"
import {$ScreenRectangle, $ScreenRectangle$Type} from "packages/net/minecraft/client/gui/navigation/$ScreenRectangle"

export class $ListWidget$Entry implements $ContainerEventHandler {

constructor()

public "nextFocusPath"(event: $FocusNavigationEvent$Type): $ComponentPath
public "setDragging"(isDragging: boolean): void
public "setFocused"(focused: $GuiEventListener$Type): void
public "isDragging"(): boolean
public "getFocused"(): $GuiEventListener
public "focusPathAtIndex"(event: $FocusNavigationEvent$Type, index: integer): $ComponentPath
public "getCurrentFocusPath"(): $ComponentPath
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "children"(): $List<(any)>
public "setFocused"(arg0: boolean): void
public "mouseReleased"(arg0: double, arg1: double, arg2: integer): boolean
public "getChildAt"(arg0: double, arg1: double): $Optional<($GuiEventListener)>
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "mouseScrolled"(arg0: double, arg1: double, arg2: double): boolean
public "mouseDragged"(arg0: double, arg1: double, arg2: integer, arg3: double, arg4: double): boolean
public "isFocused"(): boolean
public "magicalSpecialHackyFocus"(arg0: $GuiEventListener$Type): void
public "keyReleased"(arg0: integer, arg1: integer, arg2: integer): boolean
public "isMouseOver"(arg0: double, arg1: double): boolean
public "getRectangle"(): $ScreenRectangle
public "mouseMoved"(arg0: double, arg1: double): void
public "getTabOrderGroup"(): integer
set "dragging"(value: boolean)
set "focused"(value: $GuiEventListener$Type)
get "dragging"(): boolean
get "focused"(): $GuiEventListener
get "currentFocusPath"(): $ComponentPath
set "focused"(value: boolean)
get "focused"(): boolean
get "rectangle"(): $ScreenRectangle
get "tabOrderGroup"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListWidget$Entry$Type = ($ListWidget$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListWidget$Entry_ = $ListWidget$Entry$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"

export interface $IRecipeModifier {

 "apply"(arg0: double, arg1: integer): double
 "getDefaultTooltip"(): $Component
 "getTooltip"(): $Component
 "shouldApply"(arg0: $RequirementType$Type<(any)>, arg1: $RequirementIOMode$Type, arg2: string): boolean
}

export namespace $IRecipeModifier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeModifier$Type = ($IRecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeModifier_ = $IRecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$ComponentStylePopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$ComponentEditBox, $ComponentEditBox$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ComponentEditBox"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ComponentStylePopup extends $PopupScreen {
static readonly "WIDGETS": $ResourceLocation
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, editBox: $ComponentEditBox$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentStylePopup$Type = ($ComponentStylePopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentStylePopup_ = $ComponentStylePopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$IProcessor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export interface $IProcessor {

 "getType"(): $ProcessorType<(any)>
 "reset"(): void
 "tick"(): void
 "deserialize"(arg0: $CompoundTag$Type): void
 "getCurrentContext"(): $ICraftingContext
 "getTile"(): $MachineTile
 "serialize"(): $CompoundTag
 "getRecipeProgressTime"(): double
 "setMachineInventoryChanged"(): void
}

export namespace $IProcessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProcessor$Type = ($IProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProcessor_ = $IProcessor$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$IGuiElementWidgetSupplier" {
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export interface $IGuiElementWidgetSupplier<T extends $IGuiElement> {

 "get"(arg0: T, arg1: $IMachineScreen$Type): $AbstractGuiElementWidget<(T)>

(arg0: T, arg1: $IMachineScreen$Type): $AbstractGuiElementWidget<(T)>
}

export namespace $IGuiElementWidgetSupplier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiElementWidgetSupplier$Type<T> = ($IGuiElementWidgetSupplier<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiElementWidgetSupplier_<T> = $IGuiElementWidgetSupplier$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$ProgressGuiElementWidget" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$ProgressBarGuiElement$Orientation, $ProgressBarGuiElement$Orientation$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement$Orientation"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ProgressBarGuiElement, $ProgressBarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ProgressGuiElementWidget extends $AbstractGuiElementWidget<($ProgressBarGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $ProgressBarGuiElement$Type, screen: $IMachineScreen$Type)

public static "rotate"(matrix: $PoseStack$Type, orientation: $ProgressBarGuiElement$Orientation$Type, posX: integer, posY: integer, width: integer, height: integer): void
public "getRecipeProgressPercent"(): double
public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
get "recipeProgressPercent"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressGuiElementWidget$Type = ($ProgressGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressGuiElementWidget_ = $ProgressGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$RedstoneRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $RedstoneRequirementJS extends $RecipeJSBuilder {

 "requireRedstone"(power: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $RedstoneRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequirementJS$Type = ($RedstoneRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneRequirementJS_ = $RedstoneRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement$DisplayMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ExperienceGuiElement$DisplayMode extends $Enum<($ExperienceGuiElement$DisplayMode)> {
static readonly "LITERAL": $ExperienceGuiElement$DisplayMode
static readonly "LEVEL": $ExperienceGuiElement$DisplayMode
static readonly "BOTH": $ExperienceGuiElement$DisplayMode


public static "values"(): ($ExperienceGuiElement$DisplayMode)[]
public static "valueOf"(name: string): $ExperienceGuiElement$DisplayMode
public static "of"(value: string): $ExperienceGuiElement$DisplayMode
public "isLiteral"(): boolean
public "isBoth"(): boolean
public "isLevel"(): boolean
get "literal"(): boolean
get "both"(): boolean
get "level"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElement$DisplayMode$Type = (("level") | ("literal") | ("both")) | ($ExperienceGuiElement$DisplayMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElement$DisplayMode_ = $ExperienceGuiElement$DisplayMode$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$KubeJSIntegration" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$MachineLocation, $MachineLocation$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineLocation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Resource, $Resource$Type} from "packages/net/minecraft/server/packs/resources/$Resource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MachineUpgrade, $MachineUpgrade$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$MachineUpgrade"

export class $KubeJSIntegration {

constructor()

public static "getMachineLocation"(resource: $Resource$Type, packName: string, id: $ResourceLocation$Type): $MachineLocation
public static "collectMachineUpgrades"(): $List<($MachineUpgrade)>
public static "getMachineJsonPath"(location: $ResourceLocation$Type): $Path
public static "nbtFromStack"(stack: $ItemStack$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSIntegration$Type = ($KubeJSIntegration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSIntegration_ = $KubeJSIntegration$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/$RequirementTypeCTBrackets" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RequirementTypeCTBrackets {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequirementTypeCTBrackets$Type = ($RequirementTypeCTBrackets);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequirementTypeCTBrackets_ = $RequirementTypeCTBrackets$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipeBuilder" {
import {$AbstractRecipeBuilder, $AbstractRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/impl/crafting/$AbstractRecipeBuilder"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $CustomMachineRecipeBuilder extends $AbstractRecipeBuilder<($CustomMachineRecipe)> {
static readonly "CODEC": $NamedCodec<($CustomMachineRecipeBuilder)>

constructor(machine: $ResourceLocation$Type, time: integer)
constructor(recipe: $CustomMachineRecipe$Type)

public "toString"(): string
public "setResetOnError"(): $CustomMachineRecipeBuilder
public "withAppearance"(appearance: $MachineAppearance$Type): $CustomMachineRecipeBuilder
public "withGuiElement"(element: $IGuiElement$Type): $CustomMachineRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRecipeBuilder$Type = ($CustomMachineRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRecipeBuilder_ = $CustomMachineRecipeBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/codec/$NamedCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $NamedCodec<A> {

 "name"(): string
 "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
 "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
 "decode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<($Pair<(A), (T)>)>
 "encode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: A, arg2: T): $DataResult<(T)>
 "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(A)>
 "copy"(input: A): A
 "fromNetwork"(buf: $FriendlyByteBuf$Type): A
 "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
 "fieldOf"(fieldName: string): $NamedMapCodec<(A)>
 "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(A)>)>
 "optionalFieldOf"(fieldName: string, defaultValue: A): $NamedMapCodec<(A)>
 "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(A)>): $NamedMapCodec<(A)>
 "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
 "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
 "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
 "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: A): $DataResult<(T)>
 "toNetwork"(input: A, buf: $FriendlyByteBuf$Type): void
 "listOf"(): $NamedCodec<($List<(A)>)>
 "listOf"(name: string): $NamedCodec<($List<(A)>)>
 "codec"(): $Codec<(A)>
}

export namespace $NamedCodec {
const BOOL: $NamedCodec<(boolean)>
const BYTE: $NamedCodec<(byte)>
const SHORT: $NamedCodec<(short)>
const INT: $NamedCodec<(integer)>
const LONG: $NamedCodec<(long)>
const FLOAT: $NamedCodec<(float)>
const DOUBLE: $NamedCodec<(double)>
const STRING: $NamedCodec<(string)>
const BYTE_BUFFER: $NamedCodec<($ByteBuffer)>
const INT_STREAM: $NamedCodec<($IntStream)>
const LONG_STREAM: $NamedCodec<($LongStream)>
const DOUBLE_STREAM: $NamedCodec<($DoubleStream)>
const PASSTHROUGH: $NamedCodec<($Dynamic<(any)>)>
function of<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
function of<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
function list<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
function list<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
function record<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
function checkRange<N>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
function unit<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
function unit<A>(defaultValue: A, name: string): $NamedCodec<(A)>
function unit<A>(defaultValue: A): $NamedCodec<(A)>
function pair<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
function lazy<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
function fromJson<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
function either<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
function either<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
function unboundedMap<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
function doubleRange(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
function floatRange(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
function intRange(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
function validateDoubleStreamSize(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
function enumMap<K, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
function enumMap<K, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
function enumMap<K, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
function enumMap<K, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
function longRange(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
function enumCodec<E>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
function enumCodec<E>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
function registrar<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
function getJson<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedCodec$Type<A> = ($NamedCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedCodec_<A> = $NamedCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$FuelGuiElementWidget" {
import {$FuelGuiElement, $FuelGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FuelGuiElement"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $FuelGuiElementWidget extends $AbstractGuiElementWidget<($FuelGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $FuelGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelGuiElementWidget$Type = ($FuelGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelGuiElementWidget_ = $FuelGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$WidgetToJeiIngredientRegistry$IngredientGetter" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$IClickableIngredient, $IClickableIngredient$Type} from "packages/mezz/jei/api/runtime/$IClickableIngredient"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export interface $WidgetToJeiIngredientRegistry$IngredientGetter<E extends $IGuiElement> {

 "getIngredient"<T>(arg0: $AbstractGuiElementWidget$Type<(E)>, arg1: double, arg2: double, arg3: $IJeiHelpers$Type): $IClickableIngredient<(T)>

(arg0: $AbstractGuiElementWidget$Type<(E)>, arg1: double, arg2: double, arg3: $IJeiHelpers$Type): $IClickableIngredient<(T)>
}

export namespace $WidgetToJeiIngredientRegistry$IngredientGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WidgetToJeiIngredientRegistry$IngredientGetter$Type<E> = ($WidgetToJeiIngredientRegistry$IngredientGetter<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WidgetToJeiIngredientRegistry$IngredientGetter_<E> = $WidgetToJeiIngredientRegistry$IngredientGetter$Type<(E)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$GuiElementBuilderPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$GridLayout$RowHelper, $GridLayout$RowHelper$Type} from "packages/net/minecraft/client/gui/layouts/$GridLayout$RowHelper"

export class $GuiElementBuilderPopup<T extends $IGuiElement> extends $PopupScreen {
readonly "properties": $MutableProperties
readonly "baseElement": T
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, properties: $MutableProperties$Type, from: T, onFinish: $Consumer$Type<(T)>)

public "addWidgets"(arg0: $GridLayout$RowHelper$Type): void
public "addId"(row: $GridLayout$RowHelper$Type): void
public "makeElement"(): T
public "canCreate"(): $Component
public "addPriority"(row: $GridLayout$RowHelper$Type): void
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "addTexture"(row: $GridLayout$RowHelper$Type, title: $Component$Type, responder: $Consumer$Type<($ResourceLocation$Type)>, baseTexture: $ResourceLocation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementBuilderPopup$Type<T> = ($GuiElementBuilderPopup<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementBuilderPopup_<T> = $GuiElementBuilderPopup$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$EnergyGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$EnergyGuiElement, $EnergyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $EnergyGuiElementBuilder implements $IGuiElementBuilder<($EnergyGuiElement)> {

constructor()

public "type"(): $GuiElementType<($EnergyGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $EnergyGuiElement$Type): $EnergyGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $EnergyGuiElement$Type, onFinish: $Consumer$Type<($EnergyGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyGuiElementBuilder$Type = ($EnergyGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyGuiElementBuilder_ = $EnergyGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/$CTConstants" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CTConstants {
static readonly "RECIPE_BUILDER_MACHINE": string
static readonly "RECIPE_BUILDER_CRAFT": string
static readonly "RECIPE_MANAGER_MACHINE": string
static readonly "RECIPE_MANAGER_CRAFT": string
static readonly "APPEARANCE_BUILDER": string
static readonly "REQUIREMENT_TYPE_BRACKET": string
static readonly "REQUIREMENT_DISPLAY_INFO": string
static readonly "REQUIREMENT_BIOME": string
static readonly "REQUIREMENT_BLOCK": string
static readonly "REQUIREMENT_BUTTON": string
static readonly "REQUIREMENT_CHUNKLOAD": string
static readonly "REQUIREMENT_COMMAND": string
static readonly "REQUIREMENT_DIMENSION": string
static readonly "REQUIREMENT_DROP": string
static readonly "REQUIREMENT_DURABILITY": string
static readonly "REQUIREMENT_EFFECT": string
static readonly "REQUIREMENT_ENERGY": string
static readonly "REQUIREMENT_ENERGY_PER_TICK": string
static readonly "REQUIREMENT_ENTITY": string
static readonly "REQUIREMENT_FLUID": string
static readonly "REQUIREMENT_FLUID_PER_TICK": string
static readonly "REQUIREMENT_FUEL": string
static readonly "REQUIREMENT_FUNCTION": string
static readonly "REQUIREMENT_ITEM": string
static readonly "REQUIREMENT_ITEM_TRANSFORM": string
static readonly "REQUIREMENT_LIGHT": string
static readonly "REQUIREMENT_LOOT_TABLE": string
static readonly "REQUIREMENT_POSITION": string
static readonly "REQUIREMENT_REDSTONE": string
static readonly "REQUIREMENT_STRUCTURE": string
static readonly "REQUIREMENT_TIME": string
static readonly "REQUIREMENT_WEATHER": string
static readonly "REQUIREMENT_SKY": string
static readonly "REQUIREMENT_ITEM_FILTER": string
static readonly "REQUIREMENT_EXPERIENCE": string
static readonly "REQUIREMENT_EXPERIENCE_PER_TICK": string
static readonly "UPGRADE_BUILDER": string
static readonly "MODIFIER_BUILDER": string

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CTConstants$Type = ($CTConstants);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CTConstants_ = $CTConstants$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$ITickableComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $ITickableComponent extends $IMachineComponent {

 "clientTick"(): void
 "serverTick"(): void
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $ITickableComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITickableComponent$Type = ($ITickableComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITickableComponent_ = $ITickableComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export interface $IMachineComponentTemplate<T extends $IMachineComponent> {

 "getId"(): string
 "getType"(): $MachineComponentType<(T)>
 "build"(arg0: $IMachineComponentManager$Type): T
 "canAccept"(arg0: any, arg1: boolean, arg2: $IMachineComponentManager$Type): boolean
}

export namespace $IMachineComponentTemplate {
const CODEC: $NamedCodec<($IMachineComponentTemplate<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineComponentTemplate$Type<T> = ($IMachineComponentTemplate<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineComponentTemplate_<T> = $IMachineComponentTemplate$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$RequirementDisplayInfo" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfo$TooltipPredicate, $IDisplayInfo$TooltipPredicate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$TooltipPredicate"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$IDisplayInfo$ClickAction, $IDisplayInfo$ClickAction$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$ClickAction"

export class $RequirementDisplayInfo implements $IDisplayInfo {

constructor()

public "handleClick"(machine: $CustomMachine$Type, recipe: $IMachineRecipe$Type, button: integer): boolean
public "setSpriteIcon"(atlas: $ResourceLocation$Type, sprite: $ResourceLocation$Type): $IDisplayInfo
public "setClickAction"(clickAction: $IDisplayInfo$ClickAction$Type): void
public "setTextureIcon"(icon: $ResourceLocation$Type, width: integer, height: integer, u: integer, v: integer): $RequirementDisplayInfo
public "shouldRender"(): boolean
public "renderIcon"(graphics: $GuiGraphics$Type, size: integer): void
public "getTooltips"(): $List<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
public "hasClickAction"(): boolean
public "setItemIcon"(item: $Item$Type): $IDisplayInfo
public "setTextureIcon"(texture: $ResourceLocation$Type, width: integer, height: integer): $IDisplayInfo
public "setTextureIcon"(texture: $ResourceLocation$Type): $IDisplayInfo
public "addTooltip"(text: $Component$Type): $IDisplayInfo
set "clickAction"(value: $IDisplayInfo$ClickAction$Type)
get "tooltips"(): $List<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
set "itemIcon"(value: $Item$Type)
set "textureIcon"(value: $ResourceLocation$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequirementDisplayInfo$Type = ($RequirementDisplayInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequirementDisplayInfo_ = $RequirementDisplayInfo$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SOpenEditScreenPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SOpenEditScreenPacket extends $BaseS2CMessage {

constructor(machine: $ResourceLocation$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SOpenEditScreenPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SOpenEditScreenPacket$Type = ($SOpenEditScreenPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SOpenEditScreenPacket_ = $SOpenEditScreenPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ResetGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ResetGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "BASE_TEXTURE_HOVERED": $ResourceLocation
static readonly "CODEC": $NamedCodec<($ResetGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type)

public "getType"(): $GuiElementType<($ResetGuiElement)>
public "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
get "type"(): $GuiElementType<($ResetGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResetGuiElement$Type = ($ResetGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResetGuiElement_ = $ResetGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$MachineLocation$Loader" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $MachineLocation$Loader extends $Enum<($MachineLocation$Loader)> {
static readonly "DEFAULT": $MachineLocation$Loader
static readonly "DATAPACK": $MachineLocation$Loader
static readonly "DATAPACK_ZIP": $MachineLocation$Loader
static readonly "KUBEJS": $MachineLocation$Loader
static readonly "KUBEJS_SCRIPT": $MachineLocation$Loader
static readonly "CODEC": $NamedCodec<($MachineLocation$Loader)>


public static "values"(): ($MachineLocation$Loader)[]
public static "valueOf"(name: string): $MachineLocation$Loader
public "getTranslatedName"(): $MutableComponent
get "translatedName"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineLocation$Loader$Type = (("default") | ("kubejs") | ("datapack_zip") | ("kubejs_script") | ("datapack")) | ($MachineLocation$Loader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineLocation$Loader_ = $MachineLocation$Loader$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$NamedRecordCodec$Mu, $NamedRecordCodec$Mu$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Mu"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$App, $App$Type} from "packages/com/mojang/datafixers/kinds/$App"

export class $NamedRecordCodec<O, F> implements $App<($NamedRecordCodec$Mu<(O)>), (F)> {


public static "of"<O, F>(getter: $Function$Type<(O), (F)>, codec: $NamedMapCodec$Type<(F)>): $NamedRecordCodec<(O), (F)>
public static "create"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "instance"<O>(): $NamedRecordCodec$Instance<(O)>
public static "build"<O>(builderBox: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (O)>, name: string): $NamedMapCodec<(O)>
public static "unbox"<O, F>(box: $App$Type<($NamedRecordCodec$Mu$Type<(O)>), (F)>): $NamedRecordCodec<(O), (F)>
public static "point"<O, F>(instance: F): $NamedRecordCodec<(O), (F)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedRecordCodec$Type<O, F> = ($NamedRecordCodec<(O), (F)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedRecordCodec_<O, F> = $NamedRecordCodec$Type<(O), (F)>;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$DumpGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DumpGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "BASE_TEXTURE_HOVERED": $ResourceLocation
static readonly "CODEC": $NamedCodec<($DumpGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, components: $List$Type<($MachineComponentType$Type<(any)>)>, tanks: $List$Type<(string)>)

public "getType"(): $GuiElementType<($DumpGuiElement)>
public "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
public "getComponents"(): $List<($MachineComponentType<(any)>)>
public "getTanks"(): $List<(string)>
get "type"(): $GuiElementType<($DumpGuiElement)>
get "components"(): $List<($MachineComponentType<(any)>)>
get "tanks"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DumpGuiElement$Type = ($DumpGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DumpGuiElement_ = $DumpGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$FluidTank" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"

export class $FluidTank implements $IFluidHandler {

constructor(component: $FluidMachineComponent$Type)

public "fill"(stack: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): integer
public "drain"(stack: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(amount: integer, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(i: integer, stack: $FluidStack$Type): boolean
public "getFluidInTank"(i: integer): $FluidStack
public "getTankCapacity"(i: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTank$Type = ($FluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTank_ = $FluidTank$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$GuiElementWidgetSupplierRegistry" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$IGuiElementWidgetSupplier, $IGuiElementWidgetSupplier$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElementWidgetSupplier"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $GuiElementWidgetSupplierRegistry {

constructor()

public static "init"(): void
public static "hasWidgetSupplier"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>): boolean
public static "getWidgetSupplier"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>): $IGuiElementWidgetSupplier<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementWidgetSupplierRegistry$Type = ($GuiElementWidgetSupplierRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementWidgetSupplierRegistry_ = $GuiElementWidgetSupplierRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$RequirementType" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $RequirementType<T extends $IRequirement<(any)>> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($RequirementType<(any)>)>)>


public "getName"(): $Component
public "getId"(): $ResourceLocation
public static "inventory"<T extends $IRequirement<(any)>>(codec: $NamedCodec$Type<(T)>): $RequirementType<(T)>
public static "world"<T extends $IRequirement<(any)>>(codec: $NamedCodec$Type<(T)>): $RequirementType<(T)>
public "isWorldRequirement"(): boolean
public "getCodec"(): $NamedCodec<(T)>
get "name"(): $Component
get "id"(): $ResourceLocation
get "worldRequirement"(): boolean
get "codec"(): $NamedCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequirementType$Type<T> = ($RequirementType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequirementType_<T> = $RequirementType$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditTabNavigationBar" {
import {$FocusNavigationEvent, $FocusNavigationEvent$Type} from "packages/net/minecraft/client/gui/navigation/$FocusNavigationEvent"
import {$TabManager, $TabManager$Type} from "packages/net/minecraft/client/gui/components/tabs/$TabManager"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$NarratableEntry$NarrationPriority, $NarratableEntry$NarrationPriority$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry$NarrationPriority"
import {$ScreenRectangle, $ScreenRectangle$Type} from "packages/net/minecraft/client/gui/navigation/$ScreenRectangle"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TabButton, $TabButton$Type} from "packages/net/minecraft/client/gui/components/$TabButton"
import {$NarrationElementOutput, $NarrationElementOutput$Type} from "packages/net/minecraft/client/gui/narration/$NarrationElementOutput"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ComponentPath, $ComponentPath$Type} from "packages/net/minecraft/client/gui/$ComponentPath"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractContainerEventHandler, $AbstractContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$AbstractContainerEventHandler"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"

export class $MachineEditTabNavigationBar extends $AbstractContainerEventHandler implements $Renderable, $GuiEventListener, $NarratableEntry {

constructor(width: integer, tabManager: $TabManager$Type, tabs: $Iterable$Type<($MachineEditTab$Type)>)

public "bounds"(x: integer, y: integer, width: integer, height: integer): void
public "nextFocusPath"(event: $FocusNavigationEvent$Type): $ComponentPath
public "children"(): $List<($TabButton)>
public "updateNarration"(narrationElementOutput: $NarrationElementOutput$Type): void
public "narrationPriority"(): $NarratableEntry$NarrationPriority
public "getRectangle"(): $ScreenRectangle
public "setFocused"(focused: $GuiEventListener$Type): void
public "arrangeElements"(): void
public "selectTab"(index: integer, playClickSound: boolean): void
public "render"(guiGraphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "getCurrentFocusPath"(): $ComponentPath
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "setFocused"(arg0: boolean): void
public "mouseReleased"(arg0: double, arg1: double, arg2: integer): boolean
public "mouseClicked"(arg0: double, arg1: double, arg2: integer): boolean
public "charTyped"(arg0: character, arg1: integer): boolean
public "mouseScrolled"(arg0: double, arg1: double, arg2: double): boolean
public "mouseDragged"(arg0: double, arg1: double, arg2: integer, arg3: double, arg4: double): boolean
public "isFocused"(): boolean
public "keyReleased"(arg0: integer, arg1: integer, arg2: integer): boolean
public "isActive"(): boolean
get "rectangle"(): $ScreenRectangle
set "focused"(value: $GuiEventListener$Type)
get "currentFocusPath"(): $ComponentPath
set "focused"(value: boolean)
get "focused"(): boolean
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineEditTabNavigationBar$Type = ($MachineEditTabNavigationBar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineEditTabNavigationBar_ = $MachineEditTabNavigationBar$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SLootTablesPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SLootTablesPacket extends $BaseS2CMessage {

constructor(loots: $Map$Type<($ResourceLocation$Type), ($List$Type<($Pair$Type<($ItemStack$Type), (double)>)>)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SLootTablesPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SLootTablesPacket$Type = ($SLootTablesPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SLootTablesPacket_ = $SLootTablesPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement$Mode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ExperienceGuiElement$Mode extends $Enum<($ExperienceGuiElement$Mode)> {
static readonly "INPUT_ONE": $ExperienceGuiElement$Mode
static readonly "INPUT_TEN": $ExperienceGuiElement$Mode
static readonly "INPUT_ALL": $ExperienceGuiElement$Mode
static readonly "OUTPUT_ONE": $ExperienceGuiElement$Mode
static readonly "OUTPUT_TEN": $ExperienceGuiElement$Mode
static readonly "OUTPUT_ALL": $ExperienceGuiElement$Mode
static readonly "DISPLAY": $ExperienceGuiElement$Mode
static readonly "DISPLAY_BAR": $ExperienceGuiElement$Mode


public static "values"(): ($ExperienceGuiElement$Mode)[]
public static "valueOf"(name: string): $ExperienceGuiElement$Mode
public "isOutputAll"(): boolean
public "isInputOne"(): boolean
public "isDisplayBar"(): boolean
public "isInputAll"(): boolean
public "isOutputOne"(): boolean
public "isDisplay"(): boolean
public "isInput"(): boolean
public "isOutput"(): boolean
public "title"(): $Component
get "outputAll"(): boolean
get "inputOne"(): boolean
get "displayBar"(): boolean
get "inputAll"(): boolean
get "outputOne"(): boolean
get "display"(): boolean
get "input"(): boolean
get "output"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElement$Mode$Type = (("input_one") | ("output_all") | ("display_bar") | ("display") | ("output_ten") | ("input_ten") | ("input_all") | ("output_one")) | ($ExperienceGuiElement$Mode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElement$Mode_ = $ExperienceGuiElement$Mode$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$LongSyncable" {
import {$LongData, $LongData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$LongData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $LongSyncable extends $AbstractSyncable<($LongData), (long)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(long)>, consumer: $Consumer$Type<(long)>): $LongSyncable
public "getData"(id: short): $LongData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSyncable$Type = ($LongSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSyncable_ = $LongSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$CommandRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $CommandRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "runCommandOnStart"(command: string, permissionLevel: integer, log: boolean): T
 "runCommandEachTick"(command: string, permissionLevel: integer, log: boolean): T
 "runCommandOnEnd"(command: string, permissionLevel: integer, log: boolean): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $CommandRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRequirementCT$Type<T> = ($CommandRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandRequirementCT_<T> = $CommandRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$BiomeRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $BiomeRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "biomeBlacklist"(biome: $Biome$Type): T
 "biomeBlacklist"(biomes: ($Biome$Type)[]): T
 "biomeWhitelist"(biome: $Biome$Type): T
 "biomeWhitelist"(biomes: ($Biome$Type)[]): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $BiomeRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeRequirementCT$Type<T> = ($BiomeRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeRequirementCT_<T> = $BiomeRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$EnergyGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$EnergyGuiElement, $EnergyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $EnergyGuiElementWidget extends $TexturedGuiElementWidget<($EnergyGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $EnergyGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyGuiElementWidget$Type = ($EnergyGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyGuiElementWidget_ = $EnergyGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$TaskDelayer" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $TaskDelayer {

constructor()

public static "enqueue"(ticks: integer, task: $Runnable$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TaskDelayer$Type = ($TaskDelayer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TaskDelayer_ = $TaskDelayer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Context" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Result, $Result$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Result"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$MachineJS, $MachineJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$MachineJS"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $Context {

constructor(internal: $ICraftingContext$Type)

public "error"(error: $Component$Type): $Result
public "success"(): $Result
public "getBlock"(): $BlockContainerJS
public "getModifiedSpeed"(): double
public "getBaseSpeed"(): double
public "getRemainingTime"(): double
public "setBaseSpeed"(baseSpeed: double): void
public "getMachine"(): $MachineJS
public "getTile"(): $MachineTile
get "block"(): $BlockContainerJS
get "modifiedSpeed"(): double
get "baseSpeed"(): double
get "remainingTime"(): double
set "baseSpeed"(value: double)
get "machine"(): $MachineJS
get "tile"(): $MachineTile
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Context$Type = ($Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Context_ = $Context$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$InteractionFluidStorage" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"

export class $InteractionFluidStorage implements $IFluidHandler {

constructor(handler: $FluidComponentHandler$Type)

public "fill"(forgeStack: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): integer
public "drain"(maxDrain: integer, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(maxDrain: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(tank: integer, stack: $FluidStack$Type): boolean
public "getFluidInTank"(tank: integer): $FluidStack
public "getTankCapacity"(tank: integer): integer
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InteractionFluidStorage$Type = ($InteractionFluidStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InteractionFluidStorage_ = $InteractionFluidStorage$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template" {
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export class $SideConfig$Template {
static readonly "CODEC": $NamedCodec<($SideConfig$Template)>
static readonly "DEFAULT_ALL_BOTH": $SideConfig$Template
static readonly "DEFAULT_ALL_INPUT": $SideConfig$Template
static readonly "DEFAULT_ALL_OUTPUT": $SideConfig$Template
static readonly "DEFAULT_ALL_NONE": $SideConfig$Template
static readonly "DEFAULT_ALL_NONE_DISABLED": $SideConfig$Template


public "build"<T extends $ISideConfigComponent>(component: T): $SideConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideConfig$Template$Type = ($SideConfig$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideConfig$Template_ = $SideConfig$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$EnumButton" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Button, $Button$Type} from "packages/net/minecraft/client/gui/components/$Button"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $EnumButton<E> extends $Button {
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, pressedAction: $Button$OnPress$Type, messageFunction: $Function$Type<(E), ($Component$Type)>, values: $List$Type<(E)>, defaultValue: E)

public "getValue"(): E
public "getMessage"(): $Component
public "onPress"(): void
get "value"(): E
get "message"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumButton$Type<E> = ($EnumButton<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumButton_<E> = $EnumButton$Type<(E)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IdPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $IdPopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineEditScreen$Type, from: string, idConsumer: $Consumer$Type<(string)>, suggestedIds: $List$Type<(string)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdPopup$Type = ($IdPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdPopup_ = $IdPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/config/$SideMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $SideMode extends $Enum<($SideMode)> {
static readonly "INPUT": $SideMode
static readonly "OUTPUT": $SideMode
static readonly "BOTH": $SideMode
static readonly "NONE": $SideMode
static readonly "CODEC": $NamedCodec<($SideMode)>


public static "values"(): ($SideMode)[]
public static "valueOf"(name: string): $SideMode
public "next"(): $SideMode
public "previous"(): $SideMode
public "color"(): integer
public "isInput"(): boolean
public "isOutput"(): boolean
public "isNone"(): boolean
public "title"(): $Component
get "input"(): boolean
get "output"(): boolean
get "none"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideMode$Type = (("output") | ("input") | ("none") | ("both")) | ($SideMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideMode_ = $SideMode$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $AbstractGuiElement implements $IGuiElement {

constructor(properties: $AbstractGuiElement$Properties$Type)

public "getProperties"(): $AbstractGuiElement$Properties
public "getPriority"(): integer
public "getId"(): string
public "getY"(): integer
public "getX"(): integer
public "getWidth"(): integer
public "getHeight"(): integer
public static "makePropertiesCodec"(defaultTexture: $ResourceLocation$Type, defaultTextureHovered: $ResourceLocation$Type, defaultTooltips: $List$Type<($Component$Type)>): $NamedMapCodec<($AbstractGuiElement$Properties)>
public static "makePropertiesCodec"(defaultTexture: $ResourceLocation$Type, defaultTextureHovered: $ResourceLocation$Type): $NamedMapCodec<($AbstractGuiElement$Properties)>
public static "makePropertiesCodec"(defaultTexture: $ResourceLocation$Type): $NamedMapCodec<($AbstractGuiElement$Properties)>
public static "makePropertiesCodec"(): $NamedMapCodec<($AbstractGuiElement$Properties)>
public "getTooltips"(): $List<($Component)>
public "getType"(): $GuiElementType<(any)>
public "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
public "showInJei"(): boolean
get "properties"(): $AbstractGuiElement$Properties
get "priority"(): integer
get "id"(): string
get "y"(): integer
get "x"(): integer
get "width"(): integer
get "height"(): integer
get "tooltips"(): $List<($Component)>
get "type"(): $GuiElementType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractGuiElement$Type = ($AbstractGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractGuiElement_ = $AbstractGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export interface $ISideConfigComponent extends $IMachineComponent {

 "getId"(): string
 "getConfig"(): $SideConfig
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $ISideConfigComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISideConfigComponent$Type = ($ISideConfigComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISideConfigComponent_ = $ISideConfigComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$SlotGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$SlotGuiElement, $SlotGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$SlotGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $SlotGuiElementBuilder implements $IGuiElementBuilder<($SlotGuiElement)> {

constructor()

public "type"(): $GuiElementType<($SlotGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $SlotGuiElement$Type): $SlotGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $SlotGuiElement$Type, onFinish: $Consumer$Type<($SlotGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotGuiElementBuilder$Type = ($SlotGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotGuiElementBuilder_ = $SlotGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $AbstractRequirement<T extends $IMachineComponent> implements $IRequirement<(T)> {

constructor(mode: $RequirementIOMode$Type)

public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(template: $DisplayInfoTemplate$Type): void
public "test"(arg0: T, arg1: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(T)>
public "getType"(): $RequirementType<(any)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processStart"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
public "processEnd"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
get "componentType"(): $MachineComponentType<(T)>
get "type"(): $RequirementType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractRequirement$Type<T> = ($AbstractRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractRequirement_<T> = $AbstractRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$Utils" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $Utils {
static readonly "RAND": $Random

constructor()

public static "format"(number: integer): string
public static "format"(number: long): string
public static "format"(number: double): string
public static "toInt"(l: long): integer
public static "toInt"(l: float): integer
public static "makeItemStack"(item: $Item$Type, amount: integer, nbt: $CompoundTag$Type): $ItemStack
public static "testNBT"(nbt: $CompoundTag$Type, tested: $CompoundTag$Type): boolean
public static "vec3dFromBlockPos"(pos: $BlockPos$Type): $Vec3
public static "createTickerHelper"<E extends $BlockEntity, A extends $BlockEntity>(p_152133_: $BlockEntityType$Type<(A)>, p_152134_: $BlockEntityType$Type<(E)>, p_152135_: $BlockEntityTicker$Type<(any)>): $BlockEntityTicker<(A)>
public static "rotateBox"(box: $AABB$Type, to: $Direction$Type): $AABB
public static "clamp"(value: long, min: long, max: long): long
public static "getBlockName"(ingredient: $IIngredient$Type<($PartialBlockState$Type)>): $MutableComponent
public static "addToArray"<T>(array: (T)[], toAdd: T): (T)[]
public static "isResourceNameValid"(resourceLocation: string): boolean
public static "getMachineBreakSpeed"(appearance: $MachineAppearance$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): float
public static "canPlayerManageMachines"(player: $Player$Type): boolean
public static "testINBT"<T extends $Tag>(inbt: T, tested: T): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utils$Type = ($Utils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utils_ = $Utils$Type;
}}
declare module "packages/fr/frinn/custommachinery/$PlatformHelper" {
import {$IEnergyHelper, $IEnergyHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IEnergyHelper"
import {$IFluidHelper, $IFluidHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IFluidHelper"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$LootPool, $LootPool$Type} from "packages/net/minecraft/world/level/storage/loot/$LootPool"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ICommonItemHandler, $ICommonItemHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonItemHandler"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ICommonFluidHandler, $ICommonFluidHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonFluidHandler"
import {$LootTable, $LootTable$Type} from "packages/net/minecraft/world/level/storage/loot/$LootTable"
import {$ICommonEnergyHandler, $ICommonEnergyHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonEnergyHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlatformHelper {

constructor()

public static "createItemHandler"(handler: $ItemComponentHandler$Type): $ICommonItemHandler
public static "getPoolsFromTable"(table: $LootTable$Type): $List<($LootPool)>
public static "createEnergyHandler"(component: $EnergyMachineComponent$Type): $ICommonEnergyHandler
public static "createFluidHandler"(handler: $FluidComponentHandler$Type): $ICommonFluidHandler
public static "createMachineTile"(pos: $BlockPos$Type, state: $BlockState$Type): $CustomMachineTile
public static "energy"(): $IEnergyHelper
public static "hasCorrectToolsForDrops"(player: $Player$Type, state: $BlockState$Type): boolean
public static "fluid"(): $IFluidHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformHelper$Type = ($PlatformHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformHelper_ = $PlatformHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SyncableContainer" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"

export class $SyncableContainer extends $AbstractContainerMenu {
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(type: $MenuType$Type<(any)>, id: integer, syncableStuff: $ISyncableStuff$Type, player: $Player$Type)

public "init"(): void
public "broadcastChanges"(): void
public "handleData"(data: $IData$Type<(any)>): void
public "needFullSync"(): boolean
public "getPlayer"(): $ServerPlayer
public "initializeContents"(stateId: integer, items: $List$Type<($ItemStack$Type)>, carried: $ItemStack$Type): void
get "player"(): $ServerPlayer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncableContainer$Type = ($SyncableContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SyncableContainer_ = $SyncableContainer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$FluidItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ITickableComponentVariant, $ITickableComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$ITickableComponentVariant"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $FluidItemComponentVariant extends $ItemComponentVariant implements $ITickableComponentVariant<($ItemMachineComponent)> {
static readonly "CODEC": $NamedCodec<($FluidItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor(tanks: $List$Type<(string)>)

public "getId"(): $ResourceLocation
public "tick"(component: $ItemMachineComponent$Type): void
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "getCodec"(): $NamedCodec<($FluidItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidItemComponentVariant$Type = ($FluidItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidItemComponentVariant_ = $FluidItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$BoxCreatorItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BoxCreatorItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(properties: $Item$Properties$Type)

public static "getSelectedBlock"(first: boolean, stack: $ItemStack$Type): $BlockPos
public "use"(level: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "canAttackBlock"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isFoil"(stack: $ItemStack$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public static "setSelectedBlock"(first: boolean, stack: $ItemStack$Type, pos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxCreatorItem$Type = ($BoxCreatorItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxCreatorItem_ = $BoxCreatorItem$Type;
}}
declare module "packages/fr/frinn/custommachinery/$CustomMachinery" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$CustomMachineBlock, $CustomMachineBlock$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineBlock"
import {$BiMap, $BiMap$Type} from "packages/com/google/common/collect/$BiMap"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$Upgrades, $Upgrades$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$Upgrades"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CustomMachinery {
static readonly "MODID": string
static "LOGGER": $Logger
static readonly "MACHINES": $Map<($ResourceLocation), ($CustomMachine)>
static readonly "CUSTOM_BLOCK_MACHINES": $BiMap<($ResourceLocation), ($CustomMachineBlock)>
static readonly "UPGRADES": $Upgrades

constructor()

public static "init"(): void
public static "syncData"(player: $ServerPlayer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachinery$Type = ($CustomMachinery);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachinery_ = $CustomMachinery$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/$ClientHandler" {
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $ClientHandler {

constructor()

public static "init"(): void
public static "getClientSideCustomMachineTile"(pos: $BlockPos$Type): $CustomMachineTile
public static "getRenderType"(renderType: string): $RenderType
public static "isShiftKeyDown"(): boolean
public static "textWidth"(text: $Component$Type): integer
public static "renderSlotHighlight"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer): void
public static "getLineHeight"(): integer
get "shiftKeyDown"(): boolean
get "lineHeight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientHandler$Type = ($ClientHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientHandler_ = $ClientHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$MachineModelLocation" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IMachineModelLocation, $IMachineModelLocation$Type} from "packages/fr/frinn/custommachinery/impl/util/$IMachineModelLocation"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $MachineModelLocation implements $IMachineModelLocation {
static readonly "CODEC": $NamedCodec<($MachineModelLocation)>


public "toString"(): string
public static "of"(loc: string): $MachineModelLocation
public "getProperties"(): string
public "getState"(): $BlockState
public "getItem"(): $Item
public "getLoc"(): $ResourceLocation
get "properties"(): string
get "state"(): $BlockState
get "item"(): $Item
get "loc"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineModelLocation$Type = ($MachineModelLocation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineModelLocation_ = $MachineModelLocation$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/$CMConfigImpl" {
import {$ICMConfig, $ICMConfig$Type} from "packages/fr/frinn/custommachinery/api/utils/$ICMConfig"

export class $CMConfigImpl implements $ICMConfig {
static readonly "INSTANCE": $ICMConfig

constructor()

public "logMissingOptional"(): boolean
public "logFirstEitherError"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMConfigImpl$Type = ($CMConfigImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMConfigImpl_ = $CMConfigImpl$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FuelRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $FuelRequirementJS extends $RecipeJSBuilder {

 "requireFuel"(): $RecipeJSBuilder
 "requireFuel"(amount: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $FuelRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelRequirementJS$Type = ($FuelRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelRequirementJS_ = $FuelRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$EditTabButton" {
import {$TabManager, $TabManager$Type} from "packages/net/minecraft/client/gui/components/tabs/$TabManager"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TabButton, $TabButton$Type} from "packages/net/minecraft/client/gui/components/$TabButton"

export class $EditTabButton extends $TabButton {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(tabManager: $TabManager$Type, tab: $MachineEditTab$Type, width: integer, height: integer)

public "tab"(): $MachineEditTab
public "renderWidget"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EditTabButton$Type = ($EditTabButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EditTabButton_ = $EditTabButton$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$MachineLocation" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$MachineLocation$Loader, $MachineLocation$Loader$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineLocation$Loader"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $MachineLocation {
static readonly "CODEC": $NamedCodec<($MachineLocation)>


public "getId"(): $ResourceLocation
public "getFile"(server: $MinecraftServer$Type): $File
public "getLoader"(): $MachineLocation$Loader
public "getText"(): $MutableComponent
public "getPackName"(): string
public static "fromDatapack"(id: $ResourceLocation$Type, packName: string): $MachineLocation
public static "fromDefault"(id: $ResourceLocation$Type, packName: string): $MachineLocation
public static "fromDatapackZip"(id: $ResourceLocation$Type, packName: string): $MachineLocation
public static "fromLoader"(loader: $MachineLocation$Loader$Type, id: $ResourceLocation$Type, packName: string): $MachineLocation
public static "fromKubeJSScript"(id: $ResourceLocation$Type, packName: string): $MachineLocation
public static "fromKubeJS"(id: $ResourceLocation$Type, packName: string): $MachineLocation
public "canEdit"(): boolean
get "id"(): $ResourceLocation
get "loader"(): $MachineLocation$Loader
get "text"(): $MutableComponent
get "packName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineLocation$Type = ($MachineLocation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineLocation_ = $MachineLocation$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SOpenCreationScreenPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SOpenCreationScreenPacket extends $BaseS2CMessage {

constructor()

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SOpenCreationScreenPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SOpenCreationScreenPacket$Type = ($SOpenCreationScreenPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SOpenCreationScreenPacket_ = $SOpenCreationScreenPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/$CustomMachineryAPI" {
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$ICMConfig, $ICMConfig$Type} from "packages/fr/frinn/custommachinery/api/utils/$ICMConfig"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICustomMachineryAPI, $ICustomMachineryAPI$Type} from "packages/fr/frinn/custommachinery/api/$ICustomMachineryAPI"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"

export class $CustomMachineryAPI implements $ICustomMachineryAPI {

constructor()

public "rl"(path: string): $ResourceLocation
public "logger"(): $Logger
public "config"(): $ICMConfig
public "modid"(): string
public "componentRegistrar"(): $Registrar<($MachineComponentType<(any)>)>
public "getVariantCodec"<C extends $IMachineComponent>(type: $MachineComponentType$Type<(C)>, id: $ResourceLocation$Type): $NamedCodec<($IComponentVariant)>
public "dataRegistrar"(): $Registrar<($DataType<(any), (any)>)>
public "processorRegistrar"(): $Registrar<($ProcessorType<(any)>)>
public "registrar"<T>(registryKey: $ResourceKey$Type<($Registry$Type<(T)>)>): $Registrar<(T)>
public "guiElementRegistrar"(): $Registrar<($GuiElementType<(any)>)>
public "requirementRegistrar"(): $Registrar<($RequirementType<(any)>)>
public "appearancePropertyRegistrar"(): $Registrar<($MachineAppearanceProperty<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineryAPI$Type = ($CustomMachineryAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineryAPI_ = $CustomMachineryAPI$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience$Form" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Experience$Form extends $Enum<($Experience$Form)> {
static readonly "LEVEL": $Experience$Form
static readonly "POINT": $Experience$Form


public static "values"(): ($Experience$Form)[]
public static "valueOf"(name: string): $Experience$Form
public "isLevel"(): boolean
public "isPoint"(): boolean
get "level"(): boolean
get "point"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Experience$Form$Type = (("level") | ("point")) | ($Experience$Form);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Experience$Form_ = $Experience$Form$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$TextureGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$TextureGuiElement, $TextureGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextureGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $TextureGuiElementBuilder implements $IGuiElementBuilder<($TextureGuiElement)> {

constructor()

public "type"(): $GuiElementType<($TextureGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $TextureGuiElement$Type): $TextureGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $TextureGuiElement$Type, onFinish: $Consumer$Type<($TextureGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureGuiElementBuilder$Type = ($TextureGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureGuiElementBuilder_ = $TextureGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$TooltipPredicate" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export interface $IDisplayInfo$TooltipPredicate {

 "shouldDisplay"(arg0: $Player$Type, arg1: boolean): boolean

(arg0: $Player$Type, arg1: boolean): boolean
}

export namespace $IDisplayInfo$TooltipPredicate {
const ALWAYS: $IDisplayInfo$TooltipPredicate
const ADVANCED: $IDisplayInfo$TooltipPredicate
const CREATIVE: $IDisplayInfo$TooltipPredicate
const CODEC: $NamedCodec<($IDisplayInfo$TooltipPredicate)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDisplayInfo$TooltipPredicate$Type = ($IDisplayInfo$TooltipPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDisplayInfo$TooltipPredicate_ = $IDisplayInfo$TooltipPredicate$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"

export interface $ISyncableStuff {

 "getStuffToSync"(arg0: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void

(arg0: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
}

export namespace $ISyncableStuff {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncableStuff$Type = ($ISyncableStuff);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncableStuff_ = $ISyncableStuff$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/energy/$EnergyJEIIngredientRenderer" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$EnergyGuiElement, $EnergyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JEIIngredientRenderer, $JEIIngredientRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$JEIIngredientRenderer"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $EnergyJEIIngredientRenderer extends $JEIIngredientRenderer<($Energy), ($EnergyGuiElement)> {
readonly "element": E

constructor(element: $EnergyGuiElement$Type)

public "getType"(): $IIngredientType<($Energy)>
public "render"(graphics: $GuiGraphics$Type, ingredient: $Energy$Type): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getTooltip"(ingredient: $Energy$Type, iTooltipFlag: $TooltipFlag$Type): $List<($Component)>
get "type"(): $IIngredientType<($Energy)>
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyJEIIngredientRenderer$Type = ($EnergyJEIIngredientRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyJEIIngredientRenderer_ = $EnergyJEIIngredientRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/modifier/$SpeedRecipeModifier" {
import {$IRecipeModifier$OPERATION, $IRecipeModifier$OPERATION$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $SpeedRecipeModifier extends $RecipeModifier {
static readonly "CODEC": $NamedCodec<($RecipeModifier)>
static readonly "RAND": $Random
readonly "requirementType": $RequirementType<(any)>
readonly "target": string
readonly "mode": $RequirementIOMode
readonly "modifier": double
readonly "chance": double
readonly "max": double
readonly "min": double
readonly "tooltip": $Component

constructor(operation: $IRecipeModifier$OPERATION$Type, modifier: double, chance: double, max: double, min: double, tooltip: $Component$Type)

public "apply"(original: double, upgradeAmount: integer): double
public "getDefaultTooltip"(): $Component
public "shouldApply"(type: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, target: string): boolean
public "getOperation"(): $IRecipeModifier$OPERATION
get "defaultTooltip"(): $Component
get "operation"(): $IRecipeModifier$OPERATION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpeedRecipeModifier$Type = ($SpeedRecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpeedRecipeModifier_ = $SpeedRecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$GhostItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Color, $Color$Type} from "packages/fr/frinn/custommachinery/common/util/$Color"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $GhostItem extends $Record {
static readonly "CODEC": $NamedCodec<($GhostItem)>
static readonly "EMPTY": $GhostItem

constructor(items: $List$Type<($IIngredient$Type<($Item$Type)>)>, color: $Color$Type, alwaysRender: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "color"(): $Color
public "items"(): $List<($IIngredient<($Item)>)>
public "alwaysRender"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GhostItem$Type = ($GhostItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GhostItem_ = $GhostItem$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/$CustomMachineryForge" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CustomMachineryForge {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineryForge$Type = ($CustomMachineryForge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineryForge_ = $CustomMachineryForge$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/$UpgradesCustomReloadListener" {
import {$CustomJsonReloadListener, $CustomJsonReloadListener$Type} from "packages/fr/frinn/custommachinery/common/util/$CustomJsonReloadListener"

export class $UpgradesCustomReloadListener extends $CustomJsonReloadListener {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradesCustomReloadListener$Type = ($UpgradesCustomReloadListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradesCustomReloadListener_ = $UpgradesCustomReloadListener$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NumberCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NumberCodec<A extends number> implements $NamedCodec<(A)> {

constructor()

public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<(A), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: A, prefix: T): $DataResult<(T)>
public "parse"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<(A)>
public "fromString"(arg0: string): A
public "name"(): string
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(A)>
public "copy"(input: A): A
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): A
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<(A)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(A)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: A): $NamedMapCodec<(A)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(A)>): $NamedMapCodec<(A)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: A): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: A, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<(A)>)>
public "listOf"(name: string): $NamedCodec<($List<(A)>)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(A)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberCodec$Type<A> = ($NumberCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberCodec_<A> = $NumberCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/common/util/slot/$FilterSlotItemComponent" {
import {$SlotItemComponent, $SlotItemComponent$Type} from "packages/fr/frinn/custommachinery/common/util/slot/$SlotItemComponent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $FilterSlotItemComponent extends $SlotItemComponent {
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(component: $ItemMachineComponent$Type, index: integer, x: integer, y: integer)

public "setFromClient"(stack: $ItemStack$Type): void
public "mayPlace"(stack: $ItemStack$Type): boolean
public "mayPickup"(player: $Player$Type): boolean
public "tryRemove"(count: integer, decrement: integer, player: $Player$Type): $Optional<($ItemStack)>
set "fromClient"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterSlotItemComponent$Type = ($FilterSlotItemComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterSlotItemComponent_ = $FilterSlotItemComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$EnergyGuiElementJeiRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$EnergyGuiElement, $EnergyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $EnergyGuiElementJeiRenderer implements $IJEIElementRenderer<($EnergyGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $EnergyGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $EnergyGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $EnergyGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyGuiElementJeiRenderer$Type = ($EnergyGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyGuiElementJeiRenderer_ = $EnergyGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/command/$CMCommand" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$LiteralArgumentBuilder, $LiteralArgumentBuilder$Type} from "packages/com/mojang/brigadier/builder/$LiteralArgumentBuilder"
import {$SuggestionProvider, $SuggestionProvider$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionProvider"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"

export class $CMCommand {
static readonly "ALL_MACHINES": $SuggestionProvider<($CommandSourceStack)>

constructor()

public static "register"(name: string): $LiteralArgumentBuilder<($CommandSourceStack)>
public static "reloadMachines"(server: $MinecraftServer$Type, player: $ServerPlayer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMCommand$Type = ($CMCommand);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMCommand_ = $CMCommand$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/transfer/$IFluidHelper" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IFluidHelper {

 "isFluidHandler"(arg0: $ItemStack$Type): boolean
 "fillTanksFromStack"(arg0: $List$Type<($FluidMachineComponent$Type)>, arg1: $ItemMachineComponent$Type): void
 "fillStackFromTanks"(arg0: $ItemMachineComponent$Type, arg1: $List$Type<($FluidMachineComponent$Type)>): void
 "transferFluid"(arg0: $ItemStack$Type, arg1: $FluidMachineComponent$Type): $ItemStack
}

export namespace $IFluidHelper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidHelper$Type = ($IFluidHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidHelper_ = $IFluidHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$EitherManyCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EitherManyCodec<T> implements $NamedCodec<(T)> {


public "name"(): string
public "decode"<O>(ops: $DynamicOps$Type<(O)>, input: O): $DataResult<($Pair<(T), (O)>)>
public "encode"<O>(ops: $DynamicOps$Type<(O)>, input: T, prefix: O): $DataResult<(O)>
public static "of"<T>(name: string, mainCodec: $NamedCodec$Type<(T)>, ...otherCodecs: ($NamedCodec$Type<(T)>)[]): $EitherManyCodec<(T)>
public static "of"<T>(mainCodec: $NamedCodec$Type<(T)>, ...otherCodecs: ($NamedCodec$Type<(T)>)[]): $EitherManyCodec<(T)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(T)>): $NamedCodec<(T)>
public static "of"<A>(codec: $Codec$Type<(T)>, name: string): $NamedCodec<(T)>
public static "list"<A>(codec: $NamedCodec$Type<(T)>, name: string): $NamedCodec<($List<(T)>)>
public static "list"<A>(codec: $NamedCodec$Type<(T)>): $NamedCodec<($List<(T)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(T)>
public "copy"(input: T): T
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(T)>, name: string): $NamedCodec<(T)>
public static "unit"<A>(defaultValue: T, name: string): $NamedCodec<(T)>
public static "unit"<A>(defaultValue: T): $NamedCodec<(T)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(T)>)>, name: string): $NamedCodec<(T)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): T
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<(T)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(T)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: T): $NamedMapCodec<(T)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(T)>): $NamedMapCodec<(T)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: T, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<(T)>)>
public "listOf"(name: string): $NamedCodec<($List<(T)>)>
public static "registrar"<A>(registrar: $Registrar$Type<(T)>): $NamedCodec<(T)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherManyCodec$Type<T> = ($EitherManyCodec<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EitherManyCodec_<T> = $EitherManyCodec$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$ItemIngredientWrapper" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $ItemIngredientWrapper implements $IJEIIngredientWrapper<($ItemStack)> {

constructor(mode: $RequirementIOMode$Type, item: $IIngredient$Type<($Item$Type)>, amount: integer, chance: double, useDurability: boolean, nbt: $CompoundTag$Type, slot: string, showRequireSlot: boolean)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemIngredientWrapper$Type = ($ItemIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemIngredientWrapper_ = $ItemIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$Range" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Restriction, $Restriction$Type} from "packages/fr/frinn/custommachinery/impl/util/$Restriction"
import {$List, $List$Type} from "packages/java/util/$List"

export class $Range<T extends $Comparable<(T)>> {

constructor(restrictions: $List$Type<($Restriction$Type<(T)>)>)

public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "contains"(thing: T): boolean
public "match"(things: $List$Type<(T)>): T
public "toFormattedString"(): string
public "getRestrictions"(): $List<($Restriction<(T)>)>
get "restrictions"(): $List<($Restriction<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Range$Type<T> = ($Range<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Range_<T> = $Range$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$MachineComponentBuilderRegistry" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"

export class $MachineComponentBuilderRegistry {

constructor()

public static "init"(): void
public static "getBuilder"<C extends $IMachineComponent, T extends $IMachineComponentTemplate<(C)>>(type: $MachineComponentType$Type<(C)>): $IMachineComponentBuilder<(C), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineComponentBuilderRegistry$Type = ($MachineComponentBuilderRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineComponentBuilderRegistry_ = $MachineComponentBuilderRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$EnergyPerTickRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $EnergyPerTickRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireEnergyPerTick"(amount: integer): T
 "produceEnergyPerTick"(amount: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $EnergyPerTickRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyPerTickRequirementCT$Type<T> = ($EnergyPerTickRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyPerTickRequirementCT_<T> = $EnergyPerTickRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SRefreshCustomMachineTilePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SRefreshCustomMachineTilePacket extends $BaseS2CMessage {

constructor(pos: $BlockPos$Type, machine: $ResourceLocation$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SRefreshCustomMachineTilePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SRefreshCustomMachineTilePacket$Type = ($SRefreshCustomMachineTilePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SRefreshCustomMachineTilePacket_ = $SRefreshCustomMachineTilePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$TextureGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $TextureGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_BACKGROUND": $ResourceLocation
static readonly "CODEC": $NamedCodec<($TextureGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, jei: boolean)

public "getType"(): $GuiElementType<($TextureGuiElement)>
public "showInJei"(): boolean
get "type"(): $GuiElementType<($TextureGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureGuiElement$Type = ($TextureGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureGuiElement_ = $TextureGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$CustomMachineItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CustomMachineItem extends $BlockItem {
static readonly "MACHINE_TAG_KEY": string
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(block: $Block$Type, properties: $Item$Properties$Type, machineID: $ResourceLocation$Type)

public static "makeMachineItem"(machineID: $ResourceLocation$Type): $ItemStack
public static "getMachine"(stack: $ItemStack$Type): $Optional<($CustomMachine)>
public "onCraftedBy"(stack: $ItemStack$Type, worldIn: $Level$Type, playerIn: $Player$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "place"(blockPlaceContext: $BlockPlaceContext$Type): $InteractionResult
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineItem$Type = ($CustomMachineItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineItem_ = $CustomMachineItem$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$MachineComponentType" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IComponentHandler, $IComponentHandler$Type} from "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler"

export class $MachineComponentType<T extends $IMachineComponent> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($MachineComponentType<(any)>)>)>


public "getId"(): $ResourceLocation
public static "create"<T extends $IMachineComponent>(codec: $NamedCodec$Type<(any)>): $MachineComponentType<(T)>
public static "create"<T extends $IMachineComponent>(defaultComponentBuilder: $Function$Type<($IMachineComponentManager$Type), (T)>): $MachineComponentType<(T)>
public static "create"<T extends $IMachineComponent>(codec: $NamedCodec$Type<(any)>, defaultComponentBuilder: $Function$Type<($IMachineComponentManager$Type), (T)>): $MachineComponentType<(T)>
public "getHandler"(manager: $IMachineComponentManager$Type, components: $List$Type<(T)>): $IComponentHandler<(T)>
public "setNotSingle"(handlerBuilder: $BiFunction$Type<($IMachineComponentManager$Type), ($List$Type<(T)>), ($IComponentHandler$Type<(T)>)>): $MachineComponentType<(T)>
public "getTranslatedName"(): $Component
public "isSingle"(): boolean
public "isDefaultComponent"(): boolean
public "getDefaultComponentBuilder"(): $Function<($IMachineComponentManager), (T)>
public "getCodec"(): $NamedCodec<(any)>
get "id"(): $ResourceLocation
set "notSingle"(value: $BiFunction$Type<($IMachineComponentManager$Type), ($List$Type<(T)>), ($IComponentHandler$Type<(T)>)>)
get "translatedName"(): $Component
get "single"(): boolean
get "defaultComponent"(): boolean
get "defaultComponentBuilder"(): $Function<($IMachineComponentManager), (T)>
get "codec"(): $NamedCodec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineComponentType$Type<T> = ($MachineComponentType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineComponentType_<T> = $MachineComponentType$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export interface $IComponentVariant {

 "getId"(): $ResourceLocation
 "getCodec"(): $NamedCodec<(any)>
}

export namespace $IComponentVariant {
function codec<C>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComponentVariant$Type = ($IComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComponentVariant_ = $IComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$EnergyPerTickRequirement" {
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $EnergyPerTickRequirement extends $AbstractChanceableRequirement<($EnergyMachineComponent)> implements $ITickableRequirement<($EnergyMachineComponent)>, $IJEIIngredientRequirement<($Energy)> {
static readonly "CODEC": $NamedCodec<($EnergyPerTickRequirement)>

constructor(mode: $RequirementIOMode$Type, amount: integer)

public "test"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($EnergyMachineComponent)>
public "getType"(): $RequirementType<($EnergyPerTickRequirement)>
public "processTick"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(energy: $EnergyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($Energy)>)>
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($EnergyMachineComponent)>
get "type"(): $RequirementType<($EnergyPerTickRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyPerTickRequirement$Type = ($EnergyPerTickRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyPerTickRequirement_ = $EnergyPerTickRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$DummyIngredientRenderer" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IIngredientRenderer, $IIngredientRenderer$Type} from "packages/mezz/jei/api/ingredients/$IIngredientRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $DummyIngredientRenderer<T> implements $IIngredientRenderer<(T)> {

constructor()

public "render"(graphics: $GuiGraphics$Type, t: T): void
public "getTooltip"(t: T, iTooltipFlag: $TooltipFlag$Type): $List<($Component)>
public "getWidth"(): integer
public "getHeight"(): integer
public "getFontRenderer"(arg0: $Minecraft$Type, arg1: T): $Font
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DummyIngredientRenderer$Type<T> = ($DummyIngredientRenderer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DummyIngredientRenderer_<T> = $DummyIngredientRenderer$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CPlaceStructurePacket" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CPlaceStructurePacket extends $BaseC2SMessage {
static readonly "PATTERN_CODEC": $NamedCodec<($List<($List<(string)>)>)>
static readonly "KEYS_CODEC": $NamedCodec<($Map<(character), ($IIngredient<($PartialBlockState)>)>)>

constructor(machine: $ResourceLocation$Type, pattern: $List$Type<($List$Type<(string)>)>, keys: $Map$Type<(character), ($IIngredient$Type<($PartialBlockState$Type)>)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CPlaceStructurePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CPlaceStructurePacket$Type = ($CPlaceStructurePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CPlaceStructurePacket_ = $CPlaceStructurePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $MutableProperties {

constructor(properties: $AbstractGuiElement$Properties$Type)
constructor()

public "setTooltips"(tooltips: $List$Type<($Component$Type)>): void
public "setPriority"(priority: integer): void
public "getPriority"(): integer
public "getId"(): string
public "build"(): $AbstractGuiElement$Properties
public "setWidth"(width: integer): void
public "getY"(): integer
public "getTexture"(): $ResourceLocation
public "setX"(x: integer): void
public "setY"(y: integer): void
public "getX"(): integer
public "getWidth"(): integer
public "getHeight"(): integer
public "getTextureHovered"(): $ResourceLocation
public "setTexture"(texture: $ResourceLocation$Type): void
public "setTextureHovered"(textureHovered: $ResourceLocation$Type): void
public "setId"(id: string): void
public "setHeight"(height: integer): void
public "getTooltips"(): $List<($Component)>
set "tooltips"(value: $List$Type<($Component$Type)>)
set "priority"(value: integer)
get "priority"(): integer
get "id"(): string
set "width"(value: integer)
get "y"(): integer
get "texture"(): $ResourceLocation
set "x"(value: integer)
set "y"(value: integer)
get "x"(): integer
get "width"(): integer
get "height"(): integer
get "textureHovered"(): $ResourceLocation
set "texture"(value: $ResourceLocation$Type)
set "textureHovered"(value: $ResourceLocation$Type)
set "id"(value: string)
set "height"(value: integer)
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableProperties$Type = ($MutableProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableProperties_ = $MutableProperties$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/$Upgrades" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MachineUpgrade, $MachineUpgrade$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$MachineUpgrade"

export class $Upgrades {

constructor()

public "refresh"(upgrades: $List$Type<($MachineUpgrade$Type)>): void
public "getUpgradesForMachine"(machineID: $ResourceLocation$Type): $List<($MachineUpgrade)>
public "getUpgradesForItemAndMachine"(item: $Item$Type, machineID: $ResourceLocation$Type): $List<($MachineUpgrade)>
public "getAllUpgrades"(): $List<($MachineUpgrade)>
public "getUpgradesForItem"(item: $Item$Type): $List<($MachineUpgrade)>
public "addUpgrade"(upgrade: $MachineUpgrade$Type): void
get "allUpgrades"(): $List<($MachineUpgrade)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Upgrades$Type = ($Upgrades);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Upgrades_ = $Upgrades$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement" {
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"

export interface $IDisplayInfoRequirement {

 "getDisplayInfo"(arg0: $IDisplayInfo$Type): void

(arg0: $IDisplayInfo$Type): void
}

export namespace $IDisplayInfoRequirement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDisplayInfoRequirement$Type = ($IDisplayInfoRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDisplayInfoRequirement_ = $IDisplayInfoRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ForgeEnergyHelper" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IEnergyHelper, $IEnergyHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IEnergyHelper"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ForgeEnergyHelper implements $IEnergyHelper {

constructor()

public "unit"(): $Component
public "fillStackFromBuffer"(slot: $ItemMachineComponent$Type, buffer: $EnergyMachineComponent$Type): void
public "fillBufferFromStack"(buffer: $EnergyMachineComponent$Type, slot: $ItemMachineComponent$Type): void
public "isEnergyHandler"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEnergyHelper$Type = ($ForgeEnergyHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEnergyHelper_ = $ForgeEnergyHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent$WeatherType" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $WeatherMachineComponent$WeatherType extends $Enum<($WeatherMachineComponent$WeatherType)> {
static readonly "CLEAR": $WeatherMachineComponent$WeatherType
static readonly "RAIN": $WeatherMachineComponent$WeatherType
static readonly "SNOW": $WeatherMachineComponent$WeatherType
static readonly "THUNDER": $WeatherMachineComponent$WeatherType
static readonly "CODEC": $NamedCodec<($WeatherMachineComponent$WeatherType)>


public static "value"(value: string): $WeatherMachineComponent$WeatherType
public static "values"(): ($WeatherMachineComponent$WeatherType)[]
public static "valueOf"(name: string): $WeatherMachineComponent$WeatherType
public "getText"(): $Component
get "text"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatherMachineComponent$WeatherType$Type = (("rain") | ("snow") | ("clear") | ("thunder")) | ($WeatherMachineComponent$WeatherType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeatherMachineComponent$WeatherType_ = $WeatherMachineComponent$WeatherType$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$EntityMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($EntityMachineComponent)>
public "killEntities"(radius: integer, filter: $Predicate$Type<($Entity$Type)>, amount: integer): void
public "getEntitiesInRadiusHealth"(radius: integer, filter: $Predicate$Type<($Entity$Type)>): double
public "removeEntitiesHealth"(radius: integer, filter: $Predicate$Type<($Entity$Type)>, amount: integer): void
public "getEntitiesInRadius"(radius: integer, filter: $Predicate$Type<($Entity$Type)>): integer
get "type"(): $MachineComponentType<($EntityMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityMachineComponent$Type = ($EntityMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityMachineComponent_ = $EntityMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement" {
import {$StructureMachineComponent, $StructureMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$StructureMachineComponent"
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$StructureRequirement$Action, $StructureRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $StructureRequirement extends $AbstractDelayedChanceableRequirement<($StructureMachineComponent)> implements $ITickableRequirement<($StructureMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($StructureRequirement)>

constructor(pattern: $List$Type<($List$Type<(string)>)>, keys: $Map$Type<(character), ($IIngredient$Type<($PartialBlockState$Type)>)>, action: $StructureRequirement$Action$Type)

public "test"(component: $StructureMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($StructureMachineComponent)>
public "execute"(component: $StructureMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($StructureRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $StructureMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $StructureMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $StructureMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($StructureMachineComponent)>
get "type"(): $RequirementType<($StructureRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureRequirement$Type = ($StructureRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureRequirement_ = $StructureRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience" {
import {$Experience$Form, $Experience$Form$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience$Form"

export class $Experience {

constructor(xp: integer, capacity: integer, chance: double, type: $Experience$Form$Type)
constructor(xp: integer, chance: double, type: $Experience$Form$Type)
constructor(xp: integer, capacity: integer, isPerTick: boolean, type: $Experience$Form$Type)
constructor(xp: integer, isPerTick: boolean, type: $Experience$Form$Type)
constructor(xp: integer, capacity: integer, chance: double, isPerTick: boolean, type: $Experience$Form$Type)
constructor(xp: integer, capacity: integer, type: $Experience$Form$Type)
constructor(xp: integer, type: $Experience$Form$Type)
constructor(xp: integer, chance: double, isPerTick: boolean, type: $Experience$Form$Type)

public "getCapacity"(): integer
public "getLevels"(): integer
public "getForm"(): $Experience$Form
public "addXp"(xp: integer): void
public "isPoints"(): boolean
public "isLevels"(): boolean
public "isPerTick"(): boolean
public "getChance"(): double
public "setXp"(xp: integer): void
public "getXp"(): integer
get "capacity"(): integer
get "levels"(): integer
get "form"(): $Experience$Form
get "points"(): boolean
get "levels"(): boolean
get "perTick"(): boolean
get "chance"(): double
set "xp"(value: integer)
get "xp"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Experience$Type = ($Experience);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Experience_ = $Experience$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/config/$ComponentConfigButtonWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Button, $Button$Type} from "packages/net/minecraft/client/gui/components/$Button"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $ComponentConfigButtonWidget extends $Button {
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, message: $Component$Type, onPress: $Button$OnPress$Type)

public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentConfigButtonWidget$Type = ($ComponentConfigButtonWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentConfigButtonWidget_ = $ComponentConfigButtonWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$DropMachineComponent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $DropMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($DropMachineComponent)>
public "getItemAmount"(items: $List$Type<($IIngredient$Type<($Item$Type)>)>, radius: integer, whitelist: boolean): integer
public "consumeItem"(items: $List$Type<($IIngredient$Type<($Item$Type)>)>, amount: integer, radius: integer, whitelist: boolean): void
public "produceItem"(stack: $ItemStack$Type): boolean
get "type"(): $MachineComponentType<($DropMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropMachineComponent$Type = ($DropMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropMachineComponent_ = $DropMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CustomJsonReloadListener" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$SimplePreparableReloadListener, $SimplePreparableReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$SimplePreparableReloadListener"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CustomJsonReloadListener extends $SimplePreparableReloadListener<($Map<($ResourceLocation), ($JsonElement)>)> {

constructor(string: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJsonReloadListener$Type = ($CustomJsonReloadListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJsonReloadListener_ = $CustomJsonReloadListener$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$EnhancedListCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnhancedListCodec<A> implements $NamedCodec<($List<(A)>)> {


public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<($List<(A)>), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: $List$Type<(A)>, prefix: T): $DataResult<(T)>
public static "of"<A>(elementCodec: $NamedCodec$Type<(A)>): $EnhancedListCodec<(A)>
public static "of"<A>(elementCodec: $NamedCodec$Type<(A)>, name: string): $EnhancedListCodec<(A)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<($List$Type<(A)>)>): $NamedCodec<($List<(A)>)>
public static "of"<A>(codec: $Codec$Type<($List$Type<(A)>)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<($List$Type<(A)>)>, name: string): $NamedCodec<($List<($List<(A)>)>)>
public static "list"<A>(codec: $NamedCodec$Type<($List$Type<(A)>)>): $NamedCodec<($List<($List<(A)>)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($List<(A)>)>
public "copy"(input: $List$Type<(A)>): $List<(A)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<($List$Type<(A)>)>, name: string): $NamedCodec<($List<(A)>)>
public static "unit"<A>(defaultValue: $List$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "unit"<A>(defaultValue: $List$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<($List$Type<(A)>)>)>, name: string): $NamedCodec<($List<(A)>)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): $List<(A)>
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<($List<(A)>)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<($List<(A)>)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $List$Type<(A)>): $NamedMapCodec<($List<(A)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<($List$Type<(A)>)>): $NamedMapCodec<($List<(A)>)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: $List$Type<(A)>): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: $List$Type<(A)>, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<($List<(A)>)>)>
public "listOf"(name: string): $NamedCodec<($List<($List<(A)>)>)>
public static "registrar"<A>(registrar: $Registrar$Type<($List$Type<(A)>)>): $NamedCodec<($List<(A)>)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<($List<(A)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnhancedListCodec$Type<A> = ($EnhancedListCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnhancedListCodec_<A> = $EnhancedListCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$DoubleSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$DoubleData, $DoubleData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$DoubleData"

export class $DoubleSyncable extends $AbstractSyncable<($DoubleData), (double)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(double)>, consumer: $Consumer$Type<(double)>): $DoubleSyncable
public "getData"(id: short): $DoubleData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSyncable$Type = ($DoubleSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSyncable_ = $DoubleSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$CTFunction" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Context, $Context$Type} from "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$Context"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $CTFunction implements $Function<($ICraftingContext), ($CraftingResult)> {

constructor(arg0: $Function$Type<($Context$Type), ($CraftingResult$Type)>)

public "apply"(context: $ICraftingContext$Type): $CraftingResult
public static "identity"<T>(): $Function<($ICraftingContext), ($ICraftingContext)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($CraftingResult)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($ICraftingContext), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CTFunction$Type = ($CTFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CTFunction_ = $CTFunction$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$FuelRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$FuelMachineComponent, $FuelMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FuelMachineComponent"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $FuelRequirement extends $AbstractRequirement<($FuelMachineComponent)> implements $ITickableRequirement<($FuelMachineComponent)>, $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($FuelRequirement)>

constructor(amount: integer)

public "test"(component: $FuelMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($FuelMachineComponent)>
public "getType"(): $RequirementType<($FuelRequirement)>
public "processTick"(component: $FuelMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $FuelMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $FuelMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getAmount"(): integer
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<($FuelMachineComponent)>
get "type"(): $RequirementType<($FuelRequirement)>
get "amount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelRequirement$Type = ($FuelRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelRequirement_ = $FuelRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$RegisterAppearancePropertyBuilderEvent" {
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$IAppearancePropertyBuilder, $IAppearancePropertyBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder"
import {$RegisterAppearancePropertyBuilderEvent$Register, $RegisterAppearancePropertyBuilderEvent$Register$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$RegisterAppearancePropertyBuilderEvent$Register"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterAppearancePropertyBuilderEvent {
static readonly "EVENT": $Event<($RegisterAppearancePropertyBuilderEvent$Register)>
 "builders": $Map<($MachineAppearanceProperty<(any)>), ($IAppearancePropertyBuilder<(any)>)>

constructor()

public "register"<T>(property: $MachineAppearanceProperty$Type<(T)>, builder: $IAppearancePropertyBuilder$Type<(T)>): void
public "getBuilders"(): $Map<($MachineAppearanceProperty<(any)>), ($IAppearancePropertyBuilder<(any)>)>
get "builders"(): $Map<($MachineAppearanceProperty<(any)>), ($IAppearancePropertyBuilder<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterAppearancePropertyBuilderEvent$Type = ($RegisterAppearancePropertyBuilderEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterAppearancePropertyBuilderEvent_ = $RegisterAppearancePropertyBuilderEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent" {
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IVariableComponent, $IVariableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IVariableComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $ItemMachineComponent extends $AbstractMachineComponent implements $ISerializableComponent, $ISyncableStuff, $IComparatorInputComponent, $IVariableComponent<($ItemComponentVariant)>, $ISideConfigComponent {

constructor(manager: $IMachineComponentManager$Type, mode: $ComponentIOMode$Type, id: string, capacity: integer, maxInput: integer, maxOutput: integer, filter: $List$Type<($IIngredient$Type<($Item$Type)>)>, whitelist: boolean, variant: $ItemComponentVariant$Type, configTemplate: $SideConfig$Template$Type, locked: boolean)

public "extract"(amount: integer, simulate: boolean, byPassLimit: boolean): $ItemStack
public "extract"(amount: integer, simulate: boolean): $ItemStack
public "insert"(item: $Item$Type, amount: integer, nbt: $CompoundTag$Type, simulate: boolean): integer
public "insert"(item: $Item$Type, amount: integer, nbt: $CompoundTag$Type, simulate: boolean, byPassLimit: boolean): integer
public "getId"(): string
public "getType"(): $MachineComponentType<($ItemMachineComponent)>
public "isLocked"(): boolean
public "getVariant"(): $ItemComponentVariant
public "getCapacity"(): integer
public "deserialize"(nbt: $CompoundTag$Type): void
public "setItemStack"(stack: $ItemStack$Type): void
public "getRemainingSpace"(): integer
public "getComparatorInput"(): integer
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "setLocked"(locked: boolean): void
public "serialize"(nbt: $CompoundTag$Type): void
public "getConfig"(): $SideConfig
public "getItemStack"(): $ItemStack
public "isItemValid"(stack: $ItemStack$Type): boolean
get "id"(): string
get "type"(): $MachineComponentType<($ItemMachineComponent)>
get "locked"(): boolean
get "variant"(): $ItemComponentVariant
get "capacity"(): integer
set "itemStack"(value: $ItemStack$Type)
get "remainingSpace"(): integer
get "comparatorInput"(): integer
set "locked"(value: boolean)
get "config"(): $SideConfig
get "itemStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMachineComponent$Type = ($ItemMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMachineComponent_ = $ItemMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterGuiElementJEIRendererEvent" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$RegisterGuiElementJEIRendererEvent$Register, $RegisterGuiElementJEIRendererEvent$Register$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterGuiElementJEIRendererEvent$Register"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterGuiElementJEIRendererEvent {
static readonly "EVENT": $Event<($RegisterGuiElementJEIRendererEvent$Register)>

constructor()

public "register"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>, renderer: $IJEIElementRenderer$Type<(E)>): void
public "getRenderers"(): $Map<($GuiElementType<(any)>), ($IJEIElementRenderer<(any)>)>
get "renderers"(): $Map<($GuiElementType<(any)>), ($IJEIElementRenderer<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementJEIRendererEvent$Type = ($RegisterGuiElementJEIRendererEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementJEIRendererEvent_ = $RegisterGuiElementJEIRendererEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType" {
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ProcessorType<T extends $IProcessor> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($ProcessorType<(any)>)>)>


public "getId"(): $ResourceLocation
public static "create"<T extends $IProcessor>(codec: $NamedCodec$Type<(any)>): $ProcessorType<(T)>
public "getCodec"(): $NamedCodec<(any)>
get "id"(): $ResourceLocation
get "codec"(): $NamedCodec<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessorType$Type<T> = ($ProcessorType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProcessorType_<T> = $ProcessorType$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$LootTableHelper" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LootTableHelper {

constructor()

public static "generate"(server: $MinecraftServer$Type): void
public static "addTable"(table: $ResourceLocation$Type): void
public static "receiveLoots"(newLoots: $Map$Type<($ResourceLocation$Type), ($List$Type<($Pair$Type<($ItemStack$Type), (double)>)>)>): void
public static "getLoots"(): $Map<($ResourceLocation), ($List<($Pair<($ItemStack), (double)>)>)>
public static "getLootsForTable"(table: $ResourceLocation$Type): $List<($Pair<($ItemStack), (double)>)>
get "loots"(): $Map<($ResourceLocation), ($List<($Pair<($ItemStack), (double)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableHelper$Type = ($LootTableHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableHelper_ = $LootTableHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterGuiElementJEIRendererEvent$Register" {
import {$RegisterGuiElementJEIRendererEvent, $RegisterGuiElementJEIRendererEvent$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterGuiElementJEIRendererEvent"

export interface $RegisterGuiElementJEIRendererEvent$Register {

 "registerRenderers"(arg0: $RegisterGuiElementJEIRendererEvent$Type): void

(arg0: $RegisterGuiElementJEIRendererEvent$Type): void
}

export namespace $RegisterGuiElementJEIRendererEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementJEIRendererEvent$Register$Type = ($RegisterGuiElementJEIRendererEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementJEIRendererEvent$Register_ = $RegisterGuiElementJEIRendererEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$EmptyGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$AbstractGuiElement, $AbstractGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement"

export class $EmptyGuiElement extends $AbstractGuiElement {
static readonly "CODEC": $NamedCodec<($EmptyGuiElement)>

constructor(id: string)

public "getType"(): $GuiElementType<($EmptyGuiElement)>
get "type"(): $GuiElementType<($EmptyGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyGuiElement$Type = ($EmptyGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyGuiElement_ = $EmptyGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/$UpgradeManager" {
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$IRecipeModifier, $IRecipeModifier$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier"
import {$IMachineUpgradeManager, $IMachineUpgradeManager$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IMachineUpgradeManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"

export class $UpgradeManager implements $IMachineUpgradeManager {

constructor(tile: $CustomMachineTile$Type)

public "markDirty"(): void
public "getAllModifiers"(): $List<($Pair<($IRecipeModifier), (integer)>)>
get "allModifiers"(): $List<($Pair<($IRecipeModifier), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeManager$Type = ($UpgradeManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeManager_ = $UpgradeManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/$DummyProcessor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $DummyProcessor implements $IProcessor {

constructor(tile: $MachineTile$Type)

public "getType"(): $ProcessorType<($DummyProcessor)>
public "reset"(): void
public "tick"(): void
public "deserialize"(nbt: $CompoundTag$Type): void
public "getCurrentContext"(): $ICraftingContext
public "getTile"(): $MachineTile
public "serialize"(): $CompoundTag
public "getRecipeProgressTime"(): double
public "setMachineInventoryChanged"(): void
get "type"(): $ProcessorType<($DummyProcessor)>
get "currentContext"(): $ICraftingContext
get "tile"(): $MachineTile
get "recipeProgressTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DummyProcessor$Type = ($DummyProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DummyProcessor_ = $DummyProcessor$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/$CustomMachineScreen" {
import {$CustomMachineContainer, $CustomMachineContainer$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineContainer"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $CustomMachineScreen extends $AbstractContainerScreen<($CustomMachineContainer)> implements $IMachineScreen {
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(container: $CustomMachineContainer$Type, inv: $Inventory$Type, name: $Component$Type)

public "getY"(): integer
public "getX"(): integer
public "getWidth"(): integer
public "getHeight"(): integer
public "getElementUnderMouse"(mouseX: double, mouseY: double): $Optional<($AbstractGuiElementWidget<(any)>)>
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
get "y"(): integer
get "x"(): integer
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineScreen$Type = ($CustomMachineScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineScreen_ = $CustomMachineScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$CustomMachine" {
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineLocation, $MachineLocation$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineLocation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IProcessorTemplate, $IProcessorTemplate$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessorTemplate"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MachineAppearanceManager, $MachineAppearanceManager$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearanceManager"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $CustomMachine implements $ICustomMachine {
static readonly "CODEC": $NamedCodec<($CustomMachine)>
static readonly "DUMMY": $CustomMachine

constructor(name: $Component$Type, appearance: $MachineAppearanceManager$Type, tooltips: $List$Type<($Component$Type)>, guiElements: $List$Type<($IGuiElement$Type)>, jeiElements: $List$Type<($IGuiElement$Type)>, catalysts: $List$Type<($ResourceLocation$Type)>, componentTemplates: $List$Type<($IMachineComponentTemplate$Type<(any)>)>, processorTemplate: $IProcessorTemplate$Type<(any)>)

public "getName"(): $Component
public "getLocation"(): $MachineLocation
public "getId"(): $ResourceLocation
public "getRecipeIds"(): $List<($ResourceLocation)>
public "getCatalysts"(): $List<($ResourceLocation)>
public "getAppearanceManager"(): $MachineAppearanceManager
public "getGuiElements"(): $List<($IGuiElement)>
public "setLocation"(location: $MachineLocation$Type): $CustomMachine
public "isDummy"(): boolean
public "getJeiElements"(): $List<($IGuiElement)>
public "getTooltips"(): $List<($Component)>
public "getComponentTemplates"(): $List<($IMachineComponentTemplate<(any)>)>
public "getProcessorTemplate"(): $IProcessorTemplate<(any)>
get "name"(): $Component
get "location"(): $MachineLocation
get "id"(): $ResourceLocation
get "recipeIds"(): $List<($ResourceLocation)>
get "catalysts"(): $List<($ResourceLocation)>
get "appearanceManager"(): $MachineAppearanceManager
get "guiElements"(): $List<($IGuiElement)>
set "location"(value: $MachineLocation$Type)
get "dummy"(): boolean
get "jeiElements"(): $List<($IGuiElement)>
get "tooltips"(): $List<($Component)>
get "componentTemplates"(): $List<($IMachineComponentTemplate<(any)>)>
get "processorTemplate"(): $IProcessorTemplate<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachine$Type = ($CustomMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachine_ = $CustomMachine$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/$AbstractComponentHandler" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$IComponentHandler, $IComponentHandler$Type} from "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler"

export class $AbstractComponentHandler<T extends $IMachineComponent> implements $IComponentHandler<(T)> {

constructor(manager: $IMachineComponentManager$Type, components: $List$Type<(T)>)

public "getMode"(): $ComponentIOMode
public "getManager"(): $IMachineComponentManager
public "getComponents"(): $List<(T)>
public "getComponentForID"(arg0: string): $Optional<(T)>
public "init"(): void
public "getType"(): $MachineComponentType<(any)>
public "onRemoved"(): void
public "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
get "mode"(): $ComponentIOMode
get "manager"(): $IMachineComponentManager
get "components"(): $List<(T)>
get "type"(): $MachineComponentType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractComponentHandler$Type<T> = ($AbstractComponentHandler<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractComponentHandler_<T> = $AbstractComponentHandler$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$UpgradedCustomMachine" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IProcessorTemplate, $IProcessorTemplate$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessorTemplate"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MachineAppearanceManager, $MachineAppearanceManager$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearanceManager"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $UpgradedCustomMachine extends $CustomMachine {
static readonly "CODEC": $NamedCodec<($CustomMachine)>
static readonly "DUMMY": $CustomMachine

constructor(name: $Component$Type, appearance: $MachineAppearanceManager$Type, tooltips: $List$Type<($Component$Type)>, guiElements: $List$Type<($IGuiElement$Type)>, jeiElements: $List$Type<($IGuiElement$Type)>, catalysts: $List$Type<($ResourceLocation$Type)>, componentTemplates: $List$Type<($IMachineComponentTemplate$Type<(any)>)>, processorTemplate: $IProcessorTemplate$Type<(any)>, modifiers: $List$Type<($RecipeModifier$Type)>, parentId: $ResourceLocation$Type, canMakeParentRecipes: boolean)

public "getModifiers"(): $List<($RecipeModifier)>
public "getRecipeIds"(): $List<($ResourceLocation)>
public static "makeCodec"(parent: $CustomMachine$Type): $NamedCodec<($UpgradedCustomMachine)>
public "getParentId"(): $ResourceLocation
get "modifiers"(): $List<($RecipeModifier)>
get "recipeIds"(): $List<($ResourceLocation)>
get "parentId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradedCustomMachine$Type = ($UpgradedCustomMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradedCustomMachine_ = $UpgradedCustomMachine$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ItemTransformRequirement" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $ItemTransformRequirement extends $AbstractChanceableRequirement<($ItemComponentHandler)> implements $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($ItemTransformRequirement)>

constructor(input: $IIngredient$Type<($Item$Type)>, inputAmount: integer, inputSlot: string, inputNBT: $CompoundTag$Type, output: $Item$Type, outputAmount: integer, outputSlot: string, copyNBT: boolean, nbt: $Function$Type<($CompoundTag$Type), ($CompoundTag$Type)>)

public "test"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($ItemTransformRequirement)>
public "processStart"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($ItemTransformRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransformRequirement$Type = ($ItemTransformRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransformRequirement_ = $ItemTransformRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$DoubleData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $DoubleData extends $Data<(double)> {

constructor(id: short, value: double)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleData$Type = ($DoubleData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleData_ = $DoubleData$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/$PlatformHelperImpl" {
import {$ForgeFluidHelper, $ForgeFluidHelper$Type} from "packages/fr/frinn/custommachinery/forge/transfer/$ForgeFluidHelper"
import {$IEnergyHelper, $IEnergyHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IEnergyHelper"
import {$ForgeEnergyHelper, $ForgeEnergyHelper$Type} from "packages/fr/frinn/custommachinery/forge/transfer/$ForgeEnergyHelper"
import {$IFluidHelper, $IFluidHelper$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$IFluidHelper"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$LootPool, $LootPool$Type} from "packages/net/minecraft/world/level/storage/loot/$LootPool"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ICommonItemHandler, $ICommonItemHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonItemHandler"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ICommonFluidHandler, $ICommonFluidHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonFluidHandler"
import {$LootTable, $LootTable$Type} from "packages/net/minecraft/world/level/storage/loot/$LootTable"
import {$ICommonEnergyHandler, $ICommonEnergyHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonEnergyHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PlatformHelperImpl {
static readonly "ENERGY_HELPER": $ForgeEnergyHelper
static readonly "FLUID_HELPER": $ForgeFluidHelper

constructor()

public static "createItemHandler"(handler: $ItemComponentHandler$Type): $ICommonItemHandler
public static "getPoolsFromTable"(table: $LootTable$Type): $List<($LootPool)>
public static "createEnergyHandler"(component: $EnergyMachineComponent$Type): $ICommonEnergyHandler
public static "createFluidHandler"(handler: $FluidComponentHandler$Type): $ICommonFluidHandler
public static "createMachineTile"(pos: $BlockPos$Type, state: $BlockState$Type): $CustomMachineTile
public static "energy"(): $IEnergyHelper
public static "hasCorrectToolsForDrops"(player: $Player$Type, state: $BlockState$Type): boolean
public static "fluid"(): $IFluidHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformHelperImpl$Type = ($PlatformHelperImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformHelperImpl_ = $PlatformHelperImpl$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$MachineCT" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MachineCT {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineCT$Type = ($MachineCT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineCT_ = $MachineCT$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$EnergyComponentBuilder" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$EnergyMachineComponent$Template, $EnergyMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent$Template"

export class $EnergyComponentBuilder implements $IMachineComponentBuilder<($EnergyMachineComponent), ($EnergyMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($EnergyMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $EnergyMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $EnergyMachineComponent$Template$Type, onFinish: $Consumer$Type<($EnergyMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyComponentBuilder$Type = ($EnergyComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyComponentBuilder_ = $EnergyComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$GridLayoutTab, $GridLayoutTab$Type} from "packages/net/minecraft/client/gui/components/tabs/$GridLayoutTab"

export class $MachineEditTab extends $GridLayoutTab {
readonly "parent": $MachineEditScreen

constructor(title: $Component$Type, parent: $MachineEditScreen$Type)

public "closed"(): void
public "opened"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineEditTab$Type = ($MachineEditTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineEditTab_ = $MachineEditTab$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/config/$CMConfig" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$LoggingLevel, $LoggingLevel$Type} from "packages/fr/frinn/custommachinery/common/util/$LoggingLevel"
import {$ConfigData, $ConfigData$Type} from "packages/me/shedaniel/autoconfig/$ConfigData"

export class $CMConfig implements $ConfigData {
 "logMissingOptional": boolean
 "logFirstEitherError": boolean
 "debugLevel": $LoggingLevel
 "boxRenderTime": integer
 "structureRenderTime": integer
 "blockTagCycleTime": integer
 "itemSlotCycleTime": integer
 "needAdvancedInfoForRecipeID": boolean
 "modelFolders": $List<(string)>

constructor()

public static "get"(): $CMConfig
public "validatePostLoad"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMConfig$Type = ($CMConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMConfig_ = $CMConfig$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$ExperienceIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$Experience$Form, $Experience$Form$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience$Form"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"

export class $ExperienceIngredientWrapper implements $IJEIIngredientWrapper<($Experience)> {

constructor(mode: $RequirementIOMode$Type, amount: integer, chance: double, isPerTick: boolean, recipeTime: integer, type: $Experience$Form$Type)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceIngredientWrapper$Type = ($ExperienceIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceIngredientWrapper_ = $ExperienceIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$ClickAction" {
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"

export interface $IDisplayInfo$ClickAction {

 "handleClick"(arg0: $ICustomMachine$Type, arg1: $IMachineRecipe$Type, arg2: integer): void

(arg0: $ICustomMachine$Type, arg1: $IMachineRecipe$Type, arg2: integer): void
}

export namespace $IDisplayInfo$ClickAction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDisplayInfo$ClickAction$Type = ($IDisplayInfo$ClickAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDisplayInfo$ClickAction_ = $IDisplayInfo$ClickAction$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$EnumCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnumCodec<E extends $Enum<(E)>> implements $NamedCodec<(E)> {


public "name"(): string
public "toString"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<(E), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: E, prefix: T): $DataResult<(T)>
public static "of"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $EnumCodec<(E)>
public static "of"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $EnumCodec<(E)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(E)>): $NamedCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(E)>, name: string): $NamedCodec<(E)>
public static "list"<A>(codec: $NamedCodec$Type<(E)>, name: string): $NamedCodec<($List<(E)>)>
public static "list"<A>(codec: $NamedCodec$Type<(E)>): $NamedCodec<($List<(E)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(E)>
public "copy"(input: E): E
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(E)>, name: string): $NamedCodec<(E)>
public static "unit"<A>(defaultValue: E, name: string): $NamedCodec<(E)>
public static "unit"<A>(defaultValue: E): $NamedCodec<(E)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(E)>)>, name: string): $NamedCodec<(E)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): E
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<(E)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(E)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: E): $NamedMapCodec<(E)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(E)>): $NamedMapCodec<(E)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: E): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: E, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<(E)>)>
public "listOf"(name: string): $NamedCodec<($List<(E)>)>
public static "registrar"<A>(registrar: $Registrar$Type<(E)>): $NamedCodec<(E)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumCodec$Type<E> = ($EnumCodec<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumCodec_<E> = $EnumCodec$Type<(E)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$TimeRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $TimeRequirementJS extends $RecipeJSBuilder {

 "requireTime"(time: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $TimeRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeRequirementJS$Type = ($TimeRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeRequirementJS_ = $TimeRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$StructureRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$StructureRequirement$Action, $StructureRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StructureRequirementJS extends $RecipeJSBuilder {

 "placeStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, drops: boolean): $RecipeJSBuilder
 "destroyStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
 "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
 "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, action: $StructureRequirement$Action$Type): $RecipeJSBuilder
 "breakStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $StructureRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureRequirementJS$Type = ($StructureRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureRequirementJS_ = $StructureRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EffectRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $EffectRequirementJS extends $RecipeJSBuilder {

 "giveEffectEachTick"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
 "giveEffectEachTick"(effect: string, time: integer, radius: integer, levelOrFilter: any): $RecipeJSBuilder
 "giveEffectEachTick"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
 "giveEffectOnEnd"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
 "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
 "giveEffectOnEnd"(effect: string, time: integer, radius: integer, filter: (string)[]): $RecipeJSBuilder
 "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $EffectRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectRequirementJS$Type = ($EffectRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectRequirementJS_ = $EffectRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement$Alignment" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TextGuiElement$Alignment extends $Enum<($TextGuiElement$Alignment)> {
static readonly "LEFT": $TextGuiElement$Alignment
static readonly "CENTER": $TextGuiElement$Alignment
static readonly "RIGHT": $TextGuiElement$Alignment


public static "value"(value: string): $TextGuiElement$Alignment
public "toString"(): string
public static "values"(): ($TextGuiElement$Alignment)[]
public static "valueOf"(name: string): $TextGuiElement$Alignment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextGuiElement$Alignment$Type = (("left") | ("center") | ("right")) | ($TextGuiElement$Alignment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextGuiElement$Alignment_ = $TextGuiElement$Alignment$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$SlotGuiElementJeiRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$SlotGuiElement, $SlotGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$SlotGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $SlotGuiElementJeiRenderer implements $IJEIElementRenderer<($SlotGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $SlotGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $SlotGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $SlotGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotGuiElementJeiRenderer$Type = ($SlotGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotGuiElementJeiRenderer_ = $SlotGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$UpgradeItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $UpgradeItemComponentVariant extends $ItemComponentVariant {
static readonly "INSTANCE": $UpgradeItemComponentVariant
static readonly "CODEC": $NamedCodec<($UpgradeItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "getCodec"(): $NamedCodec<($UpgradeItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeItemComponentVariant$Type = ($UpgradeItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeItemComponentVariant_ = $UpgradeItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$ItemComponentBuilder" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$ItemMachineComponent$Template, $ItemMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent$Template"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ItemComponentBuilder implements $IMachineComponentBuilder<($ItemMachineComponent), ($ItemMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($ItemMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $ItemMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $ItemMachineComponent$Template$Type, onFinish: $Consumer$Type<($ItemMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentBuilder$Type = ($ItemComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemComponentBuilder_ = $ItemComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $RecipeCTBuilder<T> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $RecipeCTBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeCTBuilder$Type<T> = ($RecipeCTBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeCTBuilder_<T> = $RecipeCTBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$ItemStackData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemStackData extends $Data<($ItemStack)> {

constructor(id: short, value: $ItemStack$Type)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackData$Type = ($ItemStackData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackData_ = $ItemStackData$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$AbstractComponentHandler, $AbstractComponentHandler$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractComponentHandler"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IDumpComponent, $IDumpComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IDumpComponent"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ICommonFluidHandler, $ICommonFluidHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonFluidHandler"

export class $FluidComponentHandler extends $AbstractComponentHandler<($FluidMachineComponent)> implements $ISerializableComponent, $ISyncableStuff, $ITickableComponent, $IDumpComponent {

constructor(manager: $IMachineComponentManager$Type, components: $List$Type<($FluidMachineComponent$Type)>)

public "fill"(fluid: $FluidStack$Type, simulate: boolean): long
public "getType"(): $MachineComponentType<($FluidMachineComponent)>
public "drain"(maxDrain: $FluidStack$Type, simulate: boolean): $FluidStack
public "deserialize"(nbt: $CompoundTag$Type): void
public "getComponentForID"(id: string): $Optional<($FluidMachineComponent)>
public "getSpaceForFluid"(tank: string, fluid: $Fluid$Type, nbt: $CompoundTag$Type): long
public "removeFromInputs"(tank: string, stack: $FluidStack$Type): void
public "addToOutputs"(tank: string, stack: $FluidStack$Type): void
public "onRemoved"(): void
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
public "dump"(ids: $List$Type<(string)>): void
public "getFluidAmount"(tank: string, fluid: $Fluid$Type, nbt: $CompoundTag$Type): long
public "serverTick"(): void
public "getCommonFluidHandler"(): $ICommonFluidHandler
public "clientTick"(): void
get "type"(): $MachineComponentType<($FluidMachineComponent)>
get "commonFluidHandler"(): $ICommonFluidHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidComponentHandler$Type = ($FluidComponentHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidComponentHandler_ = $FluidComponentHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $IComparatorInputComponent extends $IMachineComponent {

 "getComparatorInput"(): integer
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $IComparatorInputComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComparatorInputComponent$Type = ($IComparatorInputComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComparatorInputComponent_ = $IComparatorInputComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IDumpComponent, $IDumpComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IDumpComponent"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICommonEnergyHandler, $ICommonEnergyHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonEnergyHandler"

export class $EnergyMachineComponent extends $AbstractMachineComponent implements $ITickableComponent, $ISerializableComponent, $ISyncableStuff, $IComparatorInputComponent, $ISideConfigComponent, $IDumpComponent {

constructor(manager: $IMachineComponentManager$Type, capacity: long, maxInput: long, maxOutput: long, configTemplate: $SideConfig$Template$Type)

public "getId"(): string
public "getType"(): $MachineComponentType<($EnergyMachineComponent)>
public "getCapacity"(): long
public "deserialize"(nbt: $CompoundTag$Type): void
public "extractRecipeEnergy"(maxExtract: integer, simulate: boolean): integer
public "receiveRecipeEnergy"(maxReceive: integer, simulate: boolean): integer
public "getMaxOutput"(): long
public "getFillPercent"(): double
public "getEnergyHandler"(): $ICommonEnergyHandler
public "getComparatorInput"(): integer
public "onRemoved"(): void
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
public "getConfig"(): $SideConfig
public "getMaxInput"(): long
public "getEnergy"(): long
public "setEnergy"(energy: long): void
public "dump"(ids: $List$Type<(string)>): void
public "serverTick"(): void
public "receiveEnergy"(maxReceive: long, simulate: boolean): long
public "extractEnergy"(maxExtract: long, simulate: boolean): long
public "clientTick"(): void
get "id"(): string
get "type"(): $MachineComponentType<($EnergyMachineComponent)>
get "capacity"(): long
get "maxOutput"(): long
get "fillPercent"(): double
get "energyHandler"(): $ICommonEnergyHandler
get "comparatorInput"(): integer
get "config"(): $SideConfig
get "maxInput"(): long
get "energy"(): long
set "energy"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyMachineComponent$Type = ($EnergyMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyMachineComponent_ = $EnergyMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$DeleteMachinePopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConfirmPopup, $ConfirmPopup$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$ConfirmPopup"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"

export class $DeleteMachinePopup extends $ConfirmPopup {
static readonly "CONFIRM": $Component
static readonly "CANCEL": $Component
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, machine: $CustomMachine$Type)

public "confirm"(): void
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeleteMachinePopup$Type = ($DeleteMachinePopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DeleteMachinePopup_ = $DeleteMachinePopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $GuiElementType<T extends $IGuiElement> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($GuiElementType<(any)>)>)>


public "getId"(): $ResourceLocation
public static "create"<T extends $IGuiElement>(codec: $NamedCodec$Type<(T)>): $GuiElementType<(T)>
public "getTranslatedName"(): $Component
public "getCodec"(): $NamedCodec<(T)>
get "id"(): $ResourceLocation
get "translatedName"(): $Component
get "codec"(): $NamedCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementType$Type<T> = ($GuiElementType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementType_<T> = $GuiElementType$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ExperienceRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $ExperienceRequirementJS extends $RecipeJSBuilder {

 "produceXp"(xp: integer): $RecipeJSBuilder
 "requireLevel"(levels: integer): $RecipeJSBuilder
 "requireXp"(xp: integer): $RecipeJSBuilder
 "produceLevel"(levels: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ExperienceRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceRequirementJS$Type = ($ExperienceRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceRequirementJS_ = $ExperienceRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder {


public "target"(target: string): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public "min"(min: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public "max"(max: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "mulInput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "expInput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "mulOutput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "addOutput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "expOutput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public "tooltip"(tooltip: $Component$Type): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public static "addInput"(type: $ResourceLocation$Type, modifier: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
public "chance"(chance: double): $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder$Type = ($CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder_ = $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/modifier/$ExponentialRecipeModifier" {
import {$IRecipeModifier$OPERATION, $IRecipeModifier$OPERATION$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $ExponentialRecipeModifier extends $RecipeModifier {
static readonly "CODEC": $NamedCodec<($RecipeModifier)>
static readonly "RAND": $Random
readonly "requirementType": $RequirementType<(any)>
readonly "target": string
readonly "mode": $RequirementIOMode
readonly "modifier": double
readonly "chance": double
readonly "max": double
readonly "min": double
readonly "tooltip": $Component

constructor(requirementType: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, modifier: double, target: string, chance: double, max: double, min: double, tooltip: $Component$Type)

public "apply"(original: double, upgradeAmount: integer): double
public "getDefaultTooltip"(): $Component
public "getOperation"(): $IRecipeModifier$OPERATION
get "defaultTooltip"(): $Component
get "operation"(): $IRecipeModifier$OPERATION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExponentialRecipeModifier$Type = ($ExponentialRecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExponentialRecipeModifier_ = $ExponentialRecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$PlayerInventoryGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $PlayerInventoryGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($PlayerInventoryGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type)

public "getType"(): $GuiElementType<($PlayerInventoryGuiElement)>
get "type"(): $GuiElementType<($PlayerInventoryGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInventoryGuiElement$Type = ($PlayerInventoryGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInventoryGuiElement_ = $PlayerInventoryGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/machine/$MachineStatus" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $MachineStatus extends $Enum<($MachineStatus)> implements $StringRepresentable {
static readonly "IDLE": $MachineStatus
static readonly "RUNNING": $MachineStatus
static readonly "ERRORED": $MachineStatus
static readonly "PAUSED": $MachineStatus


public static "value"(string: string): $MachineStatus
public "toString"(): string
public static "values"(): ($MachineStatus)[]
public static "valueOf"(name: string): $MachineStatus
public "getSerializedName"(): string
public "getTranslatedName"(): $MutableComponent
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "translatedName"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineStatus$Type = (("running") | ("paused") | ("idle") | ("errored")) | ($MachineStatus);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineStatus_ = $MachineStatus$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$LightMachineComponent" {
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $LightMachineComponent extends $AbstractMachineComponent implements $ITickableComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($LightMachineComponent)>
public "clientTick"(): void
public "getMachineLight"(): integer
public "getSkyLight"(): integer
public "getBlockLight"(): integer
public "serverTick"(): void
get "type"(): $MachineComponentType<($LightMachineComponent)>
get "machineLight"(): integer
get "skyLight"(): integer
get "blockLight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightMachineComponent$Type = ($LightMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LightMachineComponent_ = $LightMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$FloatData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $FloatData extends $Data<(float)> {

constructor(id: short, value: float)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatData$Type = ($FloatData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatData_ = $FloatData$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$DropRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $DropRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $DropRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropRequirementCT$Type<T> = ($DropRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropRequirementCT_<T> = $DropRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$EnergyItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ITickableComponentVariant, $ITickableComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$ITickableComponentVariant"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $EnergyItemComponentVariant extends $ItemComponentVariant implements $ITickableComponentVariant<($ItemMachineComponent)> {
static readonly "INSTANCE": $EnergyItemComponentVariant
static readonly "CODEC": $NamedCodec<($EnergyItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "tick"(slot: $ItemMachineComponent$Type): void
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "getCodec"(): $NamedCodec<($EnergyItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyItemComponentVariant$Type = ($EnergyItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyItemComponentVariant_ = $EnergyItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CycleTimer" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $CycleTimer {

constructor(cycleTime: $Supplier$Type<(integer)>)

public "get"<T>(list: $List$Type<(T)>): T
public "getOrDefault"<T>(list: $List$Type<(T)>, defaultObject: T): T
public "onDraw"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CycleTimer$Type = ($CycleTimer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CycleTimer_ = $CycleTimer$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/variant/$ITickableComponentVariant" {
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"

export interface $ITickableComponentVariant<T extends $IMachineComponent> {

 "tick"(arg0: T): void

(arg0: T): void
}

export namespace $ITickableComponentVariant {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITickableComponentVariant$Type<T> = ($ITickableComponentVariant<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITickableComponentVariant_<T> = $ITickableComponentVariant$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen" {
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"

export interface $IMachineScreen {

 "getY"(): integer
 "getX"(): integer
 "getWidth"(): integer
 "getHeight"(): integer
 "getMachine"(): $ICustomMachine
 "getTile"(): $MachineTile
}

export namespace $IMachineScreen {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineScreen$Type = ($IMachineScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineScreen_ = $IMachineScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export interface $IJEIElementRenderer<T extends $IGuiElement> {

 "getJEITooltips"(element: T, recipe: $IMachineRecipe$Type): $List<($Component)>
 "renderElementInJEI"(arg0: $GuiGraphics$Type, arg1: T, arg2: $IMachineRecipe$Type, arg3: integer, arg4: integer): void
 "isHoveredInJei"(element: T, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean

(element: T, recipe: $IMachineRecipe$Type): $List<($Component)>
}

export namespace $IJEIElementRenderer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJEIElementRenderer$Type<T> = ($IJEIElementRenderer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJEIElementRenderer_<T> = $IJEIElementRenderer$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler" {
import {$AbstractComponentHandler, $AbstractComponentHandler$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractComponentHandler"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IDumpComponent, $IDumpComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IDumpComponent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ICommonItemHandler, $ICommonItemHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonItemHandler"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export class $ItemComponentHandler extends $AbstractComponentHandler<($ItemMachineComponent)> implements $ISerializableComponent, $ITickableComponent, $ISyncableStuff, $IDumpComponent {

constructor(manager: $IMachineComponentManager$Type, components: $List$Type<($ItemMachineComponent$Type)>)

public "getType"(): $MachineComponentType<($ItemMachineComponent)>
public "deserialize"(nbt: $CompoundTag$Type): void
public "repairItem"(slot: string, item: $Item$Type, amount: integer, nbt: $CompoundTag$Type): void
public "getComponentForID"(id: string): $Optional<($ItemMachineComponent)>
public "removeFromInputs"(slot: string, item: $Item$Type, amount: integer, nbt: $CompoundTag$Type): void
public "addToOutputs"(slot: string, item: $Item$Type, amount: integer, nbt: $CompoundTag$Type): void
public "getItemAmount"(slot: string, item: $Item$Type, nbt: $CompoundTag$Type): integer
public "getSpaceForItem"(slot: string, item: $Item$Type, nbt: $CompoundTag$Type): integer
public "getCommonHandler"(): $ICommonItemHandler
public "removeDurability"(slot: string, item: $Item$Type, amount: integer, nbt: $CompoundTag$Type, canBreak: boolean): void
public "onRemoved"(): void
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
public "getSpaceForDurability"(slot: string, item: $Item$Type, nbt: $CompoundTag$Type): integer
public "getDurabilityAmount"(slot: string, item: $Item$Type, nbt: $CompoundTag$Type): integer
public "dump"(ids: $List$Type<(string)>): void
public "serverTick"(): void
public "clientTick"(): void
get "type"(): $MachineComponentType<($ItemMachineComponent)>
get "commonHandler"(): $ICommonItemHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentHandler$Type = ($ItemComponentHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemComponentHandler_ = $ItemComponentHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/experience/$ExperienceIngredientHelper" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$IIngredientHelper, $IIngredientHelper$Type} from "packages/mezz/jei/api/ingredients/$IIngredientHelper"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"
import {$UidContext, $UidContext$Type} from "packages/mezz/jei/api/ingredients/subtypes/$UidContext"

export class $ExperienceIngredientHelper implements $IIngredientHelper<($Experience)> {

constructor()

public "getDisplayName"(xp: $Experience$Type): string
public "copyIngredient"(xp: $Experience$Type): $Experience
public "getErrorInfo"(energy: $Experience$Type): string
public "getIngredientType"(): $IIngredientType<($Experience)>
public "getUniqueId"(xp: $Experience$Type, context: $UidContext$Type): string
public "getResourceLocation"(ingredient: $Experience$Type): $ResourceLocation
public "getWildcardId"(arg0: $Experience$Type): string
public "getDisplayModId"(arg0: $Experience$Type): string
public "getTagEquivalent"(arg0: $Collection$Type<($Experience$Type)>): $Optional<($ResourceLocation)>
public "getTagStream"(arg0: $Experience$Type): $Stream<($ResourceLocation)>
public "getCheatItemStack"(arg0: $Experience$Type): $ItemStack
public "isValidIngredient"(arg0: $Experience$Type): boolean
public "normalizeIngredient"(arg0: $Experience$Type): $Experience
public "isIngredientOnServer"(arg0: $Experience$Type): boolean
public "getColors"(arg0: $Experience$Type): $Iterable<(integer)>
get "ingredientType"(): $IIngredientType<($Experience)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceIngredientHelper$Type = ($ExperienceIngredientHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceIngredientHelper_ = $ExperienceIngredientHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$MachineRecipeFinder" {
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$CraftingContext$Mutable, $CraftingContext$Mutable$Type} from "packages/fr/frinn/custommachinery/common/crafting/$CraftingContext$Mutable"

export class $MachineRecipeFinder {

constructor(tile: $MachineTile$Type, baseCooldown: integer)

public "init"(): void
public "findRecipe"(context: $CraftingContext$Mutable$Type, immediately: boolean): $Optional<($CustomMachineRecipe)>
public "setInventoryChanged"(changed: boolean): void
set "inventoryChanged"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineRecipeFinder$Type = ($MachineRecipeFinder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineRecipeFinder_ = $MachineRecipeFinder$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$RegisterGuiElementBuilderEvent" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$RegisterGuiElementBuilderEvent$Register, $RegisterGuiElementBuilderEvent$Register$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$RegisterGuiElementBuilderEvent$Register"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterGuiElementBuilderEvent {
static readonly "EVENT": $Event<($RegisterGuiElementBuilderEvent$Register)>
 "builders": $Map<($GuiElementType<(any)>), ($IGuiElementBuilder<(any)>)>

constructor()

public "register"<T extends $IGuiElement>(type: $GuiElementType$Type<(T)>, builder: $IGuiElementBuilder$Type<(T)>): void
public "getBuilders"(): $Map<($GuiElementType<(any)>), ($IGuiElementBuilder<(any)>)>
get "builders"(): $Map<($GuiElementType<(any)>), ($IGuiElementBuilder<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementBuilderEvent$Type = ($RegisterGuiElementBuilderEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementBuilderEvent_ = $RegisterGuiElementBuilderEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$PositionRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $PositionRequirementJS extends $RecipeJSBuilder {

 "requirePosition"(xString: string, yString: string, zString: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $PositionRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionRequirementJS$Type = ($PositionRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PositionRequirementJS_ = $PositionRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$IntegerEditBox" {
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$EditBox, $EditBox$Type} from "packages/net/minecraft/client/gui/components/$EditBox"

export class $IntegerEditBox extends $EditBox {
static readonly "BACKWARDS": integer
static readonly "FORWARDS": integer
static readonly "DEFAULT_TEXT_COLOR": integer
readonly "font": $Font
 "displayPos": integer
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(font: $Font$Type, x: integer, y: integer, width: integer, height: integer, message: $Component$Type)

public "bounds"(min: integer, max: integer): void
public "setFilter"(validator: $Predicate$Type<(string)>): void
public "getIntValue"(): integer
public "render"(arg0: $GuiGraphics$Type, arg1: integer, arg2: integer, arg3: float): void
set "filter"(value: $Predicate$Type<(string)>)
get "intValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerEditBox$Type = ($IntegerEditBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerEditBox_ = $IntegerEditBox$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EnergyRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $EnergyRequirementJS extends $RecipeJSBuilder {

 "produceEnergy"(amount: integer): $RecipeJSBuilder
 "requireEnergy"(amount: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $EnergyRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyRequirementJS$Type = ($EnergyRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyRequirementJS_ = $EnergyRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ForgeFluidHandler" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$ICommonFluidHandler, $ICommonFluidHandler$Type} from "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonFluidHandler"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"

export class $ForgeFluidHandler implements $ICommonFluidHandler {

constructor(fluidHandler: $FluidComponentHandler$Type)

public "tick"(): void
public "invalidate"(): void
public "getCapability"<T>(side: $Direction$Type): $LazyOptional<(T)>
public "configChanged"(side: $RelativeSide$Type, oldMode: $SideMode$Type, newMode: $SideMode$Type): void
public "interactWithFluidHandler"(player: $Player$Type, hand: $InteractionHand$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeFluidHandler$Type = ($ForgeFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeFluidHandler_ = $ForgeFluidHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ItemFilterRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ItemFilterRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ItemFilterRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFilterRequirementCT$Type<T> = ($ItemFilterRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFilterRequirementCT_<T> = $ItemFilterRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/$ComponentVariantRegistry" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ComponentVariantRegistry {

constructor()

public static "init"(): void
public static "getVariantCodec"<C extends $IMachineComponent>(type: $MachineComponentType$Type<(C)>, id: $ResourceLocation$Type): $NamedCodec<($IComponentVariant)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentVariantRegistry$Type = ($ComponentVariantRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentVariantRegistry_ = $ComponentVariantRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/modifier/$MultiplicationRecipeModifier" {
import {$IRecipeModifier$OPERATION, $IRecipeModifier$OPERATION$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $MultiplicationRecipeModifier extends $RecipeModifier {
static readonly "CODEC": $NamedCodec<($RecipeModifier)>
static readonly "RAND": $Random
readonly "requirementType": $RequirementType<(any)>
readonly "target": string
readonly "mode": $RequirementIOMode
readonly "modifier": double
readonly "chance": double
readonly "max": double
readonly "min": double
readonly "tooltip": $Component

constructor(requirementType: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, modifier: double, target: string, chance: double, max: double, min: double, tooltip: $Component$Type)

public "apply"(original: double, upgradeAmount: integer): double
public "getDefaultTooltip"(): $Component
public "getOperation"(): $IRecipeModifier$OPERATION
get "defaultTooltip"(): $Component
get "operation"(): $IRecipeModifier$OPERATION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiplicationRecipeModifier$Type = ($MultiplicationRecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiplicationRecipeModifier_ = $MultiplicationRecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$Restriction" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $Restriction<T extends $Comparable<(T)>> extends $Record {

constructor(lowerBound: T, lowerBoundInclusive: boolean, upperBound: T, upperBoundInclusive: boolean)

public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "contains"(thing: T): boolean
public "lowerBound"(): T
public "lowerBoundInclusive"(): boolean
public "upperBoundInclusive"(): boolean
public "toFormattedString"(): string
public "upperBound"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Restriction$Type<T> = ($Restriction<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Restriction_<T> = $Restriction$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$LoggingLevel" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Level, $Level$Type} from "packages/org/apache/logging/log4j/$Level"

export class $LoggingLevel extends $Enum<($LoggingLevel)> {
static readonly "FATAL": $LoggingLevel
static readonly "ERROR": $LoggingLevel
static readonly "WARN": $LoggingLevel
static readonly "INFO": $LoggingLevel
static readonly "DEBUG": $LoggingLevel
static readonly "ALL": $LoggingLevel


public static "values"(): ($LoggingLevel)[]
public static "valueOf"(name: string): $LoggingLevel
public "getLevel"(): $Level
get "level"(): $Level
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoggingLevel$Type = (("all") | ("warn") | ("debug") | ("error") | ("fatal") | ("info")) | ($LoggingLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoggingLevel_ = $LoggingLevel$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$MachineJsonOps" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$JsonOps, $JsonOps$Type} from "packages/com/mojang/serialization/$JsonOps"

export class $MachineJsonOps extends $JsonOps {
static readonly "INSTANCE": $MachineJsonOps
static readonly "COMPRESSED": $JsonOps


public "mapBuilder"(): $RecordBuilder<($JsonElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineJsonOps$Type = ($MachineJsonOps);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineJsonOps_ = $MachineJsonOps$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$ColoredBufferSource" {
import {$VertexConsumer, $VertexConsumer$Type} from "packages/com/mojang/blaze3d/vertex/$VertexConsumer"
import {$MultiBufferSource$BufferSource, $MultiBufferSource$BufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource$BufferSource"
import {$BufferBuilder, $BufferBuilder$Type} from "packages/com/mojang/blaze3d/vertex/$BufferBuilder"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ColoredBufferSource implements $MultiBufferSource {

constructor(wrapped: $MultiBufferSource$BufferSource$Type, color: integer)

public "getBuffer"(renderType: $RenderType$Type): $VertexConsumer
public "endBatch"(): void
public static "immediateWithBuffers"(layerBuffers: $Map$Type<(any), (any)>, fallbackBuffer: $BufferBuilder$Type): $MultiBufferSource$BufferSource
public static "immediate"(arg0: $BufferBuilder$Type): $MultiBufferSource$BufferSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColoredBufferSource$Type = ($ColoredBufferSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColoredBufferSource_ = $ColoredBufferSource$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$FluidStackData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"

export class $FluidStackData extends $Data<($FluidStack)> {

constructor(id: short, value: $FluidStack$Type)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackData$Type = ($FluidStackData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStackData_ = $FluidStackData$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FunctionRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeFunction, $RecipeFunction$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$RecipeFunction"

export interface $FunctionRequirementJS extends $RecipeJSBuilder {

 "requireFunctionOnStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
 "requireFunctionEachTick"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
 "requireFunctionOnEnd"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
 "requireFunctionToStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $FunctionRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionRequirementJS$Type = ($FunctionRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionRequirementJS_ = $FunctionRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DurabilityRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $DurabilityRequirementJS extends $RecipeJSBuilder {

 "repairItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
 "repairItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
 "damageItemTagNoBreak"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
 "damageItemTagNoBreak"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "damageItemTagNoBreak"(tag: string, amount: integer): $RecipeJSBuilder
 "damageItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
 "damageItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
 "repairItemTag"(tag: string, amount: integer): $RecipeJSBuilder
 "repairItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "repairItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
 "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
 "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
 "damageItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
 "damageItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "damageItemTag"(tag: string, amount: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $DurabilityRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DurabilityRequirementJS$Type = ($DurabilityRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DurabilityRequirementJS_ = $DurabilityRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$BarGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BarGuiElement, $BarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$BarGuiElement"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $BarGuiElementWidget extends $AbstractGuiElementWidget<($BarGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $BarGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarGuiElementWidget$Type = ($BarGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BarGuiElementWidget_ = $BarGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$LightRequirement" {
import {$LightMachineComponent, $LightMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$LightMachineComponent"
import {$IntRange, $IntRange$Type} from "packages/fr/frinn/custommachinery/impl/util/$IntRange"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $LightRequirement extends $AbstractRequirement<($LightMachineComponent)> implements $ITickableRequirement<($LightMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($LightRequirement)>

constructor(light: $IntRange$Type, sky: boolean)

public "test"(component: $LightMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($LightMachineComponent)>
public "getType"(): $RequirementType<(any)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $LightMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $LightMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $LightMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($LightMachineComponent)>
get "type"(): $RequirementType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightRequirement$Type = ($LightRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LightRequirement_ = $LightRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$CustomMachineContainer" {
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$SyncableContainer, $SyncableContainer$Type} from "packages/fr/frinn/custommachinery/common/network/$SyncableContainer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $CustomMachineContainer extends $SyncableContainer {
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(id: integer, playerInv: $Inventory$Type, extraData: $FriendlyByteBuf$Type)
constructor(id: integer, playerInv: $Inventory$Type, tile: $CustomMachineTile$Type)

public "init"(): void
public static "open"(player: $ServerPlayer$Type, machine: $MachineTile$Type): void
public "needFullSync"(): boolean
public "elementClicked"(element: integer, button: byte): void
public "stillValid"(player: $Player$Type): boolean
public "removed"(player: $Player$Type): void
public "getTile"(): $CustomMachineTile
public "clicked"(slotId: integer, dragType: integer, clickTypeIn: $ClickType$Type, player: $Player$Type): void
public "quickMoveStack"(player: $Player$Type, index: integer): $ItemStack
get "tile"(): $CustomMachineTile
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineContainer$Type = ($CustomMachineContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineContainer_ = $CustomMachineContainer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineryKubeJSPlugin" {
import {$KubeJSPlugin, $KubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSPlugin"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"
import {$RegisterRecipeSchemasEvent, $RegisterRecipeSchemasEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RegisterRecipeSchemasEvent"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export class $CustomMachineryKubeJSPlugin extends $KubeJSPlugin {
static readonly "CM_EVENTS": $EventGroup
static readonly "UPGRADES": $EventHandler

constructor()

public "init"(): void
public "registerBindings"(event: $BindingsEvent$Type): void
public "registerEvents"(): void
public "clearCaches"(): void
public "registerTypeWrappers"(type: $ScriptType$Type, typeWrappers: $TypeWrappers$Type): void
public "registerRecipeSchemas"(event: $RegisterRecipeSchemasEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineryKubeJSPlugin$Type = ($CustomMachineryKubeJSPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineryKubeJSPlugin_ = $CustomMachineryKubeJSPlugin$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$FieldCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FieldCodec<A> extends $NamedMapCodec<(A)> {


public "name"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: $MapLike$Type<(T)>): $DataResult<(A)>
public "encode"<T>(input: A, ops: $DynamicOps$Type<(T)>, prefix: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(fieldName: string, elementCodec: $NamedCodec$Type<(A)>, name: string): $NamedMapCodec<(A)>
public "keys"<T>(ops: $DynamicOps$Type<(T)>): $Stream<(T)>
public static "toSnakeCase"(input: string): string
public static "tryGetValue"<T>(ops: $DynamicOps$Type<(T)>, map: $MapLike$Type<(T)>, fieldName: string): T
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldCodec$Type<A> = ($FieldCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldCodec_<A> = $FieldCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ExperiencePerTickRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ExperiencePerTickRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireLevelPerTick"(levels: integer): T
 "produceLevelPerTick"(levels: integer): T
 "requireXpPerTick"(xp: integer): T
 "produceXpPerTick"(xp: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ExperiencePerTickRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperiencePerTickRequirementCT$Type<T> = ($ExperiencePerTickRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperiencePerTickRequirementCT_<T> = $ExperiencePerTickRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$AppearanceListWidget" {
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$AppearanceListWidget$AppearanceEntry, $AppearanceListWidget$AppearanceEntry$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$AppearanceListWidget$AppearanceEntry"
import {$MachineAppearanceBuilder, $MachineAppearanceBuilder$Type} from "packages/fr/frinn/custommachinery/common/machine/builder/$MachineAppearanceBuilder"
import {$ListWidget, $ListWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AppearanceListWidget extends $ListWidget<($AppearanceListWidget$AppearanceEntry)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, itemHeight: integer, builder: $Supplier$Type<($MachineAppearanceBuilder$Type)>, parent: $MachineEditScreen$Type)

public "init"(): void
public "setFocused"(arg0: boolean): void
public "isFocused"(): boolean
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppearanceListWidget$Type = ($AppearanceListWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AppearanceListWidget_ = $AppearanceListWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/popup/$ConfirmPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $ConfirmPopup extends $PopupScreen {
static readonly "CONFIRM": $Component
static readonly "CANCEL": $Component
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, xSize: integer, ySize: integer, onConfirm: $Runnable$Type)

public "text"(...components: ($Component$Type)[]): $ConfirmPopup
public "cancel"(): void
public "confirm"(): void
public "title"(title: $Component$Type): $ConfirmPopup
public "cancelCallback"(callback: $Runnable$Type): $ConfirmPopup
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfirmPopup$Type = ($ConfirmPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfirmPopup_ = $ConfirmPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$AbstractRecipeJSBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IRecipeBuilder, $IRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IRecipeBuilder"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AbstractRecipeJSBuilder<T extends $IRecipeBuilder<(any)>> extends $RecipeJS implements $RecipeJSBuilder {
static readonly "IDS": $Map<($ResourceLocation), ($Map<($ResourceLocation), (integer)>)>
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor(typeID: $ResourceLocation$Type)

public "priority"(priority: integer): $AbstractRecipeJSBuilder<(T)>
public "info"(consumer: $Consumer$Type<($DisplayInfoTemplate$Type)>): $AbstractRecipeJSBuilder<(T)>
public "delay"(delay: double): $AbstractRecipeJSBuilder<(T)>
public "error"(error: string, ...args: (any)[]): $RecipeJSBuilder
public "hide"(): $AbstractRecipeJSBuilder<(T)>
public "afterLoaded"(): void
public "getFromToString"(): string
public "addRequirement"(requirement: $IRequirement$Type<(any)>): $AbstractRecipeJSBuilder<(T)>
public "makeBuilder"(): T
public "createRecipe"(): $Recipe<(any)>
public "jei"(): $AbstractRecipeJSBuilder<(T)>
public "chance"(chance: double): $AbstractRecipeJSBuilder<(T)>
get "fromToString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractRecipeJSBuilder$Type<T> = ($AbstractRecipeJSBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractRecipeJSBuilder_<T> = $AbstractRecipeJSBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$TextureSizeHelper" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TextureSizeHelper {

constructor()

public static "getTextureWidth"(texture: $ResourceLocation$Type): integer
public static "getTextureHeight"(texture: $ResourceLocation$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureSizeHelper$Type = ($TextureSizeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureSizeHelper_ = $TextureSizeHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/$MachineConfigScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$CustomMachineScreen, $CustomMachineScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$CustomMachineScreen"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $MachineConfigScreen extends $BaseScreen {
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $CustomMachineScreen$Type)

public "keyPressed"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "renderBackground"(graphics: $GuiGraphics$Type): void
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineConfigScreen$Type = ($MachineConfigScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineConfigScreen_ = $MachineConfigScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$MachineShape" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MachineShape implements $Function<($Direction), ($VoxelShape)> {
static readonly "CODEC": $NamedCodec<($MachineShape)>
static readonly "DEFAULT": $MachineShape
static readonly "DEFAULT_COLLISION": $MachineShape

constructor()
constructor(shapes: $Map$Type<($Direction$Type), ($VoxelShape$Type)>)

public "apply"(side: $Direction$Type): $VoxelShape
public static "identity"<T>(): $Function<($Direction), ($Direction)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($VoxelShape)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($Direction), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineShape$Type = ($MachineShape);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineShape_ = $MachineShape$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$EntityRequirementCT" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $EntityRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireEntitiesHealth"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "consumeEntityHealthOnStart"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "consumeEntityHealthOnEnd"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "requireEntities"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "killEntityOnStart"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "killEntityOnEnd"(amount: integer, radius: integer, filter: ($EntityType$Type<(any)>)[], whitelist: boolean): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $EntityRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRequirementCT$Type<T> = ($EntityRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRequirementCT_<T> = $EntityRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IMachineModelLocation, $IMachineModelLocation$Type} from "packages/fr/frinn/custommachinery/impl/util/$IMachineModelLocation"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export interface $IMachineAppearance {

 "getProperty"<T>(arg0: $MachineAppearanceProperty$Type<(T)>): T
 "copy"(): $IMachineAppearance
 "getShape"(): $Function<($Direction), ($VoxelShape)>
 "requiresCorrectToolForDrops"(): boolean
 "getCollisionShape"(): $Function<($Direction), ($VoxelShape)>
 "getResistance"(): float
 "getAmbientSound"(): $SoundEvent
 "getMiningLevel"(): $TagKey<($Block)>
 "getHardness"(): float
 "getItemModel"(): $IMachineModelLocation
 "getColor"(): integer
 "getLightLevel"(): integer
 "getTool"(): $List<($TagKey<($Block)>)>
 "getBlockModel"(): $IMachineModelLocation
 "getInteractionSound"(): $SoundType
}

export namespace $IMachineAppearance {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineAppearance$Type = ($IMachineAppearance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineAppearance_ = $IMachineAppearance$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $RequirementIOMode extends $Enum<($RequirementIOMode)> {
static readonly "INPUT": $RequirementIOMode
static readonly "OUTPUT": $RequirementIOMode
static readonly "CODEC": $NamedCodec<($RequirementIOMode)>


public static "value"(mode: string): $RequirementIOMode
public "toString"(): string
public static "values"(): ($RequirementIOMode)[]
public static "valueOf"(name: string): $RequirementIOMode
public "getTranslationKey"(): string
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequirementIOMode$Type = (("output") | ("input")) | ($RequirementIOMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RequirementIOMode_ = $RequirementIOMode$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$ChunkloadComponentBuilder" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ChunkloadMachineComponent$Template, $ChunkloadMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent$Template"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ChunkloadMachineComponent, $ChunkloadMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent"

export class $ChunkloadComponentBuilder implements $IMachineComponentBuilder<($ChunkloadMachineComponent), ($ChunkloadMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($ChunkloadMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $ChunkloadMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $ChunkloadMachineComponent$Template$Type, onFinish: $Consumer$Type<($ChunkloadMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadComponentBuilder$Type = ($ChunkloadComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadComponentBuilder_ = $ChunkloadComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentPropertyListWidget$ComponentPropertyEntry" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ListWidget$Entry, $ListWidget$Entry$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget$Entry"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ComponentPropertyListWidget$ComponentPropertyEntry extends $ListWidget$Entry {

constructor(title: $Component$Type, widget: $AbstractWidget$Type)

public "render"(graphics: $GuiGraphics$Type, index: integer, x: integer, y: integer, width: integer, height: integer, mouseX: integer, mouseY: integer, partialTick: float): void
public "children"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentPropertyListWidget$ComponentPropertyEntry$Type = ($ComponentPropertyListWidget$ComponentPropertyEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentPropertyListWidget$ComponentPropertyEntry_ = $ComponentPropertyListWidget$ComponentPropertyEntry$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$EnumMapCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnumMapCodec<K extends $Enum<(K)>, V> extends $NamedMapCodec<($Map<(K), (V)>)> {


public "name"(): string
public "toString"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: $MapLike$Type<(T)>): $DataResult<($Map<(K), (V)>)>
public "encode"<T>(input: $Map$Type<(K), (V)>, ops: $DynamicOps$Type<(T)>, prefix: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public static "of"<K extends $Enum<(K)>, V>(keyEnum: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $EnumMapCodec<(K), (V)>
public static "of"<K extends $Enum<(K)>, V>(keyEnum: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $EnumMapCodec<(K), (V)>
public static "of"<K extends $Enum<(K)>, V>(keyEnum: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $EnumMapCodec<(K), (V)>
public static "of"<K extends $Enum<(K)>, V>(keyEnum: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $EnumMapCodec<(K), (V)>
public "keys"<T>(ops: $DynamicOps$Type<(T)>): $Stream<(T)>
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumMapCodec$Type<K, V> = ($EnumMapCodec<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumMapCodec_<K, V> = $EnumMapCodec$Type<(K), (V)>;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$FluidGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$FluidGuiElement, $FluidGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $FluidGuiElementWidget extends $TexturedGuiElementWidget<($FluidGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $FluidGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidGuiElementWidget$Type = ($FluidGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidGuiElementWidget_ = $FluidGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export interface $IComponentGuiElement<T extends $IMachineComponent> {

 "getComponentType"(): $MachineComponentType<(T)>
 "getComponent"(manager: $IMachineComponentManager$Type): $Optional<(T)>
 "getComponentId"(): string
}

export namespace $IComponentGuiElement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComponentGuiElement$Type<T> = ($IComponentGuiElement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComponentGuiElement_<T> = $IComponentGuiElement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$RecipeFunction" {
import {$Context, $Context$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Context"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Result, $Result$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Result"

export interface $RecipeFunction extends $Function<($Context), ($Result)> {

 "apply"(arg0: $Context$Type): $Result
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($Result)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($Context), (V)>

(arg0: $Context$Type): $Result
}

export namespace $RecipeFunction {
function identity<T>(): $Function<($Context), ($Context)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFunction$Type = ($RecipeFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFunction_ = $RecipeFunction$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/util/$IMachineModelLocation" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IMachineModelLocation {

 "toString"(): string
 "getProperties"(): string
 "getState"(): $BlockState
 "getItem"(): $Item
 "getLoc"(): $ResourceLocation
}

export namespace $IMachineModelLocation {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineModelLocation$Type = ($IMachineModelLocation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineModelLocation_ = $IMachineModelLocation$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$StructureMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$BlockStructure, $BlockStructure$Type} from "packages/fr/frinn/custommachinery/common/util/$BlockStructure"

export class $StructureMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($StructureMachineComponent)>
public "placeStructure"(pattern: $BlockStructure$Type, drops: boolean): void
public "checkStructure"(pattern: $BlockStructure$Type): boolean
public "destroyStructure"(pattern: $BlockStructure$Type, drops: boolean): void
get "type"(): $MachineComponentType<($StructureMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureMachineComponent$Type = ($StructureMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureMachineComponent_ = $StructureMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$TimeMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $TimeMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($TimeMachineComponent)>
public "getTime"(): long
get "type"(): $MachineComponentType<($TimeMachineComponent)>
get "time"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeMachineComponent$Type = ($TimeMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeMachineComponent_ = $TimeMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$ButtonGuiElementWidget" {
import {$ButtonGuiElement, $ButtonGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ButtonGuiElement"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ButtonGuiElementWidget extends $AbstractGuiElementWidget<($ButtonGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $ButtonGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "onClick"(mouseX: double, mouseY: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonGuiElementWidget$Type = ($ButtonGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonGuiElementWidget_ = $ButtonGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$RegisterAppearancePropertyBuilderEvent$Register" {
import {$RegisterAppearancePropertyBuilderEvent, $RegisterAppearancePropertyBuilderEvent$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$RegisterAppearancePropertyBuilderEvent"

export interface $RegisterAppearancePropertyBuilderEvent$Register {

 "registerAppearancePropertyBuilders"(arg0: $RegisterAppearancePropertyBuilderEvent$Type): void

(arg0: $RegisterAppearancePropertyBuilderEvent$Type): void
}

export namespace $RegisterAppearancePropertyBuilderEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterAppearancePropertyBuilderEvent$Register$Type = ($RegisterAppearancePropertyBuilderEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterAppearancePropertyBuilderEvent$Register_ = $RegisterAppearancePropertyBuilderEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$BlockTagIngredient" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $BlockTagIngredient implements $IIngredient<($PartialBlockState)> {
static readonly "CODEC": $NamedCodec<($BlockTagIngredient)>


public "toString"(): string
public "test"(partialBlockState: $PartialBlockState$Type): boolean
public static "create"(s: string): $BlockTagIngredient
public "getAll"(): $List<($PartialBlockState)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public "negate"(): $Predicate<($PartialBlockState)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public static "isEqual"<T>(arg0: any): $Predicate<($PartialBlockState)>
get "all"(): $List<($PartialBlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTagIngredient$Type = ($BlockTagIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTagIngredient_ = $BlockTagIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/$RenderTypes" {
import {$RenderStateShard$OverlayStateShard, $RenderStateShard$OverlayStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$OverlayStateShard"
import {$RenderStateShard$TexturingStateShard, $RenderStateShard$TexturingStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TexturingStateShard"
import {$RenderStateShard$LineStateShard, $RenderStateShard$LineStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LineStateShard"
import {$RenderStateShard$TextureStateShard, $RenderStateShard$TextureStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TextureStateShard"
import {$RenderStateShard$EmptyTextureStateShard, $RenderStateShard$EmptyTextureStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$EmptyTextureStateShard"
import {$RenderStateShard$LightmapStateShard, $RenderStateShard$LightmapStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LightmapStateShard"
import {$RenderStateShard$LayeringStateShard, $RenderStateShard$LayeringStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$LayeringStateShard"
import {$RenderStateShard$WriteMaskStateShard, $RenderStateShard$WriteMaskStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$WriteMaskStateShard"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$RenderType$CompositeRenderType, $RenderType$CompositeRenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType$CompositeRenderType"
import {$VertexFormat, $VertexFormat$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$RenderStateShard$OutputStateShard, $RenderStateShard$OutputStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$OutputStateShard"
import {$RenderStateShard$ColorLogicStateShard, $RenderStateShard$ColorLogicStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$ColorLogicStateShard"
import {$VertexFormat$Mode, $VertexFormat$Mode$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat$Mode"
import {$RenderStateShard$ShaderStateShard, $RenderStateShard$ShaderStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$ShaderStateShard"
import {$RenderStateShard$DepthTestStateShard, $RenderStateShard$DepthTestStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$DepthTestStateShard"
import {$DrawBuffer, $DrawBuffer$Type} from "packages/com/jozufozu/flywheel/backend/instancing/$DrawBuffer"
import {$RenderStateShard$TransparencyStateShard, $RenderStateShard$TransparencyStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$TransparencyStateShard"
import {$RenderStateShard$CullStateShard, $RenderStateShard$CullStateShard$Type} from "packages/net/minecraft/client/renderer/$RenderStateShard$CullStateShard"

export class $RenderTypes extends $RenderType {
static readonly "PHANTOM": $RenderType
static readonly "NOPE": $RenderType
static readonly "THICK_LINES": $RenderType
static readonly "BIG_BUFFER_SIZE": integer
static readonly "MEDIUM_BUFFER_SIZE": integer
static readonly "SMALL_BUFFER_SIZE": integer
static readonly "TRANSIENT_BUFFER_SIZE": integer
static readonly "LINES": $RenderType$CompositeRenderType
static readonly "LINE_STRIP": $RenderType$CompositeRenderType
 "sortOnUpload": boolean
static readonly "VIEW_SCALE_Z_EPSILON": float
static readonly "MAX_ENCHANTMENT_GLINT_SPEED_MILLIS": double
readonly "name": string
 "setupState": $Runnable
static readonly "NO_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "ADDITIVE_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "LIGHTNING_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "GLINT_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "CRUMBLING_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "TRANSLUCENT_TRANSPARENCY": $RenderStateShard$TransparencyStateShard
static readonly "NO_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_LIGHTMAP_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_TEX_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_TEX_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_TEX_LIGHTMAP_SHADER": $RenderStateShard$ShaderStateShard
static readonly "POSITION_COLOR_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_SOLID_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CUTOUT_MIPPED_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_MOVING_BLOCK_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRANSLUCENT_NO_CRUMBLING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_CUTOUT_NO_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SOLID_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_Z_OFFSET_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_CULL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_TRANSLUCENT_EMISSIVE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SMOOTH_CUTOUT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_BEACON_BEAM_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_DECAL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_NO_OUTLINE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_SHADOW_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_ALPHA_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_EYES_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENERGY_SWIRL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LEASH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_WATER_MASK_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_OUTLINE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ARMOR_ENTITY_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_TRANSLUCENT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GLINT_DIRECT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_GLINT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_ENTITY_GLINT_DIRECT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_CRUMBLING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_BACKGROUND_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_INTENSITY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_BACKGROUND_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TEXT_INTENSITY_SEE_THROUGH_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LIGHTNING_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_TRIPWIRE_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_END_PORTAL_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_END_GATEWAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_LINES_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_OVERLAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_TEXT_HIGHLIGHT_SHADER": $RenderStateShard$ShaderStateShard
static readonly "RENDERTYPE_GUI_GHOST_RECIPE_OVERLAY_SHADER": $RenderStateShard$ShaderStateShard
static readonly "BLOCK_SHEET_MIPPED": $RenderStateShard$TextureStateShard
static readonly "BLOCK_SHEET": $RenderStateShard$TextureStateShard
static readonly "NO_TEXTURE": $RenderStateShard$EmptyTextureStateShard
static readonly "DEFAULT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "GLINT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "ENTITY_GLINT_TEXTURING": $RenderStateShard$TexturingStateShard
static readonly "LIGHTMAP": $RenderStateShard$LightmapStateShard
static readonly "NO_LIGHTMAP": $RenderStateShard$LightmapStateShard
static readonly "OVERLAY": $RenderStateShard$OverlayStateShard
static readonly "NO_OVERLAY": $RenderStateShard$OverlayStateShard
static readonly "CULL": $RenderStateShard$CullStateShard
static readonly "NO_CULL": $RenderStateShard$CullStateShard
static readonly "NO_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "EQUAL_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "LEQUAL_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "GREATER_DEPTH_TEST": $RenderStateShard$DepthTestStateShard
static readonly "COLOR_DEPTH_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "COLOR_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "DEPTH_WRITE": $RenderStateShard$WriteMaskStateShard
static readonly "NO_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "POLYGON_OFFSET_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "VIEW_OFFSET_Z_LAYERING": $RenderStateShard$LayeringStateShard
static readonly "MAIN_TARGET": $RenderStateShard$OutputStateShard
static readonly "OUTLINE_TARGET": $RenderStateShard$OutputStateShard
static readonly "TRANSLUCENT_TARGET": $RenderStateShard$OutputStateShard
static readonly "PARTICLES_TARGET": $RenderStateShard$OutputStateShard
static readonly "WEATHER_TARGET": $RenderStateShard$OutputStateShard
static readonly "CLOUDS_TARGET": $RenderStateShard$OutputStateShard
static readonly "ITEM_ENTITY_TARGET": $RenderStateShard$OutputStateShard
static readonly "DEFAULT_LINE": $RenderStateShard$LineStateShard
static readonly "NO_COLOR_LOGIC": $RenderStateShard$ColorLogicStateShard
static readonly "OR_REVERSE_COLOR_LOGIC": $RenderStateShard$ColorLogicStateShard

constructor(nameIn: string, formatIn: $VertexFormat$Type, drawModeIn: $VertexFormat$Mode$Type, bufferSizeIn: integer, useDelegateIn: boolean, needsSortingIn: boolean, setupTaskIn: $Runnable$Type, clearTaskIn: $Runnable$Type)

public static "getDrawBuffer"(arg0: $RenderType$Type): $DrawBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderTypes$Type = ($RenderTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RenderTypes_ = $RenderTypes$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TexturedGuiElementWidget<T extends $AbstractTexturedGuiElement> extends $AbstractGuiElementWidget<(T)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: T, screen: $IMachineScreen$Type, title: $Component$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TexturedGuiElementWidget$Type<T> = ($TexturedGuiElementWidget<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TexturedGuiElementWidget_<T> = $TexturedGuiElementWidget$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$FluidRenderer" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"

export class $FluidRenderer {

constructor()

public static "renderFluid"(poseStack: $PoseStack$Type, posX: integer, posY: integer, width: integer, height: integer, fluidStack: $FluidStack$Type, capacity: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidRenderer$Type = ($FluidRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidRenderer_ = $FluidRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$BlockStructure" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockStructure {

constructor(blocks: $Map$Type<($BlockPos$Type), ($IIngredient$Type<($PartialBlockState$Type)>)>)

public "match"(world: $LevelReader$Type, machinePos: $BlockPos$Type, machineFacing: $Direction$Type): boolean
public "getBlocks"(direction: $Direction$Type): $Map<($BlockPos), ($IIngredient<($PartialBlockState)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStructure$Type = ($BlockStructure);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStructure_ = $BlockStructure$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$DefaultItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DefaultItemComponentVariant extends $ItemComponentVariant {
static readonly "INSTANCE": $DefaultItemComponentVariant
static readonly "CODEC": $NamedCodec<($DefaultItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "getCodec"(): $NamedCodec<($DefaultItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultItemComponentVariant$Type = ($DefaultItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultItemComponentVariant_ = $DefaultItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$DumpGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$DumpGuiElement, $DumpGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$DumpGuiElement"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $DumpGuiElementBuilder implements $IGuiElementBuilder<($DumpGuiElement)> {

constructor()

public "type"(): $GuiElementType<($DumpGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $DumpGuiElement$Type): $DumpGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $DumpGuiElement$Type, onFinish: $Consumer$Type<($DumpGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DumpGuiElementBuilder$Type = ($DumpGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DumpGuiElementBuilder_ = $DumpGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$MachineComponentManager" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IDumpComponent, $IDumpComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IDumpComponent"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$IComponentHandler, $IComponentHandler$Type} from "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MachineComponentManager implements $IMachineComponentManager {

constructor(templates: $List$Type<($IMachineComponentTemplate$Type<(any)>)>, tile: $CustomMachineTile$Type)

public "getLevel"(): $Level
public "getConfigComponentById"(id: string): $Optional<($ISideConfigComponent)>
public "getComponent"<T extends $IMachineComponent>(type: $MachineComponentType$Type<(T)>): $Optional<(T)>
public "clientTick"(): void
public "getServer"(): $MinecraftServer
public "hasComponent"(type: $MachineComponentType$Type<(any)>): boolean
public "getDumpComponents"(): $List<($IDumpComponent)>
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "markDirty"(): void
public "getComponents"(): $Map<($MachineComponentType<(any)>), ($IMachineComponent)>
public "serverTick"(): void
public "getComponentHandler"<T extends $IMachineComponent>(type: $MachineComponentType$Type<(T)>): $Optional<($IComponentHandler<(T)>)>
public "getTickableComponents"(): $List<($ITickableComponent)>
public "getComparatorInputComponents"(): $List<($IComparatorInputComponent)>
public "getSyncableComponents"(): $List<($ISyncableStuff)>
public "getSerializableComponents"(): $List<($ISerializableComponent)>
public "getConfigComponents"(): $Collection<($ISideConfigComponent)>
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
get "level"(): $Level
get "server"(): $MinecraftServer
get "dumpComponents"(): $List<($IDumpComponent)>
get "components"(): $Map<($MachineComponentType<(any)>), ($IMachineComponent)>
get "tickableComponents"(): $List<($ITickableComponent)>
get "comparatorInputComponents"(): $List<($IComparatorInputComponent)>
get "syncableComponents"(): $List<($ISyncableStuff)>
get "serializableComponents"(): $List<($ISerializableComponent)>
get "configComponents"(): $Collection<($ISideConfigComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineComponentManager$Type = ($MachineComponentManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineComponentManager_ = $MachineComponentManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$Comparators" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $Comparators {
static readonly "GUI_ELEMENTS_COMPARATOR": $Comparator<($IGuiElement)>
static readonly "RECIPE_PRIORITY_COMPARATOR": $Comparator<($IMachineRecipe)>
static readonly "JEI_PRIORITY_COMPARATOR": $Comparator<($IMachineRecipe)>
static readonly "REQUIREMENT_COMPARATOR": $Comparator<($IRequirement<(any)>)>
static readonly "PARENT_MACHINE_FIRST": $Comparator<($CustomMachine)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Comparators$Type = ($Comparators);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Comparators_ = $Comparators$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$Registration" {
import {$ExperiencePerTickRequirement, $ExperiencePerTickRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ExperiencePerTickRequirement"
import {$RegistrarManager, $RegistrarManager$Type} from "packages/dev/architectury/registry/registries/$RegistrarManager"
import {$DimensionRequirement, $DimensionRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$DimensionRequirement"
import {$StructureMachineComponent, $StructureMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$StructureMachineComponent"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$SlotGuiElement, $SlotGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$SlotGuiElement"
import {$FunctionMachineComponent, $FunctionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FunctionMachineComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$DoubleData, $DoubleData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$DoubleData"
import {$CustomCraftRecipeSerializer, $CustomCraftRecipeSerializer$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipeSerializer"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$DurabilityRequirement, $DurabilityRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$DurabilityRequirement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FluidStackData, $FluidStackData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$FluidStackData"
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$BiomeRequirement, $BiomeRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BiomeRequirement"
import {$ExperienceMachineComponent, $ExperienceMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ItemRequirement, $ItemRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ItemRequirement"
import {$FuelMachineComponent, $FuelMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FuelMachineComponent"
import {$EnergyGuiElement, $EnergyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement"
import {$FuelRequirement, $FuelRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$FuelRequirement"
import {$ResetGuiElement, $ResetGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ResetGuiElement"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$LightMachineComponent, $LightMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$LightMachineComponent"
import {$ExperienceRequirement, $ExperienceRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ExperienceRequirement"
import {$TimeMachineComponent, $TimeMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$TimeMachineComponent"
import {$IntegerData, $IntegerData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$IntegerData"
import {$FluidGuiElement, $FluidGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement"
import {$BlockRequirement, $BlockRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement"
import {$DataMachineComponent, $DataMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$DataMachineComponent"
import {$FunctionRequirement, $FunctionRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$FunctionRequirement"
import {$ProgressBarGuiElement, $ProgressBarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement"
import {$CMSoundType, $CMSoundType$Type} from "packages/fr/frinn/custommachinery/common/util/$CMSoundType"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"
import {$PositionMachineComponent, $PositionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$PositionMachineComponent"
import {$RedstoneMachineComponent, $RedstoneMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent"
import {$StructureRequirement, $StructureRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement"
import {$LongData, $LongData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$LongData"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$PositionRequirement, $PositionRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$PositionRequirement"
import {$LootTableRequirement, $LootTableRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$LootTableRequirement"
import {$TimeRequirement, $TimeRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$TimeRequirement"
import {$ChunkloadMachineComponent, $ChunkloadMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent"
import {$TextureGuiElement, $TextureGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextureGuiElement"
import {$EntityMachineComponent, $EntityMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EntityMachineComponent"
import {$CraftProcessor, $CraftProcessor$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CraftProcessor"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$ButtonGuiElement, $ButtonGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ButtonGuiElement"
import {$LightRequirement, $LightRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$LightRequirement"
import {$BlockMachineComponent, $BlockMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$BlockMachineComponent"
import {$EffectRequirement, $EffectRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$EffectRequirement"
import {$FluidPerTickRequirement, $FluidPerTickRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$FluidPerTickRequirement"
import {$SkyMachineComponent, $SkyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$SkyMachineComponent"
import {$BooleanData, $BooleanData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$BooleanData"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$SideConfigData, $SideConfigData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$SideConfigData"
import {$EnergyRequirement, $EnergyRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$EnergyRequirement"
import {$ItemFilterRequirement, $ItemFilterRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ItemFilterRequirement"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/dev/architectury/registry/registries/$DeferredRegister"
import {$CustomMachineItem, $CustomMachineItem$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineItem"
import {$ButtonRequirement, $ButtonRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ButtonRequirement"
import {$FloatData, $FloatData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$FloatData"
import {$CustomMachineBlock, $CustomMachineBlock$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineBlock"
import {$EntityRequirement, $EntityRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$EntityRequirement"
import {$BackgroundGuiElement, $BackgroundGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$BackgroundGuiElement"
import {$WeatherMachineComponent, $WeatherMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent"
import {$MachineProcessor, $MachineProcessor$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$MachineProcessor"
import {$StringData, $StringData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$StringData"
import {$CustomMachineContainer, $CustomMachineContainer$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineContainer"
import {$SpeedRequirement, $SpeedRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$SpeedRequirement"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$EnergyPerTickRequirement, $EnergyPerTickRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$EnergyPerTickRequirement"
import {$ConfigGuiElement, $ConfigGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ConfigGuiElement"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$StatusGuiElement, $StatusGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$StatusGuiElement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ExperienceGuiElement, $ExperienceGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement"
import {$BarGuiElement, $BarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$BarGuiElement"
import {$EffectMachineComponent, $EffectMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EffectMachineComponent"
import {$CommandMachineComponent, $CommandMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$CommandMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$StructureCreatorItem, $StructureCreatorItem$Type} from "packages/fr/frinn/custommachinery/common/init/$StructureCreatorItem"
import {$DumpGuiElement, $DumpGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$DumpGuiElement"
import {$LootContextParamSet, $LootContextParamSet$Type} from "packages/net/minecraft/world/level/storage/loot/parameters/$LootContextParamSet"
import {$PlayerInventoryGuiElement, $PlayerInventoryGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$PlayerInventoryGuiElement"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$EmptyGuiElement, $EmptyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EmptyGuiElement"
import {$MachineModelLocation, $MachineModelLocation$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineModelLocation"
import {$RegistrySupplier, $RegistrySupplier$Type} from "packages/dev/architectury/registry/registries/$RegistrySupplier"
import {$NbtData, $NbtData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$NbtData"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$BoxCreatorItem, $BoxCreatorItem$Type} from "packages/fr/frinn/custommachinery/common/init/$BoxCreatorItem"
import {$CommandRequirement, $CommandRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$CommandRequirement"
import {$TextGuiElement, $TextGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement"
import {$ItemTransformRequirement, $ItemTransformRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ItemTransformRequirement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$MachineShape, $MachineShape$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineShape"
import {$RegisterComponentVariantEvent, $RegisterComponentVariantEvent$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$RegisterComponentVariantEvent"
import {$ChunkloadRequirement, $ChunkloadRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$ChunkloadRequirement"
import {$FluidRequirement, $FluidRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$FluidRequirement"
import {$DummyProcessor, $DummyProcessor$Type} from "packages/fr/frinn/custommachinery/common/crafting/$DummyProcessor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RedstoneRequirement, $RedstoneRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$RedstoneRequirement"
import {$WeatherRequirement, $WeatherRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$WeatherRequirement"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$FuelGuiElement, $FuelGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FuelGuiElement"
import {$DropMachineComponent, $DropMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$DropMachineComponent"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$CustomMachineRecipeSerializer, $CustomMachineRecipeSerializer$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipeSerializer"
import {$SkyRequirement, $SkyRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$SkyRequirement"
import {$ConfigurationCardItem, $ConfigurationCardItem$Type} from "packages/fr/frinn/custommachinery/common/init/$ConfigurationCardItem"
import {$DropRequirement, $DropRequirement$Type} from "packages/fr/frinn/custommachinery/common/requirement/$DropRequirement"
import {$ItemStackData, $ItemStackData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$ItemStackData"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"

export class $Registration {
static readonly "REGISTRIES": $RegistrarManager
static readonly "CUSTOM_MACHINE_LOOT_PARAMETER_SET": $LootContextParamSet
static readonly "BLOCKS": $DeferredRegister<($Block)>
static readonly "ITEMS": $DeferredRegister<($Item)>
static readonly "TILE_ENTITIES": $DeferredRegister<($BlockEntityType<(any)>)>
static readonly "CONTAINERS": $DeferredRegister<($MenuType<(any)>)>
static readonly "RECIPE_SERIALIZERS": $DeferredRegister<($RecipeSerializer<(any)>)>
static readonly "RECIPE_TYPES": $DeferredRegister<($RecipeType<(any)>)>
static readonly "CREATIVE_TABS": $DeferredRegister<($CreativeModeTab)>
static readonly "GUI_ELEMENTS": $DeferredRegister<($GuiElementType<(any)>)>
static readonly "MACHINE_COMPONENTS": $DeferredRegister<($MachineComponentType<(any)>)>
static readonly "REQUIREMENTS": $DeferredRegister<($RequirementType<(any)>)>
static readonly "APPEARANCE_PROPERTIES": $DeferredRegister<($MachineAppearanceProperty<(any)>)>
static readonly "DATAS": $DeferredRegister<($DataType<(any), (any)>)>
static readonly "PROCESSORS": $DeferredRegister<($ProcessorType<(any)>)>
static readonly "GUI_ELEMENT_TYPE_REGISTRY": $Registrar<($GuiElementType<(any)>)>
static readonly "MACHINE_COMPONENT_TYPE_REGISTRY": $Registrar<($MachineComponentType<(any)>)>
static readonly "REQUIREMENT_TYPE_REGISTRY": $Registrar<($RequirementType<(any)>)>
static readonly "APPEARANCE_PROPERTY_REGISTRY": $Registrar<($MachineAppearanceProperty<(any)>)>
static readonly "DATA_REGISTRY": $Registrar<($DataType<(any), (any)>)>
static readonly "PROCESSOR_REGISTRY": $Registrar<($ProcessorType<(any)>)>
static readonly "CUSTOM_MACHINE_BLOCK": $RegistrySupplier<($CustomMachineBlock)>
static readonly "CUSTOM_MACHINE_ITEM": $RegistrySupplier<($CustomMachineItem)>
static readonly "BOX_CREATOR_ITEM": $RegistrySupplier<($BoxCreatorItem)>
static readonly "STRUCTURE_CREATOR_ITEM": $RegistrySupplier<($StructureCreatorItem)>
static readonly "CONFIGURATION_CARD_ITEM": $RegistrySupplier<($ConfigurationCardItem)>
static readonly "CUSTOM_MACHINE_TILE": $RegistrySupplier<($BlockEntityType<($CustomMachineTile)>)>
static readonly "CUSTOM_MACHINE_CONTAINER": $RegistrySupplier<($MenuType<($CustomMachineContainer)>)>
static readonly "CUSTOM_MACHINE_RECIPE_SERIALIZER": $RegistrySupplier<($CustomMachineRecipeSerializer)>
static readonly "CUSTOM_CRAFT_RECIPE_SERIALIZER": $RegistrySupplier<($CustomCraftRecipeSerializer)>
static readonly "CUSTOM_MACHINE_RECIPE": $RegistrySupplier<($RecipeType<($CustomMachineRecipe)>)>
static readonly "CUSTOM_CRAFT_RECIPE": $RegistrySupplier<($RecipeType<($CustomCraftRecipe)>)>
static readonly "CUSTOM_MACHINE_TAB": $RegistrySupplier<($CreativeModeTab)>
static readonly "BACKGROUND_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($BackgroundGuiElement)>)>
static readonly "BAR_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($BarGuiElement)>)>
static readonly "BUTTON_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($ButtonGuiElement)>)>
static readonly "CONFIG_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($ConfigGuiElement)>)>
static readonly "DUMP_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($DumpGuiElement)>)>
static readonly "EMPTY_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($EmptyGuiElement)>)>
static readonly "ENERGY_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($EnergyGuiElement)>)>
static readonly "EXPERIENCE_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($ExperienceGuiElement)>)>
static readonly "FLUID_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($FluidGuiElement)>)>
static readonly "FUEL_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($FuelGuiElement)>)>
static readonly "PLAYER_INVENTORY_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($PlayerInventoryGuiElement)>)>
static readonly "PROGRESS_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($ProgressBarGuiElement)>)>
static readonly "RESET_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($ResetGuiElement)>)>
static readonly "SLOT_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($SlotGuiElement)>)>
static readonly "STATUS_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($StatusGuiElement)>)>
static readonly "TEXTURE_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($TextureGuiElement)>)>
static readonly "TEXT_GUI_ELEMENT": $RegistrySupplier<($GuiElementType<($TextGuiElement)>)>
static readonly "BLOCK_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($BlockMachineComponent)>)>
static readonly "CHUNKLOAD_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($ChunkloadMachineComponent)>)>
static readonly "COMMAND_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($CommandMachineComponent)>)>
static readonly "DATA_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($DataMachineComponent)>)>
static readonly "DROP_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($DropMachineComponent)>)>
static readonly "EFFECT_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($EffectMachineComponent)>)>
static readonly "ENERGY_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($EnergyMachineComponent)>)>
static readonly "ENTITY_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($EntityMachineComponent)>)>
static readonly "EXPERIENCE_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($ExperienceMachineComponent)>)>
static readonly "FLUID_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($FluidMachineComponent)>)>
static readonly "FUEL_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($FuelMachineComponent)>)>
static readonly "FUNCTION_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($FunctionMachineComponent)>)>
static readonly "ITEM_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($ItemMachineComponent)>)>
static readonly "LIGHT_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($LightMachineComponent)>)>
static readonly "POSITION_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($PositionMachineComponent)>)>
static readonly "REDSTONE_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($RedstoneMachineComponent)>)>
static readonly "SKY_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($SkyMachineComponent)>)>
static readonly "STRUCTURE_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($StructureMachineComponent)>)>
static readonly "TIME_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($TimeMachineComponent)>)>
static readonly "WEATHER_MACHINE_COMPONENT": $RegistrySupplier<($MachineComponentType<($WeatherMachineComponent)>)>
static readonly "BIOME_REQUIREMENT": $RegistrySupplier<($RequirementType<($BiomeRequirement)>)>
static readonly "BLOCK_REQUIREMENT": $RegistrySupplier<($RequirementType<($BlockRequirement)>)>
static readonly "BUTTON_REQUIREMENT": $RegistrySupplier<($RequirementType<($ButtonRequirement)>)>
static readonly "CHUNKLOAD_REQUIREMENT": $RegistrySupplier<($RequirementType<($ChunkloadRequirement)>)>
static readonly "COMMAND_REQUIREMENT": $RegistrySupplier<($RequirementType<($CommandRequirement)>)>
static readonly "DIMENSION_REQUIREMENT": $RegistrySupplier<($RequirementType<($DimensionRequirement)>)>
static readonly "DROP_REQUIREMENT": $RegistrySupplier<($RequirementType<($DropRequirement)>)>
static readonly "DURABILITY_REQUIREMENT": $RegistrySupplier<($RequirementType<($DurabilityRequirement)>)>
static readonly "EFFECT_REQUIREMENT": $RegistrySupplier<($RequirementType<($EffectRequirement)>)>
static readonly "ENERGY_PER_TICK_REQUIREMENT": $RegistrySupplier<($RequirementType<($EnergyPerTickRequirement)>)>
static readonly "ENERGY_REQUIREMENT": $RegistrySupplier<($RequirementType<($EnergyRequirement)>)>
static readonly "ENTITY_REQUIREMENT": $RegistrySupplier<($RequirementType<($EntityRequirement)>)>
static readonly "EXPERIENCE_PER_TICK_REQUIREMENT": $RegistrySupplier<($RequirementType<($ExperiencePerTickRequirement)>)>
static readonly "EXPERIENCE_REQUIREMENT": $RegistrySupplier<($RequirementType<($ExperienceRequirement)>)>
static readonly "FLUID_PER_TICK_REQUIREMENT": $RegistrySupplier<($RequirementType<($FluidPerTickRequirement)>)>
static readonly "FLUID_REQUIREMENT": $RegistrySupplier<($RequirementType<($FluidRequirement)>)>
static readonly "FUEL_REQUIREMENT": $RegistrySupplier<($RequirementType<($FuelRequirement)>)>
static readonly "FUNCTION_REQUIREMENT": $RegistrySupplier<($RequirementType<($FunctionRequirement)>)>
static readonly "ITEM_FILTER_REQUIREMENT": $RegistrySupplier<($RequirementType<($ItemFilterRequirement)>)>
static readonly "ITEM_REQUIREMENT": $RegistrySupplier<($RequirementType<($ItemRequirement)>)>
static readonly "ITEM_TRANSFORM_REQUIREMENT": $RegistrySupplier<($RequirementType<($ItemTransformRequirement)>)>
static readonly "LIGHT_REQUIREMENT": $RegistrySupplier<($RequirementType<($LightRequirement)>)>
static readonly "LOOT_TABLE_REQUIREMENT": $RegistrySupplier<($RequirementType<($LootTableRequirement)>)>
static readonly "POSITION_REQUIREMENT": $RegistrySupplier<($RequirementType<($PositionRequirement)>)>
static readonly "REDSTONE_REQUIREMENT": $RegistrySupplier<($RequirementType<($RedstoneRequirement)>)>
static readonly "SKY_REQUIREMENT": $RegistrySupplier<($RequirementType<($SkyRequirement)>)>
static readonly "SPEED_REQUIREMENT": $RegistrySupplier<($RequirementType<($SpeedRequirement)>)>
static readonly "STRUCTURE_REQUIREMENT": $RegistrySupplier<($RequirementType<($StructureRequirement)>)>
static readonly "TIME_REQUIREMENT": $RegistrySupplier<($RequirementType<($TimeRequirement)>)>
static readonly "WEATHER_REQUIREMENT": $RegistrySupplier<($RequirementType<($WeatherRequirement)>)>
static readonly "AMBIENT_SOUND_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($SoundEvent)>)>
static readonly "BLOCK_MODEL_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($MachineModelLocation)>)>
static readonly "COLOR_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<(integer)>)>
static readonly "HARDNESS_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<(float)>)>
static readonly "INTERACTION_SOUND_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($CMSoundType)>)>
static readonly "ITEM_MODEL_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($MachineModelLocation)>)>
static readonly "LIGHT_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<(integer)>)>
static readonly "MINING_LEVEL_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($TagKey<($Block)>)>)>
static readonly "REQUIRES_TOOL": $RegistrySupplier<($MachineAppearanceProperty<(boolean)>)>
static readonly "RESISTANCE_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<(float)>)>
static readonly "SHAPE_COLLISION_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($MachineShape)>)>
static readonly "SHAPE_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($MachineShape)>)>
static readonly "TOOL_TYPE_PROPERTY": $RegistrySupplier<($MachineAppearanceProperty<($List<($TagKey<($Block)>)>)>)>
static readonly "BOOLEAN_DATA": $RegistrySupplier<($DataType<($BooleanData), (boolean)>)>
static readonly "INTEGER_DATA": $RegistrySupplier<($DataType<($IntegerData), (integer)>)>
static readonly "DOUBLE_DATA": $RegistrySupplier<($DataType<($DoubleData), (double)>)>
static readonly "FLOAT_DATA": $RegistrySupplier<($DataType<($FloatData), (float)>)>
static readonly "ITEMSTACK_DATA": $RegistrySupplier<($DataType<($ItemStackData), ($ItemStack)>)>
static readonly "FLUIDSTACK_DATA": $RegistrySupplier<($DataType<($FluidStackData), ($FluidStack)>)>
static readonly "STRING_DATA": $RegistrySupplier<($DataType<($StringData), (string)>)>
static readonly "LONG_DATA": $RegistrySupplier<($DataType<($LongData), (long)>)>
static readonly "SIDE_CONFIG_DATA": $RegistrySupplier<($DataType<($SideConfigData), ($SideConfig)>)>
static readonly "NBT_DATA": $RegistrySupplier<($DataType<($NbtData), ($CompoundTag)>)>
static readonly "DUMMY_PROCESSOR": $RegistrySupplier<($ProcessorType<($DummyProcessor)>)>
static readonly "MACHINE_PROCESSOR": $RegistrySupplier<($ProcessorType<($MachineProcessor)>)>
static readonly "CRAFT_PROCESSOR": $RegistrySupplier<($ProcessorType<($CraftProcessor)>)>

constructor()

public static "registerComponentVariants"(event: $RegisterComponentVariantEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Registration$Type = ($Registration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Registration_ = $Registration$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemFilterRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export interface $ItemFilterRequirementJS extends $RecipeJSBuilder {

 "requireItemFilter"(ingredient: $Ingredient$Type): $RecipeJSBuilder
 "requireItemFilter"(ingredient: $Ingredient$Type, slot: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ItemFilterRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFilterRequirementJS$Type = ($ItemFilterRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFilterRequirementJS_ = $ItemFilterRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$IntegerSlider" {
import {$AbstractSliderButton, $AbstractSliderButton$Type} from "packages/net/minecraft/client/gui/components/$AbstractSliderButton"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IntegerSlider$Builder, $IntegerSlider$Builder$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$IntegerSlider$Builder"

export class $IntegerSlider extends $AbstractSliderButton {
static readonly "SLIDER_LOCATION": $ResourceLocation
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer


public "intValue"(): integer
public static "builder"(): $IntegerSlider$Builder
public "setValue"(value: integer): void
set "value"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerSlider$Type = ($IntegerSlider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerSlider_ = $IntegerSlider$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent$Template" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ChunkloadMachineComponent, $ChunkloadMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent"

export class $ChunkloadMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($ChunkloadMachineComponent)> {
static readonly "CODEC": $NamedCodec<($ChunkloadMachineComponent$Template)>

constructor(radius: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getId"(): string
public "getType"(): $MachineComponentType<($ChunkloadMachineComponent)>
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
public "radius"(): integer
get "id"(): string
get "type"(): $MachineComponentType<($ChunkloadMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadMachineComponent$Template$Type = ($ChunkloadMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadMachineComponent$Template_ = $ChunkloadMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipeBuilder" {
import {$AbstractRecipeBuilder, $AbstractRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/impl/crafting/$AbstractRecipeBuilder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$CustomCraftRecipe, $CustomCraftRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/craft/$CustomCraftRecipe"

export class $CustomCraftRecipeBuilder extends $AbstractRecipeBuilder<($CustomCraftRecipe)> {
static readonly "CODEC": $NamedCodec<($CustomCraftRecipeBuilder)>

constructor(machine: $ResourceLocation$Type, output: $ItemStack$Type)
constructor(recipe: $CustomCraftRecipe$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCraftRecipeBuilder$Type = ($CustomCraftRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCraftRecipeBuilder_ = $CustomCraftRecipeBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$ItemTagIngredient" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $ItemTagIngredient implements $IIngredient<($Item)> {


public "toString"(): string
public "test"(item: $Item$Type): boolean
public static "create"(tag: $TagKey$Type<($Item$Type)>): $ItemTagIngredient
public static "create"(s: string): $ItemTagIngredient
public "getAll"(): $List<($Item)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public "negate"(): $Predicate<($Item)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($Item)>
public static "isEqual"<T>(arg0: any): $Predicate<($Item)>
get "all"(): $List<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTagIngredient$Type = ($ItemTagIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTagIngredient_ = $ItemTagIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ItemRequirement" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $ItemRequirement extends $AbstractChanceableRequirement<($ItemComponentHandler)> implements $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($ItemRequirement)>

constructor(mode: $RequirementIOMode$Type, item: $IIngredient$Type<($Item$Type)>, amount: integer, nbt: $CompoundTag$Type, slot: string)

public "test"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($ItemRequirement)>
public "processStart"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($ItemRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirement$Type = ($ItemRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRequirement_ = $ItemRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$LootTableIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $LootTableIngredientWrapper implements $IJEIIngredientWrapper<($ItemStack)> {

constructor(lootTable: $ResourceLocation$Type)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableIngredientWrapper$Type = ($LootTableIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableIngredientWrapper_ = $LootTableIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$FuelGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $FuelGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_EMPTY_TEXURE": $ResourceLocation
static readonly "BASE_FILLED_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($FuelGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, emptyTexture: $ResourceLocation$Type, filledTexture: $ResourceLocation$Type)

public "getType"(): $GuiElementType<($FuelGuiElement)>
public "getFilledTexture"(): $ResourceLocation
public "getEmptyTexture"(): $ResourceLocation
get "type"(): $GuiElementType<($FuelGuiElement)>
get "filledTexture"(): $ResourceLocation
get "emptyTexture"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelGuiElement$Type = ($FuelGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelGuiElement_ = $FuelGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$CommandRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $CommandRequirementJS extends $RecipeJSBuilder {

 "runCommandOnStart"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
 "runCommandOnStart"(command: string, log: boolean): $RecipeJSBuilder
 "runCommandOnStart"(command: string, permissionLevel: integer): $RecipeJSBuilder
 "runCommandOnStart"(command: string): $RecipeJSBuilder
 "runCommandEachTick"(command: string, log: boolean): $RecipeJSBuilder
 "runCommandEachTick"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
 "runCommandEachTick"(command: string, permissionLevel: integer): $RecipeJSBuilder
 "runCommandEachTick"(command: string): $RecipeJSBuilder
 "runCommandOnEnd"(command: string, log: boolean): $RecipeJSBuilder
 "runCommandOnEnd"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
 "runCommandOnEnd"(command: string, permissionLevel: integer): $RecipeJSBuilder
 "runCommandOnEnd"(command: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $CommandRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRequirementJS$Type = ($CommandRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandRequirementJS_ = $CommandRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ButtonRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $ButtonRequirementJS extends $RecipeJSBuilder {

 "requireButtonReleased"(id: string): $RecipeJSBuilder
 "requireButtonPressed"(id: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ButtonRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonRequirementJS$Type = ($ButtonRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonRequirementJS_ = $ButtonRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/variant/$RegisterComponentVariantEvent$Register" {
import {$RegisterComponentVariantEvent, $RegisterComponentVariantEvent$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$RegisterComponentVariantEvent"

export interface $RegisterComponentVariantEvent$Register {

 "registerComponentVariant"(arg0: $RegisterComponentVariantEvent$Type): void

(arg0: $RegisterComponentVariantEvent$Type): void
}

export namespace $RegisterComponentVariantEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterComponentVariantEvent$Register$Type = ($RegisterComponentVariantEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterComponentVariantEvent$Register_ = $RegisterComponentVariantEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$TexturedButton$Builder" {
import {$Tooltip, $Tooltip$Type} from "packages/net/minecraft/client/gui/components/$Tooltip"
import {$Button$CreateNarration, $Button$CreateNarration$Type} from "packages/net/minecraft/client/gui/components/$Button$CreateNarration"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TexturedButton, $TexturedButton$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$TexturedButton"

export class $TexturedButton$Builder {


public "size"(width: integer, height: integer): $TexturedButton$Builder
public "bounds"(x: integer, y: integer, width: integer, height: integer): $TexturedButton$Builder
public "pos"(x: integer, y: integer): $TexturedButton$Builder
public "build"(): $TexturedButton
public "width"(width: integer): $TexturedButton$Builder
public "createNarration"(createNarration: $Button$CreateNarration$Type): $TexturedButton$Builder
public "hovered"(textureHovered: $ResourceLocation$Type): $TexturedButton$Builder
public "tooltip"(tooltip: $Tooltip$Type): $TexturedButton$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TexturedButton$Builder$Type = ($TexturedButton$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TexturedButton$Builder_ = $TexturedButton$Builder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$PositionRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $PositionRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requirePosition"(xString: string, yString: string, zString: string): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $PositionRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionRequirementCT$Type<T> = ($PositionRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PositionRequirementCT_<T> = $PositionRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export interface $IGuiElementBuilder<T extends $IGuiElement> {

 "type"(): $GuiElementType<(T)>
 "make"(arg0: $AbstractGuiElement$Properties$Type, arg1: T): T
 "makeConfigPopup"(arg0: $MachineEditScreen$Type, arg1: $MutableProperties$Type, arg2: T, arg3: $Consumer$Type<(T)>): $PopupScreen
}

export namespace $IGuiElementBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiElementBuilder$Type<T> = ($IGuiElementBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiElementBuilder_<T> = $IGuiElementBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$EnhancedDispatchCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnhancedDispatchCodec<K, V> extends $NamedMapCodec<(V)> {


public "name"(): string
public "toString"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: $MapLike$Type<(T)>): $DataResult<(V)>
public "encode"<T>(input: V, ops: $DynamicOps$Type<(T)>, prefix: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public static "of"<K, V>(typeKey: string, keyCodec: $NamedCodec$Type<(K)>, type: $Function$Type<(any), (any)>, decoder: $Function$Type<(any), (any)>, name: string): $EnhancedDispatchCodec<(K), (V)>
public "keys"<T>(ops: $DynamicOps$Type<(T)>): $Stream<(T)>
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnhancedDispatchCodec$Type<K, V> = ($EnhancedDispatchCodec<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnhancedDispatchCodec_<K, V> = $EnhancedDispatchCodec$Type<(K), (V)>;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement" {
import {$TextGuiElement$Alignment, $TextGuiElement$Alignment$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement$Alignment"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$AbstractGuiElement, $AbstractGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement"

export class $TextGuiElement extends $AbstractGuiElement {
static readonly "CODEC": $NamedCodec<($TextGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, text: $Component$Type, alignment: $TextGuiElement$Alignment$Type, jei: boolean)

public "getType"(): $GuiElementType<($TextGuiElement)>
public "getText"(): $Component
public "showInJei"(): boolean
public "getAlignment"(): $TextGuiElement$Alignment
public "getWidth"(): integer
public "getHeight"(): integer
get "type"(): $GuiElementType<($TextGuiElement)>
get "text"(): $Component
get "alignment"(): $TextGuiElement$Alignment
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextGuiElement$Type = ($TextGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextGuiElement_ = $TextGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$EnergyRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $EnergyRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "produceEnergy"(amount: integer): T
 "requireEnergy"(amount: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $EnergyRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyRequirementCT$Type<T> = ($EnergyRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyRequirementCT_<T> = $EnergyRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ExperienceRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ExperienceRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "produceXp"(xp: integer): T
 "requireLevel"(levels: integer): T
 "requireXp"(xp: integer): T
 "produceLevel"(levels: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ExperienceRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceRequirementCT$Type<T> = ($ExperienceRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceRequirementCT_<T> = $ExperienceRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$ButtonGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ButtonGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "BASE_TEXTURE_HOVERED": $ResourceLocation
static readonly "BASE_TEXTURE_TOGGLE": $ResourceLocation
static readonly "BASE_TEXTURE_TOGGLE_HOVERED": $ResourceLocation
static readonly "CODEC": $NamedCodec<($ButtonGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, textureToggle: $ResourceLocation$Type, textureToggleHovered: $ResourceLocation$Type, toggle: boolean, text: $Component$Type, item: $ItemStack$Type, holdTime: integer)

public "getType"(): $GuiElementType<($ButtonGuiElement)>
public "getText"(): $Component
public "getItem"(): $ItemStack
public "getHoldTime"(): integer
public "isToggle"(): boolean
public "getTextureToggle"(): $ResourceLocation
public "getTextureToggleHovered"(): $ResourceLocation
get "type"(): $GuiElementType<($ButtonGuiElement)>
get "text"(): $Component
get "item"(): $ItemStack
get "holdTime"(): integer
get "toggle"(): boolean
get "textureToggle"(): $ResourceLocation
get "textureToggleHovered"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonGuiElement$Type = ($ButtonGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonGuiElement_ = $ButtonGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$MachineBlockState" {
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$LoadingCache, $LoadingCache$Type} from "packages/com/google/common/cache/$LoadingCache"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $MachineBlockState extends $BlockState {
static readonly "CACHE": $LoadingCache<($MachineAppearance), ($MachineBlockState)>
static readonly "CODEC": $Codec<($BlockState)>
readonly "mapColor": $MapColor
static readonly "NAME_TAG": string
static readonly "PROPERTIES_TAG": string
 "owner": O

constructor(appearance: $MachineAppearance$Type)

public "requiresCorrectToolForDrops"(): boolean
public "is"(tag: $TagKey$Type<($Block$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineBlockState$Type = ($MachineBlockState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineBlockState_ = $MachineBlockState$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterWidgetToJeiIngredientGetterEvent" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$WidgetToJeiIngredientRegistry$IngredientGetter, $WidgetToJeiIngredientRegistry$IngredientGetter$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$WidgetToJeiIngredientRegistry$IngredientGetter"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$RegisterWidgetToJeiIngredientGetterEvent$Register, $RegisterWidgetToJeiIngredientGetterEvent$Register$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterWidgetToJeiIngredientGetterEvent$Register"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterWidgetToJeiIngredientGetterEvent {
static readonly "EVENT": $Event<($RegisterWidgetToJeiIngredientGetterEvent$Register)>

constructor()

public "register"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>, getter: $WidgetToJeiIngredientRegistry$IngredientGetter$Type<(E)>): void
public "getIngredientGetters"(): $Map<($GuiElementType<(any)>), ($WidgetToJeiIngredientRegistry$IngredientGetter<(any)>)>
get "ingredientGetters"(): $Map<($GuiElementType<(any)>), ($WidgetToJeiIngredientRegistry$IngredientGetter<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterWidgetToJeiIngredientGetterEvent$Type = ($RegisterWidgetToJeiIngredientGetterEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterWidgetToJeiIngredientGetterEvent_ = $RegisterWidgetToJeiIngredientGetterEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$GuiTab" {
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"

export class $GuiTab extends $MachineEditTab {
readonly "parent": $MachineEditScreen

constructor(parent: $MachineEditScreen$Type)

public "closed"(): void
public "opened"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTab$Type = ($GuiTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTab_ = $GuiTab$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"

export interface $IJEIIngredientRequirement<T> {

 "getJEIIngredientWrappers"(arg0: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<(T)>)>

(arg0: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<(T)>)>
}

export namespace $IJEIIngredientRequirement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJEIIngredientRequirement$Type<T> = ($IJEIIngredientRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJEIIngredientRequirement_<T> = $IJEIIngredientRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$KJSFunction" {
import {$Context, $Context$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Context"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Result, $Result$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$Result"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $KJSFunction implements $Function<($ICraftingContext), ($CraftingResult)> {

constructor(arg0: $Function$Type<($Context$Type), ($Result$Type)>)

public "apply"(context: $ICraftingContext$Type): $CraftingResult
public static "identity"<T>(): $Function<($ICraftingContext), ($ICraftingContext)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($CraftingResult)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($ICraftingContext), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSFunction$Type = ($KJSFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KJSFunction_ = $KJSFunction$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineCreationScreen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $MachineCreationScreen extends $BaseScreen {
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor()

public "delete"(): void
public "open"(): void
public "create"(): void
public "renderBackground"(graphics: $GuiGraphics$Type): void
public "edit"(): void
public "reloadList"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineCreationScreen$Type = ($MachineCreationScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineCreationScreen_ = $MachineCreationScreen$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$EffectMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EffectMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($EffectMachineComponent)>
public "applyEffect"(effect: $MobEffectInstance$Type, radius: integer, filter: $Predicate$Type<($Entity$Type)>): void
get "type"(): $MachineComponentType<($EffectMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectMachineComponent$Type = ($EffectMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectMachineComponent_ = $EffectMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$ComparatorMode" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ComparatorMode extends $Enum<($ComparatorMode)> {
static readonly "GREATER": $ComparatorMode
static readonly "GREATER_OR_EQUALS": $ComparatorMode
static readonly "EQUALS": $ComparatorMode
static readonly "LESSER_OR_EQUALS": $ComparatorMode
static readonly "LESSER": $ComparatorMode
static readonly "CODEC": $NamedCodec<($ComparatorMode)>


public static "value"(value: string): $ComparatorMode
public static "values"(): ($ComparatorMode)[]
public "compare"<T>(first: T, second: T, comparator: $Comparator$Type<(T)>): boolean
public "compare"<T extends $Comparable<(T)>>(first: T, second: T): boolean
public static "valueOf"(name: string): $ComparatorMode
public "getPrefix"(): string
public "getTranslationKey"(): string
get "prefix"(): string
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorMode$Type = (("lesser_or_equals") | ("lesser") | ("equals") | ("greater_or_equals") | ("greater")) | ($ComparatorMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComparatorMode_ = $ComparatorMode$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$IntegerSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntegerData, $IntegerData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$IntegerData"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $IntegerSyncable extends $AbstractSyncable<($IntegerData), (integer)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(integer)>, consumer: $Consumer$Type<(integer)>): $IntegerSyncable
public "getData"(id: short): $IntegerData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerSyncable$Type = ($IntegerSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerSyncable_ = $IntegerSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$CreateMachinePopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $CreateMachinePopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering


public "create"(): void
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreateMachinePopup$Type = ($CreateMachinePopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreateMachinePopup_ = $CreateMachinePopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$ExperienceUtils" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $ExperienceUtils {

constructor()

public static "getLevelFromXp"(experience: long): integer
public static "getPlayerTotalXp"(player: $Player$Type): integer
public static "getXpFromLevel"(level: integer): integer
public static "getXpNeededForNextLevel"(currentLevel: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceUtils$Type = ($ExperienceUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceUtils_ = $ExperienceUtils$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$PlayerInventoryGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$PlayerInventoryGuiElement, $PlayerInventoryGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$PlayerInventoryGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $PlayerInventoryGuiElementBuilder implements $IGuiElementBuilder<($PlayerInventoryGuiElement)> {

constructor()

public "type"(): $GuiElementType<($PlayerInventoryGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $PlayerInventoryGuiElement$Type): $PlayerInventoryGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $PlayerInventoryGuiElement$Type, onFinish: $Consumer$Type<($PlayerInventoryGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInventoryGuiElementBuilder$Type = ($PlayerInventoryGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInventoryGuiElementBuilder_ = $PlayerInventoryGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$WeatherRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $WeatherRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireWeatherOnMachine"(weatherType: string): T
 "requireWeather"(weatherType: string): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $WeatherRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatherRequirementCT$Type<T> = ($WeatherRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeatherRequirementCT_<T> = $WeatherRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $StructureRequirement$Action extends $Enum<($StructureRequirement$Action)> {
static readonly "CHECK": $StructureRequirement$Action
static readonly "DESTROY": $StructureRequirement$Action
static readonly "BREAK": $StructureRequirement$Action
static readonly "PLACE_BREAK": $StructureRequirement$Action
static readonly "PLACE_DESTROY": $StructureRequirement$Action


public static "values"(): ($StructureRequirement$Action)[]
public static "valueOf"(name: string): $StructureRequirement$Action
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureRequirement$Action$Type = (("place_destroy") | ("break") | ("destroy") | ("check") | ("place_break")) | ($StructureRequirement$Action);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureRequirement$Action_ = $StructureRequirement$Action$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractGuiElement, $AbstractGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement"

export class $AbstractTexturedGuiElement extends $AbstractGuiElement {

constructor(properties: $AbstractGuiElement$Properties$Type)
constructor(properties: $AbstractGuiElement$Properties$Type, defaultTexture: $ResourceLocation$Type)

public "getTexture"(): $ResourceLocation
public "getWidth"(): integer
public "getHeight"(): integer
public "getTextureHovered"(): $ResourceLocation
get "texture"(): $ResourceLocation
get "width"(): integer
get "height"(): integer
get "textureHovered"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractTexturedGuiElement$Type = ($AbstractTexturedGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractTexturedGuiElement_ = $AbstractTexturedGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$RegisterComponentBuilderEvent" {
import {$RegisterComponentBuilderEvent$Register, $RegisterComponentBuilderEvent$Register$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$RegisterComponentBuilderEvent$Register"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterComponentBuilderEvent {
static readonly "EVENT": $Event<($RegisterComponentBuilderEvent$Register)>
 "builders": $Map<($MachineComponentType<(any)>), ($IMachineComponentBuilder<(any), (any)>)>

constructor()

public "register"<C extends $IMachineComponent, T extends $IMachineComponentTemplate<(C)>>(type: $MachineComponentType$Type<(C)>, builder: $IMachineComponentBuilder$Type<(C), (T)>): void
public "getBuilders"(): $Map<($MachineComponentType<(any)>), ($IMachineComponentBuilder<(any), (any)>)>
get "builders"(): $Map<($MachineComponentType<(any)>), ($IMachineComponentBuilder<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterComponentBuilderEvent$Type = ($RegisterComponentBuilderEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterComponentBuilderEvent_ = $RegisterComponentBuilderEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$MachineProcessor$PHASE" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $MachineProcessor$PHASE extends $Enum<($MachineProcessor$PHASE)> {
static readonly "STARTING": $MachineProcessor$PHASE
static readonly "CRAFTING_TICKABLE": $MachineProcessor$PHASE
static readonly "CRAFTING_DELAYED": $MachineProcessor$PHASE
static readonly "ENDING": $MachineProcessor$PHASE
static readonly "CODEC": $NamedCodec<($MachineProcessor$PHASE)>


public static "value"(string: string): $MachineProcessor$PHASE
public static "values"(): ($MachineProcessor$PHASE)[]
public static "valueOf"(name: string): $MachineProcessor$PHASE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineProcessor$PHASE$Type = (("ending") | ("crafting_delayed") | ("crafting_tickable") | ("starting")) | ($MachineProcessor$PHASE);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineProcessor$PHASE_ = $MachineProcessor$PHASE$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$RegisterGuiElementBuilderEvent$Register" {
import {$RegisterGuiElementBuilderEvent, $RegisterGuiElementBuilderEvent$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$RegisterGuiElementBuilderEvent"

export interface $RegisterGuiElementBuilderEvent$Register {

 "registerGuiElementBuilders"(arg0: $RegisterGuiElementBuilderEvent$Type): void

(arg0: $RegisterGuiElementBuilderEvent$Type): void
}

export namespace $RegisterGuiElementBuilderEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementBuilderEvent$Register$Type = ($RegisterGuiElementBuilderEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementBuilderEvent$Register_ = $RegisterGuiElementBuilderEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$CommandRequirement" {
import {$MachineProcessor$PHASE, $MachineProcessor$PHASE$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$MachineProcessor$PHASE"
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$CommandMachineComponent, $CommandMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$CommandMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $CommandRequirement extends $AbstractDelayedChanceableRequirement<($CommandMachineComponent)> implements $ITickableRequirement<($CommandMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($CommandRequirement)>

constructor(command: string, phase: $MachineProcessor$PHASE$Type, permissionLevel: integer, log: boolean)

public "test"(component: $CommandMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($CommandMachineComponent)>
public "execute"(component: $CommandMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<($CommandRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $CommandMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $CommandMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $CommandMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($CommandMachineComponent)>
get "type"(): $RequirementType<($CommandRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRequirement$Type = ($CommandRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandRequirement_ = $CommandRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineTabManager" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$TabManager, $TabManager$Type} from "packages/net/minecraft/client/gui/components/tabs/$TabManager"
import {$Tab, $Tab$Type} from "packages/net/minecraft/client/gui/components/tabs/$Tab"

export class $MachineTabManager extends $TabManager {

constructor(addWidget: $Consumer$Type<($AbstractWidget$Type)>, removeWidget: $Consumer$Type<($AbstractWidget$Type)>)

public "setCurrentTab"(tab: $Tab$Type, playClickSound: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineTabManager$Type = ($MachineTabManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineTabManager_ = $MachineTabManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$FuelMachineComponent" {
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"

export class $FuelMachineComponent extends $AbstractMachineComponent implements $ISerializableComponent, $ITickableComponent, $ISyncableStuff {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($FuelMachineComponent)>
public "deserialize"(nbt: $CompoundTag$Type): void
public "getMaxFuel"(): integer
public "burn"(amount: integer): boolean
public "canStartRecipe"(amount: integer): boolean
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "getFuel"(): integer
public "addFuel"(fuel: integer): void
public "serialize"(nbt: $CompoundTag$Type): void
public "serverTick"(): void
public "clientTick"(): void
get "type"(): $MachineComponentType<($FuelMachineComponent)>
get "maxFuel"(): integer
get "fuel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelMachineComponent$Type = ($FuelMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelMachineComponent_ = $FuelMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ExperiencePerTickRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $ExperiencePerTickRequirementJS extends $RecipeJSBuilder {

 "requireLevelPerTick"(levels: integer): $RecipeJSBuilder
 "produceLevelPerTick"(levels: integer): $RecipeJSBuilder
 "requireXpPerTick"(xp: integer): $RecipeJSBuilder
 "produceXpPerTick"(xp: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ExperiencePerTickRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperiencePerTickRequirementJS$Type = ($ExperiencePerTickRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperiencePerTickRequirementJS_ = $ExperiencePerTickRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$FluidIngredientGetter" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$WidgetToJeiIngredientRegistry$IngredientGetter, $WidgetToJeiIngredientRegistry$IngredientGetter$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$WidgetToJeiIngredientRegistry$IngredientGetter"
import {$IClickableIngredient, $IClickableIngredient$Type} from "packages/mezz/jei/api/runtime/$IClickableIngredient"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$FluidGuiElement, $FluidGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement"

export class $FluidIngredientGetter implements $WidgetToJeiIngredientRegistry$IngredientGetter<($FluidGuiElement)> {

constructor()

public "getIngredient"<T>(widget: $AbstractGuiElementWidget$Type<($FluidGuiElement$Type)>, mouseX: double, mouseY: double, helpers: $IJeiHelpers$Type): $IClickableIngredient<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientGetter$Type = ($FluidIngredientGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredientGetter_ = $FluidIngredientGetter$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$DefaultOptionalFieldCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DefaultOptionalFieldCodec<A> extends $NamedMapCodec<(A)> {


public "name"(): string
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: $MapLike$Type<(T)>): $DataResult<(A)>
public "encode"<T>(input: A, ops: $DynamicOps$Type<(T)>, prefix: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(fieldName: string, elementCodec: $NamedCodec$Type<(A)>, defaultValue: $Supplier$Type<(A)>, name: string): $NamedMapCodec<(A)>
public "keys"<T>(ops: $DynamicOps$Type<(T)>): $Stream<(T)>
public "aliases"(...aliases: (string)[]): $DefaultOptionalFieldCodec<(A)>
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultOptionalFieldCodec$Type<A> = ($DefaultOptionalFieldCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultOptionalFieldCodec_<A> = $DefaultOptionalFieldCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CGuiElementClickPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CGuiElementClickPacket extends $BaseC2SMessage {

constructor(element: integer, type: byte)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CGuiElementClickPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CGuiElementClickPacket$Type = ($CGuiElementClickPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CGuiElementClickPacket_ = $CGuiElementClickPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DropRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $DropRequirementJS extends $RecipeJSBuilder {

 "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
 "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
 "consumeAnyDropOnStart"(amount: integer, radius: integer): $RecipeJSBuilder
 "consumeAnyDropOnEnd"(amount: integer, radius: integer): $RecipeJSBuilder
 "consumeDropOnEnd"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
 "dropItemOnStart"(stack: $ItemStack$Type): $RecipeJSBuilder
 "checkAnyDrop"(amount: integer, radius: integer): $RecipeJSBuilder
 "checkDrop"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
 "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
 "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
 "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
 "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
 "consumeDropOnStart"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
 "dropItemOnEnd"(stack: $ItemStack$Type): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $DropRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropRequirementJS$Type = ($DropRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropRequirementJS_ = $DropRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$ItemSlot" {
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"

export class $ItemSlot implements $IItemHandler {

constructor(component: $ItemMachineComponent$Type, side: $Direction$Type)

public "getComponent"(): $ItemMachineComponent
public "getSlots"(): integer
public "getStackInSlot"(index: integer): $ItemStack
public "insertItem"(index: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "getSlotLimit"(index: integer): integer
public "extractItem"(index: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(index: integer, stack: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(i: integer): integer
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "component"(): $ItemMachineComponent
get "slots"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSlot$Type = ($ItemSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSlot_ = $ItemSlot$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$ButtonGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ButtonGuiElement, $ButtonGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ButtonGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $ButtonGuiElementBuilder implements $IGuiElementBuilder<($ButtonGuiElement)> {

constructor()

public "type"(): $GuiElementType<($ButtonGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $ButtonGuiElement$Type): $ButtonGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $ButtonGuiElement$Type, onFinish: $Consumer$Type<($ButtonGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonGuiElementBuilder$Type = ($ButtonGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonGuiElementBuilder_ = $ButtonGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$DurabilityRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $DurabilityRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $DurabilityRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DurabilityRequirementCT$Type<T> = ($DurabilityRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DurabilityRequirementCT_<T> = $DurabilityRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EntityRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $EntityRequirementJS extends $RecipeJSBuilder {

 "requireEntitiesHealth"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "consumeEntityHealthOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "consumeEntityHealthOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "killEntitiesOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "requireEntities"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "killEntitiesOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $EntityRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRequirementJS$Type = ($EntityRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRequirementJS_ = $EntityRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$BlockRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $BlockRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): T
 "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): T
 "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): T
 "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): T
 "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string): T
 "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $BlockRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRequirementCT$Type<T> = ($BlockRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRequirementCT_<T> = $BlockRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$FunctionRequirementCT" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"
import {$Context, $Context$Type} from "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$Context"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"

export interface $FunctionRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireFunctionOnStart"(arg0: $Function$Type<($Context$Type), ($CraftingResult$Type)>): T
 "requireFunctionEachTick"(arg0: $Function$Type<($Context$Type), ($CraftingResult$Type)>): T
 "requireFunctionOnEnd"(arg0: $Function$Type<($Context$Type), ($CraftingResult$Type)>): T
 "requireFunctionToStart"(arg0: $Function$Type<($Context$Type), ($CraftingResult$Type)>): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $FunctionRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionRequirementCT$Type<T> = ($FunctionRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionRequirementCT_<T> = $FunctionRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LootTableRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $LootTableRequirementJS extends $RecipeJSBuilder {

 "lootTableOutput"(lootTable: string): $RecipeJSBuilder
 "lootTableOutput"(lootTable: string, luck: float): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $LootTableRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableRequirementJS$Type = ($LootTableRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableRequirementJS_ = $LootTableRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$RegisterGuiElementWidgetSupplierEvent$Register" {
import {$RegisterGuiElementWidgetSupplierEvent, $RegisterGuiElementWidgetSupplierEvent$Type} from "packages/fr/frinn/custommachinery/api/guielement/$RegisterGuiElementWidgetSupplierEvent"

export interface $RegisterGuiElementWidgetSupplierEvent$Register {

 "registerWidgetSuppliers"(arg0: $RegisterGuiElementWidgetSupplierEvent$Type): void

(arg0: $RegisterGuiElementWidgetSupplierEvent$Type): void
}

export namespace $RegisterGuiElementWidgetSupplierEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementWidgetSupplierEvent$Register$Type = ($RegisterGuiElementWidgetSupplierEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementWidgetSupplierEvent$Register_ = $RegisterGuiElementWidgetSupplierEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/$DisplayInfoTemplateCT" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IDisplayInfo$TooltipPredicate, $IDisplayInfo$TooltipPredicate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$TooltipPredicate"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DisplayInfoTemplateCT extends $DisplayInfoTemplate {
static readonly "TOOLTIPS": $NamedCodec<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
static readonly "CODEC": $NamedCodec<($DisplayInfoTemplate)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayInfoTemplateCT$Type = ($DisplayInfoTemplateCT);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisplayInfoTemplateCT_ = $DisplayInfoTemplateCT$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/popup/$InfoPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $InfoPopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, xSize: integer, ySize: integer)

public "text"(...text: ($Component$Type)[]): $InfoPopup
public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfoPopup$Type = ($InfoPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfoPopup_ = $InfoPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$FunctionRequirement$Phase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FunctionRequirement$Phase extends $Enum<($FunctionRequirement$Phase)> {
static readonly "CHECK": $FunctionRequirement$Phase
static readonly "START": $FunctionRequirement$Phase
static readonly "TICK": $FunctionRequirement$Phase
static readonly "END": $FunctionRequirement$Phase
static readonly "DELAY": $FunctionRequirement$Phase


public static "values"(): ($FunctionRequirement$Phase)[]
public static "valueOf"(name: string): $FunctionRequirement$Phase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionRequirement$Phase$Type = (("delay") | ("start") | ("end") | ("check") | ("tick")) | ($FunctionRequirement$Phase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionRequirement$Phase_ = $FunctionRequirement$Phase$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$StatusGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$StatusGuiElement, $StatusGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$StatusGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $StatusGuiElementBuilder implements $IGuiElementBuilder<($StatusGuiElement)> {

constructor()

public "type"(): $GuiElementType<($StatusGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $StatusGuiElement$Type): $StatusGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $StatusGuiElement$Type, onFinish: $Consumer$Type<($StatusGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatusGuiElementBuilder$Type = ($StatusGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatusGuiElementBuilder_ = $StatusGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$SkyRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$SkyMachineComponent, $SkyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$SkyMachineComponent"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $SkyRequirement extends $AbstractRequirement<($SkyMachineComponent)> implements $ITickableRequirement<($SkyMachineComponent)> {
static readonly "CODEC": $NamedCodec<($SkyRequirement)>

constructor()

public "test"(component: $SkyMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($SkyMachineComponent)>
public "getType"(): $RequirementType<($SkyRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $SkyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $SkyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $SkyMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($SkyMachineComponent)>
get "type"(): $RequirementType<($SkyRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkyRequirement$Type = ($SkyRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SkyRequirement_ = $SkyRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineRecipeBuilderJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$EnergyRequirementJS, $EnergyRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EnergyRequirementJS"
import {$RecipeFunction, $RecipeFunction$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$RecipeFunction"
import {$BiomeRequirementJS, $BiomeRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BiomeRequirementJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$PositionRequirementJS, $PositionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$PositionRequirementJS"
import {$ItemTransformRequirementJS, $ItemTransformRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemTransformRequirementJS"
import {$ExperienceRequirementJS, $ExperienceRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ExperienceRequirementJS"
import {$CustomMachineRecipeBuilder, $CustomMachineRecipeBuilder$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipeBuilder"
import {$EntityRequirementJS, $EntityRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EntityRequirementJS"
import {$BlockRequirementJS, $BlockRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BlockRequirementJS"
import {$WeatherRequirementJS, $WeatherRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$WeatherRequirementJS"
import {$EffectRequirementJS, $EffectRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EffectRequirementJS"
import {$ExperiencePerTickRequirementJS, $ExperiencePerTickRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ExperiencePerTickRequirementJS"
import {$LightRequirementJS, $LightRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LightRequirementJS"
import {$EnergyPerTickRequirementJS, $EnergyPerTickRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$EnergyPerTickRequirementJS"
import {$ChunkloadRequirementJS, $ChunkloadRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ChunkloadRequirementJS"
import {$DimensionRequirementJS, $DimensionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DimensionRequirementJS"
import {$FuelRequirementJS, $FuelRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FuelRequirementJS"
import {$CommandRequirementJS, $CommandRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$CommandRequirementJS"
import {$ItemRequirementJS, $ItemRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemRequirementJS"
import {$StructureRequirement$Action, $StructureRequirement$Action$Type} from "packages/fr/frinn/custommachinery/common/requirement/$StructureRequirement$Action"
import {$TimeRequirementJS, $TimeRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$TimeRequirementJS"
import {$BlockRequirement$ACTION, $BlockRequirement$ACTION$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement$ACTION"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ButtonRequirementJS, $ButtonRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ButtonRequirementJS"
import {$ItemFilterRequirementJS, $ItemFilterRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ItemFilterRequirementJS"
import {$FunctionRequirementJS, $FunctionRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FunctionRequirementJS"
import {$FluidPerTickRequirementJS, $FluidPerTickRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FluidPerTickRequirementJS"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$DropRequirementJS, $DropRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DropRequirementJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$DurabilityRequirementJS, $DurabilityRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$DurabilityRequirementJS"
import {$SkyRequirementJS, $SkyRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$SkyRequirementJS"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$FluidRequirementJS, $FluidRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FluidRequirementJS"
import {$StructureRequirementJS, $StructureRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$StructureRequirementJS"
import {$AbstractRecipeJSBuilder, $AbstractRecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/$AbstractRecipeJSBuilder"
import {$MachineAppearanceBuilderJS, $MachineAppearanceBuilderJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/$MachineAppearanceBuilderJS"
import {$RedstoneRequirementJS, $RedstoneRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$RedstoneRequirementJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$LootTableRequirementJS, $LootTableRequirementJS$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$LootTableRequirementJS"

export class $CustomMachineRecipeBuilderJS extends $AbstractRecipeJSBuilder<($CustomMachineRecipeBuilder)> implements $ItemRequirementJS, $ItemTransformRequirementJS, $DurabilityRequirementJS, $FluidRequirementJS, $FluidPerTickRequirementJS, $EnergyRequirementJS, $EnergyPerTickRequirementJS, $TimeRequirementJS, $PositionRequirementJS, $BiomeRequirementJS, $DimensionRequirementJS, $FuelRequirementJS, $CommandRequirementJS, $EffectRequirementJS, $WeatherRequirementJS, $RedstoneRequirementJS, $LightRequirementJS, $EntityRequirementJS, $BlockRequirementJS, $StructureRequirementJS, $LootTableRequirementJS, $DropRequirementJS, $FunctionRequirementJS, $ButtonRequirementJS, $SkyRequirementJS, $ItemFilterRequirementJS, $ExperienceRequirementJS, $ExperiencePerTickRequirementJS, $ChunkloadRequirementJS {
static readonly "IDS": $Map<($ResourceLocation), ($Map<($ResourceLocation), (integer)>)>
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "gui"(...elements: ($JsonObject$Type)[]): $CustomMachineRecipeBuilderJS
public "resetOnError"(): $CustomMachineRecipeBuilderJS
public "appearance"(consumer: $Consumer$Type<($MachineAppearanceBuilderJS$Type)>): $CustomMachineRecipeBuilderJS
public "produceItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
public "produceItem"(stack: $ItemStack$Type): $RecipeJSBuilder
public "requireItem"(stack: $ItemStack$Type): $RecipeJSBuilder
public "requireItem"(stack: $ItemStack$Type, slot: string): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "requireItemTag"(tag: string): $RecipeJSBuilder
public "requireItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type, output: $ItemStack$Type): $RecipeJSBuilder
public "transformItem"(input: $ItemStack$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type, output: $ItemStack$Type, inputSlot: string, outputSlot: string, nbt: $Function$Type<($Map$Type<(any), (any)>), (any)>): $RecipeJSBuilder
public "transformItemTag"(tag: string, inputAmount: integer, inputNBT: $CompoundTag$Type): $RecipeJSBuilder
public "transformItemTag"(tag: string): $RecipeJSBuilder
public "repairItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "repairItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "damageItemTagNoBreak"(tag: string, amount: integer): $RecipeJSBuilder
public "damageItem"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "damageItem"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "repairItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer): $RecipeJSBuilder
public "damageItemNoBreak"(stack: $ItemStack$Type, amount: integer, slot: string): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, slot: string): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "damageItemTag"(tag: string, amount: integer): $RecipeJSBuilder
public "produceFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "produceFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer): $RecipeJSBuilder
public "requireFluidTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, tank: string): $RecipeJSBuilder
public "produceFluidPerTick"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "produceFluidPerTick"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluidPerTick"(stack: $FluidStackJS$Type): $RecipeJSBuilder
public "requireFluidPerTick"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
public "requireFluidTagPerTick"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
public "requireFluidTagPerTick"(tag: string, amount: integer): $RecipeJSBuilder
public "requireFluidTagPerTick"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, tank: string): $RecipeJSBuilder
public "produceEnergy"(amount: integer): $RecipeJSBuilder
public "requireEnergy"(amount: integer): $RecipeJSBuilder
public "requireEnergyPerTick"(amount: integer): $RecipeJSBuilder
public "produceEnergyPerTick"(amount: integer): $RecipeJSBuilder
public "requireTime"(time: string): $RecipeJSBuilder
public "requirePosition"(xString: string, yString: string, zString: string): $RecipeJSBuilder
public "biomeBlacklist"(biomes: (string)[]): $RecipeJSBuilder
public "biomeWhitelist"(biomes: (string)[]): $RecipeJSBuilder
public "dimensionWhitelist"(dimensions: (string)[]): $RecipeJSBuilder
public "dimensionBlacklist"(dimensions: (string)[]): $RecipeJSBuilder
public "requireFuel"(): $RecipeJSBuilder
public "requireFuel"(amount: integer): $RecipeJSBuilder
public "runCommandOnStart"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandOnStart"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandOnStart"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandOnStart"(command: string): $RecipeJSBuilder
public "runCommandEachTick"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandEachTick"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandEachTick"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandEachTick"(command: string): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, log: boolean): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, permissionLevel: integer, log: boolean): $RecipeJSBuilder
public "runCommandOnEnd"(command: string, permissionLevel: integer): $RecipeJSBuilder
public "runCommandOnEnd"(command: string): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer, levelOrFilter: any): $RecipeJSBuilder
public "giveEffectEachTick"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, filter: (string)[]): $RecipeJSBuilder
public "giveEffectOnEnd"(effect: string, time: integer, radius: integer, level: integer): $RecipeJSBuilder
public "requireWeatherOnMachine"(weather: string): $RecipeJSBuilder
public "requireWeather"(weather: string): $RecipeJSBuilder
public "requireRedstone"(power: string): $RecipeJSBuilder
public "requireBlockLight"(level: string): $RecipeJSBuilder
public "requireSkyLight"(level: string): $RecipeJSBuilder
public "requireEntitiesHealth"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "consumeEntityHealthOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "consumeEntityHealthOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "killEntitiesOnStart"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "requireEntities"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "killEntitiesOnEnd"(amount: integer, radius: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
public "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "blockRequirement"(mode: $RequirementIOMode$Type, action: $BlockRequirement$ACTION$Type, block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string, stringFilter: (string)[], whitelist: boolean): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string): $RecipeJSBuilder
public "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
public "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
public "placeStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, drops: boolean): $RecipeJSBuilder
public "destroyStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "requireStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>, action: $StructureRequirement$Action$Type): $RecipeJSBuilder
public "breakStructure"(pattern: ((string)[])[], keys: $Map$Type<(string), (string)>): $RecipeJSBuilder
public "lootTableOutput"(lootTable: string): $RecipeJSBuilder
public "lootTableOutput"(lootTable: string, luck: float): $RecipeJSBuilder
public "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnStart"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "consumeAnyDropOnStart"(amount: integer, radius: integer): $RecipeJSBuilder
public "consumeAnyDropOnEnd"(amount: integer, radius: integer): $RecipeJSBuilder
public "consumeDropOnEnd"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "dropItemOnStart"(stack: $ItemStack$Type): $RecipeJSBuilder
public "checkAnyDrop"(amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrop"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "checkDrops"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer, whitelist: boolean): $RecipeJSBuilder
public "consumeDropsOnEnd"(items: ($ItemStack$Type)[], amount: integer, radius: integer): $RecipeJSBuilder
public "consumeDropOnStart"(item: $ItemStack$Type, amount: integer, radius: integer): $RecipeJSBuilder
public "dropItemOnEnd"(stack: $ItemStack$Type): $RecipeJSBuilder
public "requireFunctionOnStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionEachTick"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionOnEnd"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireFunctionToStart"(arg0: $RecipeFunction$Type): $RecipeJSBuilder
public "requireButtonReleased"(id: string): $RecipeJSBuilder
public "requireButtonPressed"(id: string): $RecipeJSBuilder
public "mustSeeSky"(): $RecipeJSBuilder
public "requireItemFilter"(ingredient: $Ingredient$Type): $RecipeJSBuilder
public "requireItemFilter"(ingredient: $Ingredient$Type, slot: string): $RecipeJSBuilder
public "produceXp"(xp: integer): $RecipeJSBuilder
public "requireLevel"(levels: integer): $RecipeJSBuilder
public "requireXp"(xp: integer): $RecipeJSBuilder
public "produceLevel"(levels: integer): $RecipeJSBuilder
public "requireLevelPerTick"(levels: integer): $RecipeJSBuilder
public "produceLevelPerTick"(levels: integer): $RecipeJSBuilder
public "requireXpPerTick"(xp: integer): $RecipeJSBuilder
public "produceXpPerTick"(xp: integer): $RecipeJSBuilder
public "chunkload"(): $RecipeJSBuilder
public "chunkload"(radius: integer): $RecipeJSBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRecipeBuilderJS$Type = ($CustomMachineRecipeBuilderJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRecipeBuilderJS_ = $CustomMachineRecipeBuilderJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig" {
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$TriConsumer, $TriConsumer$Type} from "packages/org/apache/logging/log4j/util/$TriConsumer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SideConfig {

constructor(component: $ISideConfigComponent$Type, defaultConfig: $Map$Type<($RelativeSide$Type), ($SideMode$Type)>, autoInput: boolean, autoOutput: boolean, enabled: boolean)

public "set"(config: $SideConfig$Type): void
public "copy"(): $SideConfig
public "isEnabled"(): boolean
public "deserialize"(tag: $Tag$Type): void
public "getComponent"(): $ISideConfigComponent
public "setSideMode"(side: $RelativeSide$Type, mode: $SideMode$Type): void
public "setAutoInput"(autoInput: boolean): void
public "setAutoOutput"(autoOutput: boolean): void
public "getSideMode"(direction: $Direction$Type): $SideMode
public "getSideMode"(side: $RelativeSide$Type): $SideMode
public "isAutoInput"(): boolean
public "isAutoOutput"(): boolean
public "serialize"(): $Tag
public "setCallback"(callback: $TriConsumer$Type<($RelativeSide$Type), ($SideMode$Type), ($SideMode$Type)>): void
get "enabled"(): boolean
get "component"(): $ISideConfigComponent
set "autoInput"(value: boolean)
set "autoOutput"(value: boolean)
get "autoInput"(): boolean
get "autoOutput"(): boolean
set "callback"(value: $TriConsumer$Type<($RelativeSide$Type), ($SideMode$Type), ($SideMode$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideConfig$Type = ($SideConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideConfig_ = $SideConfig$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $RecipeJSBuilder {

 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $RecipeJSBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeJSBuilder$Type = ($RecipeJSBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeJSBuilder_ = $RecipeJSBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/transfer/$SidedFluidStorage" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"

export class $SidedFluidStorage implements $IFluidHandler {

constructor(direction: $Direction$Type, handler: $FluidComponentHandler$Type)

public "fill"(forgeStack: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): integer
public "drain"(maxDrain: $FluidStack$Type, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "drain"(maxDrain: integer, action: $IFluidHandler$FluidAction$Type): $FluidStack
public "getTanks"(): integer
public "isFluidValid"(tank: integer, stack: $FluidStack$Type): boolean
public "getFluidInTank"(tank: integer): $FluidStack
public "getTankCapacity"(tank: integer): integer
public "getSideComponents"(filter: $Predicate$Type<($SideMode$Type)>): $List<($FluidMachineComponent)>
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedFluidStorage$Type = ($SidedFluidStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedFluidStorage_ = $SidedFluidStorage$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $IRecipeModifier$OPERATION extends $Enum<($IRecipeModifier$OPERATION)> {
static readonly "ADDITION": $IRecipeModifier$OPERATION
static readonly "MULTIPLICATION": $IRecipeModifier$OPERATION
static readonly "EXPONENTIAL": $IRecipeModifier$OPERATION
static readonly "CODEC": $NamedCodec<($IRecipeModifier$OPERATION)>


public static "value"(value: string): $IRecipeModifier$OPERATION
public static "values"(): ($IRecipeModifier$OPERATION)[]
public static "valueOf"(name: string): $IRecipeModifier$OPERATION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeModifier$OPERATION$Type = (("exponential") | ("multiplication") | ("addition")) | ($IRecipeModifier$OPERATION);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeModifier$OPERATION_ = $IRecipeModifier$OPERATION$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$SlotGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IComponentGuiElement, $IComponentGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$GhostItem, $GhostItem$Type} from "packages/fr/frinn/custommachinery/common/util/$GhostItem"
import {$ItemMachineComponent, $ItemMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ItemMachineComponent"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $SlotGuiElement extends $AbstractTexturedGuiElement implements $IComponentGuiElement<($ItemMachineComponent)> {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($SlotGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, ghost: $GhostItem$Type)

public "getComponentType"(): $MachineComponentType<($ItemMachineComponent)>
public "getType"(): $GuiElementType<($SlotGuiElement)>
public "getComponentId"(): string
public "getGhost"(): $GhostItem
public "getComponent"(manager: $IMachineComponentManager$Type): $Optional<($ItemMachineComponent)>
get "componentType"(): $MachineComponentType<($ItemMachineComponent)>
get "type"(): $GuiElementType<($SlotGuiElement)>
get "componentId"(): string
get "ghost"(): $GhostItem
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotGuiElement$Type = ($SlotGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotGuiElement_ = $SlotGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$MachineAppearanceBuilderJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MachineAppearanceBuilderJS {

constructor()

public "miningLevel"(key: $ResourceLocation$Type): $MachineAppearanceBuilderJS
public "block"(block: $ResourceLocation$Type): $MachineAppearanceBuilderJS
public "color"(color: integer): $MachineAppearanceBuilderJS
public "build"(): $MachineAppearance
public "item"(item: $ResourceLocation$Type): $MachineAppearanceBuilderJS
public "requiresTool"(requires: boolean): $MachineAppearanceBuilderJS
public "light"(light: integer): $MachineAppearanceBuilderJS
public "hardness"(hardness: float): $MachineAppearanceBuilderJS
public "ambientSound"(sound: $SoundEvent$Type): $MachineAppearanceBuilderJS
public "interactionSound"(sound: $Block$Type): $MachineAppearanceBuilderJS
public "toolType"(tools: ($ResourceLocation$Type)[]): $MachineAppearanceBuilderJS
public "resistance"(resistance: float): $MachineAppearanceBuilderJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearanceBuilderJS$Type = ($MachineAppearanceBuilderJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearanceBuilderJS_ = $MachineAppearanceBuilderJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$MapCodec, $MapCodec$Type} from "packages/com/mojang/serialization/$MapCodec"
import {$MapEncoder, $MapEncoder$Type} from "packages/com/mojang/serialization/$MapEncoder"
import {$MapCodec$ResultFunction, $MapCodec$ResultFunction$Type} from "packages/com/mojang/serialization/$MapCodec$ResultFunction"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Encoder, $Encoder$Type} from "packages/com/mojang/serialization/$Encoder"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeyCompressor, $KeyCompressor$Type} from "packages/com/mojang/serialization/$KeyCompressor"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$MapLike, $MapLike$Type} from "packages/com/mojang/serialization/$MapLike"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Decoder, $Decoder$Type} from "packages/com/mojang/serialization/$Decoder"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MapDecoder, $MapDecoder$Type} from "packages/com/mojang/serialization/$MapDecoder"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$RecordBuilder, $RecordBuilder$Type} from "packages/com/mojang/serialization/$RecordBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$CompressorHolder, $CompressorHolder$Type} from "packages/com/mojang/serialization/$CompressorHolder"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$NamedRecordCodec, $NamedRecordCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NamedMapCodec<A> extends $CompressorHolder implements $MapDecoder<(A)>, $MapEncoder<(A)>, $NamedCodec<(A)> {

constructor()

public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<(A), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: A, prefix: T): $DataResult<(T)>
public static "of"<A>(decoder: $MapDecoder$Type<(A)>, encoder: $MapEncoder$Type<(A)>, name: string): $NamedMapCodec<(A)>
public "orElse"(onError: $UnaryOperator$Type<(string)>, value: A): $NamedMapCodec<(A)>
public "orElse"(onError: $Consumer$Type<(string)>, value: A): $NamedMapCodec<(A)>
public "orElse"(value: A): $NamedMapCodec<(A)>
public "aliases"(...aliases: (string)[]): $NamedMapCodec<(A)>
public "orElseGet"(onError: $Consumer$Type<(string)>, value: $Supplier$Type<(any)>): $NamedMapCodec<(A)>
public "orElseGet"(onError: $UnaryOperator$Type<(string)>, value: $Supplier$Type<(any)>): $NamedMapCodec<(A)>
public "orElseGet"(value: $Supplier$Type<(any)>): $NamedMapCodec<(A)>
public "mapResult"(arg0: $MapCodec$ResultFunction$Type<(A)>): $NamedMapCodec<(A)>
public "mapCodec"(): $MapCodec<(A)>
public "forGetter"<O>(getter: $Function$Type<(O), (A)>): $NamedRecordCodec<(O), (A)>
public "decode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $MapLike$Type<(T)>): $DataResult<(A)>
public "map"<B>(arg0: $Function$Type<(any), (any)>): $MapDecoder<(B)>
public "flatMap"<B>(arg0: $Function$Type<(any), (any)>): $MapDecoder<(B)>
public "decoder"(): $Decoder<(A)>
public "ap"<E>(arg0: $MapDecoder$Type<($Function$Type<(any), (any)>)>): $MapDecoder<(E)>
public "compressedDecode"<T>(arg0: $DynamicOps$Type<(T)>, arg1: T): $DataResult<(A)>
public "compressor"<T>(arg0: $DynamicOps$Type<(T)>): $KeyCompressor<(T)>
public "encode"<T>(arg0: A, arg1: $DynamicOps$Type<(T)>, arg2: $RecordBuilder$Type<(T)>): $RecordBuilder<(T)>
public "encoder"(): $Encoder<(A)>
public "flatComap"<B>(arg0: $Function$Type<(any), (any)>): $MapEncoder<(B)>
public "comap"<B>(arg0: $Function$Type<(any), (any)>): $MapEncoder<(B)>
public "compressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>): $RecordBuilder<(T)>
public static "makeCompressedBuilder"<T>(arg0: $DynamicOps$Type<(T)>, arg1: $KeyCompressor$Type<(T)>): $RecordBuilder<(T)>
public "name"(): string
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<(A)>): $NamedCodec<(A)>
public static "of"<A>(codec: $Codec$Type<(A)>, name: string): $NamedCodec<(A)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>, name: string): $NamedCodec<($List<(A)>)>
public static "list"<A>(codec: $NamedCodec$Type<(A)>): $NamedCodec<($List<(A)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<(A)>
public "copy"(input: A): A
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<(A)>, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A, name: string): $NamedCodec<(A)>
public static "unit"<A>(defaultValue: A): $NamedCodec<(A)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<(A)>)>, name: string): $NamedCodec<(A)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): A
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<(A)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<(A)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: A): $NamedMapCodec<(A)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<(A)>): $NamedMapCodec<(A)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: A): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: A, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<(A)>)>
public "listOf"(name: string): $NamedCodec<($List<(A)>)>
public static "registrar"<A>(registrar: $Registrar$Type<(A)>): $NamedCodec<(A)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<(A)>
public static "forStrings"(arg0: $Supplier$Type<($Stream$Type<(string)>)>): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedMapCodec$Type<A> = ($NamedMapCodec<(A)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedMapCodec_<A> = $NamedMapCodec$Type<(A)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$DoubleSlider$Builder" {
import {$DoubleSlider, $DoubleSlider$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$DoubleSlider"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export class $DoubleSlider$Builder {

constructor()

public "bounds"(min: double, max: double): $DoubleSlider$Builder
public "defaultValue"(defaultValue: double): $DoubleSlider$Builder
public "create"(x: integer, y: integer, width: integer, height: integer, message: $Component$Type): $DoubleSlider
public "setResponder"(responder: $Consumer$Type<(double)>): $DoubleSlider$Builder
public "displayOnlyValue"(): $DoubleSlider$Builder
set "responder"(value: $Consumer$Type<(double)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSlider$Builder$Type = ($DoubleSlider$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSlider$Builder_ = $DoubleSlider$Builder$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/integration/jade/$CustomMachineServerDataProvider" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockAccessor, $BlockAccessor$Type} from "packages/snownee/jade/api/$BlockAccessor"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IServerDataProvider, $IServerDataProvider$Type} from "packages/snownee/jade/api/$IServerDataProvider"

export class $CustomMachineServerDataProvider implements $IServerDataProvider<($BlockAccessor)> {
static readonly "INSTANCE": $CustomMachineServerDataProvider
static readonly "ID": $ResourceLocation

constructor()

public "getUid"(): $ResourceLocation
public "appendServerData"(nbt: $CompoundTag$Type, accessor: $BlockAccessor$Type): void
public "getDefaultPriority"(): integer
get "uid"(): $ResourceLocation
get "defaultPriority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineServerDataProvider$Type = ($CustomMachineServerDataProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineServerDataProvider_ = $CustomMachineServerDataProvider$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$ExperienceComponentBuilder" {
import {$ExperienceMachineComponent$Template, $ExperienceMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent$Template"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$ExperienceMachineComponent, $ExperienceMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ExperienceMachineComponent"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ExperienceComponentBuilder implements $IMachineComponentBuilder<($ExperienceMachineComponent), ($ExperienceMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($ExperienceMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $ExperienceMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $ExperienceMachineComponent$Template$Type, onFinish: $Consumer$Type<($ExperienceMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceComponentBuilder$Type = ($ExperienceComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceComponentBuilder_ = $ExperienceComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/integration/jade/$CustomMachineComponentProvider" {
import {$IPluginConfig, $IPluginConfig$Type} from "packages/snownee/jade/api/config/$IPluginConfig"
import {$BlockAccessor, $BlockAccessor$Type} from "packages/snownee/jade/api/$BlockAccessor"
import {$IBlockComponentProvider, $IBlockComponentProvider$Type} from "packages/snownee/jade/api/$IBlockComponentProvider"
import {$IElement, $IElement$Type} from "packages/snownee/jade/api/ui/$IElement"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ITooltip, $ITooltip$Type} from "packages/snownee/jade/api/$ITooltip"

export class $CustomMachineComponentProvider implements $IBlockComponentProvider {
static readonly "INSTANCE": $CustomMachineComponentProvider
static readonly "ID": $ResourceLocation

constructor()

public "getUid"(): $ResourceLocation
public "appendTooltip"(tooltip: $ITooltip$Type, accessor: $BlockAccessor$Type, config: $IPluginConfig$Type): void
public "getIcon"(arg0: $BlockAccessor$Type, arg1: $IPluginConfig$Type, arg2: $IElement$Type): $IElement
public "isRequired"(): boolean
public "enabledByDefault"(): boolean
public "getDefaultPriority"(): integer
get "uid"(): $ResourceLocation
get "required"(): boolean
get "defaultPriority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineComponentProvider$Type = ($CustomMachineComponentProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineComponentProvider_ = $CustomMachineComponentProvider$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineComponentListWidget" {
import {$CustomMachineBuilder, $CustomMachineBuilder$Type} from "packages/fr/frinn/custommachinery/common/machine/builder/$CustomMachineBuilder"
import {$ListWidget, $ListWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ComponentTab, $ComponentTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$ComponentTab"
import {$MachineComponentListWidget$MachineComponentEntry, $MachineComponentListWidget$MachineComponentEntry$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineComponentListWidget$MachineComponentEntry"

export class $MachineComponentListWidget extends $ListWidget<($MachineComponentListWidget$MachineComponentEntry)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, itemHeight: integer, tab: $ComponentTab$Type)

public "setup"(builder: $CustomMachineBuilder$Type): void
public "setSelected"(selected: $MachineComponentListWidget$MachineComponentEntry$Type): void
public "setFocused"(arg0: boolean): void
public "isFocused"(): boolean
set "up"(value: $CustomMachineBuilder$Type)
set "selected"(value: $MachineComponentListWidget$MachineComponentEntry$Type)
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineComponentListWidget$Type = ($MachineComponentListWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineComponentListWidget_ = $MachineComponentListWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/builder/$NumberAppearancePropertyBuilder" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IAppearancePropertyBuilder, $IAppearancePropertyBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder"

export class $NumberAppearancePropertyBuilder<T extends number> implements $IAppearancePropertyBuilder<(T)> {

constructor(title: $Component$Type, type: $MachineAppearanceProperty$Type<(T)>, min: T, max: T)

public "getType"(): $MachineAppearanceProperty<(T)>
public "makeWidget"(parent: $BaseScreen$Type, x: integer, y: integer, width: integer, height: integer, supplier: $Supplier$Type<(T)>, consumer: $Consumer$Type<(T)>): $AbstractWidget
public "title"(): $Component
get "type"(): $MachineAppearanceProperty<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberAppearancePropertyBuilder$Type<T> = ($NumberAppearancePropertyBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberAppearancePropertyBuilder_<T> = $NumberAppearancePropertyBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineUpgradeJSBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder, $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder$Type} from "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineUpgrade, $MachineUpgrade$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$MachineUpgrade"

export class $CustomMachineUpgradeJSBuilder {

constructor(item: $Item$Type, maxAmount: integer)

public "build"(): $MachineUpgrade
public "modifier"(builder: $CustomMachineUpgradeJSBuilder$JSRecipeModifierBuilder$Type): $CustomMachineUpgradeJSBuilder
public "tooltip"(...components: ($Component$Type)[]): $CustomMachineUpgradeJSBuilder
public "machine"(...string: (string)[]): $CustomMachineUpgradeJSBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineUpgradeJSBuilder$Type = ($CustomMachineUpgradeJSBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineUpgradeJSBuilder_ = $CustomMachineUpgradeJSBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export interface $IIngredient<O> extends $Predicate<(O)> {

 "getAll"(): $List<(O)>
 "test"(arg0: O): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(O)>
 "negate"(): $Predicate<(O)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(O)>
}

export namespace $IIngredient {
const ITEM: $NamedCodec<($IIngredient<($Item)>)>
const FLUID: $NamedCodec<($IIngredient<($Fluid)>)>
const BLOCK: $NamedCodec<($IIngredient<($PartialBlockState)>)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(O)>
function isEqual<T>(arg0: any): $Predicate<(O)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IIngredient$Type<O> = ($IIngredient<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IIngredient_<O> = $IIngredient$Type<(O)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$ChunkloadRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $ChunkloadRequirementJS extends $RecipeJSBuilder {

 "chunkload"(): $RecipeJSBuilder
 "chunkload"(radius: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $ChunkloadRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadRequirementJS$Type = ($ChunkloadRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadRequirementJS_ = $ChunkloadRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/network/$ISyncable" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"

export interface $ISyncable<D extends $IData<(any)>, T> {

 "get"(): T
 "set"(arg0: T): void
 "getData"(arg0: short): D
 "needSync"(): boolean
}

export namespace $ISyncable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncable$Type<D, T> = ($ISyncable<(D), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncable_<D, T> = $ISyncable$Type<(D), (T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $IComponentHandler<T extends $IMachineComponent> extends $IMachineComponent {

 "getComponentForID"(arg0: string): $Optional<(T)>
 "getComponents"(): $List<(T)>
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $IComponentHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComponentHandler$Type<T> = ($IComponentHandler<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComponentHandler_<T> = $IComponentHandler$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BiomeRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"

export interface $BiomeRequirementJS extends $RecipeJSBuilder {

 "biomeBlacklist"(biomes: (string)[]): $RecipeJSBuilder
 "biomeWhitelist"(biomes: (string)[]): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $BiomeRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeRequirementJS$Type = ($BiomeRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeRequirementJS_ = $BiomeRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$EnergyGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IComponentGuiElement, $IComponentGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $EnergyGuiElement extends $AbstractTexturedGuiElement implements $IComponentGuiElement<($EnergyMachineComponent)> {
static readonly "BASE_ENERGY_STORAGE_EMPTY_TEXTURE": $ResourceLocation
static readonly "BASE_ENERGY_STORAGE_FILLED_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($EnergyGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, emptyTexture: $ResourceLocation$Type, filledTexture: $ResourceLocation$Type, highlight: boolean)

public "getComponentType"(): $MachineComponentType<($EnergyMachineComponent)>
public "getType"(): $GuiElementType<($EnergyGuiElement)>
public "highlight"(): boolean
public "getFilledTexture"(): $ResourceLocation
public "getEmptyTexture"(): $ResourceLocation
public "getComponentId"(): string
public "getComponent"(manager: $IMachineComponentManager$Type): $Optional<($EnergyMachineComponent)>
get "componentType"(): $MachineComponentType<($EnergyMachineComponent)>
get "type"(): $GuiElementType<($EnergyGuiElement)>
get "filledTexture"(): $ResourceLocation
get "emptyTexture"(): $ResourceLocation
get "componentId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyGuiElement$Type = ($EnergyGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyGuiElement_ = $EnergyGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$FuelGuiElementJeiRenderer" {
import {$FuelGuiElement, $FuelGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$FuelGuiElement"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $FuelGuiElementJeiRenderer implements $IJEIElementRenderer<($FuelGuiElement)> {

constructor()

public "getJEITooltips"(element: $FuelGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $FuelGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "isHoveredInJei"(element: $FuelGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelGuiElementJeiRenderer$Type = ($FuelGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelGuiElementJeiRenderer_ = $FuelGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$PlayerInventoryGuiElementWidget" {
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PlayerInventoryGuiElement, $PlayerInventoryGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$PlayerInventoryGuiElement"

export class $PlayerInventoryGuiElementWidget extends $TexturedGuiElementWidget<($PlayerInventoryGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $PlayerInventoryGuiElement$Type, screen: $IMachineScreen$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerInventoryGuiElementWidget$Type = ($PlayerInventoryGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerInventoryGuiElementWidget_ = $PlayerInventoryGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $ISerializableComponent extends $IMachineComponent {

 "deserialize"(arg0: $CompoundTag$Type): void
 "serialize"(arg0: $CompoundTag$Type): void
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $ISerializableComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISerializableComponent$Type = ($ISerializableComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISerializableComponent_ = $ISerializableComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ButtonRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ButtonRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireButtonReleased"(id: string): T
 "requireButtonPressed"(id: string): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ButtonRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonRequirementCT$Type<T> = ($ButtonRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonRequirementCT_<T> = $ButtonRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/network/$IData" {
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export interface $IData<T> {

 "getValue"(): T
 "getType"(): $DataType<(any), (T)>
 "getID"(): short
 "writeData"(buffer: $FriendlyByteBuf$Type): void
}

export namespace $IData {
function readData(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IData$Type<T> = ($IData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IData_<T> = $IData$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$MachineProcessor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $MachineProcessor implements $IProcessor, $ISyncableStuff {

constructor(tile: $MachineTile$Type, amount: integer, recipeCheckCooldown: integer)

public "getType"(): $ProcessorType<($MachineProcessor)>
public "reset"(): void
public "tick"(): void
public "deserialize"(nbt: $CompoundTag$Type): void
public "setErrored"(message: $Component$Type): void
public "getRecipeTotalTime"(): integer
public "getCurrentContext"(): $ICraftingContext
public "getCurrentRecipe"(): $CustomMachineRecipe
public "getTile"(): $MachineTile
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(): $CompoundTag
public "getRecipeProgressTime"(): double
public "setMachineInventoryChanged"(): void
public "setRunning"(): void
get "type"(): $ProcessorType<($MachineProcessor)>
set "errored"(value: $Component$Type)
get "recipeTotalTime"(): integer
get "currentContext"(): $ICraftingContext
get "currentRecipe"(): $CustomMachineRecipe
get "tile"(): $MachineTile
get "recipeProgressTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineProcessor$Type = ($MachineProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineProcessor_ = $MachineProcessor$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$FuelRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $FuelRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireFuel"(amount: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $FuelRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelRequirementCT$Type<T> = ($FuelRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelRequirementCT_<T> = $FuelRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $CustomMachineRecipeSerializer implements $RecipeSerializer<($CustomMachineRecipe)> {

constructor()

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): $CustomMachineRecipe
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): $CustomMachineRecipe
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: $CustomMachineRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $CustomMachineRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRecipeSerializer$Type = ($CustomMachineRecipeSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRecipeSerializer_ = $CustomMachineRecipeSerializer$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$IRequirement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export interface $IRequirement<T extends $IMachineComponent> {

 "test"(arg0: T, arg1: $ICraftingContext$Type): boolean
 "getComponentType"(): $MachineComponentType<(T)>
 "getType"(): $RequirementType<(any)>
 "getDisplayInfo"(info: $IDisplayInfo$Type): void
 "getMode"(): $RequirementIOMode
 "processStart"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "processEnd"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "getDisplayInfoTemplate"(): $DisplayInfoTemplate
 "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
}

export namespace $IRequirement {
const CODEC: $NamedCodec<($IRequirement<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRequirement$Type<T> = ($IRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRequirement_<T> = $IRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty" {
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $MachineAppearanceProperty<T> {
static readonly "REGISTRY_KEY": $ResourceKey<($Registry<($MachineAppearanceProperty<(any)>)>)>


public "getId"(): $ResourceLocation
public "getDefaultValue"(): T
public static "create"<T>(codec: $NamedCodec$Type<(T)>, defaultValue: T): $MachineAppearanceProperty<(T)>
public "getCodec"(): $NamedCodec<(T)>
get "id"(): $ResourceLocation
get "defaultValue"(): T
get "codec"(): $NamedCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearanceProperty$Type<T> = ($MachineAppearanceProperty<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearanceProperty_<T> = $MachineAppearanceProperty$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$FilterItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $FilterItemComponentVariant extends $ItemComponentVariant {
static readonly "INSTANCE": $FilterItemComponentVariant
static readonly "CODEC": $NamedCodec<($FilterItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "canOutput"(manager: $IMachineComponentManager$Type): boolean
public "shouldDrop"(manager: $IMachineComponentManager$Type): boolean
public "getCodec"(): $NamedCodec<($FilterItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterItemComponentVariant$Type = ($FilterItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterItemComponentVariant_ = $FilterItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IDumpComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $IDumpComponent extends $IMachineComponent {

 "dump"(arg0: $List$Type<(string)>): void
 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $IDumpComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDumpComponent$Type = ($IDumpComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDumpComponent_ = $IDumpComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$CommandMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $CommandMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($CommandMachineComponent)>
public "sendCommand"(command: string, permissionLevel: integer, log: boolean): void
get "type"(): $MachineComponentType<($CommandMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandMachineComponent$Type = ($CommandMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandMachineComponent_ = $CommandMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CRemoveMachinePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CRemoveMachinePacket extends $BaseC2SMessage {

constructor(id: $ResourceLocation$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CRemoveMachinePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CRemoveMachinePacket$Type = ($CRemoveMachinePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CRemoveMachinePacket_ = $CRemoveMachinePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ChunkloadRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ChunkloadMachineComponent, $ChunkloadMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $ChunkloadRequirement extends $AbstractRequirement<($ChunkloadMachineComponent)> implements $ITickableRequirement<($ChunkloadMachineComponent)> {
static readonly "CODEC": $NamedCodec<($ChunkloadRequirement)>

constructor(radius: integer)

public "test"(component: $ChunkloadMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($ChunkloadMachineComponent)>
public "getType"(): $RequirementType<($ChunkloadRequirement)>
public "processTick"(component: $ChunkloadMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $ChunkloadMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ChunkloadMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($ChunkloadMachineComponent)>
get "type"(): $RequirementType<($ChunkloadRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadRequirement$Type = ($ChunkloadRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadRequirement_ = $ChunkloadRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonFluidHandler" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"

export interface $ICommonFluidHandler {

 "tick"(): void
 "invalidate"(): void
 "configChanged"(arg0: $RelativeSide$Type, arg1: $SideMode$Type, arg2: $SideMode$Type): void
 "interactWithFluidHandler"(arg0: $Player$Type, arg1: $InteractionHand$Type): boolean
}

export namespace $ICommonFluidHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICommonFluidHandler$Type = ($ICommonFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICommonFluidHandler_ = $ICommonFluidHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/config/$AutoIOModeButtonWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export class $AutoIOModeButtonWidget extends $AbstractWidget {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, config: $SideConfig$Type, input: boolean)

public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutoIOModeButtonWidget$Type = ($AutoIOModeButtonWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutoIOModeButtonWidget_ = $AutoIOModeButtonWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateMachineAppearancePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateMachineAppearancePacket extends $BaseS2CMessage {

constructor(pos: $BlockPos$Type, appearance: $MachineAppearance$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateMachineAppearancePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateMachineAppearancePacket$Type = ($SUpdateMachineAppearancePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateMachineAppearancePacket_ = $SUpdateMachineAppearancePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/transfer/$ICommonEnergyHandler" {
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$SideMode, $SideMode$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideMode"

export interface $ICommonEnergyHandler {

 "tick"(): void
 "invalidate"(): void
 "configChanged"(arg0: $RelativeSide$Type, arg1: $SideMode$Type, arg2: $SideMode$Type): void
}

export namespace $ICommonEnergyHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICommonEnergyHandler$Type = ($ICommonEnergyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICommonEnergyHandler_ = $ICommonEnergyHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$DoubleSlider" {
import {$AbstractSliderButton, $AbstractSliderButton$Type} from "packages/net/minecraft/client/gui/components/$AbstractSliderButton"
import {$DoubleSlider$Builder, $DoubleSlider$Builder$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$DoubleSlider$Builder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DoubleSlider extends $AbstractSliderButton {
static readonly "SLIDER_LOCATION": $ResourceLocation
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer


public "doubleValue"(): double
public static "builder"(): $DoubleSlider$Builder
public "setValue"(value: double): void
set "value"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSlider$Type = ($DoubleSlider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSlider_ = $DoubleSlider$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineListWidget$MachineEntry" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$ListWidget$Entry, $ListWidget$Entry$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget$Entry"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $MachineListWidget$MachineEntry extends $ListWidget$Entry {

constructor(machine: $CustomMachine$Type)

public "render"(graphics: $GuiGraphics$Type, index: integer, x: integer, y: integer, width: integer, height: integer, mouseX: integer, mouseY: integer, partialTick: float): void
public "children"(): $List<(any)>
public "getMachine"(): $CustomMachine
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
get "machine"(): $CustomMachine
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineListWidget$MachineEntry$Type = ($MachineListWidget$MachineEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineListWidget$MachineEntry_ = $MachineListWidget$MachineEntry$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$ChunkloadMachineComponent" {
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"

export class $ChunkloadMachineComponent extends $AbstractMachineComponent implements $ISerializableComponent, $ITickableComponent {

constructor(manager: $IMachineComponentManager$Type, active: boolean, radius: integer)
constructor(manager: $IMachineComponentManager$Type)

public "init"(): void
public "getType"(): $MachineComponentType<($ChunkloadMachineComponent)>
public "isActive"(): boolean
public "deserialize"(nbt: $CompoundTag$Type): void
public "getRadius"(): integer
public "setActive"(level: $ServerLevel$Type, radius: integer): void
public "setInactive"(level: $ServerLevel$Type): void
public "setActiveWithTempo"(level: $ServerLevel$Type, radius: integer, tempo: integer): void
public "onRemoved"(): void
public "serialize"(nbt: $CompoundTag$Type): void
public "serverTick"(): void
public "clientTick"(): void
get "type"(): $MachineComponentType<($ChunkloadMachineComponent)>
get "active"(): boolean
get "radius"(): integer
set "inactive"(value: $ServerLevel$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkloadMachineComponent$Type = ($ChunkloadMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkloadMachineComponent_ = $ChunkloadMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/modifier/$AdditionRecipeModifier" {
import {$IRecipeModifier$OPERATION, $IRecipeModifier$OPERATION$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $AdditionRecipeModifier extends $RecipeModifier {
static readonly "CODEC": $NamedCodec<($RecipeModifier)>
static readonly "RAND": $Random
readonly "requirementType": $RequirementType<(any)>
readonly "target": string
readonly "mode": $RequirementIOMode
readonly "modifier": double
readonly "chance": double
readonly "max": double
readonly "min": double
readonly "tooltip": $Component

constructor(requirementType: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, modifier: double, target: string, chance: double, max: double, min: double, tooltip: $Component$Type)

public "apply"(original: double, upgradeAmount: integer): double
public "getDefaultTooltip"(): $Component
public "getOperation"(): $IRecipeModifier$OPERATION
get "defaultTooltip"(): $Component
get "operation"(): $IRecipeModifier$OPERATION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdditionRecipeModifier$Type = ($AdditionRecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdditionRecipeModifier_ = $AdditionRecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IMachineComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export interface $IMachineComponent {

 "init"(): void
 "getType"(): $MachineComponentType<(any)>
 "getMode"(): $ComponentIOMode
 "getManager"(): $IMachineComponentManager
 "onRemoved"(): void
 "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
}

export namespace $IMachineComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineComponent$Type = ($IMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineComponent_ = $IMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/init/$ForgeCustomMachineTile" {
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $ForgeCustomMachineTile extends $CustomMachineTile {
static readonly "DUMMY": $ResourceLocation
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "refreshClientData"(): void
public "getCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "onChunkUnloaded"(): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getModelData"(): $ModelData
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeCustomMachineTile$Type = ($ForgeCustomMachineTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeCustomMachineTile_ = $ForgeCustomMachineTile$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$ExperienceGuiElementWidget" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TexturedGuiElementWidget, $TexturedGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$TexturedGuiElementWidget"
import {$ExperienceGuiElement, $ExperienceGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $ExperienceGuiElementWidget extends $TexturedGuiElementWidget<($ExperienceGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $ExperienceGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "getTooltips"(): $List<($Component)>
get "tooltips"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElementWidget$Type = ($ExperienceGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElementWidget_ = $ExperienceGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$PacketManager" {
import {$SimpleNetworkManager, $SimpleNetworkManager$Type} from "packages/dev/architectury/networking/simple/$SimpleNetworkManager"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $PacketManager {
static readonly "MANAGER": $SimpleNetworkManager
static readonly "UPDATE_MACHINES": $MessageType
static readonly "UPDATE_UPGRADES": $MessageType
static readonly "UPDATE_CONTAINER": $MessageType
static readonly "UPDATE_MACHINE_STATUS": $MessageType
static readonly "REFRESH_MACHINE_TILE": $MessageType
static readonly "LOOT_TABLES": $MessageType
static readonly "OPEN_FILE": $MessageType
static readonly "UPDATE_MACHINE_APPEARANCE": $MessageType
static readonly "UPDATE_MACHINE_GUI_ELEMENTS": $MessageType
static readonly "OPEN_CREATION_SCREEN": $MessageType
static readonly "OPEN_EDIT_SCREEN": $MessageType
static readonly "ADD_MACHINE": $MessageType
static readonly "REMOVE_MACHINE": $MessageType
static readonly "EDIT_MACHINE": $MessageType
static readonly "ELEMENT_CLICKED": $MessageType
static readonly "CHANGE_SIDE_MODE": $MessageType
static readonly "UPDATE_MACHINE_DATA": $MessageType
static readonly "PLACE_STRUCTURE": $MessageType
static readonly "SET_FILTER_SLOT_ITEM": $MessageType

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PacketManager$Type = ($PacketManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PacketManager_ = $PacketManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/variant/item/$FuelItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$ItemComponentVariant, $ItemComponentVariant$Type} from "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $FuelItemComponentVariant extends $ItemComponentVariant {
static readonly "INSTANCE": $FuelItemComponentVariant
static readonly "CODEC": $NamedCodec<($FuelItemComponentVariant)>
static readonly "ID": $ResourceLocation

constructor()

public "getId"(): $ResourceLocation
public "canAccept"(manager: $IMachineComponentManager$Type, stack: $ItemStack$Type): boolean
public "getCodec"(): $NamedCodec<($FuelItemComponentVariant)>
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelItemComponentVariant$Type = ($FuelItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelItemComponentVariant_ = $FuelItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$ClientHandler" {
import {$ModelEvent$RegisterAdditional, $ModelEvent$RegisterAdditional$Type} from "packages/net/minecraftforge/client/event/$ModelEvent$RegisterAdditional"
import {$ModelEvent$RegisterGeometryLoaders, $ModelEvent$RegisterGeometryLoaders$Type} from "packages/net/minecraftforge/client/event/$ModelEvent$RegisterGeometryLoaders"

export class $ClientHandler {

constructor()

public static "setupConfig"(): void
public static "registerAdditionalModels"(event: $ModelEvent$RegisterAdditional$Type): void
public static "registerModelLoader"(event: $ModelEvent$RegisterGeometryLoaders$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientHandler$Type = ($ClientHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientHandler_ = $ClientHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$RegisterGuiElementWidgetSupplierEvent" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$IGuiElementWidgetSupplier, $IGuiElementWidgetSupplier$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElementWidgetSupplier"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$RegisterGuiElementWidgetSupplierEvent$Register, $RegisterGuiElementWidgetSupplierEvent$Register$Type} from "packages/fr/frinn/custommachinery/api/guielement/$RegisterGuiElementWidgetSupplierEvent$Register"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterGuiElementWidgetSupplierEvent {
static readonly "EVENT": $Event<($RegisterGuiElementWidgetSupplierEvent$Register)>

constructor()

public "register"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>, widgetSupplier: $IGuiElementWidgetSupplier$Type<(E)>): void
public "getWidgetSuppliers"(): $Map<($GuiElementType<(any)>), ($IGuiElementWidgetSupplier<(any)>)>
get "widgetSuppliers"(): $Map<($GuiElementType<(any)>), ($IGuiElementWidgetSupplier<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterGuiElementWidgetSupplierEvent$Type = ($RegisterGuiElementWidgetSupplierEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterGuiElementWidgetSupplierEvent_ = $RegisterGuiElementWidgetSupplierEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$MachineAppearanceManager" {
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MachineAppearanceManager {
static readonly "CODEC": $NamedCodec<($MachineAppearanceManager)>
static readonly "DEFAULT": $MachineAppearanceManager

constructor(defaultProperties: $Map$Type<($MachineAppearanceProperty$Type<(any)>), (any)>, idle: $MachineAppearance$Type, running: $MachineAppearance$Type, errored: $MachineAppearance$Type, paused: $MachineAppearance$Type)

public "getAppearance"(status: $MachineStatus$Type): $MachineAppearance
public "getDefaultProperties"(): $Map<($MachineAppearanceProperty<(any)>), (any)>
public "getStatusProperties"(status: $MachineStatus$Type): $Map<($MachineAppearanceProperty<(any)>), (any)>
get "defaultProperties"(): $Map<($MachineAppearanceProperty<(any)>), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearanceManager$Type = ($MachineAppearanceManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearanceManager_ = $MachineAppearanceManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$StructureRenderer" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StructureRenderer {

constructor(time: integer, blocksGetter: $Function$Type<($Direction$Type), ($Map$Type<($BlockPos$Type), ($IIngredient$Type<($PartialBlockState$Type)>)>)>)

public "render"(matrix: $PoseStack$Type, buffer: $MultiBufferSource$Type, direction: $Direction$Type, world: $Level$Type, machinePos: $BlockPos$Type): void
public "shouldRender"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureRenderer$Type = ($StructureRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureRenderer_ = $StructureRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/$MachineUpgrade" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier"

export class $MachineUpgrade {
static readonly "CODEC": $NamedCodec<($MachineUpgrade)>

constructor(item: $Item$Type, machines: $List$Type<($ResourceLocation$Type)>, modifiers: $List$Type<($RecipeModifier$Type)>, tooltips: $List$Type<($Component$Type)>, max: integer)

public "getModifiers"(): $List<($RecipeModifier)>
public "getItem"(): $Item
public "getMaxAmount"(): integer
public "getTooltips"(): $List<($Component)>
public "getMachines"(): $List<($ResourceLocation)>
get "modifiers"(): $List<($RecipeModifier)>
get "item"(): $Item
get "maxAmount"(): integer
get "tooltips"(): $List<($Component)>
get "machines"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineUpgrade$Type = ($MachineUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineUpgrade_ = $MachineUpgrade$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$GroupWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ComponentPath, $ComponentPath$Type} from "packages/net/minecraft/client/gui/$ComponentPath"
import {$FocusNavigationEvent, $FocusNavigationEvent$Type} from "packages/net/minecraft/client/gui/navigation/$FocusNavigationEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ContainerEventHandler, $ContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$ContainerEventHandler"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GroupWidget extends $AbstractWidget implements $ContainerEventHandler {
readonly "children": $List<($AbstractWidget)>
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, message: $Component$Type)

public "addWidget"<T extends $AbstractWidget>(widget: T): T
public "keyPressed"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "children"(): $List<($AbstractWidget)>
public "setDragging"(dragging: boolean): void
public "setFocused"(focused: $GuiEventListener$Type): void
public "isDragging"(): boolean
public "getFocused"(): $GuiEventListener
public "setFocused"(focused: boolean): void
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "charTyped"(codePoint: character, modifiers: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, delta: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, dragX: double, dragY: double): boolean
public "keyReleased"(keyCode: integer, scanCode: integer, modifiers: integer): boolean
public "mouseMoved"(mouseX: double, mouseY: double): void
public "setX"(x: integer): void
public "setY"(y: integer): void
public "getCurrentFocusPath"(): $ComponentPath
public "nextFocusPath"(arg0: $FocusNavigationEvent$Type): $ComponentPath
public "getChildAt"(arg0: double, arg1: double): $Optional<($GuiEventListener)>
public "isFocused"(): boolean
public "magicalSpecialHackyFocus"(arg0: $GuiEventListener$Type): void
set "dragging"(value: boolean)
set "focused"(value: $GuiEventListener$Type)
get "dragging"(): boolean
get "focused"(): $GuiEventListener
set "focused"(value: boolean)
set "x"(value: integer)
set "y"(value: integer)
get "currentFocusPath"(): $ComponentPath
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupWidget$Type = ($GroupWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GroupWidget_ = $GroupWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$TextGuiElementBuilder" {
import {$TextGuiElement, $TextGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextGuiElement"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $TextGuiElementBuilder implements $IGuiElementBuilder<($TextGuiElement)> {

constructor()

public "type"(): $GuiElementType<($TextGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $TextGuiElement$Type): $TextGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $TextGuiElement$Type, onFinish: $Consumer$Type<($TextGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextGuiElementBuilder$Type = ($TextGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextGuiElementBuilder_ = $TextGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$GuiElementBuilderRegistry" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $GuiElementBuilderRegistry {

constructor()

public static "init"(): void
public static "getBuilder"<T extends $IGuiElement>(type: $GuiElementType$Type<(T)>): $IGuiElementBuilder<(T)>
public static "hasBuilder"<E extends $IGuiElement>(type: $GuiElementType$Type<(E)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiElementBuilderRegistry$Type = ($GuiElementBuilderRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiElementBuilderRegistry_ = $GuiElementBuilderRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/element/$TextureGuiElementJeiRenderer" {
import {$TextureGuiElement, $TextureGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$TextureGuiElement"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IJEIElementRenderer, $IJEIElementRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIElementRenderer"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TextureGuiElementJeiRenderer implements $IJEIElementRenderer<($TextureGuiElement)> {

constructor()

public "renderElementInJEI"(graphics: $GuiGraphics$Type, element: $TextureGuiElement$Type, recipe: $IMachineRecipe$Type, mouseX: integer, mouseY: integer): void
public "getJEITooltips"(element: $TextureGuiElement$Type, recipe: $IMachineRecipe$Type): $List<($Component)>
public "isHoveredInJei"(element: $TextureGuiElement$Type, posX: integer, posY: integer, mouseX: integer, mouseY: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextureGuiElementJeiRenderer$Type = ($TextureGuiElementJeiRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextureGuiElementJeiRenderer_ = $TextureGuiElementJeiRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$BlockRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$BlockRequirement$ACTION, $BlockRequirement$ACTION$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement$ACTION"

export interface $BlockRequirementJS extends $RecipeJSBuilder {

 "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
 "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "breakAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
 "destroyAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
 "destroyAndPlaceBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "breakAndPlaceBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, filter: (string)[]): $RecipeJSBuilder
 "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "destroyBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "blockRequirement"(mode: $RequirementIOMode$Type, action: $BlockRequirement$ACTION$Type, block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string, stringFilter: (string)[], whitelist: boolean): $RecipeJSBuilder
 "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer, comparator: string): $RecipeJSBuilder
 "requireBlock"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "breakBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "placeBlockOnStart"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "placeBlockOnEnd"(block: string, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "breakBlockOnStart"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer, amount: integer): $RecipeJSBuilder
 "destroyBlockOnEnd"(filter: (string)[], whitelist: boolean, startX: integer, startY: integer, startZ: integer, endX: integer, endY: integer, endZ: integer): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $BlockRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRequirementJS$Type = ($BlockRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRequirementJS_ = $BlockRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/$ICustomMachineryAPI" {
import {$DataType, $DataType$Type} from "packages/fr/frinn/custommachinery/api/network/$DataType"
import {$ICMConfig, $ICMConfig$Type} from "packages/fr/frinn/custommachinery/api/utils/$ICMConfig"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Logger, $Logger$Type} from "packages/org/apache/logging/log4j/$Logger"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"

export interface $ICustomMachineryAPI {

 "rl"(arg0: string): $ResourceLocation
 "logger"(): $Logger
 "config"(): $ICMConfig
 "modid"(): string
 "componentRegistrar"(): $Registrar<($MachineComponentType<(any)>)>
 "getVariantCodec"<C extends $IMachineComponent>(arg0: $MachineComponentType$Type<(C)>, arg1: $ResourceLocation$Type): $NamedCodec<($IComponentVariant)>
 "dataRegistrar"(): $Registrar<($DataType<(any), (any)>)>
 "processorRegistrar"(): $Registrar<($ProcessorType<(any)>)>
 "registrar"<T>(arg0: $ResourceKey$Type<($Registry$Type<(T)>)>): $Registrar<(T)>
 "guiElementRegistrar"(): $Registrar<($GuiElementType<(any)>)>
 "requirementRegistrar"(): $Registrar<($RequirementType<(any)>)>
 "appearancePropertyRegistrar"(): $Registrar<($MachineAppearanceProperty<(any)>)>
}

export namespace $ICustomMachineryAPI {
const INSTANCE: $ICustomMachineryAPI
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICustomMachineryAPI$Type = ($ICustomMachineryAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICustomMachineryAPI_ = $ICustomMachineryAPI$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CChangeSideModePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CChangeSideModePacket extends $BaseC2SMessage {

constructor(containerID: integer, id: string, side: byte, next: boolean)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CChangeSideModePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CChangeSideModePacket$Type = ($CChangeSideModePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CChangeSideModePacket_ = $CChangeSideModePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$ToggleImageButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ImageButton, $ImageButton$Type} from "packages/net/minecraft/client/gui/components/$ImageButton"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $ToggleImageButton extends $ImageButton {
readonly "resourceLocation": $ResourceLocation
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, xTexStart: integer, yTexStart: integer, yDiffTex: integer, resourceLocation: $ResourceLocation$Type, textureWidth: integer, textureHeight: integer, onPress: $Button$OnPress$Type, message: $Component$Type)
constructor(x: integer, y: integer, width: integer, height: integer, xTexStart: integer, yTexStart: integer, yDiffTex: integer, resourceLocation: $ResourceLocation$Type, textureWidth: integer, textureHeight: integer, onPress: $Button$OnPress$Type)
constructor(x: integer, y: integer, width: integer, height: integer, xTexStart: integer, yTexStart: integer, yDiffTex: integer, resourceLocation: $ResourceLocation$Type, onPress: $Button$OnPress$Type)
constructor(x: integer, y: integer, width: integer, height: integer, xTexStart: integer, yTexStart: integer, resourceLocation: $ResourceLocation$Type, onPress: $Button$OnPress$Type)

public "setToggle"(toggle: boolean): void
public "renderTexture"(guiGraphics: $GuiGraphics$Type, texture: $ResourceLocation$Type, x: integer, y: integer, uOffset: integer, vOffset: integer, textureDifference: integer, width: integer, height: integer, textureWidth: integer, textureHeight: integer): void
public "onClick"(mouseX: double, mouseY: double): void
set "toggle"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToggleImageButton$Type = ($ToggleImageButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToggleImageButton_ = $ToggleImageButton$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$BaseInfoTab" {
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"

export class $BaseInfoTab extends $MachineEditTab {
readonly "parent": $MachineEditScreen

constructor(parent: $MachineEditScreen$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseInfoTab$Type = ($BaseInfoTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseInfoTab_ = $BaseInfoTab$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$ComponentPath, $ComponentPath$Type} from "packages/net/minecraft/client/gui/$ComponentPath"
import {$FocusNavigationEvent, $FocusNavigationEvent$Type} from "packages/net/minecraft/client/gui/navigation/$FocusNavigationEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ListWidget$Entry, $ListWidget$Entry$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget$Entry"
import {$ContainerEventHandler, $ContainerEventHandler$Type} from "packages/net/minecraft/client/gui/components/events/$ContainerEventHandler"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ListWidget<E extends $ListWidget$Entry> extends $AbstractWidget implements $ContainerEventHandler {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, itemHeight: integer, message: $Component$Type)

public "clear"(): void
public "addEntry"(entry: E): void
public "getEntries"(): $List<(E)>
public "ensureVisible"(entry: E): void
public "getSelected"(): E
public "nextFocusPath"(event: $FocusNavigationEvent$Type): $ComponentPath
public "children"(): $List<(E)>
public "setDragging"(isDragging: boolean): void
public "setFocused"(focused: $GuiEventListener$Type): void
public "isDragging"(): boolean
public "getFocused"(): $GuiEventListener
public "getEntryAtPosition"(mouseX: double, mouseY: double): E
public "getScrollAmount"(): double
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseScrolled"(mouseX: double, mouseY: double, delta: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, dragX: double, dragY: double): boolean
public "setSelected"(selected: E): void
public "getMaxScroll"(): integer
public "getMaxPosition"(): integer
public "setScrollAmount"(scroll: double): void
public "updateScrollingState"(mouseX: double, mouseY: double, button: integer): void
public "getCurrentFocusPath"(): $ComponentPath
public "keyPressed"(arg0: integer, arg1: integer, arg2: integer): boolean
public "setFocused"(arg0: boolean): void
public "getChildAt"(arg0: double, arg1: double): $Optional<($GuiEventListener)>
public "charTyped"(arg0: character, arg1: integer): boolean
public "isFocused"(): boolean
public "magicalSpecialHackyFocus"(arg0: $GuiEventListener$Type): void
public "keyReleased"(arg0: integer, arg1: integer, arg2: integer): boolean
get "entries"(): $List<(E)>
get "selected"(): E
set "dragging"(value: boolean)
set "focused"(value: $GuiEventListener$Type)
get "dragging"(): boolean
get "focused"(): $GuiEventListener
get "scrollAmount"(): double
set "selected"(value: E)
get "maxScroll"(): integer
get "maxPosition"(): integer
set "scrollAmount"(value: double)
get "currentFocusPath"(): $ComponentPath
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListWidget$Type<E> = ($ListWidget<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListWidget_<E> = $ListWidget$Type<(E)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineryRecipeSchemas" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $CustomMachineryRecipeSchemas {

}

export namespace $CustomMachineryRecipeSchemas {
const RESOURCE_LOCATION: $RecipeComponent<($ResourceLocation)>
const REQUIREMENT_COMPONENT: $RecipeComponent<($IRequirement<(any)>)>
const REQUIREMENT_LIST: $ArrayRecipeComponent<($IRequirement<(any)>)>
const CUSTOM_APPEARANCE: $RecipeComponent<($MachineAppearance)>
const CUSTOM_GUI_ELEMENTS: $RecipeComponent<($IGuiElement)>
const MACHINE_ID: $RecipeKey<($ResourceLocation)>
const TIME: $RecipeKey<(long)>
const OUTPUT: $RecipeKey<($OutputItem)>
const REQUIREMENTS: $RecipeKey<(($IRequirement<(any)>)[])>
const JEI_REQUIREMENTS: $RecipeKey<(($IRequirement<(any)>)[])>
const PRIORITY: $RecipeKey<(integer)>
const JEI_PRIORITY: $RecipeKey<(integer)>
const ERROR: $RecipeKey<(boolean)>
const HIDDEN: $RecipeKey<(boolean)>
const APPEARANCE: $RecipeKey<($MachineAppearance)>
const GUI: $RecipeKey<(($IGuiElement)[])>
const CUSTOM_MACHINE: $RecipeSchema
const CUSTOM_CRAFT: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineryRecipeSchemas$Type = ($CustomMachineryRecipeSchemas);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineryRecipeSchemas_ = $CustomMachineryRecipeSchemas$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateMachineStatusPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateMachineStatusPacket extends $BaseS2CMessage {

constructor(pos: $BlockPos$Type, status: $MachineStatus$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateMachineStatusPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateMachineStatusPacket$Type = ($SUpdateMachineStatusPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateMachineStatusPacket_ = $SUpdateMachineStatusPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/function/$MachineJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $MachineJS {


public static "of"(o: any): $MachineJS
public "getId"(): string
public "getOwner"(): $LivingEntity
public "setOwner"(entity: $LivingEntity$Type): void
public "getData"(): $CompoundTag
public "isSlotLocked"(slot: string): boolean
public "addFluid"(stackJS: $FluidStackJS$Type, simulate: boolean): long
public "removeFluidFromTank"(tank: string, amount: long, simulate: boolean): $FluidStackJS
public "getPaused"(): boolean
public "setFluidStored"(tank: string, stackJS: $FluidStackJS$Type): void
public "removeEnergy"(toRemove: integer, simulate: boolean): integer
public "getFluidStored"(tank: string): $FluidStackJS
public "setEnergyStored"(energy: long): void
public "addEnergy"(toAdd: integer, simulate: boolean): integer
public "getEnergyCapacity"(): long
public "addItemToSlot"(slot: string, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "removeFluid"(stackJS: $FluidStackJS$Type, simulate: boolean): $FluidStackJS
public "addFluidToTank"(tank: string, stackJS: $FluidStackJS$Type, simulate: boolean): long
public "getFluidCapacity"(tank: string): long
public "setItemStored"(slot: string, stack: $ItemStack$Type): void
public "removeItemFromSlot"(slot: string, toRemove: integer, simulate: boolean): $ItemStack
public "getItemStored"(slot: string): $ItemStack
public "getItemCapacity"(slot: string): integer
public "unlockSlot"(slot: string): void
public "isChunkloadEnabled"(): boolean
public "lockSlot"(slot: string): void
public "enableChunkload"(radius: integer): void
public "disableChunkload"(): void
public "getChunkloadRadius"(): integer
public "getEnergyStored"(): long
public "setPaused"(paused: boolean): void
public "getOwnerName"(): $Component
public "setId"(id: string): void
public "getOwnerId"(): $UUID
public "isOwner"(entity: $LivingEntity$Type): boolean
get "id"(): string
get "owner"(): $LivingEntity
set "owner"(value: $LivingEntity$Type)
get "data"(): $CompoundTag
get "paused"(): boolean
set "energyStored"(value: long)
get "energyCapacity"(): long
get "chunkloadEnabled"(): boolean
get "chunkloadRadius"(): integer
get "energyStored"(): long
set "paused"(value: boolean)
get "ownerName"(): $Component
set "id"(value: string)
get "ownerId"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineJS$Type = ($MachineJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineJS_ = $MachineJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"

export class $AbstractMachineComponent implements $IMachineComponent {

constructor(manager: $IMachineComponentManager$Type, mode: $ComponentIOMode$Type)

public "getMode"(): $ComponentIOMode
public "getManager"(): $IMachineComponentManager
public "init"(): void
public "getType"(): $MachineComponentType<(any)>
public "onRemoved"(): void
public "onStatusChanged"(oldStatus: $MachineStatus$Type, newStatus: $MachineStatus$Type, message: $Component$Type): void
get "mode"(): $ComponentIOMode
get "manager"(): $IMachineComponentManager
get "type"(): $MachineComponentType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMachineComponent$Type = ($AbstractMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMachineComponent_ = $AbstractMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$DataMachineComponent" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"

export class $DataMachineComponent extends $AbstractMachineComponent implements $ISerializableComponent, $ISyncableStuff {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($DataMachineComponent)>
public "getData"(): $CompoundTag
public "deserialize"(nbt: $CompoundTag$Type): void
public "setData"(nbt: $CompoundTag$Type): void
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
get "type"(): $MachineComponentType<($DataMachineComponent)>
get "data"(): $CompoundTag
set "data"(value: $CompoundTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMachineComponent$Type = ($DataMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataMachineComponent_ = $DataMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$NbtData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $NbtData extends $Data<($CompoundTag)> {

constructor(id: short, value: $CompoundTag$Type)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NbtData$Type = ($NbtData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NbtData_ = $NbtData$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$CustomMachineRenderer" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$BlockEntityRendererProvider$Context, $BlockEntityRendererProvider$Context$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider$Context"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$BlockEntityRenderer, $BlockEntityRenderer$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRenderer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CustomMachineRenderer implements $BlockEntityRenderer<($CustomMachineTile)> {

constructor(context: $BlockEntityRendererProvider$Context$Type)

public "render"(tile: $CustomMachineTile$Type, partialTicks: float, matrix: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer): void
public static "addRenderBox"(machine: $ResourceLocation$Type, box: $AABB$Type): void
public static "addRenderBlock"(machine: $ResourceLocation$Type, blocks: $Function$Type<($Direction$Type), ($Map$Type<($BlockPos$Type), ($IIngredient$Type<($PartialBlockState$Type)>)>)>): void
public "shouldRender"(arg0: $CustomMachineTile$Type, arg1: $Vec3$Type): boolean
public "shouldRenderOffScreen"(arg0: $CustomMachineTile$Type): boolean
public "getViewDistance"(): integer
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRenderer$Type = ($CustomMachineRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRenderer_ = $CustomMachineRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Energy {

constructor(amount: integer, chance: double, isPerTick: boolean)

public "isPerTick"(): boolean
public "getAmount"(): integer
public "getChance"(): double
get "perTick"(): boolean
get "amount"(): integer
get "chance"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Energy$Type = ($Energy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Energy_ = $Energy$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Mu" {
import {$K1, $K1$Type} from "packages/com/mojang/datafixers/kinds/$K1"

export class $NamedRecordCodec$Mu<O> implements $K1 {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedRecordCodec$Mu$Type<O> = ($NamedRecordCodec$Mu<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedRecordCodec$Mu_<O> = $NamedRecordCodec$Mu$Type<(O)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$TimeRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $TimeRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireTime"(time: string): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $TimeRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeRequirementCT$Type<T> = ($TimeRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeRequirementCT_<T> = $TimeRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CMSoundType" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $CMSoundType extends $SoundType {
static readonly "DEFAULT": $CMSoundType
static readonly "FROM_STATE": $NamedCodec<($CMSoundType)>
static readonly "FROM_PARTS": $NamedMapCodec<($CMSoundType)>
static readonly "CODEC": $NamedCodec<($CMSoundType)>
static readonly "EMPTY": $SoundType
static readonly "WOOD": $SoundType
static readonly "GRAVEL": $SoundType
static readonly "GRASS": $SoundType
static readonly "LILY_PAD": $SoundType
static readonly "STONE": $SoundType
static readonly "METAL": $SoundType
static readonly "GLASS": $SoundType
static readonly "WOOL": $SoundType
static readonly "SAND": $SoundType
static readonly "SNOW": $SoundType
static readonly "POWDER_SNOW": $SoundType
static readonly "LADDER": $SoundType
static readonly "ANVIL": $SoundType
static readonly "SLIME_BLOCK": $SoundType
static readonly "HONEY_BLOCK": $SoundType
static readonly "WET_GRASS": $SoundType
static readonly "CORAL_BLOCK": $SoundType
static readonly "BAMBOO": $SoundType
static readonly "BAMBOO_SAPLING": $SoundType
static readonly "SCAFFOLDING": $SoundType
static readonly "SWEET_BERRY_BUSH": $SoundType
static readonly "CROP": $SoundType
static readonly "HARD_CROP": $SoundType
static readonly "VINE": $SoundType
static readonly "NETHER_WART": $SoundType
static readonly "LANTERN": $SoundType
static readonly "STEM": $SoundType
static readonly "NYLIUM": $SoundType
static readonly "FUNGUS": $SoundType
static readonly "ROOTS": $SoundType
static readonly "SHROOMLIGHT": $SoundType
static readonly "WEEPING_VINES": $SoundType
static readonly "TWISTING_VINES": $SoundType
static readonly "SOUL_SAND": $SoundType
static readonly "SOUL_SOIL": $SoundType
static readonly "BASALT": $SoundType
static readonly "WART_BLOCK": $SoundType
static readonly "NETHERRACK": $SoundType
static readonly "NETHER_BRICKS": $SoundType
static readonly "NETHER_SPROUTS": $SoundType
static readonly "NETHER_ORE": $SoundType
static readonly "BONE_BLOCK": $SoundType
static readonly "NETHERITE_BLOCK": $SoundType
static readonly "ANCIENT_DEBRIS": $SoundType
static readonly "LODESTONE": $SoundType
static readonly "CHAIN": $SoundType
static readonly "NETHER_GOLD_ORE": $SoundType
static readonly "GILDED_BLACKSTONE": $SoundType
static readonly "CANDLE": $SoundType
static readonly "AMETHYST": $SoundType
static readonly "AMETHYST_CLUSTER": $SoundType
static readonly "SMALL_AMETHYST_BUD": $SoundType
static readonly "MEDIUM_AMETHYST_BUD": $SoundType
static readonly "LARGE_AMETHYST_BUD": $SoundType
static readonly "TUFF": $SoundType
static readonly "CALCITE": $SoundType
static readonly "DRIPSTONE_BLOCK": $SoundType
static readonly "POINTED_DRIPSTONE": $SoundType
static readonly "COPPER": $SoundType
static readonly "CAVE_VINES": $SoundType
static readonly "SPORE_BLOSSOM": $SoundType
static readonly "AZALEA": $SoundType
static readonly "FLOWERING_AZALEA": $SoundType
static readonly "MOSS_CARPET": $SoundType
static readonly "PINK_PETALS": $SoundType
static readonly "MOSS": $SoundType
static readonly "BIG_DRIPLEAF": $SoundType
static readonly "SMALL_DRIPLEAF": $SoundType
static readonly "ROOTED_DIRT": $SoundType
static readonly "HANGING_ROOTS": $SoundType
static readonly "AZALEA_LEAVES": $SoundType
static readonly "SCULK_SENSOR": $SoundType
static readonly "SCULK_CATALYST": $SoundType
static readonly "SCULK": $SoundType
static readonly "SCULK_VEIN": $SoundType
static readonly "SCULK_SHRIEKER": $SoundType
static readonly "GLOW_LICHEN": $SoundType
static readonly "DEEPSLATE": $SoundType
static readonly "DEEPSLATE_BRICKS": $SoundType
static readonly "DEEPSLATE_TILES": $SoundType
static readonly "POLISHED_DEEPSLATE": $SoundType
static readonly "FROGLIGHT": $SoundType
static readonly "FROGSPAWN": $SoundType
static readonly "MANGROVE_ROOTS": $SoundType
static readonly "MUDDY_MANGROVE_ROOTS": $SoundType
static readonly "MUD": $SoundType
static readonly "MUD_BRICKS": $SoundType
static readonly "PACKED_MUD": $SoundType
static readonly "HANGING_SIGN": $SoundType
static readonly "NETHER_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD_HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD": $SoundType
static readonly "NETHER_WOOD": $SoundType
static readonly "CHERRY_WOOD": $SoundType
static readonly "CHERRY_SAPLING": $SoundType
static readonly "CHERRY_LEAVES": $SoundType
static readonly "CHERRY_WOOD_HANGING_SIGN": $SoundType
static readonly "CHISELED_BOOKSHELF": $SoundType
static readonly "SUSPICIOUS_SAND": $SoundType
static readonly "SUSPICIOUS_GRAVEL": $SoundType
static readonly "DECORATED_POT": $SoundType
static readonly "DECORATED_POT_CRACKED": $SoundType
readonly "volume": float
readonly "pitch": float

constructor(volume: float, pitch: float, breakSound: $SoundEvent$Type, stepSound: $SoundEvent$Type, placeSound: $SoundEvent$Type, hitSound: $SoundEvent$Type, fallSound: $SoundEvent$Type)
constructor(state: $PartialBlockState$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMSoundType$Type = ($CMSoundType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMSoundType_ = $CMSoundType$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/$CustomMachineBlockBuilderJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $CustomMachineBlockBuilderJS extends $BuilderBase<($Block)> {
static readonly "VALID_RENDER_TYPES": $List<(string)>
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "createAdditionalObjects"(): void
public "renderType"(renderType: string): $CustomMachineBlockBuilderJS
public "occlude"(): $CustomMachineBlockBuilderJS
public "getRegistryType"(): $RegistryInfo<(any)>
public "machine"(machineID: $ResourceLocation$Type): $CustomMachineBlockBuilderJS
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineBlockBuilderJS$Type = ($CustomMachineBlockBuilderJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineBlockBuilderJS_ = $CustomMachineBlockBuilderJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/integration/jade/$CMWailaPlugin" {
import {$IWailaClientRegistration, $IWailaClientRegistration$Type} from "packages/snownee/jade/api/$IWailaClientRegistration"
import {$IWailaPlugin, $IWailaPlugin$Type} from "packages/snownee/jade/api/$IWailaPlugin"
import {$IWailaCommonRegistration, $IWailaCommonRegistration$Type} from "packages/snownee/jade/api/$IWailaCommonRegistration"

export class $CMWailaPlugin implements $IWailaPlugin {

constructor()

public "register"(registration: $IWailaCommonRegistration$Type): void
public "registerClient"(registration: $IWailaClientRegistration$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CMWailaPlugin$Type = ($CMWailaPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CMWailaPlugin_ = $CMWailaPlugin$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterWidgetToJeiIngredientGetterEvent$Register" {
import {$RegisterWidgetToJeiIngredientGetterEvent, $RegisterWidgetToJeiIngredientGetterEvent$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$RegisterWidgetToJeiIngredientGetterEvent"

export interface $RegisterWidgetToJeiIngredientGetterEvent$Register {

 "registerIngredientGetter"(arg0: $RegisterWidgetToJeiIngredientGetterEvent$Type): void

(arg0: $RegisterWidgetToJeiIngredientGetterEvent$Type): void
}

export namespace $RegisterWidgetToJeiIngredientGetterEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterWidgetToJeiIngredientGetterEvent$Register$Type = ($RegisterWidgetToJeiIngredientGetterEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterWidgetToJeiIngredientGetterEvent$Register_ = $RegisterWidgetToJeiIngredientGetterEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/builder/$TextAppearancePropertyBuilder" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IAppearancePropertyBuilder, $IAppearancePropertyBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$IAppearancePropertyBuilder"

export class $TextAppearancePropertyBuilder<T> implements $IAppearancePropertyBuilder<(T)> {

constructor(title: $Component$Type, type: $MachineAppearanceProperty$Type<(T)>, parser: $Function$Type<(string), (T)>, toString: $Function$Type<(T), (string)>)

public "getType"(): $MachineAppearanceProperty<(T)>
public "makeWidget"(parent: $BaseScreen$Type, x: integer, y: integer, width: integer, height: integer, supplier: $Supplier$Type<(T)>, consumer: $Consumer$Type<(T)>): $AbstractWidget
public "title"(): $Component
get "type"(): $MachineAppearanceProperty<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextAppearancePropertyBuilder$Type<T> = ($TextAppearancePropertyBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextAppearancePropertyBuilder_<T> = $TextAppearancePropertyBuilder$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ItemFilterRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $ItemFilterRequirement extends $AbstractRequirement<($ItemComponentHandler)> implements $ITickableRequirement<($ItemComponentHandler)>, $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($ItemFilterRequirement)>

constructor(ingredient: $Ingredient$Type, slot: string)

public "test"(handler: $ItemComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($ItemFilterRequirement)>
public "processTick"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($ItemFilterRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFilterRequirement$Type = ($ItemFilterRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFilterRequirement_ = $ItemFilterRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$FuelItemIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $FuelItemIngredientWrapper implements $IJEIIngredientWrapper<($ItemStack)> {

constructor(amount: integer)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuelItemIngredientWrapper$Type = ($FuelItemIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuelItemIngredientWrapper_ = $FuelItemIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$DropRequirement$Action" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DropRequirement$Action extends $Enum<($DropRequirement$Action)> {
static readonly "CHECK": $DropRequirement$Action
static readonly "CONSUME": $DropRequirement$Action
static readonly "PRODUCE": $DropRequirement$Action
static readonly "CODEC": $NamedCodec<($DropRequirement$Action)>


public static "value"(mode: string): $DropRequirement$Action
public static "values"(): ($DropRequirement$Action)[]
public static "valueOf"(name: string): $DropRequirement$Action
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropRequirement$Action$Type = (("consume") | ("check") | ("produce")) | ($DropRequirement$Action);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DropRequirement$Action_ = $DropRequirement$Action$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export interface $IGuiElement {

 "getProperties"(): $AbstractGuiElement$Properties
 "getPriority"(): integer
 "getId"(): string
 "getType"(): $GuiElementType<(any)>
 "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
 "getY"(): integer
 "showInJei"(): boolean
 "getX"(): integer
 "getWidth"(): integer
 "getHeight"(): integer
 "getTooltips"(): $List<($Component)>
}

export namespace $IGuiElement {
const CODEC: $NamedCodec<($IGuiElement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiElement$Type = ($IGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiElement_ = $IGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$LightRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $LightRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "requireBlockLight"(level: string): T
 "requireBlockLight"(level: integer): T
 "requireSkyLight"(level: string): T
 "requireSkyLight"(level: integer): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $LightRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightRequirementCT$Type<T> = ($LightRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LightRequirementCT_<T> = $LightRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/machine/$MachineTile" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ICustomMachine, $ICustomMachine$Type} from "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine"
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IMachineUpgradeManager, $IMachineUpgradeManager$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IMachineUpgradeManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"

export class $MachineTile extends $BlockEntity {
 "blockState": $BlockState

constructor(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, state: $BlockState$Type)

public "getMessage"(): $Component
public "getOwner"(): $LivingEntity
public "setOwner"(arg0: $LivingEntity$Type): void
public "isPaused"(): boolean
public "getMachine"(): $ICustomMachine
public "getGuiElements"(): $List<($IGuiElement)>
public "resetProcess"(): void
public "setPaused"(arg0: boolean): void
public "refreshMachine"(arg0: $ResourceLocation$Type): void
public "isUnloaded"(): boolean
public "setStatus"(status: $MachineStatus$Type): void
public "setStatus"(arg0: $MachineStatus$Type, arg1: $Component$Type): void
public "getUpgradeManager"(): $IMachineUpgradeManager
public "refreshClientData"(): void
public "getStatus"(): $MachineStatus
public "getOwnerName"(): $Component
public "getAppearance"(): $IMachineAppearance
public "getProcessor"(): $IProcessor
public "getOwnerId"(): $UUID
public "isOwner"(entity: $LivingEntity$Type): boolean
public "getComponentManager"(): $IMachineComponentManager
public "setCustomGuiElements"(arg0: $List$Type<($IGuiElement$Type)>): void
public "setCustomAppearance"(arg0: $IMachineAppearance$Type): void
get "message"(): $Component
get "owner"(): $LivingEntity
set "owner"(value: $LivingEntity$Type)
get "paused"(): boolean
get "machine"(): $ICustomMachine
get "guiElements"(): $List<($IGuiElement)>
set "paused"(value: boolean)
get "unloaded"(): boolean
set "status"(value: $MachineStatus$Type)
get "upgradeManager"(): $IMachineUpgradeManager
get "status"(): $MachineStatus
get "ownerName"(): $Component
get "appearance"(): $IMachineAppearance
get "processor"(): $IProcessor
get "ownerId"(): $UUID
get "componentManager"(): $IMachineComponentManager
set "customGuiElements"(value: $List$Type<($IGuiElement$Type)>)
set "customAppearance"(value: $IMachineAppearance$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineTile$Type = ($MachineTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineTile_ = $MachineTile$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$WeatherMachineComponent$WeatherType, $WeatherMachineComponent$WeatherType$Type} from "packages/fr/frinn/custommachinery/common/component/$WeatherMachineComponent$WeatherType"

export class $WeatherMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($WeatherMachineComponent)>
public "hasWeather"(weather: $WeatherMachineComponent$WeatherType$Type, onTile: boolean): boolean
get "type"(): $MachineComponentType<($WeatherMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatherMachineComponent$Type = ($WeatherMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WeatherMachineComponent_ = $WeatherMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$ExperienceGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ExperienceGuiElement, $ExperienceGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $ExperienceGuiElementBuilder implements $IGuiElementBuilder<($ExperienceGuiElement)> {

constructor()

public "type"(): $GuiElementType<($ExperienceGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $ExperienceGuiElement$Type): $ExperienceGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $ExperienceGuiElement$Type, onFinish: $Consumer$Type<($ExperienceGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceGuiElementBuilder$Type = ($ExperienceGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceGuiElementBuilder_ = $ExperienceGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$ClientEvents" {
import {$RenderLevelStageEvent, $RenderLevelStageEvent$Type} from "packages/net/minecraftforge/client/event/$RenderLevelStageEvent"

export class $ClientEvents {

constructor()

public static "renderLevel"(event: $RenderLevelStageEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientEvents$Type = ($ClientEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientEvents_ = $ClientEvents$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$PairCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PairCodec<F, S> implements $NamedCodec<($Pair<(F), (S)>)> {


public "name"(): string
public "equals"(o: any): boolean
public "hashCode"(): integer
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<($Pair<(F), (S)>), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, value: $Pair$Type<(F), (S)>, rest: T): $DataResult<(T)>
public static "of"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<($Pair$Type<(F), (S)>)>): $NamedCodec<($Pair<(F), (S)>)>
public static "of"<A>(codec: $Codec$Type<($Pair$Type<(F), (S)>)>, name: string): $NamedCodec<($Pair<(F), (S)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Pair$Type<(F), (S)>)>, name: string): $NamedCodec<($List<($Pair<(F), (S)>)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Pair$Type<(F), (S)>)>): $NamedCodec<($List<($Pair<(F), (S)>)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<(F), (S)>)>
public "copy"(input: $Pair$Type<(F), (S)>): $Pair<(F), (S)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<($Pair$Type<(F), (S)>)>, name: string): $NamedCodec<($Pair<(F), (S)>)>
public static "unit"<A>(defaultValue: $Pair$Type<(F), (S)>, name: string): $NamedCodec<($Pair<(F), (S)>)>
public static "unit"<A>(defaultValue: $Pair$Type<(F), (S)>): $NamedCodec<($Pair<(F), (S)>)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<($Pair$Type<(F), (S)>)>)>, name: string): $NamedCodec<($Pair<(F), (S)>)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): $Pair<(F), (S)>
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<($Pair<(F), (S)>)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<($Pair<(F), (S)>)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Pair$Type<(F), (S)>): $NamedMapCodec<($Pair<(F), (S)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<($Pair$Type<(F), (S)>)>): $NamedMapCodec<($Pair<(F), (S)>)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: $Pair$Type<(F), (S)>): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: $Pair$Type<(F), (S)>, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<($Pair<(F), (S)>)>)>
public "listOf"(name: string): $NamedCodec<($List<($Pair<(F), (S)>)>)>
public static "registrar"<A>(registrar: $Registrar$Type<($Pair$Type<(F), (S)>)>): $NamedCodec<($Pair<(F), (S)>)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<($Pair<(F), (S)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PairCodec$Type<F, S> = ($PairCodec<(F), (S)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PairCodec_<F, S> = $PairCodec$Type<(F), (S)>;
}}
declare module "packages/fr/frinn/custommachinery/api/machine/$ICustomMachine" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IProcessorTemplate, $IProcessorTemplate$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessorTemplate"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export interface $ICustomMachine {

 "getName"(): $Component
 "getId"(): $ResourceLocation
 "getRecipeIds"(): $List<($ResourceLocation)>
 "getGuiElements"(): $List<($IGuiElement)>
 "isDummy"(): boolean
 "getAppearance"(arg0: $MachineStatus$Type): $IMachineAppearance
 "getProcessorTemplate"(): $IProcessorTemplate<(any)>
}

export namespace $ICustomMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICustomMachine$Type = ($ICustomMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICustomMachine_ = $ICustomMachine$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$LRU$LRUIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LRU, $LRU$Type} from "packages/fr/frinn/custommachinery/common/util/$LRU"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $LRU$LRUIterator implements $Iterator<(T)> {

constructor(this$0: $LRU$Type<(any)>)

public "hasNext"(): boolean
public "next"(): T
public "reverse"(): $LRU$LRUIterator<>
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LRU$LRUIterator$Type = ($LRU$LRUIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LRU$LRUIterator_ = $LRU$LRUIterator$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/energy/$EnergyIngredientHelper" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$IIngredientHelper, $IIngredientHelper$Type} from "packages/mezz/jei/api/ingredients/$IIngredientHelper"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$UidContext, $UidContext$Type} from "packages/mezz/jei/api/ingredients/subtypes/$UidContext"

export class $EnergyIngredientHelper implements $IIngredientHelper<($Energy)> {

constructor()

public "getDisplayName"(energy: $Energy$Type): string
public "copyIngredient"(energy: $Energy$Type): $Energy
public "getErrorInfo"(energy: $Energy$Type): string
public "getIngredientType"(): $IIngredientType<($Energy)>
public "getUniqueId"(energy: $Energy$Type, context: $UidContext$Type): string
public "getResourceLocation"(ingredient: $Energy$Type): $ResourceLocation
public "getWildcardId"(arg0: $Energy$Type): string
public "getDisplayModId"(arg0: $Energy$Type): string
public "getTagEquivalent"(arg0: $Collection$Type<($Energy$Type)>): $Optional<($ResourceLocation)>
public "getTagStream"(arg0: $Energy$Type): $Stream<($ResourceLocation)>
public "getCheatItemStack"(arg0: $Energy$Type): $ItemStack
public "isValidIngredient"(arg0: $Energy$Type): boolean
public "normalizeIngredient"(arg0: $Energy$Type): $Energy
public "isIngredientOnServer"(arg0: $Energy$Type): boolean
public "getColors"(arg0: $Energy$Type): $Iterable<(integer)>
get "ingredientType"(): $IIngredientType<($Energy)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyIngredientHelper$Type = ($EnergyIngredientHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyIngredientHelper_ = $EnergyIngredientHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$PositionRequirement" {
import {$PositionMachineComponent, $PositionMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$PositionMachineComponent"
import {$IntRange, $IntRange$Type} from "packages/fr/frinn/custommachinery/impl/util/$IntRange"
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $PositionRequirement extends $AbstractRequirement<($PositionMachineComponent)> implements $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($PositionRequirement)>

constructor(x: $IntRange$Type, y: $IntRange$Type, z: $IntRange$Type)

public "test"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($PositionMachineComponent)>
public "getType"(): $RequirementType<($PositionRequirement)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processStart"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $PositionMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($PositionMachineComponent)>
get "type"(): $RequirementType<($PositionRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionRequirement$Type = ($PositionRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PositionRequirement_ = $PositionRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$DefaultCodecs" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DefaultCodecs {
static readonly "RESOURCE_LOCATION": $NamedCodec<($ResourceLocation)>
static readonly "CHARACTER": $NamedCodec<(character)>
static readonly "NBT_FROM_STRING": $NamedCodec<($CompoundTag)>
static readonly "NBT_FROM_JSON": $NamedCodec<($CompoundTag)>
static readonly "COMPOUND_TAG": $NamedCodec<($CompoundTag)>
static readonly "SOUND_EVENT": $NamedCodec<($SoundEvent)>
static readonly "DIRECTION": $NamedCodec<($Direction)>
static readonly "ITEM_STACK": $NamedCodec<($ItemStack)>
static readonly "ITEM_OR_STACK": $NamedCodec<($ItemStack)>
static readonly "INGREDIENT": $NamedCodec<($Ingredient)>
static readonly "BOX": $NamedCodec<($AABB)>

constructor()

public static "tagKey"<T>(registry: $ResourceKey$Type<($Registry$Type<(T)>)>): $NamedCodec<($TagKey<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultCodecs$Type = ($DefaultCodecs);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultCodecs_ = $DefaultCodecs$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/data/$IntegerData" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Data, $Data$Type} from "packages/fr/frinn/custommachinery/impl/network/$Data"

export class $IntegerData extends $Data<(integer)> {

constructor(id: short, value: integer)
constructor(id: short, buffer: $FriendlyByteBuf$Type)

public "writeData"(buffer: $FriendlyByteBuf$Type): void
public static "readData"(buffer: $FriendlyByteBuf$Type): $IData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerData$Type = ($IntegerData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntegerData_ = $IntegerData$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$RecipeHelper" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$IComponentGuiElement, $IComponentGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$MachineComponentManager, $MachineComponentManager$Type} from "packages/fr/frinn/custommachinery/common/component/$MachineComponentManager"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"

export class $RecipeHelper implements $IRecipeHelper {

constructor(machine: $CustomMachine$Type, jeiHelpers: $IJeiHelpers$Type)

public "getJeiHelpers"(): $IJeiHelpers
public "getMachine"(): $CustomMachine
public "getComponentForElement"(element: $IComponentGuiElement$Type<(any)>): $Optional<($IMachineComponentTemplate<(any)>)>
public "getDummyManager"(): $MachineComponentManager
get "jeiHelpers"(): $IJeiHelpers
get "machine"(): $CustomMachine
get "dummyManager"(): $MachineComponentManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHelper$Type = ($RecipeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeHelper_ = $RecipeHelper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$StringSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$StringData, $StringData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$StringData"

export class $StringSyncable extends $AbstractSyncable<($StringData), (string)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<(string)>, consumer: $Consumer$Type<(string)>): $StringSyncable
public "needSync"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringSyncable$Type = ($StringSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringSyncable_ = $StringSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$IChanceableRequirement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export interface $IChanceableRequirement<T extends $IMachineComponent> extends $IRequirement<(T)> {

 "shouldSkip"(arg0: T, arg1: $Random$Type, arg2: $ICraftingContext$Type): boolean
 "setChance"(arg0: double): void
 "test"(arg0: T, arg1: $ICraftingContext$Type): boolean
 "getComponentType"(): $MachineComponentType<(T)>
 "getType"(): $RequirementType<(any)>
 "getDisplayInfo"(info: $IDisplayInfo$Type): void
 "getMode"(): $RequirementIOMode
 "processStart"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "processEnd"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "getDisplayInfoTemplate"(): $DisplayInfoTemplate
 "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
}

export namespace $IChanceableRequirement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChanceableRequirement$Type<T> = ($IChanceableRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChanceableRequirement_<T> = $IChanceableRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/craft/$CraftProcessor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IProcessor, $IProcessor$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IProcessor"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ProcessorType, $ProcessorType$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ProcessorType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $CraftProcessor implements $IProcessor {

constructor(tile: $MachineTile$Type)

public "getType"(): $ProcessorType<($CraftProcessor)>
public "reset"(): void
public "tick"(): void
public "deserialize"(nbt: $CompoundTag$Type): void
public "getCurrentContext"(): $ICraftingContext
public "bulkCraft"(): boolean
public "getTile"(): $MachineTile
public "serialize"(): $CompoundTag
public "getRecipeProgressTime"(): double
public "setMachineInventoryChanged"(): void
public "craft"(): void
get "type"(): $ProcessorType<($CraftProcessor)>
get "currentContext"(): $ICraftingContext
get "tile"(): $MachineTile
get "recipeProgressTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftProcessor$Type = ($CraftProcessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftProcessor_ = $CraftProcessor$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/$ClientPacketHandler" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ClientPacketHandler {

constructor()

public static "handleRefreshCustomMachineTilePacket"(pos: $BlockPos$Type, machine: $ResourceLocation$Type): void
public static "handleUpdateContainerPacket"(windowId: integer, data: $List$Type<($IData$Type<(any)>)>): void
public static "handleMachineStatusChangedPacket"(pos: $BlockPos$Type, status: $MachineStatus$Type): void
public static "handleUpdateMachinesPacket"(machines: $Map$Type<($ResourceLocation$Type), ($CustomMachine$Type)>): void
public static "handleUpdateMachineAppearancePacket"(pos: $BlockPos$Type, appearance: $MachineAppearance$Type): void
public static "handleUpdateMachineGuiElementsPacket"(pos: $BlockPos$Type, elements: $List$Type<($IGuiElement$Type)>): void
public static "handleOpenEditScreenPacket"(machineId: $ResourceLocation$Type): void
public static "handleOpenCreationScreenPacket"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPacketHandler$Type = ($ClientPacketHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPacketHandler_ = $ClientPacketHandler$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"

export class $CraftingResult {


public "getMessage"(): $Component
public static "error"(message: $Component$Type): $CraftingResult
public static "pass"(): $CraftingResult
public static "success"(): $CraftingResult
public "isSuccess"(): boolean
get "message"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingResult$Type = ($CraftingResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingResult_ = $CraftingResult$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FluidRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $FluidRequirementJS extends $RecipeJSBuilder {

 "produceFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
 "produceFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
 "requireFluid"(stack: $FluidStackJS$Type): $RecipeJSBuilder
 "requireFluid"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
 "requireFluidTag"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "requireFluidTag"(tag: string, amount: integer): $RecipeJSBuilder
 "requireFluidTag"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, tank: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $FluidRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidRequirementJS$Type = ($FluidRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidRequirementJS_ = $FluidRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$CustomMachineryJEIPlugin" {
import {$IGuiHandlerRegistration, $IGuiHandlerRegistration$Type} from "packages/mezz/jei/api/registration/$IGuiHandlerRegistration"
import {$IJeiConfigManager, $IJeiConfigManager$Type} from "packages/mezz/jei/api/runtime/config/$IJeiConfigManager"
import {$IAdvancedRegistration, $IAdvancedRegistration$Type} from "packages/mezz/jei/api/registration/$IAdvancedRegistration"
import {$IVanillaCategoryExtensionRegistration, $IVanillaCategoryExtensionRegistration$Type} from "packages/mezz/jei/api/registration/$IVanillaCategoryExtensionRegistration"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRecipeRegistration, $IRecipeRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeRegistration"
import {$IRecipeTransferRegistration, $IRecipeTransferRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeTransferRegistration"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"
import {$IRecipeCatalystRegistration, $IRecipeCatalystRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCatalystRegistration"
import {$IModPlugin, $IModPlugin$Type} from "packages/mezz/jei/api/$IModPlugin"
import {$IRuntimeRegistration, $IRuntimeRegistration$Type} from "packages/mezz/jei/api/registration/$IRuntimeRegistration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IRecipeCategoryRegistration, $IRecipeCategoryRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCategoryRegistration"
import {$IModIngredientRegistration, $IModIngredientRegistration$Type} from "packages/mezz/jei/api/registration/$IModIngredientRegistration"
import {$ISubtypeRegistration, $ISubtypeRegistration$Type} from "packages/mezz/jei/api/registration/$ISubtypeRegistration"
import {$IPlatformFluidHelper, $IPlatformFluidHelper$Type} from "packages/mezz/jei/api/helpers/$IPlatformFluidHelper"

export class $CustomMachineryJEIPlugin implements $IModPlugin {
static readonly "PLUGIN_ID": $ResourceLocation
static readonly "FUEL_INGREDIENTS": $List<($ItemStack)>

constructor()

public "registerItemSubtypes"(registration: $ISubtypeRegistration$Type): void
public "registerGuiHandlers"(registration: $IGuiHandlerRegistration$Type): void
public "registerIngredients"(registry: $IModIngredientRegistration$Type): void
public "registerRecipeCatalysts"(registration: $IRecipeCatalystRegistration$Type): void
public "getPluginUid"(): $ResourceLocation
public "registerRecipes"(registry: $IRecipeRegistration$Type): void
public "registerCategories"(registry: $IRecipeCategoryRegistration$Type): void
public "registerVanillaCategoryExtensions"(arg0: $IVanillaCategoryExtensionRegistration$Type): void
public "registerFluidSubtypes"<T>(arg0: $ISubtypeRegistration$Type, arg1: $IPlatformFluidHelper$Type<(T)>): void
public "onConfigManagerAvailable"(arg0: $IJeiConfigManager$Type): void
public "onRuntimeUnavailable"(): void
public "registerRecipeTransferHandlers"(arg0: $IRecipeTransferRegistration$Type): void
public "registerAdvanced"(arg0: $IAdvancedRegistration$Type): void
public "onRuntimeAvailable"(arg0: $IJeiRuntime$Type): void
public "registerRuntime"(arg0: $IRuntimeRegistration$Type): void
get "pluginUid"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineryJEIPlugin$Type = ($CustomMachineryJEIPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineryJEIPlugin_ = $CustomMachineryJEIPlugin$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement" {
import {$AbstractDelayedChanceableRequirement, $AbstractDelayedChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$BlockRequirement$ACTION, $BlockRequirement$ACTION$Type} from "packages/fr/frinn/custommachinery/common/requirement/$BlockRequirement$ACTION"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ComparatorMode, $ComparatorMode$Type} from "packages/fr/frinn/custommachinery/common/util/$ComparatorMode"
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$BlockMachineComponent, $BlockMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$BlockMachineComponent"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfoRequirement, $IDisplayInfoRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfoRequirement"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $BlockRequirement extends $AbstractDelayedChanceableRequirement<($BlockMachineComponent)> implements $ITickableRequirement<($BlockMachineComponent)>, $IDisplayInfoRequirement {
static readonly "CODEC": $NamedCodec<($BlockRequirement)>

constructor(mode: $RequirementIOMode$Type, action: $BlockRequirement$ACTION$Type, pos: $AABB$Type, amount: integer, comparator: $ComparatorMode$Type, block: $PartialBlockState$Type, filter: $List$Type<($IIngredient$Type<($PartialBlockState$Type)>)>, whitelist: boolean)

public "test"(component: $BlockMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($BlockMachineComponent)>
public "execute"(component: $BlockMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getType"(): $RequirementType<(any)>
public "getDisplayInfo"(info: $IDisplayInfo$Type): void
public "processTick"(component: $BlockMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $BlockMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $BlockMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "getDelay"(): double
public "setDelay"(delay: double): void
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<($BlockMachineComponent)>
get "type"(): $RequirementType<(any)>
get "delay"(): double
set "delay"(value: double)
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRequirement$Type = ($BlockRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRequirement_ = $BlockRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$ItemStackSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemStackData, $ItemStackData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$ItemStackData"

export class $ItemStackSyncable extends $AbstractSyncable<($ItemStackData), ($ItemStack)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<($ItemStack$Type)>, consumer: $Consumer$Type<($ItemStack$Type)>): $ItemStackSyncable
public "needSync"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSyncable$Type = ($ItemStackSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackSyncable_ = $ItemStackSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export interface $ITickableRequirement<T extends $IMachineComponent> extends $IRequirement<(T)> {

 "processTick"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "test"(arg0: T, arg1: $ICraftingContext$Type): boolean
 "getComponentType"(): $MachineComponentType<(T)>
 "getType"(): $RequirementType<(any)>
 "getDisplayInfo"(info: $IDisplayInfo$Type): void
 "getMode"(): $RequirementIOMode
 "processStart"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "processEnd"(arg0: T, arg1: $ICraftingContext$Type): $CraftingResult
 "getDisplayInfoTemplate"(): $DisplayInfoTemplate
 "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
}

export namespace $ITickableRequirement {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITickableRequirement$Type<T> = ($ITickableRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITickableRequirement_<T> = $ITickableRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$RegisterComponentBuilderEvent$Register" {
import {$RegisterComponentBuilderEvent, $RegisterComponentBuilderEvent$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$RegisterComponentBuilderEvent"

export interface $RegisterComponentBuilderEvent$Register {

 "registerMachineComponentBuilders"(arg0: $RegisterComponentBuilderEvent$Type): void

(arg0: $RegisterComponentBuilderEvent$Type): void
}

export namespace $RegisterComponentBuilderEvent$Register {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterComponentBuilderEvent$Register$Type = ($RegisterComponentBuilderEvent$Register);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterComponentBuilderEvent$Register_ = $RegisterComponentBuilderEvent$Register$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$FunctionMachineComponent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"

export class $FunctionMachineComponent extends $AbstractMachineComponent {

constructor(manager: $IMachineComponentManager$Type)

public "getType"(): $MachineComponentType<($FunctionMachineComponent)>
get "type"(): $MachineComponentType<($FunctionMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionMachineComponent$Type = ($FunctionMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionMachineComponent_ = $FunctionMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AbstractGuiElement$Properties extends $Record {

constructor(x: integer, y: integer, width: integer, height: integer, priority: integer, texture: $ResourceLocation$Type, textureHovered: $ResourceLocation$Type, tooltips: $List$Type<($Component$Type)>, id: string)

public "priority"(): integer
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "x"(): integer
public "id"(): string
public "y"(): integer
public "width"(): integer
public "height"(): integer
public "tooltips"(): $List<($Component)>
public "textureHovered"(): $ResourceLocation
public "texture"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractGuiElement$Properties$Type = ($AbstractGuiElement$Properties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractGuiElement$Properties_ = $AbstractGuiElement$Properties$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$NbtSyncable" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$NbtData, $NbtData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$NbtData"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $NbtSyncable extends $AbstractSyncable<($NbtData), ($CompoundTag)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<($CompoundTag$Type)>, consumer: $Consumer$Type<($CompoundTag$Type)>): $NbtSyncable
public "needSync"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NbtSyncable$Type = ($NbtSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NbtSyncable_ = $NbtSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CButtonGuiElementPacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CButtonGuiElementPacket extends $BaseC2SMessage {

constructor(id: string, toogle: boolean)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CButtonGuiElementPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CButtonGuiElementPacket$Type = ($CButtonGuiElementPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CButtonGuiElementPacket_ = $CButtonGuiElementPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/$RecipeChecker" {
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $RecipeChecker<T extends $IMachineRecipe> {

constructor(recipe: T)

public "check"(tile: $MachineTile$Type, context: $ICraftingContext$Type, inventoryChanged: boolean): boolean
public "getRecipe"(): T
public "isInventoryRequirementsOnly"(): boolean
public "isInventoryRequirementsOk"(): boolean
get "recipe"(): T
get "inventoryRequirementsOnly"(): boolean
get "inventoryRequirementsOk"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeChecker$Type<T> = ($RecipeChecker<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeChecker_<T> = $RecipeChecker$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentPropertyListWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ComponentPropertyListWidget$ComponentPropertyEntry, $ComponentPropertyListWidget$ComponentPropertyEntry$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentPropertyListWidget$ComponentPropertyEntry"
import {$ListWidget, $ListWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ComponentPropertyListWidget extends $ListWidget<($ComponentPropertyListWidget$ComponentPropertyEntry)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, width: integer, height: integer, itemHeight: integer)

public "add"<T extends $AbstractWidget>(title: $Component$Type, widget: T): T
public "setFocused"(arg0: boolean): void
public "isFocused"(): boolean
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentPropertyListWidget$Type = ($ComponentPropertyListWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentPropertyListWidget_ = $ComponentPropertyListWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/appearance/$ModelSelectionPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$MachineModelLocation, $MachineModelLocation$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineModelLocation"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $ModelSelectionPopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, supplier: $Supplier$Type<($MachineModelLocation$Type)>, consumer: $Consumer$Type<($MachineModelLocation$Type)>, isBlock: boolean)

public "render"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "refreshBoxSuggestions"(): void
public static "renderModel"(graphics: $GuiGraphics$Type, x: float, y: float, loc: $MachineModelLocation$Type, scale: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelSelectionPopup$Type = ($ModelSelectionPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelSelectionPopup_ = $ModelSelectionPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/element/$EmptyGuiElementWidget" {
import {$EmptyGuiElement, $EmptyGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$EmptyGuiElement"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"
import {$IMachineScreen, $IMachineScreen$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IMachineScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $EmptyGuiElementWidget extends $AbstractGuiElementWidget<($EmptyGuiElement)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(element: $EmptyGuiElement$Type, screen: $IMachineScreen$Type)

public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyGuiElementWidget$Type = ($EmptyGuiElementWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyGuiElementWidget_ = $EmptyGuiElementWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$BlockIngredient" {
import {$PartialBlockState, $PartialBlockState$Type} from "packages/fr/frinn/custommachinery/common/util/$PartialBlockState"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $BlockIngredient implements $IIngredient<($PartialBlockState)> {
static readonly "AIR": $BlockIngredient
static readonly "ANY": $BlockIngredient
static readonly "MACHINE": $BlockIngredient
static readonly "CODEC": $NamedCodec<($BlockIngredient)>

constructor(partialBlockState: $PartialBlockState$Type)

public "toString"(): string
public "test"(partialBlockState: $PartialBlockState$Type): boolean
public "getAll"(): $List<($PartialBlockState)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public "negate"(): $Predicate<($PartialBlockState)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($PartialBlockState)>
public static "isEqual"<T>(arg0: any): $Predicate<($PartialBlockState)>
get "all"(): $List<($PartialBlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIngredient$Type = ($BlockIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIngredient_ = $BlockIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$ConfigGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ConfigGuiElement, $ConfigGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ConfigGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $ConfigGuiElementBuilder implements $IGuiElementBuilder<($ConfigGuiElement)> {

constructor()

public "type"(): $GuiElementType<($ConfigGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $ConfigGuiElement$Type): $ConfigGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $ConfigGuiElement$Type, onFinish: $Consumer$Type<($ConfigGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigGuiElementBuilder$Type = ($ConfigGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigGuiElementBuilder_ = $ConfigGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/$TexturedButton" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Button, $Button$Type} from "packages/net/minecraft/client/gui/components/$Button"
import {$TexturedButton$Builder, $TexturedButton$Builder$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$TexturedButton$Builder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Button$OnPress, $Button$OnPress$Type} from "packages/net/minecraft/client/gui/components/$Button$OnPress"

export class $TexturedButton extends $Button {
static readonly "SMALL_WIDTH": integer
static readonly "DEFAULT_WIDTH": integer
static readonly "DEFAULT_HEIGHT": integer
 "onPress": $Button$OnPress
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer


public static "builder"(message: $Component$Type, texture: $ResourceLocation$Type, onPress: $Button$OnPress$Type): $TexturedButton$Builder
public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TexturedButton$Type = ($TexturedButton);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TexturedButton_ = $TexturedButton$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IDisplayInfo$TooltipPredicate, $IDisplayInfo$TooltipPredicate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo$TooltipPredicate"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IDisplayInfo, $IDisplayInfo$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IDisplayInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $DisplayInfoTemplate {
static readonly "TOOLTIPS": $NamedCodec<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
static readonly "CODEC": $NamedCodec<($DisplayInfoTemplate)>

constructor()

public "build"(info: $IDisplayInfo$Type): void
public "item"(stack: $ItemStack$Type): $DisplayInfoTemplate
public "texture"(icon: $ResourceLocation$Type, width: integer, height: integer, u: integer, v: integer): $DisplayInfoTemplate
public "tooltip"(component: $Component$Type, predicate: $IDisplayInfo$TooltipPredicate$Type): $DisplayInfoTemplate
public "tooltip"(component: $Component$Type): $DisplayInfoTemplate
public "getTooltips"(): $List<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
public "sprite"(atlas: $ResourceLocation$Type, sprite: $ResourceLocation$Type): $DisplayInfoTemplate
get "tooltips"(): $List<($Pair<($Component), ($IDisplayInfo$TooltipPredicate)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayInfoTemplate$Type = ($DisplayInfoTemplate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisplayInfoTemplate_ = $DisplayInfoTemplate$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/experience/$ExperienceJEIIngredientRenderer" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$ExperienceGuiElement, $ExperienceGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ExperienceGuiElement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JEIIngredientRenderer, $JEIIngredientRenderer$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$JEIIngredientRenderer"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Experience, $Experience$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Experience"

export class $ExperienceJEIIngredientRenderer extends $JEIIngredientRenderer<($Experience), ($ExperienceGuiElement)> {
readonly "element": E

constructor(element: $ExperienceGuiElement$Type)

public "getType"(): $IIngredientType<($Experience)>
public "render"(graphics: $GuiGraphics$Type, ingredient: $Experience$Type): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getTooltip"(ingredient: $Experience$Type, iTooltipFlag: $TooltipFlag$Type): $List<($Component)>
get "type"(): $IIngredientType<($Experience)>
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceJEIIngredientRenderer$Type = ($ExperienceJEIIngredientRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperienceJEIIngredientRenderer_ = $ExperienceJEIIngredientRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$CustomMachineDamageSource" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $CustomMachineDamageSource extends $DamageSource {

constructor(machine: $MachineTile$Type)

public "getLocalizedDeathMessage"(dead: $LivingEntity$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineDamageSource$Type = ($CustomMachineDamageSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineDamageSource_ = $CustomMachineDamageSource$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/render/$BoxCreatorRenderer" {
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"

export class $BoxCreatorRenderer {

constructor()

public static "renderSelectedBlocks"(pose: $PoseStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxCreatorRenderer$Type = ($BoxCreatorRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxCreatorRenderer_ = $BoxCreatorRenderer$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$EnergyIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$Energy, $Energy$Type} from "packages/fr/frinn/custommachinery/impl/integration/jei/$Energy"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $EnergyIngredientWrapper implements $IJEIIngredientWrapper<($Energy)> {

constructor(mode: $RequirementIOMode$Type, amount: integer, chance: double, isPerTick: boolean, recipeTime: integer)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyIngredientWrapper$Type = ($EnergyIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyIngredientWrapper_ = $EnergyIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$RecipeChecker, $RecipeChecker$Type} from "packages/fr/frinn/custommachinery/common/crafting/$RecipeChecker"

export class $CustomMachineRecipe implements $Recipe<($Container)>, $IMachineRecipe {

constructor(id: $ResourceLocation$Type, machine: $ResourceLocation$Type, time: integer, requirements: $List$Type<($IRequirement$Type<(any)>)>, jeiRequirements: $List$Type<($IRequirement$Type<(any)>)>, priority: integer, jeiPriority: integer, resetOnError: boolean, hidden: boolean, appearance: $MachineAppearance$Type, guiElements: $List$Type<($IGuiElement$Type)>)

public "getPriority"(): integer
public "getJeiPriority"(): integer
public "getJeiRequirements"(): $List<($IRequirement<(any)>)>
public "showInJei"(): boolean
public "getMachineId"(): $ResourceLocation
public "getResultItem"(access: $RegistryAccess$Type): $ItemStack
public "shouldResetOnError"(): boolean
public "getRecipeId"(): $ResourceLocation
public "getRecipeTime"(): integer
public "getGuiElements"(): $List<($IGuiElement)>
public "checker"(): $RecipeChecker<($CustomMachineRecipe)>
public "canCraftInDimensions"(width: integer, height: integer): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
public "getCustomAppearance"(baseAppearance: $IMachineAppearance$Type): $MachineAppearance
public "getCustomGuiElements"(baseGuiElements: $List$Type<($IGuiElement$Type)>): $List<($IGuiElement)>
public "getAppearance"(): $MachineAppearance
public "assemble"(inv: $Container$Type, access: $RegistryAccess$Type): $ItemStack
public "getRequirements"(): $List<($IRequirement<(any)>)>
public "getId"(): $ResourceLocation
public "matches"(inv: $Container$Type, worldIn: $Level$Type): boolean
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "showNotification"(): boolean
public "isSpecial"(): boolean
public "getDisplayInfoRequirements"(): $List<($IRequirement<(any)>)>
public "getJEIIngredientRequirements"(): $List<($IJEIIngredientRequirement<(any)>)>
public "getType"(): $ResourceLocation
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getGroup"(): string
public "getMod"(): string
get "priority"(): integer
get "jeiPriority"(): integer
get "jeiRequirements"(): $List<($IRequirement<(any)>)>
get "machineId"(): $ResourceLocation
get "recipeId"(): $ResourceLocation
get "recipeTime"(): integer
get "guiElements"(): $List<($IGuiElement)>
get "serializer"(): $RecipeSerializer<(any)>
get "appearance"(): $MachineAppearance
get "requirements"(): $List<($IRequirement<(any)>)>
get "id"(): $ResourceLocation
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "special"(): boolean
get "displayInfoRequirements"(): $List<($IRequirement<(any)>)>
get "jEIIngredientRequirements"(): $List<($IJEIIngredientRequirement<(any)>)>
get "type"(): $ResourceLocation
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "group"(): string
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRecipe$Type = ($CustomMachineRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRecipe_ = $CustomMachineRecipe$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$CustomMachineBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$DyeColor, $DyeColor$Type} from "packages/net/minecraft/world/item/$DyeColor"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$IBlockWithWorldlyProperties, $IBlockWithWorldlyProperties$Type} from "packages/com/communi/suggestu/saecularia/caudices/core/block/$IBlockWithWorldlyProperties"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$SignalGetter, $SignalGetter$Type} from "packages/net/minecraft/world/level/$SignalGetter"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $CustomMachineBlock extends $Block implements $EntityBlock, $IBlockWithWorldlyProperties {
readonly "renderType": string
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor()
constructor(renderType: string, occlusion: boolean)

public "rotate"(state: $BlockState$Type, level: $LevelAccessor$Type, pos: $BlockPos$Type, rotation: $Rotation$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, type: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getColor"(): $DyeColor
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "playerDestroy"(level: $Level$Type, player: $Player$Type, pos: $BlockPos$Type, state: $BlockState$Type, blockEntity: $BlockEntity$Type, tool: $ItemStack$Type): void
public "setPlacedBy"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
public "getCloneItemStack"(level: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "playerWillDestroy"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, player: $Player$Type): void
public "canHarvestBlock"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getExplosionResistance"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): float
public "shouldDisplayFluidOverlay"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, fluidState: $FluidState$Type): boolean
public "getBeaconColorMultiplier"(blockState: $BlockState$Type, levelReader: $LevelReader$Type, blockPos: $BlockPos$Type, blockPos1: $BlockPos$Type): (float)[]
public "getSoundType"(state: $BlockState$Type, level: $LevelReader$Type, pos: $BlockPos$Type, entity: $Entity$Type): $SoundType
public "getFriction"(state: $BlockState$Type, level: $LevelReader$Type, pos: $BlockPos$Type, entity: $Entity$Type): float
public static "makeProperties"(occlusion: boolean): $BlockBehaviour$Properties
public "getCloneItemStack"(state: $BlockState$Type, hitResult: $HitResult$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): $ItemStack
public "getLightEmission"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): integer
public "shouldCheckWeakPower"(blockState: $BlockState$Type, levelReader: $SignalGetter$Type, blockPos: $BlockPos$Type, direction: $Direction$Type): boolean
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, isMoving: boolean): void
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "getRenderShape"(state: $BlockState$Type): $RenderShape
public "isSignalSource"(state: $BlockState$Type): boolean
public "hasAnalogOutputSignal"(state: $BlockState$Type): boolean
public "getDrops"(state: $BlockState$Type, builder: $LootParams$Builder$Type): $List<($ItemStack)>
public "getCollisionShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "getAnalogOutputSignal"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type): integer
public "getShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "getDestroyProgress"(state: $BlockState$Type, player: $Player$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): float
public "getSignal"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, side: $Direction$Type): integer
public "getDirectSignal"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, side: $Direction$Type): integer
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
public "canBeGrass"(arg0: $LevelReader$Type, arg1: $BlockState$Type, arg2: $BlockPos$Type, arg3: $BlockState$Type, arg4: $BlockPos$Type): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineBlock$Type = ($CustomMachineBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineBlock_ = $CustomMachineBlock$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/init/$StructureCreatorItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StructureCreatorItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(properties: $Item$Properties$Type)

public static "addSelectedBlock"(stack: $ItemStack$Type, pos: $BlockPos$Type): void
public static "getSelectedBlocks"(stack: $ItemStack$Type): $List<($BlockPos)>
public "use"(level: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "isFoil"(stack: $ItemStack$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public static "removeSelectedBlock"(stack: $ItemStack$Type, pos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCreatorItem$Type = ($StructureCreatorItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructureCreatorItem_ = $StructureCreatorItem$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$CEditMachinePacket" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $CEditMachinePacket extends $BaseC2SMessage {

constructor(machine: $CustomMachine$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $CEditMachinePacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CEditMachinePacket$Type = ($CEditMachinePacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CEditMachinePacket_ = $CEditMachinePacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IMachineModelLocation, $IMachineModelLocation$Type} from "packages/fr/frinn/custommachinery/impl/util/$IMachineModelLocation"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MachineAppearance implements $IMachineAppearance {
static readonly "CODEC": $NamedMapCodec<($Map<($MachineAppearanceProperty<(any)>), (any)>)>
static readonly "DEFAULT": $MachineAppearance

constructor(properties: $Map$Type<($MachineAppearanceProperty$Type<(any)>), (any)>)

public "getProperty"<T>(property: $MachineAppearanceProperty$Type<(T)>): T
public "getProperties"(): $Map<($MachineAppearanceProperty<(any)>), (any)>
public "requiresCorrectToolForDrops"(): boolean
public "getCollisionShape"(): $Function<($Direction), ($VoxelShape)>
public "getResistance"(): float
public "getAmbientSound"(): $SoundEvent
public "getMiningLevel"(): $TagKey<($Block)>
public "getHardness"(): float
public "getItemModel"(): $IMachineModelLocation
public "getColor"(): integer
public "getLightLevel"(): integer
public "getTool"(): $List<($TagKey<($Block)>)>
public "getBlockModel"(): $IMachineModelLocation
public static "defaultProperties"(): $Map<($MachineAppearanceProperty<(any)>), (any)>
public "getInteractionSound"(): $SoundType
get "properties"(): $Map<($MachineAppearanceProperty<(any)>), (any)>
get "collisionShape"(): $Function<($Direction), ($VoxelShape)>
get "resistance"(): float
get "ambientSound"(): $SoundEvent
get "miningLevel"(): $TagKey<($Block)>
get "hardness"(): float
get "itemModel"(): $IMachineModelLocation
get "color"(): integer
get "lightLevel"(): integer
get "tool"(): $List<($TagKey<($Block)>)>
get "blockModel"(): $IMachineModelLocation
get "interactionSound"(): $SoundType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearance$Type = ($MachineAppearance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearance_ = $MachineAppearance$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent$Template" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$EnergyMachineComponent, $EnergyMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$EnergyMachineComponent"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $EnergyMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($EnergyMachineComponent)> {
static readonly "CODEC": $NamedCodec<($EnergyMachineComponent$Template)>

constructor(capacity: long, maxInput: long, maxOutput: long, config: $SideConfig$Template$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getId"(): string
public "getType"(): $MachineComponentType<($EnergyMachineComponent)>
public "capacity"(): long
public "config"(): $SideConfig$Template
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
public "maxInput"(): long
public "maxOutput"(): long
get "id"(): string
get "type"(): $MachineComponentType<($EnergyMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyMachineComponent$Template$Type = ($EnergyMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyMachineComponent$Template_ = $EnergyMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/ingredient/$FluidIngredient" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $FluidIngredient implements $IIngredient<($Fluid)> {
static readonly "CODEC": $NamedCodec<($FluidIngredient)>

constructor(fluid: $Fluid$Type)

public "toString"(): string
public "test"(fluid: $Fluid$Type): boolean
public "getAll"(): $List<($Fluid)>
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public "negate"(): $Predicate<($Fluid)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($Fluid)>
public static "isEqual"<T>(arg0: any): $Predicate<($Fluid)>
get "all"(): $List<($Fluid)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredient$Type = ($FluidIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredient_ = $FluidIngredient$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$ItemFilterIngredientWrapper" {
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"

export class $ItemFilterIngredientWrapper implements $IJEIIngredientWrapper<($ItemStack)> {

constructor(ingredient: $Ingredient$Type, slot: string)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFilterIngredientWrapper$Type = ($ItemFilterIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFilterIngredientWrapper_ = $ItemFilterIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/builder/$MachineAppearanceBuilder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$MachineModelLocation, $MachineModelLocation$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineModelLocation"
import {$MachineShape, $MachineShape$Type} from "packages/fr/frinn/custommachinery/common/util/$MachineShape"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MachineAppearanceProperty, $MachineAppearanceProperty$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineAppearanceProperty"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MachineAppearanceBuilder {

constructor(properties: $Map$Type<($MachineAppearanceProperty$Type<(any)>), (any)>, status: $MachineStatus$Type)
constructor(appearance: $MachineAppearance$Type, status: $MachineStatus$Type)
constructor(status: $MachineStatus$Type)

public "getProperty"<T>(property: $MachineAppearanceProperty$Type<(T)>): T
public "setProperty"<T>(property: $MachineAppearanceProperty$Type<(T)>, value: T): void
public "build"(): $MachineAppearance
public "setColor"(color: integer): void
public "getShape"(): $MachineShape
public "getResistance"(): float
public "setSound"(sound: $SoundEvent$Type): void
public "getStatus"(): $MachineStatus
public "getMiningLevel"(): $TagKey<($Block)>
public "getHardness"(): float
public "getItemModel"(): $MachineModelLocation
public "getColor"(): integer
public "getLightLevel"(): integer
public "setToolType"(toolType: $TagKey$Type<($Block$Type)>): void
public "setHardness"(hardness: float): void
public "setBlockModel"(blockModel: $MachineModelLocation$Type): void
public "setItemModel"(itemModel: $MachineModelLocation$Type): void
public "setMiningLevel"(miningLevel: $TagKey$Type<($Block$Type)>): void
public "setResistance"(resistance: float): void
public "getBlockModel"(): $MachineModelLocation
public "setLightLevel"(lightLevel: integer): void
public "setShape"(shape: $MachineShape$Type): void
public "getSound"(): $SoundEvent
public "getToolType"(): $List<($TagKey<($Block)>)>
set "color"(value: integer)
get "shape"(): $MachineShape
get "resistance"(): float
set "sound"(value: $SoundEvent$Type)
get "status"(): $MachineStatus
get "miningLevel"(): $TagKey<($Block)>
get "hardness"(): float
get "itemModel"(): $MachineModelLocation
get "color"(): integer
get "lightLevel"(): integer
set "toolType"(value: $TagKey$Type<($Block$Type)>)
set "hardness"(value: float)
set "blockModel"(value: $MachineModelLocation$Type)
set "itemModel"(value: $MachineModelLocation$Type)
set "miningLevel"(value: $TagKey$Type<($Block$Type)>)
set "resistance"(value: float)
get "blockModel"(): $MachineModelLocation
set "lightLevel"(value: integer)
set "shape"(value: $MachineShape$Type)
get "sound"(): $SoundEvent
get "toolType"(): $List<($TagKey<($Block)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineAppearanceBuilder$Type = ($MachineAppearanceBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineAppearanceBuilder_ = $MachineAppearanceBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ComponentIOMode, $ComponentIOMode$Type} from "packages/fr/frinn/custommachinery/api/component/$ComponentIOMode"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$SideConfig$Template, $SideConfig$Template$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig$Template"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISideConfigComponent, $ISideConfigComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISideConfigComponent"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$AbstractMachineComponent, $AbstractMachineComponent$Type} from "packages/fr/frinn/custommachinery/impl/component/$AbstractMachineComponent"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"

export class $FluidMachineComponent extends $AbstractMachineComponent implements $ISerializableComponent, $ISyncableStuff, $IComparatorInputComponent, $ISideConfigComponent {

constructor(manager: $IMachineComponentManager$Type, mode: $ComponentIOMode$Type, id: string, capacity: long, maxInput: long, maxOutput: long, filter: $List$Type<($IIngredient$Type<($Fluid$Type)>)>, whitelist: boolean, configTemplate: $SideConfig$Template$Type, unique: boolean)

public "extract"(amount: long, simulate: boolean): $FluidStack
public "insert"(fluid: $Fluid$Type, amount: long, nbt: $CompoundTag$Type, simulate: boolean): long
public "getId"(): string
public "getType"(): $MachineComponentType<($FluidMachineComponent)>
public "getCapacity"(): long
public "deserialize"(nbt: $CompoundTag$Type): void
public "getRecipeRemainingSpace"(): long
public "setFluidStack"(fluidStack: $FluidStack$Type): void
public "getRemainingSpace"(): long
public "getMaxOutput"(): long
public "recipeInsert"(fluid: $Fluid$Type, amount: long, nbt: $CompoundTag$Type): void
public "recipeExtract"(amount: long): void
public "getComparatorInput"(): integer
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "serialize"(nbt: $CompoundTag$Type): void
public "getConfig"(): $SideConfig
public "getMaxInput"(): long
public "getFluidStack"(): $FluidStack
public "isFluidValid"(stack: $FluidStack$Type): boolean
get "id"(): string
get "type"(): $MachineComponentType<($FluidMachineComponent)>
get "capacity"(): long
get "recipeRemainingSpace"(): long
set "fluidStack"(value: $FluidStack$Type)
get "remainingSpace"(): long
get "maxOutput"(): long
get "comparatorInput"(): integer
get "config"(): $SideConfig
get "maxInput"(): long
get "fluidStack"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMachineComponent$Type = ($FluidMachineComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidMachineComponent_ = $FluidMachineComponent$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/widget/config/$SideModeButtonWidget" {
import {$AbstractWidget, $AbstractWidget$Type} from "packages/net/minecraft/client/gui/components/$AbstractWidget"
import {$RelativeSide, $RelativeSide$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$RelativeSide"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$SideConfig, $SideConfig$Type} from "packages/fr/frinn/custommachinery/impl/component/config/$SideConfig"

export class $SideModeButtonWidget extends $AbstractWidget {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(x: integer, y: integer, config: $SideConfig$Type, side: $RelativeSide$Type)

public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "m_87963_"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTick: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SideModeButtonWidget$Type = ($SideModeButtonWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SideModeButtonWidget_ = $SideModeButtonWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/kubejs/requirements/$FluidPerTickRequirementJS" {
import {$RecipeJSBuilder, $RecipeJSBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/kubejs/$RecipeJSBuilder"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $FluidPerTickRequirementJS extends $RecipeJSBuilder {

 "produceFluidPerTick"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
 "produceFluidPerTick"(stack: $FluidStackJS$Type): $RecipeJSBuilder
 "requireFluidPerTick"(stack: $FluidStackJS$Type): $RecipeJSBuilder
 "requireFluidPerTick"(stack: $FluidStackJS$Type, tank: string): $RecipeJSBuilder
 "requireFluidTagPerTick"(tag: string, amount: integer, thing: any): $RecipeJSBuilder
 "requireFluidTagPerTick"(tag: string, amount: integer): $RecipeJSBuilder
 "requireFluidTagPerTick"(tag: string, amount: integer, nbt: $Map$Type<(any), (any)>, tank: string): $RecipeJSBuilder
 "error"(arg0: string, ...arg1: (any)[]): $RecipeJSBuilder
 "addRequirement"(arg0: $IRequirement$Type<(any)>): $RecipeJSBuilder
}

export namespace $FluidPerTickRequirementJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPerTickRequirementJS$Type = ($FluidPerTickRequirementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPerTickRequirementJS_ = $FluidPerTickRequirementJS$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedChanceableRequirement" {
import {$IChanceableRequirement, $IChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IChanceableRequirement"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"
import {$AbstractDelayedRequirement, $AbstractDelayedRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractDelayedRequirement"

export class $AbstractDelayedChanceableRequirement<T extends $IMachineComponent> extends $AbstractDelayedRequirement<(T)> implements $IChanceableRequirement<(T)> {

constructor(mode: $RequirementIOMode$Type)

public "shouldSkip"(component: T, rand: $Random$Type, context: $ICraftingContext$Type): boolean
public "getChance"(): double
public "setChance"(chance: double): void
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "chance"(): double
set "chance"(value: double)
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDelayedChanceableRequirement$Type<T> = ($AbstractDelayedChanceableRequirement<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractDelayedChanceableRequirement_<T> = $AbstractDelayedChanceableRequirement$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager" {
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IDumpComponent, $IDumpComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IDumpComponent"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$IComponentHandler, $IComponentHandler$Type} from "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IMachineComponentManager {

 "getLevel"(): $Level
 "getComponent"<T extends $IMachineComponent>(arg0: $MachineComponentType$Type<(T)>): $Optional<(T)>
 "getServer"(): $MinecraftServer
 "hasComponent"(arg0: $MachineComponentType$Type<(any)>): boolean
 "getDumpComponents"(): $List<($IDumpComponent)>
 "getTile"(): $MachineTile
 "markDirty"(): void
 "getComponents"(): $Map<($MachineComponentType<(any)>), ($IMachineComponent)>
 "getComponentHandler"<T extends $IMachineComponent>(arg0: $MachineComponentType$Type<(T)>): $Optional<($IComponentHandler<(T)>)>
 "getTickableComponents"(): $List<($ITickableComponent)>
 "getComparatorInputComponents"(): $List<($IComparatorInputComponent)>
 "getSyncableComponents"(): $List<($ISyncableStuff)>
 "getSerializableComponents"(): $List<($ISerializableComponent)>
}

export namespace $IMachineComponentManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineComponentManager$Type = ($IMachineComponentManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineComponentManager_ = $IMachineComponentManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/$CustomMachineRecipeCategory" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$AbstractRecipeCategory, $AbstractRecipeCategory$Type} from "packages/fr/frinn/custommachinery/client/integration/jei/$AbstractRecipeCategory"
import {$RecipeType, $RecipeType$Type} from "packages/mezz/jei/api/recipe/$RecipeType"
import {$CustomMachine, $CustomMachine$Type} from "packages/fr/frinn/custommachinery/common/machine/$CustomMachine"
import {$CustomMachineRecipe, $CustomMachineRecipe$Type} from "packages/fr/frinn/custommachinery/common/crafting/machine/$CustomMachineRecipe"

export class $CustomMachineRecipeCategory extends $AbstractRecipeCategory<($CustomMachineRecipe)> {

constructor(machine: $CustomMachine$Type, type: $RecipeType$Type<($CustomMachineRecipe$Type)>, helpers: $IJeiHelpers$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineRecipeCategory$Type = ($CustomMachineRecipeCategory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineRecipeCategory_ = $CustomMachineRecipeCategory$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$FluidGuiElement" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$IComponentGuiElement, $IComponentGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IComponentGuiElement"
import {$MachineTile, $MachineTile$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineTile"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"

export class $FluidGuiElement extends $AbstractTexturedGuiElement implements $IComponentGuiElement<($FluidMachineComponent)> {
static readonly "BASE_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($FluidGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, id: string, highlight: boolean)

public "getComponentType"(): $MachineComponentType<($FluidMachineComponent)>
public "getType"(): $GuiElementType<($FluidGuiElement)>
public "handleClick"(button: byte, tile: $MachineTile$Type, container: $AbstractContainerMenu$Type, player: $ServerPlayer$Type): void
public "highlight"(): boolean
public "getComponentId"(): string
public "getComponent"(manager: $IMachineComponentManager$Type): $Optional<($FluidMachineComponent)>
get "componentType"(): $MachineComponentType<($FluidMachineComponent)>
get "type"(): $GuiElementType<($FluidGuiElement)>
get "componentId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidGuiElement$Type = ($FluidGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidGuiElement_ = $FluidGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/$MachineListWidget" {
import {$MachineCreationScreen, $MachineCreationScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineCreationScreen"
import {$ListWidget, $ListWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/widget/$ListWidget"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MachineListWidget$MachineEntry, $MachineListWidget$MachineEntry$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineListWidget$MachineEntry"

export class $MachineListWidget extends $ListWidget<($MachineListWidget$MachineEntry)> {
static readonly "WIDGETS_LOCATION": $ResourceLocation
static readonly "ACCESSIBILITY_TEXTURE": $ResourceLocation
 "height": integer
 "x": integer
 "y": integer
 "active": boolean
 "visible": boolean
static readonly "UNSET_FG_COLOR": integer

constructor(parent: $MachineCreationScreen$Type, x: integer, y: integer, width: integer, height: integer, itemHeight: integer)

public "reload"(): void
public "setFocused"(arg0: boolean): void
public "isFocused"(): boolean
set "focused"(value: boolean)
get "focused"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineListWidget$Type = ($MachineListWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineListWidget_ = $MachineListWidget$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/$SUpdateContainerPacket" {
import {$IData, $IData$Type} from "packages/fr/frinn/custommachinery/api/network/$IData"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SUpdateContainerPacket extends $BaseS2CMessage {

constructor(windowId: integer, data: $List$Type<($IData$Type<(any)>)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public static "read"(buf: $FriendlyByteBuf$Type): $SUpdateContainerPacket
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SUpdateContainerPacket$Type = ($SUpdateContainerPacket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SUpdateContainerPacket_ = $SUpdateContainerPacket$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentBuilderPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentPropertyListWidget, $ComponentPropertyListWidget$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$ComponentPropertyListWidget"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"

export class $ComponentBuilderPopup<T extends $IMachineComponentTemplate<(any)>> extends $PopupScreen {
static readonly "CONFIRM": $Component
static readonly "CANCEL": $Component
 "propertyList": $ComponentPropertyListWidget
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $BaseScreen$Type, template: T, onFinish: $Consumer$Type<(T)>, title: $Component$Type)

public "parseLong"(s: string): long
public "baseTemplate"(): $Optional<(T)>
public "checkLong"(s: string): boolean
public "makeTemplate"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBuilderPopup$Type<T> = ($ComponentBuilderPopup<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBuilderPopup_<T> = $ComponentBuilderPopup$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/$CTUtils" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CTUtils {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CTUtils$Type = ($CTUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CTUtils_ = $CTUtils$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/guielement/$StatusGuiElement" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"
import {$AbstractTexturedGuiElement, $AbstractTexturedGuiElement$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractTexturedGuiElement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $StatusGuiElement extends $AbstractTexturedGuiElement {
static readonly "BASE_STATUS_IDLE_TEXTURE": $ResourceLocation
static readonly "BASE_STATUS_RUNNING_TEXTURE": $ResourceLocation
static readonly "BASE_STATUS_ERRORED_TEXTURE": $ResourceLocation
static readonly "CODEC": $NamedCodec<($StatusGuiElement)>

constructor(properties: $AbstractGuiElement$Properties$Type, idleTexture: $ResourceLocation$Type, runningTexture: $ResourceLocation$Type, erroredTexture: $ResourceLocation$Type)

public "getType"(): $GuiElementType<($StatusGuiElement)>
public "getIdleTexture"(): $ResourceLocation
public "getErroredTexture"(): $ResourceLocation
public "getRunningTexture"(): $ResourceLocation
get "type"(): $GuiElementType<($StatusGuiElement)>
get "idleTexture"(): $ResourceLocation
get "erroredTexture"(): $ResourceLocation
get "runningTexture"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatusGuiElement$Type = ($StatusGuiElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatusGuiElement_ = $StatusGuiElement$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/component/variant/$ItemComponentVariant" {
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $ItemComponentVariant implements $IComponentVariant {

constructor()

public "canAccept"(arg0: $IMachineComponentManager$Type, arg1: $ItemStack$Type): boolean
public "canOutput"(manager: $IMachineComponentManager$Type): boolean
public "shouldDrop"(manager: $IMachineComponentManager$Type): boolean
public "getId"(): $ResourceLocation
public static "codec"<C extends $IMachineComponent>(type: $Supplier$Type<($MachineComponentType$Type<(C)>)>): $NamedMapCodec<($IComponentVariant)>
public "getCodec"(): $NamedCodec<(any)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentVariant$Type = ($ItemComponentVariant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemComponentVariant_ = $ItemComponentVariant$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/$BackgroundEditorPopup" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$BaseScreen, $BaseScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/$BaseScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BackgroundEditorPopup extends $PopupScreen {
readonly "parent": $BaseScreen
readonly "mc": $Minecraft
 "x": integer
 "y": integer
 "xSize": integer
 "ySize": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(parent: $MachineEditScreen$Type)

public "closed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BackgroundEditorPopup$Type = ($BackgroundEditorPopup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BackgroundEditorPopup_ = $BackgroundEditorPopup$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent$Template" {
import {$RedstoneMachineComponent, $RedstoneMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$RedstoneMachineComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IMachineComponentManager, $IMachineComponentManager$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentManager"
import {$IMachineComponentTemplate, $IMachineComponentTemplate$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponentTemplate"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $RedstoneMachineComponent$Template extends $Record implements $IMachineComponentTemplate<($RedstoneMachineComponent)> {
static readonly "CODEC": $NamedCodec<($RedstoneMachineComponent$Template)>

constructor(powerToPause: integer, craftingPowerOutput: integer, idlePowerOutput: integer, erroredPowerOutput: integer, pausedPowerOutput: integer, comparatorInputType: $MachineComponentType$Type<(any)>, comparatorInputId: string)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getId"(): string
public "getType"(): $MachineComponentType<($RedstoneMachineComponent)>
public "build"(manager: $IMachineComponentManager$Type): $RedstoneMachineComponent
public "canAccept"(ingredient: any, isInput: boolean, manager: $IMachineComponentManager$Type): boolean
public "powerToPause"(): integer
public "erroredPowerOutput"(): integer
public "pausedPowerOutput"(): integer
public "comparatorInputId"(): string
public "idlePowerOutput"(): integer
public "comparatorInputType"(): $MachineComponentType<(any)>
public "craftingPowerOutput"(): integer
get "id"(): string
get "type"(): $MachineComponentType<($RedstoneMachineComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneMachineComponent$Template$Type = ($RedstoneMachineComponent$Template);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RedstoneMachineComponent$Template_ = $RedstoneMachineComponent$Template$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$LootTableRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$ItemComponentHandler, $ItemComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$ItemComponentHandler"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $LootTableRequirement extends $AbstractRequirement<($ItemComponentHandler)> implements $IJEIIngredientRequirement<($ItemStack)> {
static readonly "CODEC": $NamedCodec<($LootTableRequirement)>

constructor(lootTable: $ResourceLocation$Type, luck: float)

public "test"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($LootTableRequirement)>
public "processStart"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $ItemComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($ItemStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($LootTableRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableRequirement$Type = ($LootTableRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableRequirement_ = $LootTableRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/forge/client/$CustomMachineBakedModel" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$ItemOverrides, $ItemOverrides$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemOverrides"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$IDynamicBakedModel, $IDynamicBakedModel$Type} from "packages/net/minecraftforge/client/model/$IDynamicBakedModel"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$MachineAppearance, $MachineAppearance$Type} from "packages/fr/frinn/custommachinery/common/machine/$MachineAppearance"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$IMachineAppearance, $IMachineAppearance$Type} from "packages/fr/frinn/custommachinery/api/machine/$IMachineAppearance"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$ItemTransforms, $ItemTransforms$Type} from "packages/net/minecraft/client/renderer/block/model/$ItemTransforms"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ChunkRenderTypeSet, $ChunkRenderTypeSet$Type} from "packages/net/minecraftforge/client/$ChunkRenderTypeSet"
import {$MachineStatus, $MachineStatus$Type} from "packages/fr/frinn/custommachinery/api/machine/$MachineStatus"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export class $CustomMachineBakedModel implements $IDynamicBakedModel {
static readonly "APPEARANCE": $ModelProperty<($MachineAppearance)>
static readonly "STATUS": $ModelProperty<($MachineStatus)>

constructor(defaults: $Map$Type<($MachineStatus$Type), ($ResourceLocation$Type)>)

public "usesBlockLight"(): boolean
public "isGui3d"(): boolean
public "getParticleIcon"(): $TextureAtlasSprite
public "getRenderTypes"(stack: $ItemStack$Type, fabulous: boolean): $List<($RenderType)>
public "getRenderTypes"(state: $BlockState$Type, rand: $RandomSource$Type, data: $ModelData$Type): $ChunkRenderTypeSet
public "isCustomRenderer"(): boolean
public "getOverrides"(): $ItemOverrides
public "getMachineBlockModel"(appearance: $IMachineAppearance$Type, status: $MachineStatus$Type): $BakedModel
public "getMachineItemModel"(appearance: $IMachineAppearance$Type): $BakedModel
public "getRotatedDirection"(machineFacing: $Direction$Type, quad: $Direction$Type): $Direction
public "getTransforms"(): $ItemTransforms
public "getQuads"(state: $BlockState$Type, side: $Direction$Type, rand: $RandomSource$Type, data: $ModelData$Type, type: $RenderType$Type): $List<($BakedQuad)>
public "useAmbientOcclusion"(): boolean
public "getParticleIcon"(data: $ModelData$Type): $TextureAtlasSprite
public "getQuads"(arg0: $BlockState$Type, arg1: $Direction$Type, arg2: $RandomSource$Type): $List<($BakedQuad)>
public "useAmbientOcclusion"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
public "useAmbientOcclusion"(arg0: $BlockState$Type): boolean
public "getRenderPasses"(arg0: $ItemStack$Type, arg1: boolean): $List<($BakedModel)>
public "applyTransform"(arg0: $ItemDisplayContext$Type, arg1: $PoseStack$Type, arg2: boolean): $BakedModel
public "getModelData"(arg0: $BlockAndTintGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $ModelData$Type): $ModelData
public "useAmbientOcclusionWithLightEmission"(arg0: $BlockState$Type, arg1: $RenderType$Type): boolean
get "gui3d"(): boolean
get "particleIcon"(): $TextureAtlasSprite
get "customRenderer"(): boolean
get "overrides"(): $ItemOverrides
get "transforms"(): $ItemTransforms
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineBakedModel$Type = ($CustomMachineBakedModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineBakedModel_ = $CustomMachineBakedModel$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$FluidPerTickRequirement" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$ITickableRequirement, $ITickableRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$ITickableRequirement"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DisplayInfoTemplate, $DisplayInfoTemplate$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$DisplayInfoTemplate"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $FluidPerTickRequirement extends $AbstractChanceableRequirement<($FluidComponentHandler)> implements $ITickableRequirement<($FluidComponentHandler)>, $IJEIIngredientRequirement<($FluidStack)> {
static readonly "CODEC": $NamedCodec<($FluidPerTickRequirement)>

constructor(mode: $RequirementIOMode$Type, fluid: $IIngredient$Type<($Fluid$Type)>, amount: long, nbt: $CompoundTag$Type, tank: string)

public "test"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($FluidPerTickRequirement)>
public "processTick"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processStart"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($FluidStack)>)>
public "getMode"(): $RequirementIOMode
public "getDisplayInfoTemplate"(): $DisplayInfoTemplate
public "setDisplayInfoTemplate"(arg0: $DisplayInfoTemplate$Type): void
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($FluidPerTickRequirement)>
get "mode"(): $RequirementIOMode
get "displayInfoTemplate"(): $DisplayInfoTemplate
set "displayInfoTemplate"(value: $DisplayInfoTemplate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPerTickRequirement$Type = ($FluidPerTickRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPerTickRequirement_ = $FluidPerTickRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/api/component/variant/$RegisterComponentVariantEvent" {
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RegisterComponentVariantEvent$Register, $RegisterComponentVariantEvent$Register$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$RegisterComponentVariantEvent$Register"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$IComponentVariant, $IComponentVariant$Type} from "packages/fr/frinn/custommachinery/api/component/variant/$IComponentVariant"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterComponentVariantEvent {
static readonly "EVENT": $Event<($RegisterComponentVariantEvent$Register)>

constructor()

public "register"<C extends $IMachineComponent>(type: $MachineComponentType$Type<(C)>, id: $ResourceLocation$Type, codec: $NamedCodec$Type<(any)>): void
public "getComponentVariants"(): $Map<($MachineComponentType<(any)>), ($Map<($ResourceLocation), ($NamedCodec<($IComponentVariant)>)>)>
get "componentVariants"(): $Map<($MachineComponentType<(any)>), ($Map<($ResourceLocation), ($NamedCodec<($IComponentVariant)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterComponentVariantEvent$Type = ($RegisterComponentVariantEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterComponentVariantEvent_ = $RegisterComponentVariantEvent$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/util/$TagUtil" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $TagUtil {

constructor()

public static "getFluids"(tag: $TagKey$Type<($Fluid$Type)>): $Stream<($Fluid)>
public static "getItems"(tag: $TagKey$Type<($Item$Type)>): $Stream<($Item)>
public static "getBlocks"(tag: $TagKey$Type<($Block$Type)>): $Stream<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagUtil$Type = ($TagUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagUtil_ = $TagUtil$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/integration/jei/$WidgetToJeiIngredientRegistry" {
import {$IJeiHelpers, $IJeiHelpers$Type} from "packages/mezz/jei/api/helpers/$IJeiHelpers"
import {$IClickableIngredient, $IClickableIngredient$Type} from "packages/mezz/jei/api/runtime/$IClickableIngredient"
import {$AbstractGuiElementWidget, $AbstractGuiElementWidget$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElementWidget"

export class $WidgetToJeiIngredientRegistry {

constructor()

public static "init"(): void
public static "getIngredient"(widget: $AbstractGuiElementWidget$Type<(any)>, mouseX: double, mouseY: double, helpers: $IJeiHelpers$Type): $IClickableIngredient<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WidgetToJeiIngredientRegistry$Type = ($WidgetToJeiIngredientRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WidgetToJeiIngredientRegistry_ = $WidgetToJeiIngredientRegistry$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$DimensionRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $DimensionRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "dimensionWhitelist"(dimensions: (string)[]): T
 "dimensionWhitelist"(dimension: string): T
 "dimensionBlacklist"(dimension: string): T
 "dimensionBlacklist"(dimensions: (string)[]): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $DimensionRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionRequirementCT$Type<T> = ($DimensionRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionRequirementCT_<T> = $DimensionRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/component/builder/$FluidComponentBuilder" {
import {$FluidMachineComponent, $FluidMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$IMachineComponentBuilder, $IMachineComponentBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/component/$IMachineComponentBuilder"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$FluidMachineComponent$Template, $FluidMachineComponent$Template$Type} from "packages/fr/frinn/custommachinery/common/component/$FluidMachineComponent$Template"

export class $FluidComponentBuilder implements $IMachineComponentBuilder<($FluidMachineComponent), ($FluidMachineComponent$Template)> {

constructor()

public "type"(): $MachineComponentType<($FluidMachineComponent)>
public "render"(graphics: $GuiGraphics$Type, x: integer, y: integer, width: integer, height: integer, template: $FluidMachineComponent$Template$Type): void
public "makePopup"(parent: $MachineEditScreen$Type, template: $FluidMachineComponent$Template$Type, onFinish: $Consumer$Type<($FluidMachineComponent$Template$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidComponentBuilder$Type = ($FluidComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidComponentBuilder_ = $FluidComponentBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$ButtonRequirement" {
import {$AbstractRequirement, $AbstractRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractRequirement"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$DataMachineComponent, $DataMachineComponent$Type} from "packages/fr/frinn/custommachinery/common/component/$DataMachineComponent"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $ButtonRequirement extends $AbstractRequirement<($DataMachineComponent)> {
static readonly "CODEC": $NamedCodec<($ButtonRequirement)>

constructor(id: string, inverse: boolean)

public "test"(component: $DataMachineComponent$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<($DataMachineComponent)>
public "getType"(): $RequirementType<($ButtonRequirement)>
public "processStart"(component: $DataMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $DataMachineComponent$Type, context: $ICraftingContext$Type): $CraftingResult
get "componentType"(): $MachineComponentType<($DataMachineComponent)>
get "type"(): $RequirementType<($ButtonRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonRequirement$Type = ($ButtonRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonRequirement_ = $ButtonRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$BarGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$BarGuiElement, $BarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$BarGuiElement"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $BarGuiElementBuilder implements $IGuiElementBuilder<($BarGuiElement)> {

constructor()

public "type"(): $GuiElementType<($BarGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $BarGuiElement$Type): $BarGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $BarGuiElement$Type, onFinish: $Consumer$Type<($BarGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarGuiElementBuilder$Type = ($BarGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BarGuiElementBuilder_ = $BarGuiElementBuilder$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/network/syncable/$FluidStackSyncable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractSyncable, $AbstractSyncable$Type} from "packages/fr/frinn/custommachinery/impl/network/$AbstractSyncable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$FluidStackData, $FluidStackData$Type} from "packages/fr/frinn/custommachinery/common/network/data/$FluidStackData"

export class $FluidStackSyncable extends $AbstractSyncable<($FluidStackData), ($FluidStack)> {
 "lastKnownValue": T

constructor()

public static "create"(supplier: $Supplier$Type<($FluidStack$Type)>, consumer: $Consumer$Type<($FluidStack$Type)>): $FluidStackSyncable
public "needSync"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackSyncable$Type = ($FluidStackSyncable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStackSyncable_ = $FluidStackSyncable$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$Context" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$MachineCT, $MachineCT$Type} from "packages/fr/frinn/custommachinery/common/integration/crafttweaker/function/$MachineCT"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $Context {

constructor(internal: $ICraftingContext$Type)

public "error"(error: string): $CraftingResult
public "success"(): $CraftingResult
public "getModifiedSpeed"(): double
public "getBaseSpeed"(): double
public "getRemainingTime"(): double
public "setBaseSpeed"(baseSpeed: double): void
public "getMachine"(): $MachineCT
public "getTile"(): $BlockEntity
get "modifiedSpeed"(): double
get "baseSpeed"(): double
get "remainingTime"(): double
set "baseSpeed"(value: double)
get "machine"(): $MachineCT
get "tile"(): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Context$Type = ($Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Context_ = $Context$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$ComponentTab" {
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MachineEditTab, $MachineEditTab$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/tabs/$MachineEditTab"

export class $ComponentTab extends $MachineEditTab {
readonly "parent": $MachineEditScreen

constructor(parent: $MachineEditScreen$Type)

public "delete"(): void
public "create"(): void
public "edit"(): void
public "setupButtons"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentTab$Type = ($ComponentTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentTab_ = $ComponentTab$Type;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$EnhancedEitherCodec" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$NamedMapCodec, $NamedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedMapCodec"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$DynamicOps, $DynamicOps$Type} from "packages/com/mojang/serialization/$DynamicOps"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$UnboundedMapCodec, $UnboundedMapCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$UnboundedMapCodec"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Dynamic, $Dynamic$Type} from "packages/com/mojang/serialization/$Dynamic"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$PairCodec, $PairCodec$Type} from "packages/fr/frinn/custommachinery/impl/codec/$PairCodec"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$DataResult, $DataResult$Type} from "packages/com/mojang/serialization/$DataResult"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$NamedRecordCodec$Instance, $NamedRecordCodec$Instance$Type} from "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnhancedEitherCodec<F, S> implements $NamedCodec<($Either<(F), (S)>)> {


public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "decode"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Pair<($Either<(F), (S)>), (T)>)>
public "encode"<T>(ops: $DynamicOps$Type<(T)>, input: $Either$Type<(F), (S)>, prefix: T): $DataResult<(T)>
public static "of"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $EnhancedEitherCodec<(F), (S)>
public static "of"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $EnhancedEitherCodec<(F), (S)>
public "dispatch"<E>(type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public "dispatch"<E>(typeKey: string, type: $Function$Type<(any), (any)>, valueCodecGetter: $Function$Type<(any), (any)>, name: string): $NamedMapCodec<(E)>
public static "of"<A>(codec: $Codec$Type<($Either$Type<(F), (S)>)>): $NamedCodec<($Either<(F), (S)>)>
public static "of"<A>(codec: $Codec$Type<($Either$Type<(F), (S)>)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Either$Type<(F), (S)>)>, name: string): $NamedCodec<($List<($Either<(F), (S)>)>)>
public static "list"<A>(codec: $NamedCodec$Type<($Either$Type<(F), (S)>)>): $NamedCodec<($List<($Either<(F), (S)>)>)>
public static "record"<O>(builder: $Function$Type<($NamedRecordCodec$Instance$Type<(O)>), (any)>, name: string): $NamedMapCodec<(O)>
public "read"<T>(ops: $DynamicOps$Type<(T)>, input: T): $DataResult<($Either<(F), (S)>)>
public "copy"(input: $Either$Type<(F), (S)>): $Either<(F), (S)>
public static "checkRange"<N extends (number) & ($Comparable<(N)>)>(minInclusive: N, maxInclusive: N): $Function<(N), ($DataResult<(N)>)>
public static "unit"<A>(defaultValue: $Supplier$Type<($Either$Type<(F), (S)>)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "unit"<A>(defaultValue: $Either$Type<(F), (S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "unit"<A>(defaultValue: $Either$Type<(F), (S)>): $NamedCodec<($Either<(F), (S)>)>
public static "pair"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $PairCodec<(F), (S)>
public static "lazy"<A>(supplier: $Supplier$Type<($NamedCodec$Type<($Either$Type<(F), (S)>)>)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "fromJson"<T>(parser: $Function$Type<($JsonElement$Type), (T)>, encoder: $Function$Type<(T), ($JsonElement$Type)>, name: string): $NamedCodec<(T)>
public "fromNetwork"(buf: $FriendlyByteBuf$Type): $Either<(F), (S)>
public "xmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public "fieldOf"(fieldName: string): $NamedMapCodec<($Either<(F), (S)>)>
public "optionalFieldOf"(fieldName: string): $NamedMapCodec<($Optional<($Either<(F), (S)>)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Either$Type<(F), (S)>): $NamedMapCodec<($Either<(F), (S)>)>
public "optionalFieldOf"(fieldName: string, defaultValue: $Supplier$Type<($Either$Type<(F), (S)>)>): $NamedMapCodec<($Either<(F), (S)>)>
public "flatXmap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>, name: string): $NamedCodec<($Either<(F), (S)>)>
public static "either"<F, S>(first: $NamedCodec$Type<(F)>, second: $NamedCodec$Type<(S)>): $NamedCodec<($Either<(F), (S)>)>
public "comapFlatMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "unboundedMap"<K, V>(keyCodec: $NamedCodec$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $UnboundedMapCodec<(K), (V)>
public "flatComapMap"<S>(to: $Function$Type<(any), (any)>, from: $Function$Type<(any), (any)>, name: string): $NamedCodec<(S)>
public static "doubleRange"(minInclusive: double, maxInclusive: double): $NamedCodec<(double)>
public static "floatRange"(minInclusive: float, maxInclusive: float): $NamedCodec<(float)>
public static "intRange"(minInclusive: integer, maxInclusive: integer): $NamedCodec<(integer)>
public "encodeStart"<T>(ops: $DynamicOps$Type<(T)>, input: $Either$Type<(F), (S)>): $DataResult<(T)>
public static "validateDoubleStreamSize"(stream: $DoubleStream$Type, size: integer): $DataResult<((double)[])>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, name: string): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>): $NamedMapCodec<($Map<(K), (V)>)>
public static "enumMap"<K extends $Enum<(K)>, V>(keyEnumClass: $Class$Type<(K)>, valueCodec: $NamedCodec$Type<(V)>, defaultValue: V): $NamedMapCodec<($Map<(K), (V)>)>
public static "longRange"(minInclusive: long, maxInclusive: long): $NamedCodec<(long)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>): $NamedCodec<(E)>
public static "enumCodec"<E extends $Enum<(E)>>(enumClass: $Class$Type<(E)>, name: string): $NamedCodec<(E)>
public "toNetwork"(input: $Either$Type<(F), (S)>, buf: $FriendlyByteBuf$Type): void
public "listOf"(): $NamedCodec<($List<($Either<(F), (S)>)>)>
public "listOf"(name: string): $NamedCodec<($List<($Either<(F), (S)>)>)>
public static "registrar"<A>(registrar: $Registrar$Type<($Either$Type<(F), (S)>)>): $NamedCodec<($Either<(F), (S)>)>
public static "getJson"<U>(dynamic: $Dynamic$Type<(any)>): $JsonElement
public "codec"(): $Codec<($Either<(F), (S)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnhancedEitherCodec$Type<F, S> = ($EnhancedEitherCodec<(F), (S)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnhancedEitherCodec_<F, S> = $EnhancedEitherCodec$Type<(F), (S)>;
}}
declare module "packages/fr/frinn/custommachinery/common/component/$DummyComponentManager" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ISerializableComponent, $ISerializableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ISerializableComponent"
import {$IMachineComponent, $IMachineComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IMachineComponent"
import {$MachineComponentManager, $MachineComponentManager$Type} from "packages/fr/frinn/custommachinery/common/component/$MachineComponentManager"
import {$IComparatorInputComponent, $IComparatorInputComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$IComparatorInputComponent"
import {$IComponentHandler, $IComponentHandler$Type} from "packages/fr/frinn/custommachinery/api/component/handler/$IComponentHandler"
import {$CustomMachineTile, $CustomMachineTile$Type} from "packages/fr/frinn/custommachinery/common/init/$CustomMachineTile"
import {$ITickableComponent, $ITickableComponent$Type} from "packages/fr/frinn/custommachinery/api/component/$ITickableComponent"
import {$ISyncableStuff, $ISyncableStuff$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncableStuff"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ISyncable, $ISyncable$Type} from "packages/fr/frinn/custommachinery/api/network/$ISyncable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DummyComponentManager extends $MachineComponentManager {

constructor(tile: $CustomMachineTile$Type)

public "getComponent"<T extends $IMachineComponent>(type: $MachineComponentType$Type<(T)>): $Optional<(T)>
public "hasComponent"(type: $MachineComponentType$Type<(any)>): boolean
public "getStuffToSync"(container: $Consumer$Type<($ISyncable$Type<(any), (any)>)>): void
public "markDirty"(): void
public "getComponents"(): $Map<($MachineComponentType<(any)>), ($IMachineComponent)>
public "serverTick"(): void
public "getComponentHandler"<T extends $IMachineComponent>(type: $MachineComponentType$Type<(T)>): $Optional<($IComponentHandler<(T)>)>
public "getTickableComponents"(): $List<($ITickableComponent)>
public "getComparatorInputComponents"(): $List<($IComparatorInputComponent)>
public "getSyncableComponents"(): $List<($ISyncableStuff)>
public "getSerializableComponents"(): $List<($ISerializableComponent)>
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
get "components"(): $Map<($MachineComponentType<(any)>), ($IMachineComponent)>
get "tickableComponents"(): $List<($ITickableComponent)>
get "comparatorInputComponents"(): $List<($IComparatorInputComponent)>
get "syncableComponents"(): $List<($ISyncableStuff)>
get "serializableComponents"(): $List<($ISerializableComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DummyComponentManager$Type = ($DummyComponentManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DummyComponentManager_ = $DummyComponentManager$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$EffectRequirementCT" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export interface $EffectRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "giveEffectEachTick"(effect: $MobEffect$Type, time: integer, radius: integer, level: integer, filter: ($EntityType$Type<(any)>)[]): T
 "giveEffectOnEnd"(effect: $MobEffect$Type, time: integer, radius: integer, level: integer, filter: ($EntityType$Type<(any)>)[]): T
 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $EffectRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EffectRequirementCT$Type<T> = ($EffectRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EffectRequirementCT_<T> = $EffectRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$FluidRequirement" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AbstractChanceableRequirement, $AbstractChanceableRequirement$Type} from "packages/fr/frinn/custommachinery/impl/requirement/$AbstractChanceableRequirement"
import {$IJEIIngredientRequirement, $IJEIIngredientRequirement$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientRequirement"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$CraftingResult, $CraftingResult$Type} from "packages/fr/frinn/custommachinery/api/crafting/$CraftingResult"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"
import {$FluidComponentHandler, $FluidComponentHandler$Type} from "packages/fr/frinn/custommachinery/common/component/handler/$FluidComponentHandler"
import {$IMachineRecipe, $IMachineRecipe$Type} from "packages/fr/frinn/custommachinery/api/crafting/$IMachineRecipe"
import {$MachineComponentType, $MachineComponentType$Type} from "packages/fr/frinn/custommachinery/api/component/$MachineComponentType"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$ICraftingContext, $ICraftingContext$Type} from "packages/fr/frinn/custommachinery/api/crafting/$ICraftingContext"

export class $FluidRequirement extends $AbstractChanceableRequirement<($FluidComponentHandler)> implements $IJEIIngredientRequirement<($FluidStack)> {
static readonly "CODEC": $NamedCodec<($FluidRequirement)>

constructor(mode: $RequirementIOMode$Type, fluid: $IIngredient$Type<($Fluid$Type)>, amount: long, nbt: $CompoundTag$Type, tank: string)

public "test"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): boolean
public "getComponentType"(): $MachineComponentType<(any)>
public "getType"(): $RequirementType<($FluidRequirement)>
public "processStart"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "processEnd"(component: $FluidComponentHandler$Type, context: $ICraftingContext$Type): $CraftingResult
public "getJEIIngredientWrappers"(recipe: $IMachineRecipe$Type): $List<($IJEIIngredientWrapper<($FluidStack)>)>
get "componentType"(): $MachineComponentType<(any)>
get "type"(): $RequirementType<($FluidRequirement)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidRequirement$Type = ($FluidRequirement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidRequirement_ = $FluidRequirement$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/integration/crafttweaker/requirements/$ItemTransformRequirementCT" {
import {$IRequirement, $IRequirement$Type} from "packages/fr/frinn/custommachinery/api/requirement/$IRequirement"
import {$RecipeCTBuilder, $RecipeCTBuilder$Type} from "packages/fr/frinn/custommachinery/api/integration/crafttweaker/$RecipeCTBuilder"

export interface $ItemTransformRequirementCT<T> extends $RecipeCTBuilder<(T)> {

 "error"(arg0: string, ...arg1: (any)[]): T
 "addRequirement"(arg0: $IRequirement$Type<(any)>): T
}

export namespace $ItemTransformRequirementCT {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTransformRequirementCT$Type<T> = ($ItemTransformRequirementCT<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTransformRequirementCT_<T> = $ItemTransformRequirementCT$Type<(T)>;
}}
declare module "packages/fr/frinn/custommachinery/impl/codec/$NamedRecordCodec$Instance$Mu" {
import {$Applicative$Mu, $Applicative$Mu$Type} from "packages/com/mojang/datafixers/kinds/$Applicative$Mu"

export class $NamedRecordCodec$Instance$Mu<O> implements $Applicative$Mu {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedRecordCodec$Instance$Mu$Type<O> = ($NamedRecordCodec$Instance$Mu<(O)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedRecordCodec$Instance$Mu_<O> = $NamedRecordCodec$Instance$Mu$Type<(O)>;
}}
declare module "packages/fr/frinn/custommachinery/common/machine/$CustomMachineJsonReloadListener" {
import {$CustomJsonReloadListener, $CustomJsonReloadListener$Type} from "packages/fr/frinn/custommachinery/common/util/$CustomJsonReloadListener"

export class $CustomMachineJsonReloadListener extends $CustomJsonReloadListener {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomMachineJsonReloadListener$Type = ($CustomMachineJsonReloadListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomMachineJsonReloadListener_ = $CustomMachineJsonReloadListener$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/requirement/$EntityRequirement$ACTION" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $EntityRequirement$ACTION extends $Enum<($EntityRequirement$ACTION)> {
static readonly "CHECK_AMOUNT": $EntityRequirement$ACTION
static readonly "CHECK_HEALTH": $EntityRequirement$ACTION
static readonly "CONSUME_HEALTH": $EntityRequirement$ACTION
static readonly "KILL": $EntityRequirement$ACTION
static readonly "CODEC": $NamedCodec<($EntityRequirement$ACTION)>


public static "value"(mode: string): $EntityRequirement$ACTION
public static "values"(): ($EntityRequirement$ACTION)[]
public static "valueOf"(name: string): $EntityRequirement$ACTION
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRequirement$ACTION$Type = (("consume_health") | ("check_amount") | ("kill") | ("check_health")) | ($EntityRequirement$ACTION);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRequirement$ACTION_ = $EntityRequirement$ACTION$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/integration/jei/wrapper/$FluidIngredientWrapper" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IRecipeLayoutBuilder, $IRecipeLayoutBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeLayoutBuilder"
import {$RecipeIngredientRole, $RecipeIngredientRole$Type} from "packages/mezz/jei/api/recipe/$RecipeIngredientRole"
import {$IJEIIngredientWrapper, $IJEIIngredientWrapper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IJEIIngredientWrapper"
import {$IRecipeSlotBuilder, $IRecipeSlotBuilder$Type} from "packages/mezz/jei/api/gui/builder/$IRecipeSlotBuilder"
import {$IRecipeHelper, $IRecipeHelper$Type} from "packages/fr/frinn/custommachinery/api/integration/jei/$IRecipeHelper"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$IGuiElement, $IGuiElement$Type} from "packages/fr/frinn/custommachinery/api/guielement/$IGuiElement"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$IIngredient, $IIngredient$Type} from "packages/fr/frinn/custommachinery/common/util/ingredient/$IIngredient"
import {$IPlatformFluidHelper, $IPlatformFluidHelper$Type} from "packages/mezz/jei/api/helpers/$IPlatformFluidHelper"

export class $FluidIngredientWrapper implements $IJEIIngredientWrapper<($FluidStack)> {

constructor(mode: $RequirementIOMode$Type, fluid: $IIngredient$Type<($Fluid$Type)>, amount: long, chance: double, isPerTick: boolean, nbt: $CompoundTag$Type, tank: string)

public "setupRecipe"(builder: $IRecipeLayoutBuilder$Type, xOffset: integer, yOffset: integer, element: $IGuiElement$Type, helper: $IRecipeHelper$Type): boolean
public "addFluidIngredients"<T>(helper: $IPlatformFluidHelper$Type<(T)>, builder: $IRecipeSlotBuilder$Type): void
public "roleFromMode"(mode: $RequirementIOMode$Type): $RecipeIngredientRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientWrapper$Type = ($FluidIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredientWrapper_ = $FluidIngredientWrapper$Type;
}}
declare module "packages/fr/frinn/custommachinery/common/upgrade/$RecipeModifier" {
import {$IRecipeModifier$OPERATION, $IRecipeModifier$OPERATION$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier$OPERATION"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IRecipeModifier, $IRecipeModifier$Type} from "packages/fr/frinn/custommachinery/api/upgrade/$IRecipeModifier"
import {$RequirementIOMode, $RequirementIOMode$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementIOMode"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$RequirementType, $RequirementType$Type} from "packages/fr/frinn/custommachinery/api/requirement/$RequirementType"
import {$NamedCodec, $NamedCodec$Type} from "packages/fr/frinn/custommachinery/api/codec/$NamedCodec"

export class $RecipeModifier implements $IRecipeModifier {
static readonly "CODEC": $NamedCodec<($RecipeModifier)>
static readonly "RAND": $Random
readonly "requirementType": $RequirementType<(any)>
readonly "target": string
readonly "mode": $RequirementIOMode
readonly "modifier": double
readonly "chance": double
readonly "max": double
readonly "min": double
readonly "tooltip": $Component

constructor(requirementType: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, modifier: double, target: string, chance: double, max: double, min: double, tooltip: $Component$Type)

public "getTooltip"(): $Component
public "shouldApply"(type: $RequirementType$Type<(any)>, mode: $RequirementIOMode$Type, target: string): boolean
public "getOperation"(): $IRecipeModifier$OPERATION
public "apply"(arg0: double, arg1: integer): double
public "getDefaultTooltip"(): $Component
get "tooltip"(): $Component
get "operation"(): $IRecipeModifier$OPERATION
get "defaultTooltip"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeModifier$Type = ($RecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeModifier_ = $RecipeModifier$Type;
}}
declare module "packages/fr/frinn/custommachinery/client/screen/creation/gui/builder/$ProgressBarGuiElementBuilder" {
import {$GuiElementType, $GuiElementType$Type} from "packages/fr/frinn/custommachinery/api/guielement/$GuiElementType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MachineEditScreen, $MachineEditScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/$MachineEditScreen"
import {$MutableProperties, $MutableProperties$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$MutableProperties"
import {$IGuiElementBuilder, $IGuiElementBuilder$Type} from "packages/fr/frinn/custommachinery/client/screen/creation/gui/$IGuiElementBuilder"
import {$PopupScreen, $PopupScreen$Type} from "packages/fr/frinn/custommachinery/client/screen/popup/$PopupScreen"
import {$ProgressBarGuiElement, $ProgressBarGuiElement$Type} from "packages/fr/frinn/custommachinery/common/guielement/$ProgressBarGuiElement"
import {$AbstractGuiElement$Properties, $AbstractGuiElement$Properties$Type} from "packages/fr/frinn/custommachinery/impl/guielement/$AbstractGuiElement$Properties"

export class $ProgressBarGuiElementBuilder implements $IGuiElementBuilder<($ProgressBarGuiElement)> {

constructor()

public "type"(): $GuiElementType<($ProgressBarGuiElement)>
public "make"(properties: $AbstractGuiElement$Properties$Type, from: $ProgressBarGuiElement$Type): $ProgressBarGuiElement
public "makeConfigPopup"(parent: $MachineEditScreen$Type, properties: $MutableProperties$Type, from: $ProgressBarGuiElement$Type, onFinish: $Consumer$Type<($ProgressBarGuiElement$Type)>): $PopupScreen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProgressBarGuiElementBuilder$Type = ($ProgressBarGuiElementBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProgressBarGuiElementBuilder_ = $ProgressBarGuiElementBuilder$Type;
}}
